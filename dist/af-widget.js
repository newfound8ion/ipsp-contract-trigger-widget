var Af = Object.defineProperty;
var bf = (r, t, e) => t in r ? Af(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;
var A = (r, t, e) => (bf(r, typeof t != "symbol" ? t + "" : t, e), e), Eo = (r, t, e) => {
  if (!t.has(r))
    throw TypeError("Cannot " + e);
};
var l = (r, t, e) => (Eo(r, t, "read from private field"), e ? e.call(r) : t.get(r)), b = (r, t, e) => {
  if (t.has(r))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(r) : t.set(r, e);
}, d = (r, t, e, n) => (Eo(r, t, "write to private field"), n ? n.call(r, e) : t.set(r, e), e);
var xs = (r, t, e, n) => ({
  set _(s) {
    d(r, t, s, e);
  },
  get _() {
    return l(r, t, n);
  }
}), I = (r, t, e) => (Eo(r, t, "access private method"), e);
import fu, { useState as kn, useEffect as hu } from "react";
var Qo = { exports: {} }, dr = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var vo, Xa;
function du() {
  if (Xa)
    return vo;
  Xa = 1;
  var r = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, e = Object.prototype.propertyIsEnumerable;
  function n(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function s() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var o = {}, a = 0; a < 10; a++)
        o["_" + String.fromCharCode(a)] = a;
      var c = Object.getOwnPropertyNames(o).map(function(f) {
        return o[f];
      });
      if (c.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(f) {
        u[f] = f;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return vo = s() ? Object.assign : function(i, o) {
    for (var a, c = n(i), u, f = 1; f < arguments.length; f++) {
      a = Object(arguments[f]);
      for (var h in a)
        t.call(a, h) && (c[h] = a[h]);
      if (r) {
        u = r(a);
        for (var g = 0; g < u.length; g++)
          e.call(a, u[g]) && (c[u[g]] = a[u[g]]);
      }
    }
    return c;
  }, vo;
}
/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qa;
function Ef() {
  if (qa)
    return dr;
  qa = 1, du();
  var r = fu, t = 60103;
  if (dr.Fragment = 60107, typeof Symbol == "function" && Symbol.for) {
    var e = Symbol.for;
    t = e("react.element"), dr.Fragment = e("react.fragment");
  }
  var n = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = Object.prototype.hasOwnProperty, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(a, c, u) {
    var f, h = {}, g = null, w = null;
    u !== void 0 && (g = "" + u), c.key !== void 0 && (g = "" + c.key), c.ref !== void 0 && (w = c.ref);
    for (f in c)
      s.call(c, f) && !i.hasOwnProperty(f) && (h[f] = c[f]);
    if (a && a.defaultProps)
      for (f in c = a.defaultProps, c)
        h[f] === void 0 && (h[f] = c[f]);
    return { $$typeof: t, type: a, key: g, ref: w, props: h, _owner: n.current };
  }
  return dr.jsx = o, dr.jsxs = o, dr;
}
var xo = {};
/** @license React v17.0.2
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $a;
function vf() {
  return $a || ($a = 1, function(r) {
    process.env.NODE_ENV !== "production" && function() {
      var t = fu, e = du(), n = 60103, s = 60106;
      r.Fragment = 60107;
      var i = 60108, o = 60114, a = 60109, c = 60110, u = 60112, f = 60113, h = 60120, g = 60115, w = 60116, E = 60121, m = 60122, x = 60117, v = 60129, B = 60131;
      if (typeof Symbol == "function" && Symbol.for) {
        var T = Symbol.for;
        n = T("react.element"), s = T("react.portal"), r.Fragment = T("react.fragment"), i = T("react.strict_mode"), o = T("react.profiler"), a = T("react.provider"), c = T("react.context"), u = T("react.forward_ref"), f = T("react.suspense"), h = T("react.suspense_list"), g = T("react.memo"), w = T("react.lazy"), E = T("react.block"), m = T("react.server.block"), x = T("react.fundamental"), T("react.scope"), T("react.opaque.id"), v = T("react.debug_trace_mode"), T("react.offscreen"), B = T("react.legacy_hidden");
      }
      var H = typeof Symbol == "function" && Symbol.iterator, G = "@@iterator";
      function U(p) {
        if (p === null || typeof p != "object")
          return null;
        var N = H && p[H] || p[G];
        return typeof N == "function" ? N : null;
      }
      var D = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function k(p) {
        {
          for (var N = arguments.length, O = new Array(N > 1 ? N - 1 : 0), Q = 1; Q < N; Q++)
            O[Q - 1] = arguments[Q];
          ot("error", p, O);
        }
      }
      function ot(p, N, O) {
        {
          var Q = D.ReactDebugCurrentFrame, tt = Q.getStackAddendum();
          tt !== "" && (N += "%s", O = O.concat([tt]));
          var et = O.map(function(j) {
            return "" + j;
          });
          et.unshift("Warning: " + N), Function.prototype.apply.call(console[p], console, et);
        }
      }
      var Y = !1;
      function K(p) {
        return !!(typeof p == "string" || typeof p == "function" || p === r.Fragment || p === o || p === v || p === i || p === f || p === h || p === B || Y || typeof p == "object" && p !== null && (p.$$typeof === w || p.$$typeof === g || p.$$typeof === a || p.$$typeof === c || p.$$typeof === u || p.$$typeof === x || p.$$typeof === E || p[0] === m));
      }
      function Ot(p, N, O) {
        var Q = N.displayName || N.name || "";
        return p.displayName || (Q !== "" ? O + "(" + Q + ")" : O);
      }
      function bt(p) {
        return p.displayName || "Context";
      }
      function ht(p) {
        if (p == null)
          return null;
        if (typeof p.tag == "number" && k("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof p == "function")
          return p.displayName || p.name || null;
        if (typeof p == "string")
          return p;
        switch (p) {
          case r.Fragment:
            return "Fragment";
          case s:
            return "Portal";
          case o:
            return "Profiler";
          case i:
            return "StrictMode";
          case f:
            return "Suspense";
          case h:
            return "SuspenseList";
        }
        if (typeof p == "object")
          switch (p.$$typeof) {
            case c:
              var N = p;
              return bt(N) + ".Consumer";
            case a:
              var O = p;
              return bt(O._context) + ".Provider";
            case u:
              return Ot(p, p.render, "ForwardRef");
            case g:
              return ht(p.type);
            case E:
              return ht(p._render);
            case w: {
              var Q = p, tt = Q._payload, et = Q._init;
              try {
                return ht(et(tt));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var C = 0, S, _, $, Z, ct, Et, vt;
      function oe() {
      }
      oe.__reactDisabledLog = !0;
      function Ae() {
        {
          if (C === 0) {
            S = console.log, _ = console.info, $ = console.warn, Z = console.error, ct = console.group, Et = console.groupCollapsed, vt = console.groupEnd;
            var p = {
              configurable: !0,
              enumerable: !0,
              value: oe,
              writable: !0
            };
            Object.defineProperties(console, {
              info: p,
              log: p,
              warn: p,
              error: p,
              group: p,
              groupCollapsed: p,
              groupEnd: p
            });
          }
          C++;
        }
      }
      function rn() {
        {
          if (C--, C === 0) {
            var p = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: e({}, p, {
                value: S
              }),
              info: e({}, p, {
                value: _
              }),
              warn: e({}, p, {
                value: $
              }),
              error: e({}, p, {
                value: Z
              }),
              group: e({}, p, {
                value: ct
              }),
              groupCollapsed: e({}, p, {
                value: Et
              }),
              groupEnd: e({}, p, {
                value: vt
              })
            });
          }
          C < 0 && k("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var Be = D.ReactCurrentDispatcher, Wt;
      function sn(p, N, O) {
        {
          if (Wt === void 0)
            try {
              throw Error();
            } catch (tt) {
              var Q = tt.stack.trim().match(/\n( *(at )?)/);
              Wt = Q && Q[1] || "";
            }
          return `
` + Wt + p;
        }
      }
      var ae = !1, ce;
      {
        var di = typeof WeakMap == "function" ? WeakMap : Map;
        ce = new di();
      }
      function Re(p, N) {
        if (!p || ae)
          return "";
        {
          var O = ce.get(p);
          if (O !== void 0)
            return O;
        }
        var Q;
        ae = !0;
        var tt = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var et;
        et = Be.current, Be.current = null, Ae();
        try {
          if (N) {
            var j = function() {
              throw Error();
            };
            if (Object.defineProperty(j.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(j, []);
              } catch (Se) {
                Q = Se;
              }
              Reflect.construct(p, [], j);
            } else {
              try {
                j.call();
              } catch (Se) {
                Q = Se;
              }
              p.call(j.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Se) {
              Q = Se;
            }
            p();
          }
        } catch (Se) {
          if (Se && Q && typeof Se.stack == "string") {
            for (var J = Se.stack.split(`
`), It = Q.stack.split(`
`), ut = J.length - 1, ft = It.length - 1; ut >= 1 && ft >= 0 && J[ut] !== It[ft]; )
              ft--;
            for (; ut >= 1 && ft >= 0; ut--, ft--)
              if (J[ut] !== It[ft]) {
                if (ut !== 1 || ft !== 1)
                  do
                    if (ut--, ft--, ft < 0 || J[ut] !== It[ft]) {
                      var ke = `
` + J[ut].replace(" at new ", " at ");
                      return typeof p == "function" && ce.set(p, ke), ke;
                    }
                  while (ut >= 1 && ft >= 0);
                break;
              }
          }
        } finally {
          ae = !1, Be.current = et, rn(), Error.prepareStackTrace = tt;
        }
        var hr = p ? p.displayName || p.name : "", Za = hr ? sn(hr) : "";
        return typeof p == "function" && ce.set(p, Za), Za;
      }
      function Dt(p, N, O) {
        return Re(p, !1);
      }
      function on(p) {
        var N = p.prototype;
        return !!(N && N.isReactComponent);
      }
      function Rn(p, N, O) {
        if (p == null)
          return "";
        if (typeof p == "function")
          return Re(p, on(p));
        if (typeof p == "string")
          return sn(p);
        switch (p) {
          case f:
            return sn("Suspense");
          case h:
            return sn("SuspenseList");
        }
        if (typeof p == "object")
          switch (p.$$typeof) {
            case u:
              return Dt(p.render);
            case g:
              return Rn(p.type, N, O);
            case E:
              return Dt(p._render);
            case w: {
              var Q = p, tt = Q._payload, et = Q._init;
              try {
                return Rn(et(tt), N, O);
              } catch {
              }
            }
          }
        return "";
      }
      var Es = {}, Ha = D.ReactDebugCurrentFrame;
      function pi(p) {
        if (p) {
          var N = p._owner, O = Rn(p.type, p._source, N ? N.type : null);
          Ha.setExtraStackFrame(O);
        } else
          Ha.setExtraStackFrame(null);
      }
      function ef(p, N, O, Q, tt) {
        {
          var et = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var j in p)
            if (et(p, j)) {
              var J = void 0;
              try {
                if (typeof p[j] != "function") {
                  var It = Error((Q || "React class") + ": " + O + " type `" + j + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof p[j] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw It.name = "Invariant Violation", It;
                }
                J = p[j](N, j, Q, O, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ut) {
                J = ut;
              }
              J && !(J instanceof Error) && (pi(tt), k("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Q || "React class", O, j, typeof J), pi(null)), J instanceof Error && !(J.message in Es) && (Es[J.message] = !0, pi(tt), k("Failed %s type: %s", O, J.message), pi(null));
            }
        }
      }
      var vs = D.ReactCurrentOwner, yo = Object.prototype.hasOwnProperty, nf = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, _a, Va, mo;
      mo = {};
      function rf(p) {
        if (yo.call(p, "ref")) {
          var N = Object.getOwnPropertyDescriptor(p, "ref").get;
          if (N && N.isReactWarning)
            return !1;
        }
        return p.ref !== void 0;
      }
      function sf(p) {
        if (yo.call(p, "key")) {
          var N = Object.getOwnPropertyDescriptor(p, "key").get;
          if (N && N.isReactWarning)
            return !1;
        }
        return p.key !== void 0;
      }
      function of(p, N) {
        if (typeof p.ref == "string" && vs.current && N && vs.current.stateNode !== N) {
          var O = ht(vs.current.type);
          mo[O] || (k('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', ht(vs.current.type), p.ref), mo[O] = !0);
        }
      }
      function af(p, N) {
        {
          var O = function() {
            _a || (_a = !0, k("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", N));
          };
          O.isReactWarning = !0, Object.defineProperty(p, "key", {
            get: O,
            configurable: !0
          });
        }
      }
      function cf(p, N) {
        {
          var O = function() {
            Va || (Va = !0, k("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", N));
          };
          O.isReactWarning = !0, Object.defineProperty(p, "ref", {
            get: O,
            configurable: !0
          });
        }
      }
      var uf = function(p, N, O, Q, tt, et, j) {
        var J = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: n,
          // Built-in properties that belong on the element
          type: p,
          key: N,
          ref: O,
          props: j,
          // Record the component responsible for creating this element.
          _owner: et
        };
        return J._store = {}, Object.defineProperty(J._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(J, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Q
        }), Object.defineProperty(J, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: tt
        }), Object.freeze && (Object.freeze(J.props), Object.freeze(J)), J;
      };
      function lf(p, N, O, Q, tt) {
        {
          var et, j = {}, J = null, It = null;
          O !== void 0 && (J = "" + O), sf(N) && (J = "" + N.key), rf(N) && (It = N.ref, of(N, tt));
          for (et in N)
            yo.call(N, et) && !nf.hasOwnProperty(et) && (j[et] = N[et]);
          if (p && p.defaultProps) {
            var ut = p.defaultProps;
            for (et in ut)
              j[et] === void 0 && (j[et] = ut[et]);
          }
          if (J || It) {
            var ft = typeof p == "function" ? p.displayName || p.name || "Unknown" : p;
            J && af(j, ft), It && cf(j, ft);
          }
          return uf(p, J, It, tt, Q, vs.current, j);
        }
      }
      var wo = D.ReactCurrentOwner, Ja = D.ReactDebugCurrentFrame;
      function fr(p) {
        if (p) {
          var N = p._owner, O = Rn(p.type, p._source, N ? N.type : null);
          Ja.setExtraStackFrame(O);
        } else
          Ja.setExtraStackFrame(null);
      }
      var Ao;
      Ao = !1;
      function bo(p) {
        return typeof p == "object" && p !== null && p.$$typeof === n;
      }
      function ja() {
        {
          if (wo.current) {
            var p = ht(wo.current.type);
            if (p)
              return `

Check the render method of \`` + p + "`.";
          }
          return "";
        }
      }
      function ff(p) {
        {
          if (p !== void 0) {
            var N = p.fileName.replace(/^.*[\\\/]/, ""), O = p.lineNumber;
            return `

Check your code at ` + N + ":" + O + ".";
          }
          return "";
        }
      }
      var za = {};
      function hf(p) {
        {
          var N = ja();
          if (!N) {
            var O = typeof p == "string" ? p : p.displayName || p.name;
            O && (N = `

Check the top-level render call using <` + O + ">.");
          }
          return N;
        }
      }
      function Ka(p, N) {
        {
          if (!p._store || p._store.validated || p.key != null)
            return;
          p._store.validated = !0;
          var O = hf(N);
          if (za[O])
            return;
          za[O] = !0;
          var Q = "";
          p && p._owner && p._owner !== wo.current && (Q = " It was passed a child from " + ht(p._owner.type) + "."), fr(p), k('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', O, Q), fr(null);
        }
      }
      function Wa(p, N) {
        {
          if (typeof p != "object")
            return;
          if (Array.isArray(p))
            for (var O = 0; O < p.length; O++) {
              var Q = p[O];
              bo(Q) && Ka(Q, N);
            }
          else if (bo(p))
            p._store && (p._store.validated = !0);
          else if (p) {
            var tt = U(p);
            if (typeof tt == "function" && tt !== p.entries)
              for (var et = tt.call(p), j; !(j = et.next()).done; )
                bo(j.value) && Ka(j.value, N);
          }
        }
      }
      function df(p) {
        {
          var N = p.type;
          if (N == null || typeof N == "string")
            return;
          var O;
          if (typeof N == "function")
            O = N.propTypes;
          else if (typeof N == "object" && (N.$$typeof === u || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          N.$$typeof === g))
            O = N.propTypes;
          else
            return;
          if (O) {
            var Q = ht(N);
            ef(O, p.props, "prop", Q, p);
          } else if (N.PropTypes !== void 0 && !Ao) {
            Ao = !0;
            var tt = ht(N);
            k("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", tt || "Unknown");
          }
          typeof N.getDefaultProps == "function" && !N.getDefaultProps.isReactClassApproved && k("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function pf(p) {
        {
          for (var N = Object.keys(p.props), O = 0; O < N.length; O++) {
            var Q = N[O];
            if (Q !== "children" && Q !== "key") {
              fr(p), k("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Q), fr(null);
              break;
            }
          }
          p.ref !== null && (fr(p), k("Invalid attribute `ref` supplied to `React.Fragment`."), fr(null));
        }
      }
      function Ya(p, N, O, Q, tt, et) {
        {
          var j = K(p);
          if (!j) {
            var J = "";
            (p === void 0 || typeof p == "object" && p !== null && Object.keys(p).length === 0) && (J += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
            var It = ff(tt);
            It ? J += It : J += ja();
            var ut;
            p === null ? ut = "null" : Array.isArray(p) ? ut = "array" : p !== void 0 && p.$$typeof === n ? (ut = "<" + (ht(p.type) || "Unknown") + " />", J = " Did you accidentally export a JSX literal instead of a component?") : ut = typeof p, k("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", ut, J);
          }
          var ft = lf(p, N, O, tt, et);
          if (ft == null)
            return ft;
          if (j) {
            var ke = N.children;
            if (ke !== void 0)
              if (Q)
                if (Array.isArray(ke)) {
                  for (var hr = 0; hr < ke.length; hr++)
                    Wa(ke[hr], p);
                  Object.freeze && Object.freeze(ke);
                } else
                  k("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
              else
                Wa(ke, p);
          }
          return p === r.Fragment ? pf(ft) : df(ft), ft;
        }
      }
      function gf(p, N, O) {
        return Ya(p, N, O, !0);
      }
      function yf(p, N, O) {
        return Ya(p, N, O, !1);
      }
      var mf = yf, wf = gf;
      r.jsx = mf, r.jsxs = wf;
    }();
  }(xo)), xo;
}
process.env.NODE_ENV === "production" ? Qo.exports = Ef() : Qo.exports = vf();
var q = Qo.exports;
const xf = "6.8.0";
function Pf(r, t, e) {
  const n = t.split("|").map((i) => i.trim());
  for (let i = 0; i < n.length; i++)
    switch (t) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof r === t)
          return;
    }
  const s = new Error(`invalid value for type ${t}`);
  throw s.code = "INVALID_ARGUMENT", s.argument = `value.${e}`, s.value = r, s;
}
async function Bt(r) {
  const t = Object.keys(r);
  return (await Promise.all(t.map((n) => Promise.resolve(r[n])))).reduce((n, s, i) => (n[t[i]] = s, n), {});
}
function M(r, t, e) {
  for (let n in t) {
    let s = t[n];
    const i = e ? e[n] : null;
    i && Pf(s, i, n), Object.defineProperty(r, n, { enumerable: !0, value: s, writable: !1 });
  }
}
function br(r) {
  if (r == null)
    return "null";
  if (Array.isArray(r))
    return "[ " + r.map(br).join(", ") + " ]";
  if (r instanceof Uint8Array) {
    const t = "0123456789abcdef";
    let e = "0x";
    for (let n = 0; n < r.length; n++)
      e += t[r[n] >> 4], e += t[r[n] & 15];
    return e;
  }
  if (typeof r == "object" && typeof r.toJSON == "function")
    return br(r.toJSON());
  switch (typeof r) {
    case "boolean":
    case "symbol":
      return r.toString();
    case "bigint":
      return BigInt(r).toString();
    case "number":
      return r.toString();
    case "string":
      return JSON.stringify(r);
    case "object": {
      const t = Object.keys(r);
      return t.sort(), "{ " + t.map((e) => `${br(e)}: ${br(r[e])}`).join(", ") + " }";
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function se(r, t) {
  return r && r.code === t;
}
function ma(r) {
  return se(r, "CALL_EXCEPTION");
}
function dt(r, t, e) {
  let n = r;
  {
    const i = [];
    if (e) {
      if ("message" in e || "code" in e || "name" in e)
        throw new Error(`value will overwrite populated values: ${br(e)}`);
      for (const o in e) {
        if (o === "shortMessage")
          continue;
        const a = e[o];
        i.push(o + "=" + br(a));
      }
    }
    i.push(`code=${t}`), i.push(`version=${xf}`), i.length && (r += " (" + i.join(", ") + ")");
  }
  let s;
  switch (t) {
    case "INVALID_ARGUMENT":
      s = new TypeError(r);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      s = new RangeError(r);
      break;
    default:
      s = new Error(r);
  }
  return M(s, { code: t }), e && Object.assign(s, e), s.shortMessage == null && M(s, { shortMessage: n }), s;
}
function P(r, t, e, n) {
  if (!r)
    throw dt(t, e, n);
}
function y(r, t, e, n) {
  P(r, t, "INVALID_ARGUMENT", { argument: e, value: n });
}
function pu(r, t, e) {
  e == null && (e = ""), e && (e = ": " + e), P(r >= t, "missing arguemnt" + e, "MISSING_ARGUMENT", {
    count: r,
    expectedCount: t
  }), P(r <= t, "too many arguemnts" + e, "UNEXPECTED_ARGUMENT", {
    count: r,
    expectedCount: t
  });
}
const Nf = ["NFD", "NFC", "NFKD", "NFKC"].reduce((r, t) => {
  try {
    if ("test".normalize(t) !== "test")
      throw new Error("bad");
    if (t === "NFD") {
      const e = String.fromCharCode(233).normalize("NFD"), n = String.fromCharCode(101, 769);
      if (e !== n)
        throw new Error("broken");
    }
    r.push(t);
  } catch {
  }
  return r;
}, []);
function Cf(r) {
  P(Nf.indexOf(r) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form: r }
  });
}
function eo(r, t, e) {
  if (e == null && (e = ""), r !== t) {
    let n = e, s = "new";
    e && (n += ".", s += " " + e), P(!1, `private constructor; use ${n}from* methods`, "UNSUPPORTED_OPERATION", {
      operation: s
    });
  }
}
function gu(r, t, e) {
  if (r instanceof Uint8Array)
    return e ? new Uint8Array(r) : r;
  if (typeof r == "string" && r.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
    const n = new Uint8Array((r.length - 2) / 2);
    let s = 2;
    for (let i = 0; i < n.length; i++)
      n[i] = parseInt(r.substring(s, s + 2), 16), s += 2;
    return n;
  }
  y(!1, "invalid BytesLike value", t || "value", r);
}
function X(r, t) {
  return gu(r, t, !1);
}
function Ht(r, t) {
  return gu(r, t, !0);
}
function it(r, t) {
  return !(typeof r != "string" || !r.match(/^0x[0-9A-Fa-f]*$/) || typeof t == "number" && r.length !== 2 + 2 * t || t === !0 && r.length % 2 !== 0);
}
function Tf(r) {
  return it(r, !0) || r instanceof Uint8Array;
}
const tc = "0123456789abcdef";
function F(r) {
  const t = X(r);
  let e = "0x";
  for (let n = 0; n < t.length; n++) {
    const s = t[n];
    e += tc[(s & 240) >> 4] + tc[s & 15];
  }
  return e;
}
function pt(r) {
  return "0x" + r.map((t) => F(t).substring(2)).join("");
}
function Tr(r) {
  return it(r, !0) ? (r.length - 2) / 2 : X(r).length;
}
function at(r, t, e) {
  const n = X(r);
  return e != null && e > n.length && P(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
    buffer: n,
    length: n.length,
    offset: e
  }), F(n.slice(t ?? 0, e ?? n.length));
}
function yu(r, t, e) {
  const n = X(r);
  P(t >= n.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(n),
    length: t,
    offset: t + 1
  });
  const s = new Uint8Array(t);
  return s.fill(0), e ? s.set(n, t - n.length) : s.set(n, 0), F(s);
}
function ir(r, t) {
  return yu(r, t, !0);
}
function Of(r, t) {
  return yu(r, t, !1);
}
const no = BigInt(0), ge = BigInt(1), Er = 9007199254740991;
function If(r, t) {
  const e = ro(r, "value"), n = BigInt(V(t, "width"));
  if (P(e >> n === no, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: r
  }), e >> n - ge) {
    const s = (ge << n) - ge;
    return -((~e & s) + ge);
  }
  return e;
}
function mu(r, t) {
  let e = L(r, "value");
  const n = BigInt(V(t, "width")), s = ge << n - ge;
  if (e < no) {
    e = -e, P(e <= s, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: r
    });
    const i = (ge << n) - ge;
    return (~e & i) + ge;
  } else
    P(e < s, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: r
    });
  return e;
}
function Cs(r, t) {
  const e = ro(r, "value"), n = BigInt(V(t, "bits"));
  return e & (ge << n) - ge;
}
function L(r, t) {
  switch (typeof r) {
    case "bigint":
      return r;
    case "number":
      return y(Number.isInteger(r), "underflow", t || "value", r), y(r >= -Er && r <= Er, "overflow", t || "value", r), BigInt(r);
    case "string":
      try {
        if (r === "")
          throw new Error("empty string");
        return r[0] === "-" && r[1] !== "-" ? -BigInt(r.substring(1)) : BigInt(r);
      } catch (e) {
        y(!1, `invalid BigNumberish string: ${e.message}`, t || "value", r);
      }
  }
  y(!1, "invalid BigNumberish value", t || "value", r);
}
function ro(r, t) {
  const e = L(r, t);
  return P(e >= no, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value: r
  }), e;
}
const ec = "0123456789abcdef";
function wa(r) {
  if (r instanceof Uint8Array) {
    let t = "0x0";
    for (const e of r)
      t += ec[e >> 4], t += ec[e & 15];
    return BigInt(t);
  }
  return L(r);
}
function V(r, t) {
  switch (typeof r) {
    case "bigint":
      return y(r >= -Er && r <= Er, "overflow", t || "value", r), Number(r);
    case "number":
      return y(Number.isInteger(r), "underflow", t || "value", r), y(r >= -Er && r <= Er, "overflow", t || "value", r), r;
    case "string":
      try {
        if (r === "")
          throw new Error("empty string");
        return V(BigInt(r), t);
      } catch (e) {
        y(!1, `invalid numeric string: ${e.message}`, t || "value", r);
      }
  }
  y(!1, "invalid numeric value", t || "value", r);
}
function Bf(r) {
  return V(wa(r));
}
function On(r, t) {
  let n = ro(r, "value").toString(16);
  if (t == null)
    n.length % 2 && (n = "0" + n);
  else {
    const s = V(t, "width");
    for (P(s * 2 >= n.length, `value exceeds width (${s} bits)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: r
    }); n.length < s * 2; )
      n = "0" + n;
  }
  return "0x" + n;
}
function Kt(r) {
  const t = ro(r, "value");
  if (t === no)
    return new Uint8Array([]);
  let e = t.toString(16);
  e.length % 2 && (e = "0" + e);
  const n = new Uint8Array(e.length / 2);
  for (let s = 0; s < n.length; s++) {
    const i = s * 2;
    n[s] = parseInt(e.substring(i, i + 2), 16);
  }
  return n;
}
function vr(r) {
  let t = F(Tf(r) ? r : Kt(r)).substring(2);
  for (; t.startsWith("0"); )
    t = t.substring(1);
  return t === "" && (t = "0"), "0x" + t;
}
const Rf = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
BigInt(0);
const nc = BigInt(58);
function kf(r) {
  let t = wa(X(r)), e = "";
  for (; t; )
    e = Rf[Number(t % nc)] + e, t /= nc;
  return e;
}
function Sf(r) {
  r = atob(r);
  const t = new Uint8Array(r.length);
  for (let e = 0; e < r.length; e++)
    t[e] = r.charCodeAt(e);
  return X(t);
}
function Uf(r) {
  const t = X(r);
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += String.fromCharCode(t[n]);
  return btoa(e);
}
var Ir;
class wu {
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(t, e, n) {
    /**
     *  The event filter.
     */
    A(this, "filter");
    /**
     *  The **EventEmitterable**.
     */
    A(this, "emitter");
    b(this, Ir, void 0);
    d(this, Ir, e), M(this, { emitter: t, filter: n });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    l(this, Ir) != null && await this.emitter.off(this.filter, l(this, Ir));
  }
}
Ir = new WeakMap();
function Df(r, t, e, n, s) {
  y(!1, `invalid codepoint at offset ${t}; ${r}`, "bytes", e);
}
function Au(r, t, e, n, s) {
  if (r === "BAD_PREFIX" || r === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o = t + 1; o < e.length && e[o] >> 6 === 2; o++)
      i++;
    return i;
  }
  return r === "OVERRUN" ? e.length - t - 1 : 0;
}
function Ff(r, t, e, n, s) {
  return r === "OVERLONG" ? (y(typeof s == "number", "invalid bad code point for replacement", "badCodepoint", s), n.push(s), 0) : (n.push(65533), Au(r, t, e));
}
const Lf = Object.freeze({
  error: Df,
  ignore: Au,
  replace: Ff
});
function Mf(r, t) {
  t == null && (t = Lf.error);
  const e = X(r, "bytes"), n = [];
  let s = 0;
  for (; s < e.length; ) {
    const i = e[s++];
    if (!(i >> 7)) {
      n.push(i);
      continue;
    }
    let o = null, a = null;
    if ((i & 224) === 192)
      o = 1, a = 127;
    else if ((i & 240) === 224)
      o = 2, a = 2047;
    else if ((i & 248) === 240)
      o = 3, a = 65535;
    else {
      (i & 192) === 128 ? s += t("UNEXPECTED_CONTINUE", s - 1, e, n) : s += t("BAD_PREFIX", s - 1, e, n);
      continue;
    }
    if (s - 1 + o >= e.length) {
      s += t("OVERRUN", s - 1, e, n);
      continue;
    }
    let c = i & (1 << 8 - o - 1) - 1;
    for (let u = 0; u < o; u++) {
      let f = e[s];
      if ((f & 192) != 128) {
        s += t("MISSING_CONTINUE", s, e, n), c = null;
        break;
      }
      c = c << 6 | f & 63, s++;
    }
    if (c !== null) {
      if (c > 1114111) {
        s += t("OUT_OF_RANGE", s - 1 - o, e, n, c);
        continue;
      }
      if (c >= 55296 && c <= 57343) {
        s += t("UTF16_SURROGATE", s - 1 - o, e, n, c);
        continue;
      }
      if (c <= a) {
        s += t("OVERLONG", s - 1 - o, e, n, c);
        continue;
      }
      n.push(c);
    }
  }
  return n;
}
function $e(r, t) {
  t != null && (Cf(t), r = r.normalize(t));
  let e = [];
  for (let n = 0; n < r.length; n++) {
    const s = r.charCodeAt(n);
    if (s < 128)
      e.push(s);
    else if (s < 2048)
      e.push(s >> 6 | 192), e.push(s & 63 | 128);
    else if ((s & 64512) == 55296) {
      n++;
      const i = r.charCodeAt(n);
      y(n < r.length && (i & 64512) === 56320, "invalid surrogate pair", "str", r);
      const o = 65536 + ((s & 1023) << 10) + (i & 1023);
      e.push(o >> 18 | 240), e.push(o >> 12 & 63 | 128), e.push(o >> 6 & 63 | 128), e.push(o & 63 | 128);
    } else
      e.push(s >> 12 | 224), e.push(s >> 6 & 63 | 128), e.push(s & 63 | 128);
  }
  return new Uint8Array(e);
}
function Gf(r) {
  return r.map((t) => t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10 & 1023) + 55296, (t & 1023) + 56320))).join("");
}
function Aa(r, t) {
  return Gf(Mf(r, t));
}
function bu(r) {
  async function t(e, n) {
    const s = e.url.split(":")[0].toLowerCase();
    P(s === "http" || s === "https", `unsupported protocol ${s}`, "UNSUPPORTED_OPERATION", {
      info: { protocol: s },
      operation: "request"
    }), P(s === "https" || !e.credentials || e.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let i;
    if (n) {
      const h = new AbortController();
      i = h.signal, n.addListener(() => {
        h.abort();
      });
    }
    const o = {
      method: e.method,
      headers: new Headers(Array.from(e)),
      body: e.body || void 0,
      signal: i
    }, a = await fetch(e.url, o), c = {};
    a.headers.forEach((h, g) => {
      c[g.toLowerCase()] = h;
    });
    const u = await a.arrayBuffer(), f = u == null ? null : new Uint8Array(u);
    return {
      statusCode: a.status,
      statusMessage: a.statusText,
      headers: c,
      body: f
    };
  }
  return t;
}
const Qf = 12, Hf = 250;
let rc = bu();
const _f = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), Vf = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let Po = !1;
async function Eu(r, t) {
  try {
    const e = r.match(_f);
    if (!e)
      throw new Error("invalid data");
    return new Cn(200, "OK", {
      "content-type": e[1] || "text/plain"
    }, e[2] ? Sf(e[3]) : jf(e[3]));
  } catch {
    return new Cn(599, "BAD REQUEST (invalid data: URI)", {}, null, new In(r));
  }
}
function vu(r) {
  async function t(e, n) {
    try {
      const s = e.match(Vf);
      if (!s)
        throw new Error("invalid link");
      return new In(`${r}${s[2]}`);
    } catch {
      return new Cn(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new In(e));
    }
  }
  return t;
}
const gi = {
  data: Eu,
  ipfs: vu("https://gateway.ipfs.io/ipfs/")
}, xu = /* @__PURE__ */ new WeakMap();
var Mn, fn;
class Jf {
  constructor(t) {
    b(this, Mn, void 0);
    b(this, fn, void 0);
    d(this, Mn, []), d(this, fn, !1), xu.set(t, () => {
      if (!l(this, fn)) {
        d(this, fn, !0);
        for (const e of l(this, Mn))
          setTimeout(() => {
            e();
          }, 0);
        d(this, Mn, []);
      }
    });
  }
  addListener(t) {
    P(!l(this, fn), "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    }), l(this, Mn).push(t);
  }
  get cancelled() {
    return l(this, fn);
  }
  checkSignal() {
    P(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
Mn = new WeakMap(), fn = new WeakMap();
function yi(r) {
  if (r == null)
    throw new Error("missing signal; should not happen");
  return r.checkSignal(), r;
}
var Br, Rr, fe, Le, kr, Sr, gt, Jt, Me, Gn, Qn, Hn, Ee, Ge, hn, _n, Ts;
const Ki = class Ki {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(t) {
    b(this, _n);
    b(this, Br, void 0);
    b(this, Rr, void 0);
    b(this, fe, void 0);
    b(this, Le, void 0);
    b(this, kr, void 0);
    b(this, Sr, void 0);
    b(this, gt, void 0);
    b(this, Jt, void 0);
    b(this, Me, void 0);
    // Hooks
    b(this, Gn, void 0);
    b(this, Qn, void 0);
    b(this, Hn, void 0);
    b(this, Ee, void 0);
    b(this, Ge, void 0);
    b(this, hn, void 0);
    d(this, Sr, String(t)), d(this, Br, !1), d(this, Rr, !0), d(this, fe, {}), d(this, Le, ""), d(this, kr, 3e5), d(this, Ge, {
      slotInterval: Hf,
      maxAttempts: Qf
    }), d(this, hn, null);
  }
  /**
   *  The fetch URI to requrest.
   */
  get url() {
    return l(this, Sr);
  }
  set url(t) {
    d(this, Sr, String(t));
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``) and the .
   *
   *  If %%body%% is a string, the intrincis ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrincis ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrincis ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    return l(this, gt) == null ? null : new Uint8Array(l(this, gt));
  }
  set body(t) {
    if (t == null)
      d(this, gt, void 0), d(this, Jt, void 0);
    else if (typeof t == "string")
      d(this, gt, $e(t)), d(this, Jt, "text/plain");
    else if (t instanceof Uint8Array)
      d(this, gt, t), d(this, Jt, "application/octet-stream");
    else if (typeof t == "object")
      d(this, gt, $e(JSON.stringify(t))), d(this, Jt, "application/json");
    else
      throw new Error("invalid body");
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return l(this, gt) != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    return l(this, Le) ? l(this, Le) : this.hasBody() ? "POST" : "GET";
  }
  set method(t) {
    t == null && (t = ""), d(this, Le, String(t).toUpperCase());
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any chnages will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const t = Object.assign({}, l(this, fe));
    return l(this, Me) && (t.authorization = `Basic ${Uf($e(l(this, Me)))}`), this.allowGzip && (t["accept-encoding"] = "gzip"), t["content-type"] == null && l(this, Jt) && (t["content-type"] = l(this, Jt)), this.body && (t["content-length"] = String(this.body.length)), t;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(t) {
    return this.headers[t.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(t, e) {
    l(this, fe)[String(t).toLowerCase()] = String(e);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    d(this, fe, {});
  }
  [Symbol.iterator]() {
    const t = this.headers, e = Object.keys(t);
    let n = 0;
    return {
      next: () => {
        if (n < e.length) {
          const s = e[n++];
          return {
            value: [s, t[s]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return l(this, Me) || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(t, e) {
    y(!t.match(/:/), "invalid basic authentication username", "username", "[REDACTED]"), d(this, Me, `${t}:${e}`);
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return l(this, Rr);
  }
  set allowGzip(t) {
    d(this, Rr, !!t);
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!l(this, Br);
  }
  set allowInsecureAuthentication(t) {
    d(this, Br, !!t);
  }
  /**
   *  The timeout (in milliseconds) to wait for a complere response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return l(this, kr);
  }
  set timeout(t) {
    y(t >= 0, "timeout must be non-zero", "timeout", t), d(this, kr, t);
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return l(this, Gn) || null;
  }
  set preflightFunc(t) {
    d(this, Gn, t);
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return l(this, Qn) || null;
  }
  set processFunc(t) {
    d(this, Qn, t);
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return l(this, Hn) || null;
  }
  set retryFunc(t) {
    d(this, Hn, t);
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return l(this, hn) || rc;
  }
  set getUrlFunc(t) {
    d(this, hn, t);
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${l(this, gt) ? F(l(this, gt)) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(t) {
    t.slotInterval != null && (l(this, Ge).slotInterval = t.slotInterval), t.maxAttempts != null && (l(this, Ge).maxAttempts = t.maxAttempts);
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    return P(l(this, Ee) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" }), d(this, Ee, new Jf(this)), I(this, _n, Ts).call(this, 0, sc() + this.timeout, 0, this, new Cn(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    P(l(this, Ee) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const t = xu.get(this);
    if (!t)
      throw new Error("missing signal; should not happen");
    t();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(t) {
    const e = this.url.split(":")[0].toLowerCase(), n = t.split(":")[0].toLowerCase();
    P(this.method === "GET" && (e !== "https" || n !== "http") && t.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(t)})`
    });
    const s = new Ki(t);
    return s.method = "GET", s.allowGzip = this.allowGzip, s.timeout = this.timeout, d(s, fe, Object.assign({}, l(this, fe))), l(this, gt) && d(s, gt, new Uint8Array(l(this, gt))), d(s, Jt, l(this, Jt)), s;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const t = new Ki(this.url);
    return d(t, Le, l(this, Le)), l(this, gt) && d(t, gt, l(this, gt)), d(t, Jt, l(this, Jt)), d(t, fe, Object.assign({}, l(this, fe))), d(t, Me, l(this, Me)), this.allowGzip && (t.allowGzip = !0), t.timeout = this.timeout, this.allowInsecureAuthentication && (t.allowInsecureAuthentication = !0), d(t, Gn, l(this, Gn)), d(t, Qn, l(this, Qn)), d(t, Hn, l(this, Hn)), d(t, hn, l(this, hn)), t;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    Po = !0;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(t) {
    return gi[t.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(t, e) {
    if (t = t.toLowerCase(), t === "http" || t === "https")
      throw new Error(`cannot intercept ${t}; use registerGetUrl`);
    if (Po)
      throw new Error("gateways locked");
    gi[t] = e;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(t) {
    if (Po)
      throw new Error("gateways locked");
    rc = t;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(t) {
    return bu();
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return Eu;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(t) {
    return vu(t);
  }
};
Br = new WeakMap(), Rr = new WeakMap(), fe = new WeakMap(), Le = new WeakMap(), kr = new WeakMap(), Sr = new WeakMap(), gt = new WeakMap(), Jt = new WeakMap(), Me = new WeakMap(), Gn = new WeakMap(), Qn = new WeakMap(), Hn = new WeakMap(), Ee = new WeakMap(), Ge = new WeakMap(), hn = new WeakMap(), _n = new WeakSet(), Ts = async function(t, e, n, s, i) {
  var f, h, g;
  if (t >= l(this, Ge).maxAttempts)
    return i.makeServerError("exceeded maximum retry limit");
  P(sc() <= e, "timeout", "TIMEOUT", {
    operation: "request.send",
    reason: "timeout",
    request: s
  }), n > 0 && await zf(n);
  let o = this.clone();
  const a = (o.url.split(":")[0] || "").toLowerCase();
  if (a in gi) {
    const w = await gi[a](o.url, yi(l(s, Ee)));
    if (w instanceof Cn) {
      let E = w;
      if (this.processFunc) {
        yi(l(s, Ee));
        try {
          E = await this.processFunc(o, E);
        } catch (m) {
          (m.throttle == null || typeof m.stall != "number") && E.makeServerError("error in post-processing function", m).assertOk();
        }
      }
      return E;
    }
    o = w;
  }
  this.preflightFunc && (o = await this.preflightFunc(o));
  const c = await this.getUrlFunc(o, yi(l(s, Ee)));
  let u = new Cn(c.statusCode, c.statusMessage, c.headers, c.body, s);
  if (u.statusCode === 301 || u.statusCode === 302) {
    try {
      const w = u.headers.location || "";
      return I(f = o.redirect(w), _n, Ts).call(f, t + 1, e, 0, s, u);
    } catch {
    }
    return u;
  } else if (u.statusCode === 429 && (this.retryFunc == null || await this.retryFunc(o, u, t))) {
    const w = u.headers["retry-after"];
    let E = l(this, Ge).slotInterval * Math.trunc(Math.random() * Math.pow(2, t));
    return typeof w == "string" && w.match(/^[1-9][0-9]*$/) && (E = parseInt(w)), I(h = o.clone(), _n, Ts).call(h, t + 1, e, E, s, u);
  }
  if (this.processFunc) {
    yi(l(s, Ee));
    try {
      u = await this.processFunc(o, u);
    } catch (w) {
      (w.throttle == null || typeof w.stall != "number") && u.makeServerError("error in post-processing function", w).assertOk();
      let E = l(this, Ge).slotInterval * Math.trunc(Math.random() * Math.pow(2, t));
      return w.stall >= 0 && (E = w.stall), I(g = o.clone(), _n, Ts).call(g, t + 1, e, E, s, u);
    }
  }
  return u;
};
let In = Ki;
var zs, Ks, Ws, he, Ur, Vn;
const Ma = class Ma {
  constructor(t, e, n, s, i) {
    b(this, zs, void 0);
    b(this, Ks, void 0);
    b(this, Ws, void 0);
    b(this, he, void 0);
    b(this, Ur, void 0);
    b(this, Vn, void 0);
    d(this, zs, t), d(this, Ks, e), d(this, Ws, Object.keys(n).reduce((o, a) => (o[a.toLowerCase()] = String(n[a]), o), {})), d(this, he, s == null ? null : new Uint8Array(s)), d(this, Ur, i || null), d(this, Vn, { message: "" });
  }
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${l(this, he) ? F(l(this, he)) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return l(this, zs);
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return l(this, Ks);
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, l(this, Ws));
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return l(this, he) == null ? null : new Uint8Array(l(this, he));
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return l(this, he) == null ? "" : Aa(l(this, he));
    } catch {
      P(!1, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch {
      P(!1, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const t = this.headers, e = Object.keys(t);
    let n = 0;
    return {
      next: () => {
        if (n < e.length) {
          const s = e[n++];
          return {
            value: [s, t[s]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(t, e) {
    let n;
    t ? n = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${t})` : (t = `${this.statusCode} ${this.statusMessage}`, n = `CLIENT ESCALATED SERVER ERROR (${t})`);
    const s = new Ma(599, n, this.headers, this.body, l(this, Ur) || void 0);
    return d(s, Vn, { message: t, error: e }), s;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(t, e) {
    e == null ? e = -1 : y(Number.isInteger(e) && e >= 0, "invalid stall timeout", "stall", e);
    const n = new Error(t || "throttling requests");
    throw M(n, { stall: e, throttle: !0 }), n;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(t) {
    return this.headers[t.toLowerCase()];
  }
  /**
   *  Returns true of the response has a body.
   */
  hasBody() {
    return l(this, he) != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return l(this, Ur);
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return l(this, Vn).message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok())
      return;
    let { message: t, error: e } = l(this, Vn);
    t === "" && (t = `server response ${this.statusCode} ${this.statusMessage}`), P(!1, t, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error: e
    });
  }
};
zs = new WeakMap(), Ks = new WeakMap(), Ws = new WeakMap(), he = new WeakMap(), Ur = new WeakMap(), Vn = new WeakMap();
let Cn = Ma;
function sc() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function jf(r) {
  return $e(r.replace(/%([0-9a-f][0-9a-f])/gi, (t, e) => String.fromCharCode(parseInt(e, 16))));
}
function zf(r) {
  return new Promise((t) => setTimeout(t, r));
}
function Kf(r) {
  let t = r.toString(16);
  for (; t.length < 2; )
    t = "0" + t;
  return "0x" + t;
}
function ic(r, t, e) {
  let n = 0;
  for (let s = 0; s < e; s++)
    n = n * 256 + r[t + s];
  return n;
}
function oc(r, t, e, n) {
  const s = [];
  for (; e < t + 1 + n; ) {
    const i = Pu(r, e);
    s.push(i.result), e += i.consumed, P(e <= t + 1 + n, "child data too short", "BUFFER_OVERRUN", {
      buffer: r,
      length: n,
      offset: t
    });
  }
  return { consumed: 1 + n, result: s };
}
function Pu(r, t) {
  P(r.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: r,
    length: 0,
    offset: 1
  });
  const e = (n) => {
    P(n <= r.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: r,
      length: r.length,
      offset: n
    });
  };
  if (r[t] >= 248) {
    const n = r[t] - 247;
    e(t + 1 + n);
    const s = ic(r, t + 1, n);
    return e(t + 1 + n + s), oc(r, t, t + 1 + n, n + s);
  } else if (r[t] >= 192) {
    const n = r[t] - 192;
    return e(t + 1 + n), oc(r, t, t + 1, n);
  } else if (r[t] >= 184) {
    const n = r[t] - 183;
    e(t + 1 + n);
    const s = ic(r, t + 1, n);
    e(t + 1 + n + s);
    const i = F(r.slice(t + 1 + n, t + 1 + n + s));
    return { consumed: 1 + n + s, result: i };
  } else if (r[t] >= 128) {
    const n = r[t] - 128;
    e(t + 1 + n);
    const s = F(r.slice(t + 1, t + 1 + n));
    return { consumed: 1 + n, result: s };
  }
  return { consumed: 1, result: Kf(r[t]) };
}
function ba(r) {
  const t = X(r, "data"), e = Pu(t, 0);
  return y(e.consumed === t.length, "unexpected junk after rlp payload", "data", r), e.result;
}
function ac(r) {
  const t = [];
  for (; r; )
    t.unshift(r & 255), r >>= 8;
  return t;
}
function Nu(r) {
  if (Array.isArray(r)) {
    let n = [];
    if (r.forEach(function(i) {
      n = n.concat(Nu(i));
    }), n.length <= 55)
      return n.unshift(192 + n.length), n;
    const s = ac(n.length);
    return s.unshift(247 + s.length), s.concat(n);
  }
  const t = Array.prototype.slice.call(X(r, "object"));
  if (t.length === 1 && t[0] <= 127)
    return t;
  if (t.length <= 55)
    return t.unshift(128 + t.length), t;
  const e = ac(t.length);
  return e.unshift(183 + e.length), e.concat(t);
}
const cc = "0123456789abcdef";
function Fs(r) {
  let t = "0x";
  for (const e of Nu(r))
    t += cc[e >> 4], t += cc[e & 15];
  return t;
}
const kt = 32, Ho = new Uint8Array(kt), Wf = ["then"], mi = {};
function Ps(r, t) {
  const e = new Error(`deferred error during ABI decoding triggered accessing ${r}`);
  throw e.error = t, e;
}
var dn;
const Us = class Us extends Array {
  /**
   *  @private
   */
  constructor(...e) {
    const n = e[0];
    let s = e[1], i = (e[2] || []).slice(), o = !0;
    n !== mi && (s = e, i = [], o = !1);
    super(s.length);
    b(this, dn, void 0);
    s.forEach((c, u) => {
      this[u] = c;
    });
    const a = i.reduce((c, u) => (typeof u == "string" && c.set(u, (c.get(u) || 0) + 1), c), /* @__PURE__ */ new Map());
    if (d(this, dn, Object.freeze(s.map((c, u) => {
      const f = i[u];
      return f != null && a.get(f) === 1 ? f : null;
    }))), !!o)
      return Object.freeze(this), new Proxy(this, {
        get: (c, u, f) => {
          if (typeof u == "string") {
            if (u.match(/^[0-9]+$/)) {
              const g = V(u, "%index");
              if (g < 0 || g >= this.length)
                throw new RangeError("out of result range");
              const w = c[g];
              return w instanceof Error && Ps(`index ${g}`, w), w;
            }
            if (Wf.indexOf(u) >= 0)
              return Reflect.get(c, u, f);
            const h = c[u];
            if (h instanceof Function)
              return function(...g) {
                return h.apply(this === f ? c : this, g);
              };
            if (!(u in c))
              return c.getValue.apply(this === f ? c : this, [u]);
          }
          return Reflect.get(c, u, f);
        }
      });
  }
  /**
   *  Returns the Result as a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray() {
    const e = [];
    return this.forEach((n, s) => {
      n instanceof Error && Ps(`index ${s}`, n), e.push(n);
    }), e;
  }
  /**
   *  Returns the Result as an Object with each name-value pair.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject() {
    return l(this, dn).reduce((e, n, s) => (P(n != null, "value at index ${ index } unnamed", "UNSUPPORTED_OPERATION", {
      operation: "toObject()"
    }), n in e || (e[n] = this.getValue(n)), e), {});
  }
  /**
   *  @_ignore
   */
  slice(e, n) {
    e == null && (e = 0), e < 0 && (e += this.length, e < 0 && (e = 0)), n == null && (n = this.length), n < 0 && (n += this.length, n < 0 && (n = 0)), n > this.length && (n = this.length);
    const s = [], i = [];
    for (let o = e; o < n; o++)
      s.push(this[o]), i.push(l(this, dn)[o]);
    return new Us(mi, s, i);
  }
  /**
   *  @_ignore
   */
  filter(e, n) {
    const s = [], i = [];
    for (let o = 0; o < this.length; o++) {
      const a = this[o];
      a instanceof Error && Ps(`index ${o}`, a), e.call(n, a, o, this) && (s.push(a), i.push(l(this, dn)[o]));
    }
    return new Us(mi, s, i);
  }
  /**
   *  @_ignore
   */
  map(e, n) {
    const s = [];
    for (let i = 0; i < this.length; i++) {
      const o = this[i];
      o instanceof Error && Ps(`index ${i}`, o), s.push(e.call(n, o, i, this));
    }
    return s;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(e) {
    const n = l(this, dn).indexOf(e);
    if (n === -1)
      return;
    const s = this[n];
    return s instanceof Error && Ps(`property ${JSON.stringify(e)}`, s.error), s;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(e, n) {
    return new Us(mi, e, n);
  }
};
dn = new WeakMap();
let Ui = Us;
function uc(r) {
  let t = Kt(r);
  return P(t.length <= kt, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: t, length: kt, offset: t.length }), t.length !== kt && (t = Ht(pt([Ho.slice(t.length % kt), t]))), t;
}
class nn {
  constructor(t, e, n, s) {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    A(this, "name");
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    A(this, "type");
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    A(this, "localName");
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    A(this, "dynamic");
    M(this, { name: t, type: e, localName: n, dynamic: s }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(t, e) {
    y(!1, t, this.localName, e);
  }
}
var Qe, Jn, Dr, Ni;
class _o {
  constructor() {
    b(this, Dr);
    // An array of WordSize lengthed objects to concatenation
    b(this, Qe, void 0);
    b(this, Jn, void 0);
    d(this, Qe, []), d(this, Jn, 0);
  }
  get data() {
    return pt(l(this, Qe));
  }
  get length() {
    return l(this, Jn);
  }
  appendWriter(t) {
    return I(this, Dr, Ni).call(this, Ht(t.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(t) {
    let e = Ht(t);
    const n = e.length % kt;
    return n && (e = Ht(pt([e, Ho.slice(n)]))), I(this, Dr, Ni).call(this, e);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(t) {
    return I(this, Dr, Ni).call(this, uc(t));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const t = l(this, Qe).length;
    return l(this, Qe).push(Ho), d(this, Jn, l(this, Jn) + kt), (e) => {
      l(this, Qe)[t] = uc(e);
    };
  }
}
Qe = new WeakMap(), Jn = new WeakMap(), Dr = new WeakSet(), Ni = function(t) {
  return l(this, Qe).push(t), d(this, Jn, l(this, Jn) + t.length), t.length;
};
var jt, $t, Wi, Cu;
const Ga = class Ga {
  constructor(t, e) {
    b(this, Wi);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    A(this, "allowLoose");
    b(this, jt, void 0);
    b(this, $t, void 0);
    M(this, { allowLoose: !!e }), d(this, jt, Ht(t)), d(this, $t, 0);
  }
  get data() {
    return F(l(this, jt));
  }
  get dataLength() {
    return l(this, jt).length;
  }
  get consumed() {
    return l(this, $t);
  }
  get bytes() {
    return new Uint8Array(l(this, jt));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(t) {
    return new Ga(l(this, jt).slice(l(this, $t) + t), this.allowLoose);
  }
  // Read bytes
  readBytes(t, e) {
    let n = I(this, Wi, Cu).call(this, 0, t, !!e);
    return d(this, $t, l(this, $t) + n.length), n.slice(0, t);
  }
  // Read a numeric values
  readValue() {
    return wa(this.readBytes(kt));
  }
  readIndex() {
    return Bf(this.readBytes(kt));
  }
};
jt = new WeakMap(), $t = new WeakMap(), Wi = new WeakSet(), Cu = function(t, e, n) {
  let s = Math.ceil(e / kt) * kt;
  return l(this, $t) + s > l(this, jt).length && (this.allowLoose && n && l(this, $t) + e <= l(this, jt).length ? s = e : P(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
    buffer: Ht(l(this, jt)),
    length: l(this, jt).length,
    offset: l(this, $t) + s
  })), l(this, jt).slice(l(this, $t), l(this, $t) + s);
};
let Vo = Ga;
function Di(r) {
  if (!Number.isSafeInteger(r) || r < 0)
    throw new Error(`Wrong positive integer: ${r}`);
}
function Ea(r, ...t) {
  if (!(r instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(r.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${r.length}`);
}
function Yf(r) {
  if (typeof r != "function" || typeof r.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Di(r.outputLen), Di(r.blockLen);
}
function ps(r, t = !0) {
  if (r.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && r.finished)
    throw new Error("Hash#digest() has already been called");
}
function Tu(r, t) {
  Ea(r);
  const e = t.outputLen;
  if (r.length < e)
    throw new Error(`digestInto() expects output buffer of length at least ${e}`);
}
const No = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ou = (r) => r instanceof Uint8Array, Zf = (r) => new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4)), Co = (r) => new DataView(r.buffer, r.byteOffset, r.byteLength), be = (r, t) => r << 32 - t | r >>> t, Xf = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Xf)
  throw new Error("Non little-endian hardware is not supported");
function qf(r) {
  if (typeof r != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof r}`);
  return new Uint8Array(new TextEncoder().encode(r));
}
function so(r) {
  if (typeof r == "string" && (r = qf(r)), !Ou(r))
    throw new Error(`expected Uint8Array, got ${typeof r}`);
  return r;
}
function $f(...r) {
  const t = new Uint8Array(r.reduce((n, s) => n + s.length, 0));
  let e = 0;
  return r.forEach((n) => {
    if (!Ou(n))
      throw new Error("Uint8Array expected");
    t.set(n, e), e += n.length;
  }), t;
}
class va {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function Iu(r) {
  const t = (n) => r().update(so(n)).digest(), e = r();
  return t.outputLen = e.outputLen, t.blockLen = e.blockLen, t.create = () => r(), t;
}
function th(r = 32) {
  if (No && typeof No.getRandomValues == "function")
    return No.getRandomValues(new Uint8Array(r));
  throw new Error("crypto.getRandomValues must be defined");
}
class Bu extends va {
  constructor(t, e) {
    super(), this.finished = !1, this.destroyed = !1, Yf(t);
    const n = so(e);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const s = this.blockLen, i = new Uint8Array(s);
    i.set(n.length > s ? t.create().update(n).digest() : n);
    for (let o = 0; o < i.length; o++)
      i[o] ^= 54;
    this.iHash.update(i), this.oHash = t.create();
    for (let o = 0; o < i.length; o++)
      i[o] ^= 106;
    this.oHash.update(i), i.fill(0);
  }
  update(t) {
    return ps(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    ps(this), Ea(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: e, iHash: n, finished: s, destroyed: i, blockLen: o, outputLen: a } = this;
    return t = t, t.finished = s, t.destroyed = i, t.blockLen = o, t.outputLen = a, t.oHash = e._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const Ru = (r, t, e) => new Bu(r, t).update(e).digest();
Ru.create = (r, t) => new Bu(r, t);
function eh(r, t, e, n) {
  if (typeof r.setBigUint64 == "function")
    return r.setBigUint64(t, e, n);
  const s = BigInt(32), i = BigInt(4294967295), o = Number(e >> s & i), a = Number(e & i), c = n ? 4 : 0, u = n ? 0 : 4;
  r.setUint32(t + c, o, n), r.setUint32(t + u, a, n);
}
class nh extends va {
  constructor(t, e, n, s) {
    super(), this.blockLen = t, this.outputLen = e, this.padOffset = n, this.isLE = s, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = Co(this.buffer);
  }
  update(t) {
    ps(this);
    const { view: e, buffer: n, blockLen: s } = this;
    t = so(t);
    const i = t.length;
    for (let o = 0; o < i; ) {
      const a = Math.min(s - this.pos, i - o);
      if (a === s) {
        const c = Co(t);
        for (; s <= i - o; o += s)
          this.process(c, o);
        continue;
      }
      n.set(t.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === s && (this.process(e, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    ps(this), Tu(t, this), this.finished = !0;
    const { buffer: e, view: n, blockLen: s, isLE: i } = this;
    let { pos: o } = this;
    e[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > s - o && (this.process(n, 0), o = 0);
    for (let h = o; h < s; h++)
      e[h] = 0;
    eh(n, s - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const a = Co(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, f = this.get();
    if (u > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let h = 0; h < u; h++)
      a.setUint32(4 * h, f[h], i);
  }
  digest() {
    const { buffer: t, outputLen: e } = this;
    this.digestInto(t);
    const n = t.slice(0, e);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: e, buffer: n, length: s, finished: i, destroyed: o, pos: a } = this;
    return t.length = s, t.pos = a, t.finished = i, t.destroyed = o, s % e && t.buffer.set(n), t;
  }
}
const rh = (r, t, e) => r & t ^ ~r & e, sh = (r, t, e) => r & t ^ r & e ^ t & e, ih = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), an = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), cn = /* @__PURE__ */ new Uint32Array(64);
class oh extends nh {
  constructor() {
    super(64, 32, 8, !1), this.A = an[0] | 0, this.B = an[1] | 0, this.C = an[2] | 0, this.D = an[3] | 0, this.E = an[4] | 0, this.F = an[5] | 0, this.G = an[6] | 0, this.H = an[7] | 0;
  }
  get() {
    const { A: t, B: e, C: n, D: s, E: i, F: o, G: a, H: c } = this;
    return [t, e, n, s, i, o, a, c];
  }
  // prettier-ignore
  set(t, e, n, s, i, o, a, c) {
    this.A = t | 0, this.B = e | 0, this.C = n | 0, this.D = s | 0, this.E = i | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, e) {
    for (let h = 0; h < 16; h++, e += 4)
      cn[h] = t.getUint32(e, !1);
    for (let h = 16; h < 64; h++) {
      const g = cn[h - 15], w = cn[h - 2], E = be(g, 7) ^ be(g, 18) ^ g >>> 3, m = be(w, 17) ^ be(w, 19) ^ w >>> 10;
      cn[h] = m + cn[h - 7] + E + cn[h - 16] | 0;
    }
    let { A: n, B: s, C: i, D: o, E: a, F: c, G: u, H: f } = this;
    for (let h = 0; h < 64; h++) {
      const g = be(a, 6) ^ be(a, 11) ^ be(a, 25), w = f + g + rh(a, c, u) + ih[h] + cn[h] | 0, m = (be(n, 2) ^ be(n, 13) ^ be(n, 22)) + sh(n, s, i) | 0;
      f = u, u = c, c = a, a = o + w | 0, o = i, i = s, s = n, n = w + m | 0;
    }
    n = n + this.A | 0, s = s + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, f = f + this.H | 0, this.set(n, s, i, o, a, c, u, f);
  }
  roundClean() {
    cn.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const ah = /* @__PURE__ */ Iu(() => new oh()), wi = /* @__PURE__ */ BigInt(2 ** 32 - 1), lc = /* @__PURE__ */ BigInt(32);
function ch(r, t = !1) {
  return t ? { h: Number(r & wi), l: Number(r >> lc & wi) } : { h: Number(r >> lc & wi) | 0, l: Number(r & wi) | 0 };
}
function uh(r, t = !1) {
  let e = new Uint32Array(r.length), n = new Uint32Array(r.length);
  for (let s = 0; s < r.length; s++) {
    const { h: i, l: o } = ch(r[s], t);
    [e[s], n[s]] = [i, o];
  }
  return [e, n];
}
const lh = (r, t, e) => r << e | t >>> 32 - e, fh = (r, t, e) => t << e | r >>> 32 - e, hh = (r, t, e) => t << e - 32 | r >>> 64 - e, dh = (r, t, e) => r << e - 32 | t >>> 64 - e, [ku, Su, Uu] = [[], [], []], ph = /* @__PURE__ */ BigInt(0), Ns = /* @__PURE__ */ BigInt(1), gh = /* @__PURE__ */ BigInt(2), yh = /* @__PURE__ */ BigInt(7), mh = /* @__PURE__ */ BigInt(256), wh = /* @__PURE__ */ BigInt(113);
for (let r = 0, t = Ns, e = 1, n = 0; r < 24; r++) {
  [e, n] = [n, (2 * e + 3 * n) % 5], ku.push(2 * (5 * n + e)), Su.push((r + 1) * (r + 2) / 2 % 64);
  let s = ph;
  for (let i = 0; i < 7; i++)
    t = (t << Ns ^ (t >> yh) * wh) % mh, t & gh && (s ^= Ns << (Ns << /* @__PURE__ */ BigInt(i)) - Ns);
  Uu.push(s);
}
const [Ah, bh] = /* @__PURE__ */ uh(Uu, !0), fc = (r, t, e) => e > 32 ? hh(r, t, e) : lh(r, t, e), hc = (r, t, e) => e > 32 ? dh(r, t, e) : fh(r, t, e);
function Eh(r, t = 24) {
  const e = new Uint32Array(10);
  for (let n = 24 - t; n < 24; n++) {
    for (let o = 0; o < 10; o++)
      e[o] = r[o] ^ r[o + 10] ^ r[o + 20] ^ r[o + 30] ^ r[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10, c = (o + 2) % 10, u = e[c], f = e[c + 1], h = fc(u, f, 1) ^ e[a], g = hc(u, f, 1) ^ e[a + 1];
      for (let w = 0; w < 50; w += 10)
        r[o + w] ^= h, r[o + w + 1] ^= g;
    }
    let s = r[2], i = r[3];
    for (let o = 0; o < 24; o++) {
      const a = Su[o], c = fc(s, i, a), u = hc(s, i, a), f = ku[o];
      s = r[f], i = r[f + 1], r[f] = c, r[f + 1] = u;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++)
        e[a] = r[o + a];
      for (let a = 0; a < 10; a++)
        r[o + a] ^= ~e[(a + 2) % 10] & e[(a + 4) % 10];
    }
    r[0] ^= Ah[n], r[1] ^= bh[n];
  }
  e.fill(0);
}
class xa extends va {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, e, n, s = !1, i = 24) {
    if (super(), this.blockLen = t, this.suffix = e, this.outputLen = n, this.enableXOF = s, this.rounds = i, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, Di(n), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = Zf(this.state);
  }
  keccak() {
    Eh(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    ps(this);
    const { blockLen: e, state: n } = this;
    t = so(t);
    const s = t.length;
    for (let i = 0; i < s; ) {
      const o = Math.min(e - this.pos, s - i);
      for (let a = 0; a < o; a++)
        n[this.pos++] ^= t[i++];
      this.pos === e && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: e, pos: n, blockLen: s } = this;
    t[n] ^= e, e & 128 && n === s - 1 && this.keccak(), t[s - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    ps(this, !1), Ea(t), this.finish();
    const e = this.state, { blockLen: n } = this;
    for (let s = 0, i = t.length; s < i; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, i - s);
      t.set(e.subarray(this.posOut, this.posOut + o), s), this.posOut += o, s += o;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return Di(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (Tu(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: e, suffix: n, outputLen: s, rounds: i, enableXOF: o } = this;
    return t || (t = new xa(e, n, s, o, i)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = i, t.suffix = n, t.outputLen = s, t.enableXOF = o, t.destroyed = this.destroyed, t;
  }
}
const vh = (r, t, e) => Iu(() => new xa(t, r, e)), xh = /* @__PURE__ */ vh(1, 136, 256 / 8);
let Du = !1;
const Fu = function(r) {
  return xh(r);
};
let Lu = Fu;
function st(r) {
  const t = X(r, "data");
  return F(Lu(t));
}
st._ = Fu;
st.lock = function() {
  Du = !0;
};
st.register = function(r) {
  if (Du)
    throw new TypeError("keccak256 is locked");
  Lu = r;
};
Object.freeze(st);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Mu = BigInt(0), io = BigInt(1), Ph = BigInt(2), oo = (r) => r instanceof Uint8Array, Nh = /* @__PURE__ */ Array.from({ length: 256 }, (r, t) => t.toString(16).padStart(2, "0"));
function gs(r) {
  if (!oo(r))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let e = 0; e < r.length; e++)
    t += Nh[r[e]];
  return t;
}
function Gu(r) {
  const t = r.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function Pa(r) {
  if (typeof r != "string")
    throw new Error("hex string expected, got " + typeof r);
  return BigInt(r === "" ? "0" : `0x${r}`);
}
function ys(r) {
  if (typeof r != "string")
    throw new Error("hex string expected, got " + typeof r);
  const t = r.length;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const e = new Uint8Array(t / 2);
  for (let n = 0; n < e.length; n++) {
    const s = n * 2, i = r.slice(s, s + 2), o = Number.parseInt(i, 16);
    if (Number.isNaN(o) || o < 0)
      throw new Error("Invalid byte sequence");
    e[n] = o;
  }
  return e;
}
function rr(r) {
  return Pa(gs(r));
}
function Na(r) {
  if (!oo(r))
    throw new Error("Uint8Array expected");
  return Pa(gs(Uint8Array.from(r).reverse()));
}
function ms(r, t) {
  return ys(r.toString(16).padStart(t * 2, "0"));
}
function Ca(r, t) {
  return ms(r, t).reverse();
}
function Ch(r) {
  return ys(Gu(r));
}
function le(r, t, e) {
  let n;
  if (typeof t == "string")
    try {
      n = ys(t);
    } catch (i) {
      throw new Error(`${r} must be valid hex string, got "${t}". Cause: ${i}`);
    }
  else if (oo(t))
    n = Uint8Array.from(t);
  else
    throw new Error(`${r} must be hex string or Uint8Array`);
  const s = n.length;
  if (typeof e == "number" && s !== e)
    throw new Error(`${r} expected ${e} bytes, got ${s}`);
  return n;
}
function Ls(...r) {
  const t = new Uint8Array(r.reduce((n, s) => n + s.length, 0));
  let e = 0;
  return r.forEach((n) => {
    if (!oo(n))
      throw new Error("Uint8Array expected");
    t.set(n, e), e += n.length;
  }), t;
}
function Th(r, t) {
  if (r.length !== t.length)
    return !1;
  for (let e = 0; e < r.length; e++)
    if (r[e] !== t[e])
      return !1;
  return !0;
}
function Oh(r) {
  if (typeof r != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof r}`);
  return new Uint8Array(new TextEncoder().encode(r));
}
function Ih(r) {
  let t;
  for (t = 0; r > Mu; r >>= io, t += 1)
    ;
  return t;
}
function Bh(r, t) {
  return r >> BigInt(t) & io;
}
const Rh = (r, t, e) => r | (e ? io : Mu) << BigInt(t), Ta = (r) => (Ph << BigInt(r - 1)) - io, To = (r) => new Uint8Array(r), dc = (r) => Uint8Array.from(r);
function Qu(r, t, e) {
  if (typeof r != "number" || r < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof e != "function")
    throw new Error("hmacFn must be a function");
  let n = To(r), s = To(r), i = 0;
  const o = () => {
    n.fill(1), s.fill(0), i = 0;
  }, a = (...h) => e(s, n, ...h), c = (h = To()) => {
    s = a(dc([0]), h), n = a(), h.length !== 0 && (s = a(dc([1]), h), n = a());
  }, u = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let h = 0;
    const g = [];
    for (; h < t; ) {
      n = a();
      const w = n.slice();
      g.push(w), h += n.length;
    }
    return Ls(...g);
  };
  return (h, g) => {
    o(), c(h);
    let w;
    for (; !(w = g(u())); )
      c();
    return o(), w;
  };
}
const kh = {
  bigint: (r) => typeof r == "bigint",
  function: (r) => typeof r == "function",
  boolean: (r) => typeof r == "boolean",
  string: (r) => typeof r == "string",
  stringOrUint8Array: (r) => typeof r == "string" || r instanceof Uint8Array,
  isSafeInteger: (r) => Number.isSafeInteger(r),
  array: (r) => Array.isArray(r),
  field: (r, t) => t.Fp.isValid(r),
  hash: (r) => typeof r == "function" && Number.isSafeInteger(r.outputLen)
};
function ui(r, t, e = {}) {
  const n = (s, i, o) => {
    const a = kh[i];
    if (typeof a != "function")
      throw new Error(`Invalid validator "${i}", expected function`);
    const c = r[s];
    if (!(o && c === void 0) && !a(c, r))
      throw new Error(`Invalid param ${String(s)}=${c} (${typeof c}), expected ${i}`);
  };
  for (const [s, i] of Object.entries(t))
    n(s, i, !1);
  for (const [s, i] of Object.entries(e))
    n(s, i, !0);
  return r;
}
const Sh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: Bh,
  bitLen: Ih,
  bitMask: Ta,
  bitSet: Rh,
  bytesToHex: gs,
  bytesToNumberBE: rr,
  bytesToNumberLE: Na,
  concatBytes: Ls,
  createHmacDrbg: Qu,
  ensureBytes: le,
  equalBytes: Th,
  hexToBytes: ys,
  hexToNumber: Pa,
  numberToBytesBE: ms,
  numberToBytesLE: Ca,
  numberToHexUnpadded: Gu,
  numberToVarBytesBE: Ch,
  utf8ToBytes: Oh,
  validateObject: ui
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const yt = BigInt(0), lt = BigInt(1), Sn = BigInt(2), Uh = BigInt(3), Jo = BigInt(4), pc = BigInt(5), gc = BigInt(8);
BigInt(9);
BigInt(16);
function Mt(r, t) {
  const e = r % t;
  return e >= yt ? e : t + e;
}
function Dh(r, t, e) {
  if (e <= yt || t < yt)
    throw new Error("Expected power/modulo > 0");
  if (e === lt)
    return yt;
  let n = lt;
  for (; t > yt; )
    t & lt && (n = n * r % e), r = r * r % e, t >>= lt;
  return n;
}
function Yt(r, t, e) {
  let n = r;
  for (; t-- > yt; )
    n *= n, n %= e;
  return n;
}
function jo(r, t) {
  if (r === yt || t <= yt)
    throw new Error(`invert: expected positive integers, got n=${r} mod=${t}`);
  let e = Mt(r, t), n = t, s = yt, i = lt;
  for (; e !== yt; ) {
    const a = n / e, c = n % e, u = s - i * a;
    n = e, e = c, s = i, i = u;
  }
  if (n !== lt)
    throw new Error("invert: does not exist");
  return Mt(s, t);
}
function Fh(r) {
  const t = (r - lt) / Sn;
  let e, n, s;
  for (e = r - lt, n = 0; e % Sn === yt; e /= Sn, n++)
    ;
  for (s = Sn; s < r && Dh(s, t, r) !== r - lt; s++)
    ;
  if (n === 1) {
    const o = (r + lt) / Jo;
    return function(c, u) {
      const f = c.pow(u, o);
      if (!c.eql(c.sqr(f), u))
        throw new Error("Cannot find square root");
      return f;
    };
  }
  const i = (e + lt) / Sn;
  return function(a, c) {
    if (a.pow(c, t) === a.neg(a.ONE))
      throw new Error("Cannot find square root");
    let u = n, f = a.pow(a.mul(a.ONE, s), e), h = a.pow(c, i), g = a.pow(c, e);
    for (; !a.eql(g, a.ONE); ) {
      if (a.eql(g, a.ZERO))
        return a.ZERO;
      let w = 1;
      for (let m = a.sqr(g); w < u && !a.eql(m, a.ONE); w++)
        m = a.sqr(m);
      const E = a.pow(f, lt << BigInt(u - w - 1));
      f = a.sqr(E), h = a.mul(h, E), g = a.mul(g, f), u = w;
    }
    return h;
  };
}
function Lh(r) {
  if (r % Jo === Uh) {
    const t = (r + lt) / Jo;
    return function(n, s) {
      const i = n.pow(s, t);
      if (!n.eql(n.sqr(i), s))
        throw new Error("Cannot find square root");
      return i;
    };
  }
  if (r % gc === pc) {
    const t = (r - pc) / gc;
    return function(n, s) {
      const i = n.mul(s, Sn), o = n.pow(i, t), a = n.mul(s, o), c = n.mul(n.mul(a, Sn), o), u = n.mul(a, n.sub(c, n.ONE));
      if (!n.eql(n.sqr(u), s))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  return Fh(r);
}
const Mh = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Gh(r) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, e = Mh.reduce((n, s) => (n[s] = "function", n), t);
  return ui(r, e);
}
function Qh(r, t, e) {
  if (e < yt)
    throw new Error("Expected power > 0");
  if (e === yt)
    return r.ONE;
  if (e === lt)
    return t;
  let n = r.ONE, s = t;
  for (; e > yt; )
    e & lt && (n = r.mul(n, s)), s = r.sqr(s), e >>= lt;
  return n;
}
function Hh(r, t) {
  const e = new Array(t.length), n = t.reduce((i, o, a) => r.is0(o) ? i : (e[a] = i, r.mul(i, o)), r.ONE), s = r.inv(n);
  return t.reduceRight((i, o, a) => r.is0(o) ? i : (e[a] = r.mul(i, e[a]), r.mul(i, o)), s), e;
}
function Hu(r, t) {
  const e = t !== void 0 ? t : r.toString(2).length, n = Math.ceil(e / 8);
  return { nBitLength: e, nByteLength: n };
}
function _h(r, t, e = !1, n = {}) {
  if (r <= yt)
    throw new Error(`Expected Field ORDER > 0, got ${r}`);
  const { nBitLength: s, nByteLength: i } = Hu(r, t);
  if (i > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const o = Lh(r), a = Object.freeze({
    ORDER: r,
    BITS: s,
    BYTES: i,
    MASK: Ta(s),
    ZERO: yt,
    ONE: lt,
    create: (c) => Mt(c, r),
    isValid: (c) => {
      if (typeof c != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
      return yt <= c && c < r;
    },
    is0: (c) => c === yt,
    isOdd: (c) => (c & lt) === lt,
    neg: (c) => Mt(-c, r),
    eql: (c, u) => c === u,
    sqr: (c) => Mt(c * c, r),
    add: (c, u) => Mt(c + u, r),
    sub: (c, u) => Mt(c - u, r),
    mul: (c, u) => Mt(c * u, r),
    pow: (c, u) => Qh(a, c, u),
    div: (c, u) => Mt(c * jo(u, r), r),
    // Same as above, but doesn't normalize
    sqrN: (c) => c * c,
    addN: (c, u) => c + u,
    subN: (c, u) => c - u,
    mulN: (c, u) => c * u,
    inv: (c) => jo(c, r),
    sqrt: n.sqrt || ((c) => o(a, c)),
    invertBatch: (c) => Hh(a, c),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (c, u, f) => f ? u : c,
    toBytes: (c) => e ? Ca(c, i) : ms(c, i),
    fromBytes: (c) => {
      if (c.length !== i)
        throw new Error(`Fp.fromBytes: expected ${i}, got ${c.length}`);
      return e ? Na(c) : rr(c);
    }
  });
  return Object.freeze(a);
}
function _u(r) {
  if (typeof r != "bigint")
    throw new Error("field order must be bigint");
  const t = r.toString(2).length;
  return Math.ceil(t / 8);
}
function Vu(r) {
  const t = _u(r);
  return t + Math.ceil(t / 2);
}
function Vh(r, t, e = !1) {
  const n = r.length, s = _u(t), i = Vu(t);
  if (n < 16 || n < i || n > 1024)
    throw new Error(`expected ${i}-1024 bytes of input, got ${n}`);
  const o = e ? rr(r) : Na(r), a = Mt(o, t - lt) + lt;
  return e ? Ca(a, s) : ms(a, s);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Jh = BigInt(0), Oo = BigInt(1);
function jh(r, t) {
  const e = (s, i) => {
    const o = i.negate();
    return s ? o : i;
  }, n = (s) => {
    const i = Math.ceil(t / s) + 1, o = 2 ** (s - 1);
    return { windows: i, windowSize: o };
  };
  return {
    constTimeNegate: e,
    // non-const time multiplication ladder
    unsafeLadder(s, i) {
      let o = r.ZERO, a = s;
      for (; i > Jh; )
        i & Oo && (o = o.add(a)), a = a.double(), i >>= Oo;
      return o;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(s, i) {
      const { windows: o, windowSize: a } = n(i), c = [];
      let u = s, f = u;
      for (let h = 0; h < o; h++) {
        f = u, c.push(f);
        for (let g = 1; g < a; g++)
          f = f.add(u), c.push(f);
        u = f.double();
      }
      return c;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(s, i, o) {
      const { windows: a, windowSize: c } = n(s);
      let u = r.ZERO, f = r.BASE;
      const h = BigInt(2 ** s - 1), g = 2 ** s, w = BigInt(s);
      for (let E = 0; E < a; E++) {
        const m = E * c;
        let x = Number(o & h);
        o >>= w, x > c && (x -= g, o += Oo);
        const v = m, B = m + Math.abs(x) - 1, T = E % 2 !== 0, H = x < 0;
        x === 0 ? f = f.add(e(T, i[v])) : u = u.add(e(H, i[B]));
      }
      return { p: u, f };
    },
    wNAFCached(s, i, o, a) {
      const c = s._WINDOW_SIZE || 1;
      let u = i.get(s);
      return u || (u = this.precomputeWindow(s, c), c !== 1 && i.set(s, a(u))), this.wNAF(c, u, o);
    }
  };
}
function Ju(r) {
  return Gh(r.Fp), ui(r, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...Hu(r.n, r.nBitLength),
    ...r,
    p: r.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function zh(r) {
  const t = Ju(r);
  ui(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: e, Fp: n, a: s } = t;
  if (e) {
    if (!n.eql(s, n.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof e != "object" || typeof e.beta != "bigint" || typeof e.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: Kh, hexToBytes: Wh } = Sh, Dn = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(t = "") {
      super(t);
    }
  },
  _parseInt(r) {
    const { Err: t } = Dn;
    if (r.length < 2 || r[0] !== 2)
      throw new t("Invalid signature integer tag");
    const e = r[1], n = r.subarray(2, e + 2);
    if (!e || n.length !== e)
      throw new t("Invalid signature integer: wrong length");
    if (n[0] & 128)
      throw new t("Invalid signature integer: negative");
    if (n[0] === 0 && !(n[1] & 128))
      throw new t("Invalid signature integer: unnecessary leading zero");
    return { d: Kh(n), l: r.subarray(e + 2) };
  },
  toSig(r) {
    const { Err: t } = Dn, e = typeof r == "string" ? Wh(r) : r;
    if (!(e instanceof Uint8Array))
      throw new Error("ui8a expected");
    let n = e.length;
    if (n < 2 || e[0] != 48)
      throw new t("Invalid signature tag");
    if (e[1] !== n - 2)
      throw new t("Invalid signature: incorrect length");
    const { d: s, l: i } = Dn._parseInt(e.subarray(2)), { d: o, l: a } = Dn._parseInt(i);
    if (a.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: s, s: o };
  },
  hexFromSig(r) {
    const t = (u) => Number.parseInt(u[0], 16) & 8 ? "00" + u : u, e = (u) => {
      const f = u.toString(16);
      return f.length & 1 ? `0${f}` : f;
    }, n = t(e(r.s)), s = t(e(r.r)), i = n.length / 2, o = s.length / 2, a = e(i), c = e(o);
    return `30${e(o + i + 4)}02${c}${s}02${a}${n}`;
  }
}, Ze = BigInt(0), re = BigInt(1);
BigInt(2);
const yc = BigInt(3);
BigInt(4);
function Yh(r) {
  const t = zh(r), { Fp: e } = t, n = t.toBytes || ((E, m, x) => {
    const v = m.toAffine();
    return Ls(Uint8Array.from([4]), e.toBytes(v.x), e.toBytes(v.y));
  }), s = t.fromBytes || ((E) => {
    const m = E.subarray(1), x = e.fromBytes(m.subarray(0, e.BYTES)), v = e.fromBytes(m.subarray(e.BYTES, 2 * e.BYTES));
    return { x, y: v };
  });
  function i(E) {
    const { a: m, b: x } = t, v = e.sqr(E), B = e.mul(v, E);
    return e.add(e.add(B, e.mul(E, m)), x);
  }
  if (!e.eql(e.sqr(t.Gy), i(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function o(E) {
    return typeof E == "bigint" && Ze < E && E < t.n;
  }
  function a(E) {
    if (!o(E))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function c(E) {
    const { allowedPrivateKeyLengths: m, nByteLength: x, wrapPrivateKey: v, n: B } = t;
    if (m && typeof E != "bigint") {
      if (E instanceof Uint8Array && (E = gs(E)), typeof E != "string" || !m.includes(E.length))
        throw new Error("Invalid key");
      E = E.padStart(x * 2, "0");
    }
    let T;
    try {
      T = typeof E == "bigint" ? E : rr(le("private key", E, x));
    } catch {
      throw new Error(`private key must be ${x} bytes, hex or bigint, not ${typeof E}`);
    }
    return v && (T = Mt(T, B)), a(T), T;
  }
  const u = /* @__PURE__ */ new Map();
  function f(E) {
    if (!(E instanceof h))
      throw new Error("ProjectivePoint expected");
  }
  class h {
    constructor(m, x, v) {
      if (this.px = m, this.py = x, this.pz = v, m == null || !e.isValid(m))
        throw new Error("x required");
      if (x == null || !e.isValid(x))
        throw new Error("y required");
      if (v == null || !e.isValid(v))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(m) {
      const { x, y: v } = m || {};
      if (!m || !e.isValid(x) || !e.isValid(v))
        throw new Error("invalid affine point");
      if (m instanceof h)
        throw new Error("projective point not allowed");
      const B = (T) => e.eql(T, e.ZERO);
      return B(x) && B(v) ? h.ZERO : new h(x, v, e.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(m) {
      const x = e.invertBatch(m.map((v) => v.pz));
      return m.map((v, B) => v.toAffine(x[B])).map(h.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(m) {
      const x = h.fromAffine(s(le("pointHex", m)));
      return x.assertValidity(), x;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(m) {
      return h.BASE.multiply(c(m));
    }
    // "Private method", don't use it directly
    _setWindowSize(m) {
      this._WINDOW_SIZE = m, u.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint && !e.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: m, y: x } = this.toAffine();
      if (!e.isValid(m) || !e.isValid(x))
        throw new Error("bad point: x or y not FE");
      const v = e.sqr(x), B = i(m);
      if (!e.eql(v, B))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: m } = this.toAffine();
      if (e.isOdd)
        return !e.isOdd(m);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(m) {
      f(m);
      const { px: x, py: v, pz: B } = this, { px: T, py: H, pz: G } = m, U = e.eql(e.mul(x, G), e.mul(T, B)), D = e.eql(e.mul(v, G), e.mul(H, B));
      return U && D;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new h(this.px, e.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: m, b: x } = t, v = e.mul(x, yc), { px: B, py: T, pz: H } = this;
      let G = e.ZERO, U = e.ZERO, D = e.ZERO, k = e.mul(B, B), ot = e.mul(T, T), Y = e.mul(H, H), K = e.mul(B, T);
      return K = e.add(K, K), D = e.mul(B, H), D = e.add(D, D), G = e.mul(m, D), U = e.mul(v, Y), U = e.add(G, U), G = e.sub(ot, U), U = e.add(ot, U), U = e.mul(G, U), G = e.mul(K, G), D = e.mul(v, D), Y = e.mul(m, Y), K = e.sub(k, Y), K = e.mul(m, K), K = e.add(K, D), D = e.add(k, k), k = e.add(D, k), k = e.add(k, Y), k = e.mul(k, K), U = e.add(U, k), Y = e.mul(T, H), Y = e.add(Y, Y), k = e.mul(Y, K), G = e.sub(G, k), D = e.mul(Y, ot), D = e.add(D, D), D = e.add(D, D), new h(G, U, D);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(m) {
      f(m);
      const { px: x, py: v, pz: B } = this, { px: T, py: H, pz: G } = m;
      let U = e.ZERO, D = e.ZERO, k = e.ZERO;
      const ot = t.a, Y = e.mul(t.b, yc);
      let K = e.mul(x, T), Ot = e.mul(v, H), bt = e.mul(B, G), ht = e.add(x, v), C = e.add(T, H);
      ht = e.mul(ht, C), C = e.add(K, Ot), ht = e.sub(ht, C), C = e.add(x, B);
      let S = e.add(T, G);
      return C = e.mul(C, S), S = e.add(K, bt), C = e.sub(C, S), S = e.add(v, B), U = e.add(H, G), S = e.mul(S, U), U = e.add(Ot, bt), S = e.sub(S, U), k = e.mul(ot, C), U = e.mul(Y, bt), k = e.add(U, k), U = e.sub(Ot, k), k = e.add(Ot, k), D = e.mul(U, k), Ot = e.add(K, K), Ot = e.add(Ot, K), bt = e.mul(ot, bt), C = e.mul(Y, C), Ot = e.add(Ot, bt), bt = e.sub(K, bt), bt = e.mul(ot, bt), C = e.add(C, bt), K = e.mul(Ot, C), D = e.add(D, K), K = e.mul(S, C), U = e.mul(ht, U), U = e.sub(U, K), K = e.mul(ht, Ot), k = e.mul(S, k), k = e.add(k, K), new h(U, D, k);
    }
    subtract(m) {
      return this.add(m.negate());
    }
    is0() {
      return this.equals(h.ZERO);
    }
    wNAF(m) {
      return w.wNAFCached(this, u, m, (x) => {
        const v = e.invertBatch(x.map((B) => B.pz));
        return x.map((B, T) => B.toAffine(v[T])).map(h.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(m) {
      const x = h.ZERO;
      if (m === Ze)
        return x;
      if (a(m), m === re)
        return this;
      const { endo: v } = t;
      if (!v)
        return w.unsafeLadder(this, m);
      let { k1neg: B, k1: T, k2neg: H, k2: G } = v.splitScalar(m), U = x, D = x, k = this;
      for (; T > Ze || G > Ze; )
        T & re && (U = U.add(k)), G & re && (D = D.add(k)), k = k.double(), T >>= re, G >>= re;
      return B && (U = U.negate()), H && (D = D.negate()), D = new h(e.mul(D.px, v.beta), D.py, D.pz), U.add(D);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(m) {
      a(m);
      let x = m, v, B;
      const { endo: T } = t;
      if (T) {
        const { k1neg: H, k1: G, k2neg: U, k2: D } = T.splitScalar(x);
        let { p: k, f: ot } = this.wNAF(G), { p: Y, f: K } = this.wNAF(D);
        k = w.constTimeNegate(H, k), Y = w.constTimeNegate(U, Y), Y = new h(e.mul(Y.px, T.beta), Y.py, Y.pz), v = k.add(Y), B = ot.add(K);
      } else {
        const { p: H, f: G } = this.wNAF(x);
        v = H, B = G;
      }
      return h.normalizeZ([v, B])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(m, x, v) {
      const B = h.BASE, T = (G, U) => U === Ze || U === re || !G.equals(B) ? G.multiplyUnsafe(U) : G.multiply(U), H = T(this, x).add(T(m, v));
      return H.is0() ? void 0 : H;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(m) {
      const { px: x, py: v, pz: B } = this, T = this.is0();
      m == null && (m = T ? e.ONE : e.inv(B));
      const H = e.mul(x, m), G = e.mul(v, m), U = e.mul(B, m);
      if (T)
        return { x: e.ZERO, y: e.ZERO };
      if (!e.eql(U, e.ONE))
        throw new Error("invZ was invalid");
      return { x: H, y: G };
    }
    isTorsionFree() {
      const { h: m, isTorsionFree: x } = t;
      if (m === re)
        return !0;
      if (x)
        return x(h, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: m, clearCofactor: x } = t;
      return m === re ? this : x ? x(h, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(m = !0) {
      return this.assertValidity(), n(h, this, m);
    }
    toHex(m = !0) {
      return gs(this.toRawBytes(m));
    }
  }
  h.BASE = new h(t.Gx, t.Gy, e.ONE), h.ZERO = new h(e.ZERO, e.ONE, e.ZERO);
  const g = t.nBitLength, w = jh(h, t.endo ? Math.ceil(g / 2) : g);
  return {
    CURVE: t,
    ProjectivePoint: h,
    normPrivateKeyToScalar: c,
    weierstrassEquation: i,
    isWithinCurveOrder: o
  };
}
function Zh(r) {
  const t = Ju(r);
  return ui(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function Xh(r) {
  const t = Zh(r), { Fp: e, n } = t, s = e.BYTES + 1, i = 2 * e.BYTES + 1;
  function o(C) {
    return Ze < C && C < e.ORDER;
  }
  function a(C) {
    return Mt(C, n);
  }
  function c(C) {
    return jo(C, n);
  }
  const { ProjectivePoint: u, normPrivateKeyToScalar: f, weierstrassEquation: h, isWithinCurveOrder: g } = Yh({
    ...t,
    toBytes(C, S, _) {
      const $ = S.toAffine(), Z = e.toBytes($.x), ct = Ls;
      return _ ? ct(Uint8Array.from([S.hasEvenY() ? 2 : 3]), Z) : ct(Uint8Array.from([4]), Z, e.toBytes($.y));
    },
    fromBytes(C) {
      const S = C.length, _ = C[0], $ = C.subarray(1);
      if (S === s && (_ === 2 || _ === 3)) {
        const Z = rr($);
        if (!o(Z))
          throw new Error("Point is not on curve");
        const ct = h(Z);
        let Et = e.sqrt(ct);
        const vt = (Et & re) === re;
        return (_ & 1) === 1 !== vt && (Et = e.neg(Et)), { x: Z, y: Et };
      } else if (S === i && _ === 4) {
        const Z = e.fromBytes($.subarray(0, e.BYTES)), ct = e.fromBytes($.subarray(e.BYTES, 2 * e.BYTES));
        return { x: Z, y: ct };
      } else
        throw new Error(`Point of length ${S} was invalid. Expected ${s} compressed bytes or ${i} uncompressed bytes`);
    }
  }), w = (C) => gs(ms(C, t.nByteLength));
  function E(C) {
    const S = n >> re;
    return C > S;
  }
  function m(C) {
    return E(C) ? a(-C) : C;
  }
  const x = (C, S, _) => rr(C.slice(S, _));
  class v {
    constructor(S, _, $) {
      this.r = S, this.s = _, this.recovery = $, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(S) {
      const _ = t.nByteLength;
      return S = le("compactSignature", S, _ * 2), new v(x(S, 0, _), x(S, _, 2 * _));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(S) {
      const { r: _, s: $ } = Dn.toSig(le("DER", S));
      return new v(_, $);
    }
    assertValidity() {
      if (!g(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!g(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(S) {
      return new v(this.r, this.s, S);
    }
    recoverPublicKey(S) {
      const { r: _, s: $, recovery: Z } = this, ct = D(le("msgHash", S));
      if (Z == null || ![0, 1, 2, 3].includes(Z))
        throw new Error("recovery id invalid");
      const Et = Z === 2 || Z === 3 ? _ + t.n : _;
      if (Et >= e.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const vt = Z & 1 ? "03" : "02", oe = u.fromHex(vt + w(Et)), Ae = c(Et), rn = a(-ct * Ae), Be = a($ * Ae), Wt = u.BASE.multiplyAndAddUnsafe(oe, rn, Be);
      if (!Wt)
        throw new Error("point at infinify");
      return Wt.assertValidity(), Wt;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return E(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new v(this.r, a(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return ys(this.toDERHex());
    }
    toDERHex() {
      return Dn.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return ys(this.toCompactHex());
    }
    toCompactHex() {
      return w(this.r) + w(this.s);
    }
  }
  const B = {
    isValidPrivateKey(C) {
      try {
        return f(C), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: f,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const C = Vu(t.n);
      return Vh(t.randomBytes(C), t.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(C = 8, S = u.BASE) {
      return S._setWindowSize(C), S.multiply(BigInt(3)), S;
    }
  };
  function T(C, S = !0) {
    return u.fromPrivateKey(C).toRawBytes(S);
  }
  function H(C) {
    const S = C instanceof Uint8Array, _ = typeof C == "string", $ = (S || _) && C.length;
    return S ? $ === s || $ === i : _ ? $ === 2 * s || $ === 2 * i : C instanceof u;
  }
  function G(C, S, _ = !0) {
    if (H(C))
      throw new Error("first arg must be private key");
    if (!H(S))
      throw new Error("second arg must be public key");
    return u.fromHex(S).multiply(f(C)).toRawBytes(_);
  }
  const U = t.bits2int || function(C) {
    const S = rr(C), _ = C.length * 8 - t.nBitLength;
    return _ > 0 ? S >> BigInt(_) : S;
  }, D = t.bits2int_modN || function(C) {
    return a(U(C));
  }, k = Ta(t.nBitLength);
  function ot(C) {
    if (typeof C != "bigint")
      throw new Error("bigint expected");
    if (!(Ze <= C && C < k))
      throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return ms(C, t.nByteLength);
  }
  function Y(C, S, _ = K) {
    if (["recovered", "canonical"].some((ae) => ae in _))
      throw new Error("sign() legacy options not supported");
    const { hash: $, randomBytes: Z } = t;
    let { lowS: ct, prehash: Et, extraEntropy: vt } = _;
    ct == null && (ct = !0), C = le("msgHash", C), Et && (C = le("prehashed msgHash", $(C)));
    const oe = D(C), Ae = f(S), rn = [ot(Ae), ot(oe)];
    if (vt != null) {
      const ae = vt === !0 ? Z(e.BYTES) : vt;
      rn.push(le("extraEntropy", ae));
    }
    const Be = Ls(...rn), Wt = oe;
    function sn(ae) {
      const ce = U(ae);
      if (!g(ce))
        return;
      const di = c(ce), Re = u.BASE.multiply(ce).toAffine(), Dt = a(Re.x);
      if (Dt === Ze)
        return;
      const on = a(di * a(Wt + Dt * Ae));
      if (on === Ze)
        return;
      let Rn = (Re.x === Dt ? 0 : 2) | Number(Re.y & re), Es = on;
      return ct && E(on) && (Es = m(on), Rn ^= 1), new v(Dt, Es, Rn);
    }
    return { seed: Be, k2sig: sn };
  }
  const K = { lowS: t.lowS, prehash: !1 }, Ot = { lowS: t.lowS, prehash: !1 };
  function bt(C, S, _ = K) {
    const { seed: $, k2sig: Z } = Y(C, S, _), ct = t;
    return Qu(ct.hash.outputLen, ct.nByteLength, ct.hmac)($, Z);
  }
  u.BASE._setWindowSize(8);
  function ht(C, S, _, $ = Ot) {
    var Re;
    const Z = C;
    if (S = le("msgHash", S), _ = le("publicKey", _), "strict" in $)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: ct, prehash: Et } = $;
    let vt, oe;
    try {
      if (typeof Z == "string" || Z instanceof Uint8Array)
        try {
          vt = v.fromDER(Z);
        } catch (Dt) {
          if (!(Dt instanceof Dn.Err))
            throw Dt;
          vt = v.fromCompact(Z);
        }
      else if (typeof Z == "object" && typeof Z.r == "bigint" && typeof Z.s == "bigint") {
        const { r: Dt, s: on } = Z;
        vt = new v(Dt, on);
      } else
        throw new Error("PARSE");
      oe = u.fromHex(_);
    } catch (Dt) {
      if (Dt.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (ct && vt.hasHighS())
      return !1;
    Et && (S = t.hash(S));
    const { r: Ae, s: rn } = vt, Be = D(S), Wt = c(rn), sn = a(Be * Wt), ae = a(Ae * Wt), ce = (Re = u.BASE.multiplyAndAddUnsafe(oe, sn, ae)) == null ? void 0 : Re.toAffine();
    return ce ? a(ce.x) === Ae : !1;
  }
  return {
    CURVE: t,
    getPublicKey: T,
    getSharedSecret: G,
    sign: bt,
    verify: ht,
    ProjectivePoint: u,
    Signature: v,
    utils: B
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function qh(r) {
  return {
    hash: r,
    hmac: (t, ...e) => Ru(r, t, $f(...e)),
    randomBytes: th
  };
}
function $h(r, t) {
  const e = (n) => Xh({ ...r, ...qh(n) });
  return Object.freeze({ ...e(t), create: e });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ju = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), mc = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), td = BigInt(1), zo = BigInt(2), wc = (r, t) => (r + t / zo) / t;
function ed(r) {
  const t = ju, e = BigInt(3), n = BigInt(6), s = BigInt(11), i = BigInt(22), o = BigInt(23), a = BigInt(44), c = BigInt(88), u = r * r * r % t, f = u * u * r % t, h = Yt(f, e, t) * f % t, g = Yt(h, e, t) * f % t, w = Yt(g, zo, t) * u % t, E = Yt(w, s, t) * w % t, m = Yt(E, i, t) * E % t, x = Yt(m, a, t) * m % t, v = Yt(x, c, t) * x % t, B = Yt(v, a, t) * m % t, T = Yt(B, e, t) * f % t, H = Yt(T, o, t) * E % t, G = Yt(H, n, t) * u % t, U = Yt(G, zo, t);
  if (!Ko.eql(Ko.sqr(U), r))
    throw new Error("Cannot find square root");
  return U;
}
const Ko = _h(ju, void 0, void 0, { sqrt: ed }), un = $h({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Ko,
  n: mc,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (r) => {
      const t = mc, e = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -td * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), i = e, o = BigInt("0x100000000000000000000000000000000"), a = wc(i * r, t), c = wc(-n * r, t);
      let u = Mt(r - a * e - c * s, t), f = Mt(-a * n - c * i, t);
      const h = u > o, g = f > o;
      if (h && (u = t - u), g && (f = t - f), u > o || f > o)
        throw new Error("splitScalar: Endomorphism failed, k=" + r);
      return { k1neg: h, k1: u, k2neg: g, k2: f };
    }
  }
}, ah);
BigInt(0);
un.ProjectivePoint;
const Wo = "0x0000000000000000000000000000000000000000", Ac = "0x0000000000000000000000000000000000000000000000000000000000000000", bc = BigInt(0), Ec = BigInt(1), vc = BigInt(2), xc = BigInt(27), Pc = BigInt(28), Ai = BigInt(35), pr = {};
function Nc(r) {
  return ir(Kt(r), 32);
}
var Fr, Lr, Mr, jn;
const ue = class ue {
  /**
   *  @private
   */
  constructor(t, e, n, s) {
    b(this, Fr, void 0);
    b(this, Lr, void 0);
    b(this, Mr, void 0);
    b(this, jn, void 0);
    eo(t, pr, "Signature"), d(this, Fr, e), d(this, Lr, n), d(this, Mr, s), d(this, jn, null);
  }
  /**
   *  The ``r`` value for a signautre.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return l(this, Fr);
  }
  set r(t) {
    y(Tr(t) === 32, "invalid r", "value", t), d(this, Fr, F(t));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return l(this, Lr);
  }
  set s(t) {
    y(Tr(t) === 32, "invalid s", "value", t);
    const e = F(t);
    y(parseInt(e.substring(0, 3)) < 8, "non-canonical s", "value", e), d(this, Lr, e);
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return l(this, Mr);
  }
  set v(t) {
    const e = V(t, "value");
    y(e === 27 || e === 28, "invalid v", "v", t), d(this, Mr, e);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return l(this, jn);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const t = this.networkV;
    return t == null ? null : ue.getChainId(t);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const t = X(this.s);
    return this.yParity && (t[0] |= 128), F(t);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return pt([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return pt([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const t = new ue(pr, this.r, this.s, this.v);
    return this.networkV && d(t, jn, this.networkV), t;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const t = this.networkV;
    return {
      _type: "signature",
      networkV: t != null ? t.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(t) {
    const e = L(t, "v");
    return e == xc || e == Pc ? bc : (y(e >= Ai, "invalid EIP-155 v", "v", t), (e - Ai) / vc);
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(t, e) {
    return L(t) * vc + BigInt(35 + e - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(t) {
    const e = L(t);
    return e === bc || e === xc ? 27 : e === Ec || e === Pc ? 28 : (y(e >= Ai, "invalid v", "v", t), e & Ec ? 27 : 28);
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(t) {
    function e(u, f) {
      y(u, f, "signature", t);
    }
    if (t == null)
      return new ue(pr, Ac, Ac, 27);
    if (typeof t == "string") {
      const u = X(t, "signature");
      if (u.length === 64) {
        const f = F(u.slice(0, 32)), h = u.slice(32, 64), g = h[0] & 128 ? 28 : 27;
        return h[0] &= 127, new ue(pr, f, F(h), g);
      }
      if (u.length === 65) {
        const f = F(u.slice(0, 32)), h = u.slice(32, 64);
        e((h[0] & 128) === 0, "non-canonical s");
        const g = ue.getNormalizedV(u[64]);
        return new ue(pr, f, F(h), g);
      }
      e(!1, "invalid raw signature length");
    }
    if (t instanceof ue)
      return t.clone();
    const n = t.r;
    e(n != null, "missing r");
    const s = Nc(n), i = function(u, f) {
      if (u != null)
        return Nc(u);
      if (f != null) {
        e(it(f, 32), "invalid yParityAndS");
        const h = X(f);
        return h[0] &= 127, F(h);
      }
      e(!1, "missing s");
    }(t.s, t.yParityAndS);
    e((X(i)[0] & 128) == 0, "non-canonical s");
    const { networkV: o, v: a } = function(u, f, h) {
      if (u != null) {
        const g = L(u);
        return {
          networkV: g >= Ai ? g : void 0,
          v: ue.getNormalizedV(g)
        };
      }
      if (f != null)
        return e(it(f, 32), "invalid yParityAndS"), { v: X(f)[0] & 128 ? 28 : 27 };
      if (h != null) {
        switch (V(h, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        e(!1, "invalid yParity");
      }
      e(!1, "missing v");
    }(t.v, t.yParityAndS, t.yParity), c = new ue(pr, s, i, a);
    return o && d(c, jn, o), e(t.yParity == null || V(t.yParity, "sig.yParity") === c.yParity, "yParity mismatch"), e(t.yParityAndS == null || t.yParityAndS === c.yParityAndS, "yParityAndS mismatch"), c;
  }
};
Fr = new WeakMap(), Lr = new WeakMap(), Mr = new WeakMap(), jn = new WeakMap();
let ye = ue;
var He;
const Un = class Un {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(t) {
    b(this, He, void 0);
    y(Tr(t) === 32, "invalid private key", "privateKey", "[REDACTED]"), d(this, He, F(t));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return l(this, He);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return Un.computePublicKey(l(this, He));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return Un.computePublicKey(l(this, He), !0);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(t) {
    y(Tr(t) === 32, "invalid digest length", "digest", t);
    const e = un.sign(Ht(t), Ht(l(this, He)), {
      lowS: !0
    });
    return ye.from({
      r: On(e.r, 32),
      s: On(e.s, 32),
      v: e.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(t) {
    const e = Un.computePublicKey(t);
    return F(un.getSharedSecret(Ht(l(this, He)), X(e), !1));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(t, e) {
    let n = X(t, "key");
    if (n.length === 32) {
      const i = un.getPublicKey(n, !!e);
      return F(i);
    }
    if (n.length === 64) {
      const i = new Uint8Array(65);
      i[0] = 4, i.set(n, 1), n = i;
    }
    const s = un.ProjectivePoint.fromHex(n);
    return F(s.toRawBytes(e));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(t, e) {
    y(Tr(t) === 32, "invalid digest length", "digest", t);
    const n = ye.from(e);
    let s = un.Signature.fromCompact(Ht(pt([n.r, n.s])));
    s = s.addRecoveryBit(n.yParity);
    const i = s.recoverPublicKey(Ht(t));
    return y(i != null, "invalid signautre for digest", "signature", e), "0x" + i.toHex(!1);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(t, e, n) {
    const s = un.ProjectivePoint.fromHex(Un.computePublicKey(t).substring(2)), i = un.ProjectivePoint.fromHex(Un.computePublicKey(e).substring(2));
    return "0x" + s.add(i).toHex(!!n);
  }
};
He = new WeakMap();
let Ms = Un;
const nd = BigInt(0), rd = BigInt(36);
function Cc(r) {
  r = r.toLowerCase();
  const t = r.substring(2).split(""), e = new Uint8Array(40);
  for (let s = 0; s < 40; s++)
    e[s] = t[s].charCodeAt(0);
  const n = X(st(e));
  for (let s = 0; s < 40; s += 2)
    n[s >> 1] >> 4 >= 8 && (t[s] = t[s].toUpperCase()), (n[s >> 1] & 15) >= 8 && (t[s + 1] = t[s + 1].toUpperCase());
  return "0x" + t.join("");
}
const Oa = {};
for (let r = 0; r < 10; r++)
  Oa[String(r)] = String(r);
for (let r = 0; r < 26; r++)
  Oa[String.fromCharCode(65 + r)] = String(10 + r);
const Tc = 15;
function sd(r) {
  r = r.toUpperCase(), r = r.substring(4) + r.substring(0, 2) + "00";
  let t = r.split("").map((n) => Oa[n]).join("");
  for (; t.length >= Tc; ) {
    let n = t.substring(0, Tc);
    t = parseInt(n, 10) % 97 + t.substring(n.length);
  }
  let e = String(98 - parseInt(t, 10) % 97);
  for (; e.length < 2; )
    e = "0" + e;
  return e;
}
const id = function() {
  const r = {};
  for (let t = 0; t < 36; t++) {
    const e = "0123456789abcdefghijklmnopqrstuvwxyz"[t];
    r[e] = BigInt(t);
  }
  return r;
}();
function od(r) {
  r = r.toLowerCase();
  let t = nd;
  for (let e = 0; e < r.length; e++)
    t = t * rd + id[r[e]];
  return t;
}
function W(r) {
  if (y(typeof r == "string", "invalid address", "address", r), r.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    r.startsWith("0x") || (r = "0x" + r);
    const t = Cc(r);
    return y(!r.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || t === r, "bad address checksum", "address", r), t;
  }
  if (r.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    y(r.substring(2, 4) === sd(r), "bad icap checksum", "address", r);
    let t = od(r.substring(4)).toString(16);
    for (; t.length < 40; )
      t = "0" + t;
    return Cc("0x" + t);
  }
  y(!1, "invalid address", "address", r);
}
function ad(r) {
  const t = W(r.from);
  let n = L(r.nonce, "tx.nonce").toString(16);
  return n === "0" ? n = "0x" : n.length % 2 ? n = "0x0" + n : n = "0x" + n, W(at(st(Fs([t, n])), 12));
}
function zu(r) {
  return r && typeof r.getAddress == "function";
}
async function Io(r, t) {
  const e = await t;
  return (e == null || e === "0x0000000000000000000000000000000000000000") && (P(typeof r != "string", "unconfigured name", "UNCONFIGURED_NAME", { value: r }), y(!1, "invalid AddressLike value; did not resolve to a value address", "target", r)), W(e);
}
function St(r, t) {
  if (typeof r == "string")
    return r.match(/^0x[0-9a-f]{40}$/i) ? W(r) : (P(t != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" }), Io(r, t.resolveName(r)));
  if (zu(r))
    return Io(r, r.getAddress());
  if (r && typeof r.then == "function")
    return Io(r, r);
  y(!1, "unsupported addressable value", "target", r);
}
const Ue = {};
function R(r, t) {
  let e = !1;
  return t < 0 && (e = !0, t *= -1), new Tt(Ue, `${e ? "" : "u"}int${t}`, r, { signed: e, width: t });
}
function z(r, t) {
  return new Tt(Ue, `bytes${t || ""}`, r, { size: t });
}
const Oc = Symbol.for("_ethers_typed");
var zn;
const De = class De {
  /**
   *  @_ignore:
   */
  constructor(t, e, n, s) {
    /**
     *  The type, as a Solidity-compatible type.
     */
    A(this, "type");
    /**
     *  The actual value.
     */
    A(this, "value");
    b(this, zn, void 0);
    /**
     *  @_ignore:
     */
    A(this, "_typedSymbol");
    s == null && (s = null), eo(Ue, t, "Typed"), M(this, { _typedSymbol: Oc, type: e, value: n }), d(this, zn, s), this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array")
      throw new Error("");
    if (this.type === "dynamicArray")
      throw new Error("");
    return this.type === "tuple" ? `tuple(${this.value.map((t) => t.format()).join(",")})` : this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple")
      throw TypeError("not a tuple");
    return l(this, zn);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array")
      throw TypeError("not an array");
    return l(this, zn) === !0 ? -1 : l(this, zn) === !1 ? this.value.length : null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(t, e) {
    return new De(Ue, t, e);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(t) {
    return R(t, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(t) {
    return R(t, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(t) {
    return R(t, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(t) {
    return R(t, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(t) {
    return R(t, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(t) {
    return R(t, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(t) {
    return R(t, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(t) {
    return R(t, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(t) {
    return R(t, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(t) {
    return R(t, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(t) {
    return R(t, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(t) {
    return R(t, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(t) {
    return R(t, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(t) {
    return R(t, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(t) {
    return R(t, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(t) {
    return R(t, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(t) {
    return R(t, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(t) {
    return R(t, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(t) {
    return R(t, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(t) {
    return R(t, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(t) {
    return R(t, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(t) {
    return R(t, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(t) {
    return R(t, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(t) {
    return R(t, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(t) {
    return R(t, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(t) {
    return R(t, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(t) {
    return R(t, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(t) {
    return R(t, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(t) {
    return R(t, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(t) {
    return R(t, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(t) {
    return R(t, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(t) {
    return R(t, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(t) {
    return R(t, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(t) {
    return R(t, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(t) {
    return R(t, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(t) {
    return R(t, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(t) {
    return R(t, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(t) {
    return R(t, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(t) {
    return R(t, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(t) {
    return R(t, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(t) {
    return R(t, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(t) {
    return R(t, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(t) {
    return R(t, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(t) {
    return R(t, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(t) {
    return R(t, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(t) {
    return R(t, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(t) {
    return R(t, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(t) {
    return R(t, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(t) {
    return R(t, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(t) {
    return R(t, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(t) {
    return R(t, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(t) {
    return R(t, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(t) {
    return R(t, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(t) {
    return R(t, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(t) {
    return R(t, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(t) {
    return R(t, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(t) {
    return R(t, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(t) {
    return R(t, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(t) {
    return R(t, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(t) {
    return R(t, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(t) {
    return R(t, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(t) {
    return R(t, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(t) {
    return R(t, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(t) {
    return R(t, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(t) {
    return R(t, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(t) {
    return R(t, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(t) {
    return z(t, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(t) {
    return z(t, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(t) {
    return z(t, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(t) {
    return z(t, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(t) {
    return z(t, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(t) {
    return z(t, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(t) {
    return z(t, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(t) {
    return z(t, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(t) {
    return z(t, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(t) {
    return z(t, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(t) {
    return z(t, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(t) {
    return z(t, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(t) {
    return z(t, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(t) {
    return z(t, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(t) {
    return z(t, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(t) {
    return z(t, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(t) {
    return z(t, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(t) {
    return z(t, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(t) {
    return z(t, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(t) {
    return z(t, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(t) {
    return z(t, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(t) {
    return z(t, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(t) {
    return z(t, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(t) {
    return z(t, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(t) {
    return z(t, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(t) {
    return z(t, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(t) {
    return z(t, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(t) {
    return z(t, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(t) {
    return z(t, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(t) {
    return z(t, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(t) {
    return z(t, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(t) {
    return z(t, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(t) {
    return new De(Ue, "address", t);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(t) {
    return new De(Ue, "bool", !!t);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(t) {
    return new De(Ue, "bytes", t);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(t) {
    return new De(Ue, "string", t);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(t, e) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(t, e) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(t) {
    return new De(Ue, "overrides", Object.assign({}, t));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(t) {
    return t && typeof t == "object" && "_typedSymbol" in t && t._typedSymbol === Oc;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(t, e) {
    if (De.isTyped(t)) {
      if (t.type !== e)
        throw new Error(`invalid type: expecetd ${e}, got ${t.type}`);
      return t.value;
    }
    return t;
  }
};
zn = new WeakMap();
let Tt = De;
class cd extends nn {
  constructor(t) {
    super("address", "address", t, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(t, e) {
    let n = Tt.dereference(e, "string");
    try {
      n = W(n);
    } catch (s) {
      return this._throwError(s.message, e);
    }
    return t.writeValue(n);
  }
  decode(t) {
    return W(On(t.readValue(), 20));
  }
}
class ud extends nn {
  constructor(e) {
    super(e.name, e.type, "_", e.dynamic);
    A(this, "coder");
    this.coder = e;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(e, n) {
    return this.coder.encode(e, n);
  }
  decode(e) {
    return this.coder.decode(e);
  }
}
function Ku(r, t, e) {
  let n = [];
  if (Array.isArray(e))
    n = e;
  else if (e && typeof e == "object") {
    let c = {};
    n = t.map((u) => {
      const f = u.localName;
      return P(f, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder: u }, value: e }), P(!c[f], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder: u }, value: e }), c[f] = !0, e[f];
    });
  } else
    y(!1, "invalid tuple value", "tuple", e);
  y(t.length === n.length, "types/value length mismatch", "tuple", e);
  let s = new _o(), i = new _o(), o = [];
  t.forEach((c, u) => {
    let f = n[u];
    if (c.dynamic) {
      let h = i.length;
      c.encode(i, f);
      let g = s.writeUpdatableValue();
      o.push((w) => {
        g(w + h);
      });
    } else
      c.encode(s, f);
  }), o.forEach((c) => {
    c(s.length);
  });
  let a = r.appendWriter(s);
  return a += r.appendWriter(i), a;
}
function Wu(r, t) {
  let e = [], n = [], s = r.subReader(0);
  return t.forEach((i) => {
    let o = null;
    if (i.dynamic) {
      let a = r.readIndex(), c = s.subReader(a);
      try {
        o = i.decode(c);
      } catch (u) {
        if (se(u, "BUFFER_OVERRUN"))
          throw u;
        o = u, o.baseType = i.name, o.name = i.localName, o.type = i.type;
      }
    } else
      try {
        o = i.decode(r);
      } catch (a) {
        if (se(a, "BUFFER_OVERRUN"))
          throw a;
        o = a, o.baseType = i.name, o.name = i.localName, o.type = i.type;
      }
    if (o == null)
      throw new Error("investigate");
    e.push(o), n.push(i.localName || null);
  }), Ui.fromItems(e, n);
}
class ld extends nn {
  constructor(e, n, s) {
    const i = e.type + "[" + (n >= 0 ? n : "") + "]", o = n === -1 || e.dynamic;
    super("array", i, s, o);
    A(this, "coder");
    A(this, "length");
    M(this, { coder: e, length: n });
  }
  defaultValue() {
    const e = this.coder.defaultValue(), n = [];
    for (let s = 0; s < this.length; s++)
      n.push(e);
    return n;
  }
  encode(e, n) {
    const s = Tt.dereference(n, "array");
    Array.isArray(s) || this._throwError("expected array value", s);
    let i = this.length;
    i === -1 && (i = s.length, e.writeValue(s.length)), pu(s.length, i, "coder array" + (this.localName ? " " + this.localName : ""));
    let o = [];
    for (let a = 0; a < s.length; a++)
      o.push(this.coder);
    return Ku(e, o, s);
  }
  decode(e) {
    let n = this.length;
    n === -1 && (n = e.readIndex(), P(n * kt <= e.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: e.bytes, offset: n * kt, length: e.dataLength }));
    let s = [];
    for (let i = 0; i < n; i++)
      s.push(new ud(this.coder));
    return Wu(e, s);
  }
}
class fd extends nn {
  constructor(t) {
    super("bool", "bool", t, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(t, e) {
    const n = Tt.dereference(e, "bool");
    return t.writeValue(n ? 1 : 0);
  }
  decode(t) {
    return !!t.readValue();
  }
}
class Yu extends nn {
  constructor(t, e) {
    super(t, t, e, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(t, e) {
    e = Ht(e);
    let n = t.writeValue(e.length);
    return n += t.writeBytes(e), n;
  }
  decode(t) {
    return t.readBytes(t.readIndex(), !0);
  }
}
class hd extends Yu {
  constructor(t) {
    super("bytes", t);
  }
  decode(t) {
    return F(super.decode(t));
  }
}
class dd extends nn {
  constructor(e, n) {
    let s = "bytes" + String(e);
    super(s, s, n, !1);
    A(this, "size");
    M(this, { size: e }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(e, n) {
    let s = Ht(Tt.dereference(n, this.type));
    return s.length !== this.size && this._throwError("incorrect data length", n), e.writeBytes(s);
  }
  decode(e) {
    return F(e.readBytes(this.size));
  }
}
const pd = new Uint8Array([]);
class gd extends nn {
  constructor(t) {
    super("null", "", t, !1);
  }
  defaultValue() {
    return null;
  }
  encode(t, e) {
    return e != null && this._throwError("not null", e), t.writeBytes(pd);
  }
  decode(t) {
    return t.readBytes(0), null;
  }
}
const yd = BigInt(0), md = BigInt(1), wd = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class Ad extends nn {
  constructor(e, n, s) {
    const i = (n ? "int" : "uint") + e * 8;
    super(i, i, s, !1);
    A(this, "size");
    A(this, "signed");
    M(this, { size: e, signed: n }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(e, n) {
    let s = L(Tt.dereference(n, this.type)), i = Cs(wd, kt * 8);
    if (this.signed) {
      let o = Cs(i, this.size * 8 - 1);
      (s > o || s < -(o + md)) && this._throwError("value out-of-bounds", n), s = mu(s, 8 * kt);
    } else
      (s < yd || s > Cs(i, this.size * 8)) && this._throwError("value out-of-bounds", n);
    return e.writeValue(s);
  }
  decode(e) {
    let n = Cs(e.readValue(), this.size * 8);
    return this.signed && (n = If(n, this.size * 8)), n;
  }
}
class bd extends Yu {
  constructor(t) {
    super("string", t);
  }
  defaultValue() {
    return "";
  }
  encode(t, e) {
    return super.encode(t, $e(Tt.dereference(e, "string")));
  }
  decode(t) {
    return Aa(super.decode(t));
  }
}
class bi extends nn {
  constructor(e, n) {
    let s = !1;
    const i = [];
    e.forEach((a) => {
      a.dynamic && (s = !0), i.push(a.type);
    });
    const o = "tuple(" + i.join(",") + ")";
    super("tuple", o, n, s);
    A(this, "coders");
    M(this, { coders: Object.freeze(e.slice()) });
  }
  defaultValue() {
    const e = [];
    this.coders.forEach((s) => {
      e.push(s.defaultValue());
    });
    const n = this.coders.reduce((s, i) => {
      const o = i.localName;
      return o && (s[o] || (s[o] = 0), s[o]++), s;
    }, {});
    return this.coders.forEach((s, i) => {
      let o = s.localName;
      !o || n[o] !== 1 || (o === "length" && (o = "_length"), e[o] == null && (e[o] = e[i]));
    }), Object.freeze(e);
  }
  encode(e, n) {
    const s = Tt.dereference(n, "tuple");
    return Ku(e, this.coders, s);
  }
  decode(e) {
    return Wu(e, this.coders);
  }
}
function or(r) {
  return st($e(r));
}
var Ed = "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";
const Ic = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]), Bc = 4;
function vd(r) {
  let t = 0;
  function e() {
    return r[t++] << 8 | r[t++];
  }
  let n = e(), s = 1, i = [0, 1];
  for (let G = 1; G < n; G++)
    i.push(s += e());
  let o = e(), a = t;
  t += o;
  let c = 0, u = 0;
  function f() {
    return c == 0 && (u = u << 8 | r[t++], c = 8), u >> --c & 1;
  }
  const h = 31, g = 2 ** h, w = g >>> 1, E = w >> 1, m = g - 1;
  let x = 0;
  for (let G = 0; G < h; G++)
    x = x << 1 | f();
  let v = [], B = 0, T = g;
  for (; ; ) {
    let G = Math.floor(((x - B + 1) * s - 1) / T), U = 0, D = n;
    for (; D - U > 1; ) {
      let Y = U + D >>> 1;
      G < i[Y] ? D = Y : U = Y;
    }
    if (U == 0)
      break;
    v.push(U);
    let k = B + Math.floor(T * i[U] / s), ot = B + Math.floor(T * i[U + 1] / s) - 1;
    for (; !((k ^ ot) & w); )
      x = x << 1 & m | f(), k = k << 1 & m, ot = ot << 1 & m | 1;
    for (; k & ~ot & E; )
      x = x & w | x << 1 & m >>> 1 | f(), k = k << 1 ^ w, ot = (ot ^ w) << 1 | w | 1;
    B = k, T = 1 + ot - k;
  }
  let H = n - 4;
  return v.map((G) => {
    switch (G - H) {
      case 3:
        return H + 65792 + (r[a++] << 16 | r[a++] << 8 | r[a++]);
      case 2:
        return H + 256 + (r[a++] << 8 | r[a++]);
      case 1:
        return H + r[a++];
      default:
        return G - 1;
    }
  });
}
function xd(r) {
  let t = 0;
  return () => r[t++];
}
function Zu(r) {
  return xd(vd(Pd(r)));
}
function Pd(r) {
  let t = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((s, i) => t[s.charCodeAt(0)] = i);
  let e = r.length, n = new Uint8Array(6 * e >> 3);
  for (let s = 0, i = 0, o = 0, a = 0; s < e; s++)
    a = a << 6 | t[r.charCodeAt(s)], o += 6, o >= 8 && (n[i++] = a >> (o -= 8));
  return n;
}
function Nd(r) {
  return r & 1 ? ~r >> 1 : r >> 1;
}
function Cd(r, t) {
  let e = Array(r);
  for (let n = 0, s = 0; n < r; n++)
    e[n] = s += Nd(t());
  return e;
}
function Gs(r, t = 0) {
  let e = [];
  for (; ; ) {
    let n = r(), s = r();
    if (!s)
      break;
    t += n;
    for (let i = 0; i < s; i++)
      e.push(t + i);
    t += s + 1;
  }
  return e;
}
function Xu(r) {
  return Qs(() => {
    let t = Gs(r);
    if (t.length)
      return t;
  });
}
function qu(r) {
  let t = [];
  for (; ; ) {
    let e = r();
    if (e == 0)
      break;
    t.push(Td(e, r));
  }
  for (; ; ) {
    let e = r() - 1;
    if (e < 0)
      break;
    t.push(Od(e, r));
  }
  return t.flat();
}
function Qs(r) {
  let t = [];
  for (; ; ) {
    let e = r(t.length);
    if (!e)
      break;
    t.push(e);
  }
  return t;
}
function $u(r, t, e) {
  let n = Array(r).fill().map(() => []);
  for (let s = 0; s < t; s++)
    Cd(r, e).forEach((i, o) => n[o].push(i));
  return n;
}
function Td(r, t) {
  let e = 1 + t(), n = t(), s = Qs(t);
  return $u(s.length, 1 + r, t).flatMap((o, a) => {
    let [c, ...u] = o;
    return Array(s[a]).fill().map((f, h) => {
      let g = h * n;
      return [c + h * e, u.map((w) => w + g)];
    });
  });
}
function Od(r, t) {
  let e = 1 + t();
  return $u(e, 1 + r, t).map((s) => [s[0], s.slice(1)]);
}
function Id(r) {
  let t = [], e = Gs(r);
  return s(n([]), []), t;
  function n(i) {
    let o = r(), a = Qs(() => {
      let c = Gs(r).map((u) => e[u]);
      if (c.length)
        return n(c);
    });
    return { S: o, B: a, Q: i };
  }
  function s({ S: i, B: o }, a, c) {
    if (!(i & 4 && c === a[a.length - 1])) {
      i & 2 && (c = a[a.length - 1]), i & 1 && t.push(a);
      for (let u of o)
        for (let f of u.Q)
          s(u, [...a, f], c);
    }
  }
}
function Bd(r) {
  return r.toString(16).toUpperCase().padStart(2, "0");
}
function tl(r) {
  return `{${Bd(r)}}`;
}
function Rd(r) {
  let t = [];
  for (let e = 0, n = r.length; e < n; ) {
    let s = r.codePointAt(e);
    e += s < 65536 ? 1 : 2, t.push(s);
  }
  return t;
}
function ws(r) {
  let e = r.length;
  if (e < 4096)
    return String.fromCodePoint(...r);
  let n = [];
  for (let s = 0; s < e; )
    n.push(String.fromCodePoint(...r.slice(s, s += 4096)));
  return n.join("");
}
function kd(r, t) {
  let e = r.length, n = e - t.length;
  for (let s = 0; n == 0 && s < e; s++)
    n = r[s] - t[s];
  return n;
}
var Sd = "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";
const Hs = 44032, Fi = 4352, Li = 4449, Mi = 4519, el = 19, nl = 21, As = 28, Gi = nl * As, Ud = el * Gi, Dd = Hs + Ud, Fd = Fi + el, Ld = Li + nl, Md = Mi + As;
function Os(r) {
  return r >> 24 & 255;
}
function rl(r) {
  return r & 16777215;
}
let Yo, Rc, Zo, Ci;
function Gd() {
  let r = Zu(Sd);
  Yo = new Map(Xu(r).flatMap((t, e) => t.map((n) => [n, e + 1 << 24]))), Rc = new Set(Gs(r)), Zo = /* @__PURE__ */ new Map(), Ci = /* @__PURE__ */ new Map();
  for (let [t, e] of qu(r)) {
    if (!Rc.has(t) && e.length == 2) {
      let [n, s] = e, i = Ci.get(n);
      i || (i = /* @__PURE__ */ new Map(), Ci.set(n, i)), i.set(s, t);
    }
    Zo.set(t, e.reverse());
  }
}
function sl(r) {
  return r >= Hs && r < Dd;
}
function Qd(r, t) {
  if (r >= Fi && r < Fd && t >= Li && t < Ld)
    return Hs + (r - Fi) * Gi + (t - Li) * As;
  if (sl(r) && t > Mi && t < Md && (r - Hs) % As == 0)
    return r + (t - Mi);
  {
    let e = Ci.get(r);
    return e && (e = e.get(t), e) ? e : -1;
  }
}
function il(r) {
  Yo || Gd();
  let t = [], e = [], n = !1;
  function s(i) {
    let o = Yo.get(i);
    o && (n = !0, i |= o), t.push(i);
  }
  for (let i of r)
    for (; ; ) {
      if (i < 128)
        t.push(i);
      else if (sl(i)) {
        let o = i - Hs, a = o / Gi | 0, c = o % Gi / As | 0, u = o % As;
        s(Fi + a), s(Li + c), u > 0 && s(Mi + u);
      } else {
        let o = Zo.get(i);
        o ? e.push(...o) : s(i);
      }
      if (!e.length)
        break;
      i = e.pop();
    }
  if (n && t.length > 1) {
    let i = Os(t[0]);
    for (let o = 1; o < t.length; o++) {
      let a = Os(t[o]);
      if (a == 0 || i <= a) {
        i = a;
        continue;
      }
      let c = o - 1;
      for (; ; ) {
        let u = t[c + 1];
        if (t[c + 1] = t[c], t[c] = u, !c || (i = Os(t[--c]), i <= a))
          break;
      }
      i = Os(t[o]);
    }
  }
  return t;
}
function Hd(r) {
  let t = [], e = [], n = -1, s = 0;
  for (let i of r) {
    let o = Os(i), a = rl(i);
    if (n == -1)
      o == 0 ? n = a : t.push(a);
    else if (s > 0 && s >= o)
      o == 0 ? (t.push(n, ...e), e.length = 0, n = a) : e.push(a), s = o;
    else {
      let c = Qd(n, a);
      c >= 0 ? n = c : s == 0 && o == 0 ? (t.push(n), n = a) : (e.push(a), s = o);
    }
  }
  return n >= 0 && t.push(n, ...e), t;
}
function ol(r) {
  return il(r).map(rl);
}
function _d(r) {
  return Hd(il(r));
}
const kc = 45, al = ".", cl = 65039, ul = 1, xr = (r) => Array.from(r);
function _s(r, t) {
  return r.P.has(t) || r.Q.has(t);
}
class Vd extends Array {
  get is_emoji() {
    return !0;
  }
  // free tagging system
}
let Xo, ll, Fn, qo, fl, Or, Bo, mr, hl, Sc, $o;
function Ia() {
  if (Xo)
    return;
  let r = Zu(Ed);
  const t = () => Gs(r), e = () => new Set(t());
  Xo = new Map(qu(r)), ll = e(), Fn = t(), qo = new Set(t().map((f) => Fn[f])), Fn = new Set(Fn), fl = e(), e();
  let n = Xu(r), s = r();
  const i = () => new Set(t().flatMap((f) => n[f]).concat(t()));
  Or = Qs((f) => {
    let h = Qs(r).map((g) => g + 96);
    if (h.length) {
      let g = f >= s;
      h[0] -= 32, h = ws(h), g && (h = `Restricted[${h}]`);
      let w = i(), E = i(), m = !r();
      return { N: h, P: w, Q: E, M: m, R: g };
    }
  }), Bo = e(), mr = /* @__PURE__ */ new Map();
  let o = t().concat(xr(Bo)).sort((f, h) => f - h);
  o.forEach((f, h) => {
    let g = r(), w = o[h] = g ? o[h - g] : { V: [], M: /* @__PURE__ */ new Map() };
    w.V.push(f), Bo.has(f) || mr.set(f, w);
  });
  for (let { V: f, M: h } of new Set(mr.values())) {
    let g = [];
    for (let E of f) {
      let m = Or.filter((v) => _s(v, E)), x = g.find(({ G: v }) => m.some((B) => v.has(B)));
      x || (x = { G: /* @__PURE__ */ new Set(), V: [] }, g.push(x)), x.V.push(E), m.forEach((v) => x.G.add(v));
    }
    let w = g.flatMap((E) => xr(E.G));
    for (let { G: E, V: m } of g) {
      let x = new Set(w.filter((v) => !E.has(v)));
      for (let v of m)
        h.set(v, x);
    }
  }
  let a = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();
  const u = (f) => a.has(f) ? c.add(f) : a.add(f);
  for (let f of Or) {
    for (let h of f.P)
      u(h);
    for (let h of f.Q)
      u(h);
  }
  for (let f of a)
    !mr.has(f) && !c.has(f) && mr.set(f, ul);
  hl = new Set(xr(a).concat(xr(ol(a)))), Sc = Id(r).map((f) => Vd.from(f)).sort(kd), $o = /* @__PURE__ */ new Map();
  for (let f of Sc) {
    let h = [$o];
    for (let g of f) {
      let w = h.map((E) => {
        let m = E.get(g);
        return m || (m = /* @__PURE__ */ new Map(), E.set(g, m)), m;
      });
      g === cl ? h.push(...w) : h = w;
    }
    for (let g of h)
      g.V = f;
  }
}
function Ba(r) {
  return (dl(r) ? "" : `${Ra(ao([r]))} `) + tl(r);
}
function Ra(r) {
  return `"${r}"‎`;
}
function Jd(r) {
  if (r.length >= 4 && r[2] == kc && r[3] == kc)
    throw new Error(`invalid label extension: "${ws(r.slice(0, 4))}"`);
}
function jd(r) {
  for (let e = r.lastIndexOf(95); e > 0; )
    if (r[--e] !== 95)
      throw new Error("underscore allowed only at start");
}
function zd(r) {
  let t = r[0], e = Ic.get(t);
  if (e)
    throw ks(`leading ${e}`);
  let n = r.length, s = -1;
  for (let i = 1; i < n; i++) {
    t = r[i];
    let o = Ic.get(t);
    if (o) {
      if (s == i)
        throw ks(`${e} + ${o}`);
      s = i + 1, e = o;
    }
  }
  if (s == n)
    throw ks(`trailing ${e}`);
}
function ao(r, t = tl) {
  let e = [];
  Kd(r[0]) && e.push("◌");
  let n = 0, s = r.length;
  for (let i = 0; i < s; i++) {
    let o = r[i];
    dl(o) && (e.push(ws(r.slice(n, i))), e.push(t(o)), n = i + 1);
  }
  return e.push(ws(r.slice(n, s))), e.join("");
}
function Kd(r) {
  return Ia(), Fn.has(r);
}
function dl(r) {
  return Ia(), fl.has(r);
}
function Wd(r) {
  return qd(Yd(r, _d, ep));
}
function Yd(r, t, e) {
  if (!r)
    return [];
  Ia();
  let n = 0;
  return r.split(al).map((s) => {
    let i = Rd(s), o = {
      input: i,
      offset: n
      // codepoint, not substring!
    };
    n += i.length + 1;
    try {
      let a = o.tokens = tp(i, t, e), c = a.length, u;
      if (!c)
        throw new Error("empty label");
      let f = o.output = a.flat();
      if (jd(f), !(o.emoji = c > 1 || a[0].is_emoji) && f.every((g) => g < 128))
        Jd(f), u = "ASCII";
      else {
        let g = a.flatMap((w) => w.is_emoji ? [] : w);
        if (!g.length)
          u = "Emoji";
        else {
          if (Fn.has(f[0]))
            throw ks("leading combining mark");
          for (let m = 1; m < c; m++) {
            let x = a[m];
            if (!x.is_emoji && Fn.has(x[0]))
              throw ks(`emoji + combining mark: "${ws(a[m - 1])} + ${ao([x[0]])}"`);
          }
          zd(f);
          let w = xr(new Set(g)), [E] = Xd(w);
          $d(E, g), Zd(E, w), u = E.N;
        }
      }
      o.type = u;
    } catch (a) {
      o.error = a;
    }
    return o;
  });
}
function Zd(r, t) {
  let e, n = [];
  for (let s of t) {
    let i = mr.get(s);
    if (i === ul)
      return;
    if (i) {
      let o = i.M.get(s);
      if (e = e ? e.filter((a) => o.has(a)) : xr(o), !e.length)
        return;
    } else
      n.push(s);
  }
  if (e) {
    for (let s of e)
      if (n.every((i) => _s(s, i)))
        throw new Error(`whole-script confusable: ${r.N}/${s.N}`);
  }
}
function Xd(r) {
  let t = Or;
  for (let e of r) {
    let n = t.filter((s) => _s(s, e));
    if (!n.length)
      throw Or.some((s) => _s(s, e)) ? gl(t[0], e) : pl(e);
    if (t = n, n.length == 1)
      break;
  }
  return t;
}
function qd(r) {
  return r.map(({ input: t, error: e, output: n }) => {
    if (e) {
      let s = e.message;
      throw new Error(r.length == 1 ? s : `Invalid label ${Ra(ao(t))}: ${s}`);
    }
    return ws(n);
  }).join(al);
}
function pl(r) {
  return new Error(`disallowed character: ${Ba(r)}`);
}
function gl(r, t) {
  let e = Ba(t), n = Or.find((s) => s.P.has(t));
  return n && (e = `${n.N} ${e}`), new Error(`illegal mixture: ${r.N} + ${e}`);
}
function ks(r) {
  return new Error(`illegal placement: ${r}`);
}
function $d(r, t) {
  for (let e of t)
    if (!_s(r, e))
      throw gl(r, e);
  if (r.M) {
    let e = ol(t);
    for (let n = 1, s = e.length; n < s; n++)
      if (qo.has(e[n])) {
        let i = n + 1;
        for (let o; i < s && qo.has(o = e[i]); i++)
          for (let a = n; a < i; a++)
            if (e[a] == o)
              throw new Error(`duplicate non-spacing marks: ${Ba(o)}`);
        if (i - n > Bc)
          throw new Error(`excessive non-spacing marks: ${Ra(ao(e.slice(n - 1, i)))} (${i - n}/${Bc})`);
        n = i;
      }
  }
}
function tp(r, t, e) {
  let n = [], s = [];
  for (r = r.slice().reverse(); r.length; ) {
    let i = np(r);
    if (i)
      s.length && (n.push(t(s)), s = []), n.push(e(i));
    else {
      let o = r.pop();
      if (hl.has(o))
        s.push(o);
      else {
        let a = Xo.get(o);
        if (a)
          s.push(...a);
        else if (!ll.has(o))
          throw pl(o);
      }
    }
  }
  return s.length && n.push(t(s)), n;
}
function ep(r) {
  return r.filter((t) => t != cl);
}
function np(r, t) {
  let e = $o, n, s = r.length;
  for (; s && (e = e.get(r[--s]), !!e); ) {
    let { V: i } = e;
    i && (n = i, t && t.push(...r.slice(s).reverse()), r.length = s);
  }
  return n;
}
const yl = new Uint8Array(32);
yl.fill(0);
function Uc(r) {
  return y(r.length !== 0, "invalid ENS name; empty component", "comp", r), r;
}
function ml(r) {
  const t = $e(rp(r)), e = [];
  if (r.length === 0)
    return e;
  let n = 0;
  for (let s = 0; s < t.length; s++)
    t[s] === 46 && (e.push(Uc(t.slice(n, s))), n = s + 1);
  return y(n < t.length, "invalid ENS name; empty component", "name", r), e.push(Uc(t.slice(n))), e;
}
function rp(r) {
  try {
    if (r.length === 0)
      throw new Error("empty label");
    return Wd(r);
  } catch (t) {
    y(!1, `invalid ENS name (${t.message})`, "name", r);
  }
}
function ta(r) {
  y(typeof r == "string", "invalid ENS name; not a string", "name", r), y(r.length, "invalid ENS name (empty label)", "name", r);
  let t = yl;
  const e = ml(r);
  for (; e.length; )
    t = st(pt([t, st(e.pop())]));
  return F(t);
}
function sp(r) {
  return F(pt(ml(r).map((t) => {
    if (t.length > 63)
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    const e = new Uint8Array(t.length + 1);
    return e.set(t, 1), e[0] = e.length - 1, e;
  }))) + "00";
}
function Ro(r, t) {
  return {
    address: W(r),
    storageKeys: t.map((e, n) => (y(it(e, 32), "invalid slot", `storageKeys[${n}]`, e), e.toLowerCase()))
  };
}
function lr(r) {
  if (Array.isArray(r))
    return r.map((e, n) => Array.isArray(e) ? (y(e.length === 2, "invalid slot set", `value[${n}]`, e), Ro(e[0], e[1])) : (y(e != null && typeof e == "object", "invalid address-slot set", "value", r), Ro(e.address, e.storageKeys)));
  y(r != null && typeof r == "object", "invalid access list", "value", r);
  const t = Object.keys(r).map((e) => {
    const n = r[e].reduce((s, i) => (s[i] = !0, s), {});
    return Ro(e, Object.keys(n).sort());
  });
  return t.sort((e, n) => e.address.localeCompare(n.address)), t;
}
function ip(r) {
  let t;
  return typeof r == "string" ? t = Ms.computePublicKey(r, !1) : t = r.publicKey, W(st("0x" + t.substring(4)).substring(26));
}
function op(r, t) {
  return ip(Ms.recoverPublicKey(r, t));
}
const Gt = BigInt(0), ap = BigInt(2), cp = BigInt(27), up = BigInt(28), lp = BigInt(35), fp = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function ka(r) {
  return r === "0x" ? null : W(r);
}
function wl(r, t) {
  try {
    return lr(r);
  } catch (e) {
    y(!1, e.message, t, r);
  }
}
function co(r, t) {
  return r === "0x" ? 0 : V(r, t);
}
function Rt(r, t) {
  if (r === "0x")
    return Gt;
  const e = L(r, t);
  return y(e <= fp, "value exceeds uint size", t, e), e;
}
function wt(r, t) {
  const e = L(r, "value"), n = Kt(e);
  return y(n.length <= 32, "value too large", `tx.${t}`, e), n;
}
function Al(r) {
  return lr(r).map((t) => [t.address, t.storageKeys]);
}
function hp(r) {
  const t = ba(r);
  y(Array.isArray(t) && (t.length === 9 || t.length === 6), "invalid field count for legacy transaction", "data", r);
  const e = {
    type: 0,
    nonce: co(t[0], "nonce"),
    gasPrice: Rt(t[1], "gasPrice"),
    gasLimit: Rt(t[2], "gasLimit"),
    to: ka(t[3]),
    value: Rt(t[4], "value"),
    data: F(t[5]),
    chainId: Gt
  };
  if (t.length === 6)
    return e;
  const n = Rt(t[6], "v"), s = Rt(t[7], "r"), i = Rt(t[8], "s");
  if (s === Gt && i === Gt)
    e.chainId = n;
  else {
    let o = (n - lp) / ap;
    o < Gt && (o = Gt), e.chainId = o, y(o !== Gt || n === cp || n === up, "non-canonical legacy v", "v", t[6]), e.signature = ye.from({
      r: ir(t[7], 32),
      s: ir(t[8], 32),
      v: n
    }), e.hash = st(r);
  }
  return e;
}
function Dc(r, t) {
  const e = [
    wt(r.nonce || 0, "nonce"),
    wt(r.gasPrice || 0, "gasPrice"),
    wt(r.gasLimit || 0, "gasLimit"),
    r.to != null ? W(r.to) : "0x",
    wt(r.value || 0, "value"),
    r.data || "0x"
  ];
  let n = Gt;
  if (r.chainId != Gt)
    n = L(r.chainId, "tx.chainId"), y(!t || t.networkV == null || t.legacyChainId === n, "tx.chainId/sig.v mismatch", "sig", t);
  else if (r.signature) {
    const i = r.signature.legacyChainId;
    i != null && (n = i);
  }
  if (!t)
    return n !== Gt && (e.push(Kt(n)), e.push("0x"), e.push("0x")), Fs(e);
  let s = BigInt(27 + t.yParity);
  return n !== Gt ? s = ye.getChainIdV(n, t.v) : BigInt(t.v) !== s && y(!1, "tx.chainId/sig.v mismatch", "sig", t), e.push(Kt(s)), e.push(Kt(t.r)), e.push(Kt(t.s)), Fs(e);
}
function bl(r, t) {
  let e;
  try {
    if (e = co(t[0], "yParity"), e !== 0 && e !== 1)
      throw new Error("bad yParity");
  } catch {
    y(!1, "invalid yParity", "yParity", t[0]);
  }
  const n = ir(t[1], 32), s = ir(t[2], 32), i = ye.from({ r: n, s, yParity: e });
  r.signature = i;
}
function dp(r) {
  const t = ba(X(r).slice(1));
  y(Array.isArray(t) && (t.length === 9 || t.length === 12), "invalid field count for transaction type: 2", "data", F(r));
  const e = Rt(t[2], "maxPriorityFeePerGas"), n = Rt(t[3], "maxFeePerGas"), s = {
    type: 2,
    chainId: Rt(t[0], "chainId"),
    nonce: co(t[1], "nonce"),
    maxPriorityFeePerGas: e,
    maxFeePerGas: n,
    gasPrice: null,
    gasLimit: Rt(t[4], "gasLimit"),
    to: ka(t[5]),
    value: Rt(t[6], "value"),
    data: F(t[7]),
    accessList: wl(t[8], "accessList")
  };
  return t.length === 9 || (s.hash = st(r), bl(s, t.slice(9))), s;
}
function Fc(r, t) {
  const e = [
    wt(r.chainId || 0, "chainId"),
    wt(r.nonce || 0, "nonce"),
    wt(r.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    wt(r.maxFeePerGas || 0, "maxFeePerGas"),
    wt(r.gasLimit || 0, "gasLimit"),
    r.to != null ? W(r.to) : "0x",
    wt(r.value || 0, "value"),
    r.data || "0x",
    Al(r.accessList || [])
  ];
  return t && (e.push(wt(t.yParity, "yParity")), e.push(Kt(t.r)), e.push(Kt(t.s))), pt(["0x02", Fs(e)]);
}
function pp(r) {
  const t = ba(X(r).slice(1));
  y(Array.isArray(t) && (t.length === 8 || t.length === 11), "invalid field count for transaction type: 1", "data", F(r));
  const e = {
    type: 1,
    chainId: Rt(t[0], "chainId"),
    nonce: co(t[1], "nonce"),
    gasPrice: Rt(t[2], "gasPrice"),
    gasLimit: Rt(t[3], "gasLimit"),
    to: ka(t[4]),
    value: Rt(t[5], "value"),
    data: F(t[6]),
    accessList: wl(t[7], "accessList")
  };
  return t.length === 8 || (e.hash = st(r), bl(e, t.slice(8))), e;
}
function Lc(r, t) {
  const e = [
    wt(r.chainId || 0, "chainId"),
    wt(r.nonce || 0, "nonce"),
    wt(r.gasPrice || 0, "gasPrice"),
    wt(r.gasLimit || 0, "gasLimit"),
    r.to != null ? W(r.to) : "0x",
    wt(r.value || 0, "value"),
    r.data || "0x",
    Al(r.accessList || [])
  ];
  return t && (e.push(wt(t.yParity, "recoveryParam")), e.push(Kt(t.r)), e.push(Kt(t.s))), pt(["0x01", Fs(e)]);
}
var _e, Gr, Qr, Hr, _r, Vr, Jr, jr, zr, Kr, Wr, Yr;
const ln = class ln {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    b(this, _e, void 0);
    b(this, Gr, void 0);
    b(this, Qr, void 0);
    b(this, Hr, void 0);
    b(this, _r, void 0);
    b(this, Vr, void 0);
    b(this, Jr, void 0);
    b(this, jr, void 0);
    b(this, zr, void 0);
    b(this, Kr, void 0);
    b(this, Wr, void 0);
    b(this, Yr, void 0);
    d(this, _e, null), d(this, Gr, null), d(this, Hr, 0), d(this, _r, BigInt(0)), d(this, Vr, null), d(this, Jr, null), d(this, jr, null), d(this, Qr, "0x"), d(this, zr, BigInt(0)), d(this, Kr, BigInt(0)), d(this, Wr, null), d(this, Yr, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return l(this, _e);
  }
  set type(t) {
    switch (t) {
      case null:
        d(this, _e, null);
        break;
      case 0:
      case "legacy":
        d(this, _e, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        d(this, _e, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        d(this, _e, 2);
        break;
      default:
        y(!1, "unsupported transaction type", "type", t);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    return l(this, Gr);
  }
  set to(t) {
    d(this, Gr, t == null ? null : W(t));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return l(this, Hr);
  }
  set nonce(t) {
    d(this, Hr, V(t, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return l(this, _r);
  }
  set gasLimit(t) {
    d(this, _r, L(t));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const t = l(this, Vr);
    return t == null && (this.type === 0 || this.type === 1) ? Gt : t;
  }
  set gasPrice(t) {
    d(this, Vr, t == null ? null : L(t, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const t = l(this, Jr);
    return t ?? (this.type === 2 ? Gt : null);
  }
  set maxPriorityFeePerGas(t) {
    d(this, Jr, t == null ? null : L(t, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const t = l(this, jr);
    return t ?? (this.type === 2 ? Gt : null);
  }
  set maxFeePerGas(t) {
    d(this, jr, t == null ? null : L(t, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return l(this, Qr);
  }
  set data(t) {
    d(this, Qr, F(t));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return l(this, zr);
  }
  set value(t) {
    d(this, zr, L(t, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return l(this, Kr);
  }
  set chainId(t) {
    d(this, Kr, L(t));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return l(this, Wr) || null;
  }
  set signature(t) {
    d(this, Wr, t == null ? null : ye.from(t));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const t = l(this, Yr) || null;
    return t ?? (this.type === 1 || this.type === 2 ? [] : null);
  }
  set accessList(t) {
    d(this, Yr, t == null ? null : lr(t));
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    return this.signature == null ? null : st(this.serialized);
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return st(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    return this.signature == null ? null : op(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    return this.signature == null ? null : Ms.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    switch (P(this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" }), this.inferType()) {
      case 0:
        return Dc(this, this.signature);
      case 1:
        return Lc(this, this.signature);
      case 2:
        return Fc(this, this.signature);
    }
    P(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    switch (this.inferType()) {
      case 0:
        return Dc(this);
      case 1:
        return Lc(this);
      case 2:
        return Fc(this);
    }
    P(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".unsignedSerialized" });
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    return this.inferTypes().pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const t = this.gasPrice != null, e = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null, n = this.accessList != null;
    this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && P(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this }), P(!e || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this }), P(this.type !== 0 || !n, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const s = [];
    return this.type != null ? s.push(this.type) : e ? s.push(2) : t ? (s.push(1), n || s.push(0)) : n ? (s.push(1), s.push(2)) : (s.push(0), s.push(1), s.push(2)), s.sort(), s;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return ln.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const t = (e) => e == null ? null : e.toString();
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: t(this.gasLimit),
      gasPrice: t(this.gasPrice),
      maxPriorityFeePerGas: t(this.maxPriorityFeePerGas),
      maxFeePerGas: t(this.maxFeePerGas),
      value: t(this.value),
      chainId: t(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(t) {
    if (t == null)
      return new ln();
    if (typeof t == "string") {
      const n = X(t);
      if (n[0] >= 127)
        return ln.from(hp(n));
      switch (n[0]) {
        case 1:
          return ln.from(pp(n));
        case 2:
          return ln.from(dp(n));
      }
      P(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const e = new ln();
    return t.type != null && (e.type = t.type), t.to != null && (e.to = t.to), t.nonce != null && (e.nonce = t.nonce), t.gasLimit != null && (e.gasLimit = t.gasLimit), t.gasPrice != null && (e.gasPrice = t.gasPrice), t.maxPriorityFeePerGas != null && (e.maxPriorityFeePerGas = t.maxPriorityFeePerGas), t.maxFeePerGas != null && (e.maxFeePerGas = t.maxFeePerGas), t.data != null && (e.data = t.data), t.value != null && (e.value = t.value), t.chainId != null && (e.chainId = t.chainId), t.signature != null && (e.signature = ye.from(t.signature)), t.accessList != null && (e.accessList = t.accessList), t.hash != null && (y(e.isSigned(), "unsigned transaction cannot define hash", "tx", t), y(e.hash === t.hash, "hash mismatch", "tx", t)), t.from != null && (y(e.isSigned(), "unsigned transaction cannot define from", "tx", t), y(e.from.toLowerCase() === (t.from || "").toLowerCase(), "from mismatch", "tx", t)), e;
  }
};
_e = new WeakMap(), Gr = new WeakMap(), Qr = new WeakMap(), Hr = new WeakMap(), _r = new WeakMap(), Vr = new WeakMap(), Jr = new WeakMap(), jr = new WeakMap(), zr = new WeakMap(), Kr = new WeakMap(), Wr = new WeakMap(), Yr = new WeakMap();
let Qi = ln;
const El = new Uint8Array(32);
El.fill(0);
const gp = BigInt(-1), vl = BigInt(0), xl = BigInt(1), yp = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function mp(r) {
  const t = X(r), e = t.length % 32;
  return e ? pt([t, El.slice(e)]) : F(t);
}
const wp = On(xl, 32), Ap = On(vl, 32), Mc = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, ko = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function Gc(r) {
  return function(t) {
    return y(typeof t == "string", `invalid domain value for ${JSON.stringify(r)}`, `domain.${r}`, t), t;
  };
}
const bp = {
  name: Gc("name"),
  version: Gc("version"),
  chainId: function(r) {
    const t = L(r, "domain.chainId");
    return y(t >= 0, "invalid chain ID", "domain.chainId", r), Number.isSafeInteger(t) ? Number(t) : vr(t);
  },
  verifyingContract: function(r) {
    try {
      return W(r).toLowerCase();
    } catch {
    }
    y(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", r);
  },
  salt: function(r) {
    const t = X(r, "domain.salt");
    return y(t.length === 32, 'invalid domain value "salt"', "domain.salt", r), F(t);
  }
};
function So(r) {
  {
    const t = r.match(/^(u?)int(\d*)$/);
    if (t) {
      const e = t[1] === "", n = parseInt(t[2] || "256");
      y(n % 8 === 0 && n !== 0 && n <= 256 && (t[2] == null || t[2] === String(n)), "invalid numeric width", "type", r);
      const s = Cs(yp, e ? n - 1 : n), i = e ? (s + xl) * gp : vl;
      return function(o) {
        const a = L(o, "value");
        return y(a >= i && a <= s, `value out-of-bounds for ${r}`, "value", a), On(e ? mu(a, 256) : a, 32);
      };
    }
  }
  {
    const t = r.match(/^bytes(\d+)$/);
    if (t) {
      const e = parseInt(t[1]);
      return y(e !== 0 && e <= 32 && t[1] === String(e), "invalid bytes width", "type", r), function(n) {
        const s = X(n);
        return y(s.length === e, `invalid length for ${r}`, "value", n), mp(n);
      };
    }
  }
  switch (r) {
    case "address":
      return function(t) {
        return ir(W(t), 32);
      };
    case "bool":
      return function(t) {
        return t ? wp : Ap;
      };
    case "bytes":
      return function(t) {
        return st(t);
      };
    case "string":
      return function(t) {
        return or(t);
      };
  }
  return null;
}
function Qc(r, t) {
  return `${r}(${t.map(({ name: e, type: n }) => n + " " + e).join(",")})`;
}
var Ys, Ve, Zr, Yi, Pl;
const Xt = class Xt {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(t) {
    b(this, Yi);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    A(this, "primaryType");
    b(this, Ys, void 0);
    b(this, Ve, void 0);
    b(this, Zr, void 0);
    d(this, Ys, JSON.stringify(t)), d(this, Ve, /* @__PURE__ */ new Map()), d(this, Zr, /* @__PURE__ */ new Map());
    const e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
    Object.keys(t).forEach((a) => {
      e.set(a, /* @__PURE__ */ new Set()), n.set(a, []), s.set(a, /* @__PURE__ */ new Set());
    });
    for (const a in t) {
      const c = /* @__PURE__ */ new Set();
      for (const u of t[a]) {
        y(!c.has(u.name), `duplicate variable name ${JSON.stringify(u.name)} in ${JSON.stringify(a)}`, "types", t), c.add(u.name);
        const f = u.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
        y(f !== a, `circular type reference to ${JSON.stringify(f)}`, "types", t), !So(f) && (y(n.has(f), `unknown type ${JSON.stringify(f)}`, "types", t), n.get(f).push(a), e.get(a).add(f));
      }
    }
    const i = Array.from(n.keys()).filter((a) => n.get(a).length === 0);
    y(i.length !== 0, "missing primary type", "types", t), y(i.length === 1, `ambiguous primary types or unused types: ${i.map((a) => JSON.stringify(a)).join(", ")}`, "types", t), M(this, { primaryType: i[0] });
    function o(a, c) {
      y(!c.has(a), `circular type reference to ${JSON.stringify(a)}`, "types", t), c.add(a);
      for (const u of e.get(a))
        if (n.has(u)) {
          o(u, c);
          for (const f of c)
            s.get(f).add(u);
        }
      c.delete(a);
    }
    o(this.primaryType, /* @__PURE__ */ new Set());
    for (const [a, c] of s) {
      const u = Array.from(c);
      u.sort(), l(this, Ve).set(a, Qc(a, t[a]) + u.map((f) => Qc(f, t[f])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(l(this, Ys));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(t) {
    let e = l(this, Zr).get(t);
    return e || (e = I(this, Yi, Pl).call(this, t), l(this, Zr).set(t, e)), e;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(t) {
    const e = l(this, Ve).get(t);
    return y(e, `unknown type: ${JSON.stringify(t)}`, "name", t), e;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(t, e) {
    return this.getEncoder(t)(e);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(t, e) {
    return st(this.encodeData(t, e));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(t) {
    return this.encodeData(this.primaryType, t);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(t) {
    return this.hashStruct(this.primaryType, t);
  }
  /**
   *  @_ignore:
   */
  _visit(t, e, n) {
    if (So(t))
      return n(t, e);
    const s = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (s)
      return y(!s[3] || parseInt(s[3]) === e.length, `array length mismatch; expected length ${parseInt(s[3])}`, "value", e), e.map((o) => this._visit(s[1], o, n));
    const i = this.types[t];
    if (i)
      return i.reduce((o, { name: a, type: c }) => (o[a] = this._visit(c, e[a], n), o), {});
    y(!1, `unknown type: ${t}`, "type", t);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(t, e) {
    return this._visit(this.primaryType, t, e);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(t) {
    return new Xt(t);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(t) {
    return Xt.from(t).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(t, e, n) {
    return Xt.from(e).hashStruct(t, n);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(t) {
    const e = [];
    for (const n in t) {
      if (t[n] == null)
        continue;
      const s = Mc[n];
      y(s, `invalid typed-data domain key: ${JSON.stringify(n)}`, "domain", t), e.push({ name: n, type: s });
    }
    return e.sort((n, s) => ko.indexOf(n.name) - ko.indexOf(s.name)), Xt.hashStruct("EIP712Domain", { EIP712Domain: e }, t);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(t, e, n) {
    return pt([
      "0x1901",
      Xt.hashDomain(t),
      Xt.from(e).hash(n)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(t, e, n) {
    return st(Xt.encode(t, e, n));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(t, e, n, s) {
    t = Object.assign({}, t);
    for (const a in t)
      t[a] == null && delete t[a];
    const i = {};
    t.verifyingContract && !it(t.verifyingContract, 20) && (i[t.verifyingContract] = "0x");
    const o = Xt.from(e);
    o.visit(n, (a, c) => (a === "address" && !it(c, 20) && (i[c] = "0x"), c));
    for (const a in i)
      i[a] = await s(a);
    return t.verifyingContract && i[t.verifyingContract] && (t.verifyingContract = i[t.verifyingContract]), n = o.visit(n, (a, c) => a === "address" && i[c] ? i[c] : c), { domain: t, value: n };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(t, e, n) {
    Xt.hashDomain(t);
    const s = {}, i = [];
    ko.forEach((c) => {
      const u = t[c];
      u != null && (s[c] = bp[c](u), i.push({ name: c, type: Mc[c] }));
    });
    const o = Xt.from(e), a = Object.assign({}, e);
    return y(a.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", e), a.EIP712Domain = i, o.encode(n), {
      types: a,
      domain: s,
      primaryType: o.primaryType,
      message: o.visit(n, (c, u) => {
        if (c.match(/^bytes(\d*)/))
          return F(X(u));
        if (c.match(/^u?int/))
          return L(u).toString();
        switch (c) {
          case "address":
            return u.toLowerCase();
          case "bool":
            return !!u;
          case "string":
            return y(typeof u == "string", "invalid string", "value", u), u;
        }
        y(!1, "unsupported type", "type", c);
      })
    };
  }
};
Ys = new WeakMap(), Ve = new WeakMap(), Zr = new WeakMap(), Yi = new WeakSet(), Pl = function(t) {
  {
    const s = So(t);
    if (s)
      return s;
  }
  const e = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
  if (e) {
    const s = e[1], i = this.getEncoder(s);
    return (o) => {
      y(!e[3] || parseInt(e[3]) === o.length, `array length mismatch; expected length ${parseInt(e[3])}`, "value", o);
      let a = o.map(i);
      return l(this, Ve).has(s) && (a = a.map(st)), st(pt(a));
    };
  }
  const n = this.types[t];
  if (n) {
    const s = or(l(this, Ve).get(t));
    return (i) => {
      const o = n.map(({ name: a, type: c }) => {
        const u = this.getEncoder(c)(i[a]);
        return l(this, Ve).has(c) ? st(u) : u;
      });
      return o.unshift(s), pt(o);
    };
  }
  y(!1, `unknown type: ${t}`, "type", t);
};
let Hi = Xt;
function Ut(r) {
  const t = /* @__PURE__ */ new Set();
  return r.forEach((e) => t.add(e)), Object.freeze(t);
}
const Ep = "external public payable", vp = Ut(Ep.split(" ")), Nl = "constant external internal payable private public pure view", xp = Ut(Nl.split(" ")), Cl = "constructor error event fallback function receive struct", Tl = Ut(Cl.split(" ")), Ol = "calldata memory storage payable indexed", Pp = Ut(Ol.split(" ")), Np = "tuple returns", Cp = [Cl, Ol, Np, Nl].join(" "), Tp = Ut(Cp.split(" ")), Op = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
}, Ip = new RegExp("^(\\s*)"), Bp = new RegExp("^([0-9]+)"), Rp = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"), Il = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"), Bl = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var mt, de, Zs, ea;
const Zi = class Zi {
  constructor(t) {
    b(this, Zs);
    b(this, mt, void 0);
    b(this, de, void 0);
    d(this, mt, 0), d(this, de, t.slice());
  }
  get offset() {
    return l(this, mt);
  }
  get length() {
    return l(this, de).length - l(this, mt);
  }
  clone() {
    return new Zi(l(this, de));
  }
  reset() {
    d(this, mt, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(t) {
    const e = this.peek();
    if (e.type !== "KEYWORD" || !t.has(e.text))
      throw new Error(`expected keyword ${e.text}`);
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(t) {
    if (this.peek().type !== t)
      throw new Error(`expected ${t}; got ${JSON.stringify(this.peek())}`);
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const t = this.peek();
    if (t.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const e = I(this, Zs, ea).call(this, l(this, mt) + 1, t.match + 1);
    return d(this, mt, t.match + 1), e;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const t = this.peek();
    if (t.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const e = [];
    for (; l(this, mt) < t.match - 1; ) {
      const n = this.peek().linkNext;
      e.push(I(this, Zs, ea).call(this, l(this, mt) + 1, n)), d(this, mt, n);
    }
    return d(this, mt, t.match + 1), e;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (l(this, mt) >= l(this, de).length)
      throw new Error("out-of-bounds");
    return l(this, de)[l(this, mt)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(t) {
    const e = this.peekType("KEYWORD");
    return e != null && t.has(e) ? e : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(t) {
    if (this.length === 0)
      return null;
    const e = this.peek();
    return e.type === t ? e.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const t = this.peek();
    return xs(this, mt)._++, t;
  }
  toString() {
    const t = [];
    for (let e = l(this, mt); e < l(this, de).length; e++) {
      const n = l(this, de)[e];
      t.push(`${n.type}:${n.text}`);
    }
    return `<TokenString ${t.join(" ")}>`;
  }
};
mt = new WeakMap(), de = new WeakMap(), Zs = new WeakSet(), ea = function(t = 0, e = 0) {
  return new Zi(l(this, de).slice(t, e).map((n) => Object.freeze(Object.assign({}, n, {
    match: n.match - t,
    linkBack: n.linkBack - t,
    linkNext: n.linkNext - t
  }))));
};
let me = Zi;
function Bn(r) {
  const t = [], e = (o) => {
    const a = i < r.length ? JSON.stringify(r[i]) : "$EOI";
    throw new Error(`invalid token ${a} at ${i}: ${o}`);
  };
  let n = [], s = [], i = 0;
  for (; i < r.length; ) {
    let o = r.substring(i), a = o.match(Ip);
    a && (i += a[1].length, o = r.substring(i));
    const c = { depth: n.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset: i, value: -1 };
    t.push(c);
    let u = Op[o[0]] || "";
    if (u) {
      if (c.type = u, c.text = o[0], i++, u === "OPEN_PAREN")
        n.push(t.length - 1), s.push(t.length - 1);
      else if (u == "CLOSE_PAREN")
        n.length === 0 && e("no matching open bracket"), c.match = n.pop(), t[c.match].match = t.length - 1, c.depth--, c.linkBack = s.pop(), t[c.linkBack].linkNext = t.length - 1;
      else if (u === "COMMA")
        c.linkBack = s.pop(), t[c.linkBack].linkNext = t.length - 1, s.push(t.length - 1);
      else if (u === "OPEN_BRACKET")
        c.type = "BRACKET";
      else if (u === "CLOSE_BRACKET") {
        let f = t.pop().text;
        if (t.length > 0 && t[t.length - 1].type === "NUMBER") {
          const h = t.pop().text;
          f = h + f, t[t.length - 1].value = V(h);
        }
        if (t.length === 0 || t[t.length - 1].type !== "BRACKET")
          throw new Error("missing opening bracket");
        t[t.length - 1].text += f;
      }
      continue;
    }
    if (a = o.match(Rp), a) {
      if (c.text = a[1], i += c.text.length, Tp.has(c.text)) {
        c.type = "KEYWORD";
        continue;
      }
      if (c.text.match(Bl)) {
        c.type = "TYPE";
        continue;
      }
      c.type = "ID";
      continue;
    }
    if (a = o.match(Bp), a) {
      c.text = a[1], c.type = "NUMBER", i += c.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(o[0])} at position ${i}`);
  }
  return new me(t.map((o) => Object.freeze(o)));
}
function Hc(r, t) {
  let e = [];
  for (const n in t.keys())
    r.has(n) && e.push(n);
  if (e.length > 1)
    throw new Error(`conflicting types: ${e.join(", ")}`);
}
function uo(r, t) {
  if (t.peekKeyword(Tl)) {
    const e = t.pop().text;
    if (e !== r)
      throw new Error(`expected ${r}, got ${e}`);
  }
  return t.popType("ID");
}
function en(r, t) {
  const e = /* @__PURE__ */ new Set();
  for (; ; ) {
    const n = r.peekType("KEYWORD");
    if (n == null || t && !t.has(n))
      break;
    if (r.pop(), e.has(n))
      throw new Error(`duplicate keywords: ${JSON.stringify(n)}`);
    e.add(n);
  }
  return Object.freeze(e);
}
function Rl(r) {
  let t = en(r, xp);
  return Hc(t, Ut("constant payable nonpayable".split(" "))), Hc(t, Ut("pure view payable nonpayable".split(" "))), t.has("view") ? "view" : t.has("pure") ? "pure" : t.has("payable") ? "payable" : t.has("nonpayable") ? "nonpayable" : t.has("constant") ? "view" : "nonpayable";
}
function tn(r, t) {
  return r.popParams().map((e) => At.from(e, t));
}
function kl(r) {
  if (r.peekType("AT")) {
    if (r.pop(), r.peekType("NUMBER"))
      return L(r.pop().text);
    throw new Error("invalid gas");
  }
  return null;
}
function ar(r) {
  if (r.length)
    throw new Error(`unexpected tokens: ${r.toString()}`);
}
const kp = new RegExp(/^(.*)\[([0-9]*)\]$/);
function _c(r) {
  const t = r.match(Bl);
  if (y(t, "invalid type", "type", r), r === "uint")
    return "uint256";
  if (r === "int")
    return "int256";
  if (t[2]) {
    const e = parseInt(t[2]);
    y(e !== 0 && e <= 32, "invalid bytes length", "type", r);
  } else if (t[3]) {
    const e = parseInt(t[3]);
    y(e !== 0 && e <= 256 && e % 8 === 0, "invalid numeric width", "type", r);
  }
  return r;
}
const rt = {}, _t = Symbol.for("_ethers_internal"), Vc = "_ParamTypeInternal", Jc = "_ErrorInternal", jc = "_EventInternal", zc = "_ConstructorInternal", Kc = "_FallbackInternal", Wc = "_FunctionInternal", Yc = "_StructInternal";
var Xr, Ti;
const qt = class qt {
  /**
   *  @private
   */
  constructor(t, e, n, s, i, o, a, c) {
    b(this, Xr);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    A(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    A(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    A(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    A(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    A(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    A(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    A(this, "arrayChildren");
    if (eo(t, rt, "ParamType"), Object.defineProperty(this, _t, { value: Vc }), o && (o = Object.freeze(o.slice())), s === "array") {
      if (a == null || c == null)
        throw new Error("");
    } else if (a != null || c != null)
      throw new Error("");
    if (s === "tuple") {
      if (o == null)
        throw new Error("");
    } else if (o != null)
      throw new Error("");
    M(this, {
      name: e,
      type: n,
      baseType: s,
      indexed: i,
      components: o,
      arrayLength: a,
      arrayChildren: c
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(t) {
    if (t == null && (t = "sighash"), t === "json") {
      const n = this.name || "";
      if (this.isArray()) {
        const i = JSON.parse(this.arrayChildren.format("json"));
        return i.name = n, i.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`, JSON.stringify(i);
      }
      const s = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: n
      };
      return typeof this.indexed == "boolean" && (s.indexed = this.indexed), this.isTuple() && (s.components = this.components.map((i) => JSON.parse(i.format(t)))), JSON.stringify(s);
    }
    let e = "";
    return this.isArray() ? (e += this.arrayChildren.format(t), e += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`) : this.isTuple() ? (t !== "sighash" && (e += this.type), e += "(" + this.components.map((n) => n.format(t)).join(t === "full" ? ", " : ",") + ")") : e += this.type, t !== "sighash" && (this.indexed === !0 && (e += " indexed"), t === "full" && this.name && (e += " " + this.name)), e;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(t, e) {
    if (this.isArray()) {
      if (!Array.isArray(t))
        throw new Error("invalid array value");
      if (this.arrayLength !== -1 && t.length !== this.arrayLength)
        throw new Error("array is wrong length");
      const n = this;
      return t.map((s) => n.arrayChildren.walk(s, e));
    }
    if (this.isTuple()) {
      if (!Array.isArray(t))
        throw new Error("invalid tuple value");
      if (t.length !== this.components.length)
        throw new Error("array is wrong length");
      const n = this;
      return t.map((s, i) => n.components[i].walk(s, e));
    }
    return e(this.type, t);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS naes by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(t, e) {
    const n = [], s = [t];
    return I(this, Xr, Ti).call(this, n, t, e, (i) => {
      s[0] = i;
    }), n.length && await Promise.all(n), s[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(t, e) {
    if (qt.isParamType(t))
      return t;
    if (typeof t == "string")
      try {
        return qt.from(Bn(t), e);
      } catch {
        y(!1, "invalid param type", "obj", t);
      }
    else if (t instanceof me) {
      let a = "", c = "", u = null;
      en(t, Ut(["tuple"])).has("tuple") || t.peekType("OPEN_PAREN") ? (c = "tuple", u = t.popParams().map((m) => qt.from(m)), a = `tuple(${u.map((m) => m.format()).join(",")})`) : (a = _c(t.popType("TYPE")), c = a);
      let f = null, h = null;
      for (; t.length && t.peekType("BRACKET"); ) {
        const m = t.pop();
        f = new qt(rt, "", a, c, null, u, h, f), h = m.value, a += m.text, c = "array", u = null;
      }
      let g = null;
      if (en(t, Pp).has("indexed")) {
        if (!e)
          throw new Error("");
        g = !0;
      }
      const E = t.peekType("ID") ? t.pop().text : "";
      if (t.length)
        throw new Error("leftover tokens");
      return new qt(rt, E, a, c, g, u, h, f);
    }
    const n = t.name;
    y(!n || typeof n == "string" && n.match(Il), "invalid name", "obj.name", n);
    let s = t.indexed;
    s != null && (y(e, "parameter cannot be indexed", "obj.indexed", t.indexed), s = !!s);
    let i = t.type, o = i.match(kp);
    if (o) {
      const a = parseInt(o[2] || "-1"), c = qt.from({
        type: o[1],
        components: t.components
      });
      return new qt(rt, n || "", i, "array", s, null, a, c);
    }
    if (i === "tuple" || i.startsWith(
      "tuple("
      /* fix: ) */
    ) || i.startsWith(
      "("
      /* fix: ) */
    )) {
      const a = t.components != null ? t.components.map((u) => qt.from(u)) : null;
      return new qt(rt, n || "", i, "tuple", s, a, null, null);
    }
    return i = _c(t.type), new qt(rt, n || "", i, i, s, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(t) {
    return t && t[_t] === Vc;
  }
};
Xr = new WeakSet(), Ti = function(t, e, n, s) {
  if (this.isArray()) {
    if (!Array.isArray(e))
      throw new Error("invalid array value");
    if (this.arrayLength !== -1 && e.length !== this.arrayLength)
      throw new Error("array is wrong length");
    const o = this.arrayChildren, a = e.slice();
    a.forEach((c, u) => {
      var f;
      I(f = o, Xr, Ti).call(f, t, c, n, (h) => {
        a[u] = h;
      });
    }), s(a);
    return;
  }
  if (this.isTuple()) {
    const o = this.components;
    let a;
    if (Array.isArray(e))
      a = e.slice();
    else {
      if (e == null || typeof e != "object")
        throw new Error("invalid tuple value");
      a = o.map((c) => {
        if (!c.name)
          throw new Error("cannot use object value with unnamed components");
        if (!(c.name in e))
          throw new Error(`missing value for component ${c.name}`);
        return e[c.name];
      });
    }
    if (a.length !== this.components.length)
      throw new Error("array is wrong length");
    a.forEach((c, u) => {
      var f;
      I(f = o[u], Xr, Ti).call(f, t, c, n, (h) => {
        a[u] = h;
      });
    }), s(a);
    return;
  }
  const i = n(this.type, e);
  i.then ? t.push(async function() {
    s(await i);
  }()) : s(i);
};
let At = qt;
class cr {
  /**
   *  @private
   */
  constructor(t, e, n) {
    /**
     *  The type of the fragment.
     */
    A(this, "type");
    /**
     *  The inputs for the fragment.
     */
    A(this, "inputs");
    eo(t, rt, "Fragment"), n = Object.freeze(n.slice()), M(this, { type: e, inputs: n });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(t) {
    if (typeof t == "string") {
      try {
        cr.from(JSON.parse(t));
      } catch {
      }
      return cr.from(Bn(t));
    }
    if (t instanceof me)
      switch (t.peekKeyword(Tl)) {
        case "constructor":
          return Xe.from(t);
        case "error":
          return Qt.from(t);
        case "event":
          return Oe.from(t);
        case "fallback":
        case "receive":
          return Fe.from(t);
        case "function":
          return Ie.from(t);
        case "struct":
          return sr.from(t);
      }
    else if (typeof t == "object") {
      switch (t.type) {
        case "constructor":
          return Xe.from(t);
        case "error":
          return Qt.from(t);
        case "event":
          return Oe.from(t);
        case "fallback":
        case "receive":
          return Fe.from(t);
        case "function":
          return Ie.from(t);
        case "struct":
          return sr.from(t);
      }
      P(!1, `unsupported type: ${t.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    y(!1, "unsupported frgament object", "obj", t);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(t) {
    return Xe.isFragment(t);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(t) {
    return Qt.isFragment(t);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(t) {
    return Oe.isFragment(t);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(t) {
    return Ie.isFragment(t);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(t) {
    return sr.isFragment(t);
  }
}
class lo extends cr {
  /**
   *  @private
   */
  constructor(e, n, s, i) {
    super(e, n, i);
    /**
     *  The name of the fragment.
     */
    A(this, "name");
    y(typeof s == "string" && s.match(Il), "invalid identifier", "name", s), i = Object.freeze(i.slice()), M(this, { name: s });
  }
}
function Vs(r, t) {
  return "(" + t.map((e) => e.format(r)).join(r === "full" ? ", " : ",") + ")";
}
class Qt extends lo {
  /**
   *  @private
   */
  constructor(t, e, n) {
    super(t, "error", e, n), Object.defineProperty(this, _t, { value: Jc });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return or(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(t) {
    if (t == null && (t = "sighash"), t === "json")
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((n) => JSON.parse(n.format(t)))
      });
    const e = [];
    return t !== "sighash" && e.push("error"), e.push(this.name + Vs(t, this.inputs)), e.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(t) {
    if (Qt.isFragment(t))
      return t;
    if (typeof t == "string")
      return Qt.from(Bn(t));
    if (t instanceof me) {
      const e = uo("error", t), n = tn(t);
      return ar(t), new Qt(rt, e, n);
    }
    return new Qt(rt, t.name, t.inputs ? t.inputs.map(At.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(t) {
    return t && t[_t] === Jc;
  }
}
class Oe extends lo {
  /**
   *  @private
   */
  constructor(e, n, s, i) {
    super(e, "event", n, s);
    /**
     *  Whether this event is anonymous.
     */
    A(this, "anonymous");
    Object.defineProperty(this, _t, { value: jc }), M(this, { anonymous: i });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return or(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json")
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((s) => JSON.parse(s.format(e)))
      });
    const n = [];
    return e !== "sighash" && n.push("event"), n.push(this.name + Vs(e, this.inputs)), e !== "sighash" && this.anonymous && n.push("anonymous"), n.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(e, n) {
    return n = (n || []).map((i) => At.from(i)), new Oe(rt, e, n, !1).topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(e) {
    if (Oe.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return Oe.from(Bn(e));
      } catch {
        y(!1, "invalid event fragment", "obj", e);
      }
    else if (e instanceof me) {
      const n = uo("event", e), s = tn(e, !0), i = !!en(e, Ut(["anonymous"])).has("anonymous");
      return ar(e), new Oe(rt, n, s, i);
    }
    return new Oe(rt, e.name, e.inputs ? e.inputs.map((n) => At.from(n, !0)) : [], !!e.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(e) {
    return e && e[_t] === jc;
  }
}
class Xe extends cr {
  /**
   *  @private
   */
  constructor(e, n, s, i, o) {
    super(e, n, s);
    /**
     *  Whether the constructor can receive an endowment.
     */
    A(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    A(this, "gas");
    Object.defineProperty(this, _t, { value: zc }), M(this, { payable: i, gas: o });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(e) {
    if (P(e != null && e !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" }), e === "json")
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((s) => JSON.parse(s.format(e)))
      });
    const n = [`constructor${Vs(e, this.inputs)}`];
    return n.push(this.payable ? "payable" : "nonpayable"), this.gas != null && n.push(`@${this.gas.toString()}`), n.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(e) {
    if (Xe.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return Xe.from(Bn(e));
      } catch {
        y(!1, "invalid constuctor fragment", "obj", e);
      }
    else if (e instanceof me) {
      en(e, Ut(["constructor"]));
      const n = tn(e), s = !!en(e, vp).has("payable"), i = kl(e);
      return ar(e), new Xe(rt, "constructor", n, s, i);
    }
    return new Xe(rt, "constructor", e.inputs ? e.inputs.map(At.from) : [], !!e.payable, e.gas != null ? e.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(e) {
    return e && e[_t] === zc;
  }
}
class Fe extends cr {
  constructor(e, n, s) {
    super(e, "fallback", n);
    /**
     *  If the function can be sent value during invocation.
     */
    A(this, "payable");
    Object.defineProperty(this, _t, { value: Kc }), M(this, { payable: s });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(e) {
    const n = this.inputs.length === 0 ? "receive" : "fallback";
    if (e === "json") {
      const s = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type: n, stateMutability: s });
    }
    return `${n}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(e) {
    if (Fe.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return Fe.from(Bn(e));
      } catch {
        y(!1, "invalid fallback fragment", "obj", e);
      }
    else if (e instanceof me) {
      const n = e.toString(), s = e.peekKeyword(Ut(["fallback", "receive"]));
      if (y(s, "type must be fallback or receive", "obj", n), e.popKeyword(Ut(["fallback", "receive"])) === "receive") {
        const c = tn(e);
        return y(c.length === 0, "receive cannot have arguments", "obj.inputs", c), en(e, Ut(["payable"])), ar(e), new Fe(rt, [], !0);
      }
      let o = tn(e);
      o.length ? y(o.length === 1 && o[0].type === "bytes", "invalid fallback inputs", "obj.inputs", o.map((c) => c.format("minimal")).join(", ")) : o = [At.from("bytes")];
      const a = Rl(e);
      if (y(a === "nonpayable" || a === "payable", "fallback cannot be constants", "obj.stateMutability", a), en(e, Ut(["returns"])).has("returns")) {
        const c = tn(e);
        y(c.length === 1 && c[0].type === "bytes", "invalid fallback outputs", "obj.outputs", c.map((u) => u.format("minimal")).join(", "));
      }
      return ar(e), new Fe(rt, o, a === "payable");
    }
    if (e.type === "receive")
      return new Fe(rt, [], !0);
    if (e.type === "fallback") {
      const n = [At.from("bytes")], s = e.stateMutability === "payable";
      return new Fe(rt, n, s);
    }
    y(!1, "invalid fallback description", "obj", e);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(e) {
    return e && e[_t] === Kc;
  }
}
class Ie extends lo {
  /**
   *  @private
   */
  constructor(e, n, s, i, o, a) {
    super(e, "function", n, i);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    A(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    A(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    A(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    A(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    A(this, "gas");
    Object.defineProperty(this, _t, { value: Wc }), o = Object.freeze(o.slice()), M(this, { constant: s === "view" || s === "pure", gas: a, outputs: o, payable: s === "payable", stateMutability: s });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return or(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json")
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((s) => JSON.parse(s.format(e))),
        outputs: this.outputs.map((s) => JSON.parse(s.format(e)))
      });
    const n = [];
    return e !== "sighash" && n.push("function"), n.push(this.name + Vs(e, this.inputs)), e !== "sighash" && (this.stateMutability !== "nonpayable" && n.push(this.stateMutability), this.outputs && this.outputs.length && (n.push("returns"), n.push(Vs(e, this.outputs))), this.gas != null && n.push(`@${this.gas.toString()}`)), n.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(e, n) {
    return n = (n || []).map((i) => At.from(i)), new Ie(rt, e, "view", n, [], null).selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(e) {
    if (Ie.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return Ie.from(Bn(e));
      } catch {
        y(!1, "invalid function fragment", "obj", e);
      }
    else if (e instanceof me) {
      const s = uo("function", e), i = tn(e), o = Rl(e);
      let a = [];
      en(e, Ut(["returns"])).has("returns") && (a = tn(e));
      const c = kl(e);
      return ar(e), new Ie(rt, s, o, i, a, c);
    }
    let n = e.stateMutability;
    return n == null && (n = "payable", typeof e.constant == "boolean" ? (n = "view", e.constant || (n = "payable", typeof e.payable == "boolean" && !e.payable && (n = "nonpayable"))) : typeof e.payable == "boolean" && !e.payable && (n = "nonpayable")), new Ie(rt, e.name, n, e.inputs ? e.inputs.map(At.from) : [], e.outputs ? e.outputs.map(At.from) : [], e.gas != null ? e.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(e) {
    return e && e[_t] === Wc;
  }
}
class sr extends lo {
  /**
   *  @private
   */
  constructor(t, e, n) {
    super(t, "struct", e, n), Object.defineProperty(this, _t, { value: Yc });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(t) {
    if (typeof t == "string")
      try {
        return sr.from(Bn(t));
      } catch {
        y(!1, "invalid struct fragment", "obj", t);
      }
    else if (t instanceof me) {
      const e = uo("struct", t), n = tn(t);
      return ar(t), new sr(rt, e, n);
    }
    return new sr(rt, t.name, t.inputs ? t.inputs.map(At.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(t) {
    return t && t[_t] === Yc;
  }
}
const we = /* @__PURE__ */ new Map();
we.set(0, "GENERIC_PANIC");
we.set(1, "ASSERT_FALSE");
we.set(17, "OVERFLOW");
we.set(18, "DIVIDE_BY_ZERO");
we.set(33, "ENUM_RANGE_ERROR");
we.set(34, "BAD_STORAGE_DATA");
we.set(49, "STACK_UNDERFLOW");
we.set(50, "ARRAY_RANGE_ERROR");
we.set(65, "OUT_OF_MEMORY");
we.set(81, "UNINITIALIZED_FUNCTION_CALL");
const Sp = new RegExp(/^bytes([0-9]*)$/), Up = new RegExp(/^(u?int)([0-9]*)$/);
let Uo = null;
function Dp(r, t, e, n) {
  let s = "missing revert data", i = null;
  const o = null;
  let a = null;
  if (e) {
    s = "execution reverted";
    const u = X(e);
    if (e = F(e), u.length === 0)
      s += " (no data present; likely require(false) occurred", i = "require(false)";
    else if (u.length % 32 !== 4)
      s += " (could not decode reason; invalid data length)";
    else if (F(u.slice(0, 4)) === "0x08c379a0")
      try {
        i = n.decode(["string"], u.slice(4))[0], a = {
          signature: "Error(string)",
          name: "Error",
          args: [i]
        }, s += `: ${JSON.stringify(i)}`;
      } catch {
        s += " (could not decode reason; invalid string data)";
      }
    else if (F(u.slice(0, 4)) === "0x4e487b71")
      try {
        const f = Number(n.decode(["uint256"], u.slice(4))[0]);
        a = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [f]
        }, i = `Panic due to ${we.get(f) || "UNKNOWN"}(${f})`, s += `: ${i}`;
      } catch {
        s += " (could not decode panic code)";
      }
    else
      s += " (unknown custom error)";
  }
  const c = {
    to: t.to ? W(t.to) : null,
    data: t.data || "0x"
  };
  return t.from && (c.from = W(t.from)), dt(s, "CALL_EXCEPTION", {
    action: r,
    data: e,
    reason: i,
    transaction: c,
    invocation: o,
    revert: a
  });
}
var pn, wr;
const Xi = class Xi {
  constructor() {
    b(this, pn);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(t) {
    const e = t.map((s) => I(this, pn, wr).call(this, At.from(s)));
    return new bi(e, "_").defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(t, e) {
    pu(e.length, t.length, "types/values length mismatch");
    const n = t.map((o) => I(this, pn, wr).call(this, At.from(o))), s = new bi(n, "_"), i = new _o();
    return s.encode(i, e), i.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(t, e, n) {
    const s = t.map((o) => I(this, pn, wr).call(this, At.from(o)));
    return new bi(s, "_").decode(new Vo(e, n));
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    return Uo == null && (Uo = new Xi()), Uo;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(t, e, n) {
    return Dp(t, e, n, Xi.defaultAbiCoder());
  }
};
pn = new WeakSet(), wr = function(t) {
  if (t.isArray())
    return new ld(I(this, pn, wr).call(this, t.arrayChildren), t.arrayLength, t.name);
  if (t.isTuple())
    return new bi(t.components.map((n) => I(this, pn, wr).call(this, n)), t.name);
  switch (t.baseType) {
    case "address":
      return new cd(t.name);
    case "bool":
      return new fd(t.name);
    case "string":
      return new bd(t.name);
    case "bytes":
      return new hd(t.name);
    case "":
      return new gd(t.name);
  }
  let e = t.type.match(Up);
  if (e) {
    let n = parseInt(e[2] || "256");
    return y(n !== 0 && n <= 256 && n % 8 === 0, "invalid " + e[1] + " bit length", "param", t), new Ad(n / 8, e[1] === "int", t.name);
  }
  if (e = t.type.match(Sp), e) {
    let n = parseInt(e[1]);
    return y(n !== 0 && n <= 32, "invalid bytes length", "param", t), new dd(n, t.name);
  }
  y(!1, "invalid type", "type", t.type);
};
let Js = Xi;
class Fp {
  /**
   *  @_ignore:
   */
  constructor(t, e, n) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    A(this, "fragment");
    /**
     *  The name of the Event.
     */
    A(this, "name");
    /**
     *  The full Event signature.
     */
    A(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    A(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    A(this, "args");
    const s = t.name, i = t.format();
    M(this, {
      fragment: t,
      name: s,
      signature: i,
      topic: e,
      args: n
    });
  }
}
class Lp {
  /**
   *  @_ignore:
   */
  constructor(t, e, n, s) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    A(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    A(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    A(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    A(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    A(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    A(this, "value");
    const i = t.name, o = t.format();
    M(this, {
      fragment: t,
      name: i,
      args: n,
      signature: o,
      selector: e,
      value: s
    });
  }
}
class Mp {
  /**
   *  @_ignore:
   */
  constructor(t, e, n) {
    /**
     *  The matching fragment.
     */
    A(this, "fragment");
    /**
     *  The name of the Error.
     */
    A(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    A(this, "args");
    /**
     *  The full Error signature.
     */
    A(this, "signature");
    /**
     *  The selector for the Error.
     */
    A(this, "selector");
    const s = t.name, i = t.format();
    M(this, {
      fragment: t,
      name: s,
      args: n,
      signature: i,
      selector: e
    });
  }
}
class Zc {
  /**
   *  @_ignore:
   */
  constructor(t) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    A(this, "hash");
    /**
     *  @_ignore:
     */
    A(this, "_isIndexed");
    M(this, { hash: t, _isIndexed: !0 });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(t) {
    return !!(t && t._isIndexed);
  }
}
const Xc = {
  0: "generic panic",
  1: "assert(false)",
  17: "arithmetic overflow",
  18: "division or modulo by zero",
  33: "enum overflow",
  34: "invalid encoded storage byte array accessed",
  49: "out-of-bounds array access; popping on an empty array",
  50: "out-of-bounds access of an array or bytesN",
  65: "out of memory",
  81: "uninitialized function"
}, qc = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (r) => `reverted with reason string ${JSON.stringify(r)}`
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (r) => {
      let t = "unknown panic code";
      return r >= 0 && r <= 255 && Xc[r.toString()] && (t = Xc[r.toString()]), `reverted with panic code 0x${r.toString(16)} (${t})`;
    }
  }
};
var ve, xe, Pe, xt, qr, Oi, $r, Ii;
const Pr = class Pr {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(t) {
    // Find a function definition by any means necessary (unless it is ambiguous)
    b(this, qr);
    // Find an event definition by any means necessary (unless it is ambiguous)
    b(this, $r);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    A(this, "fragments");
    /**
     *  The Contract constructor.
     */
    A(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    A(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    A(this, "receive");
    b(this, ve, void 0);
    b(this, xe, void 0);
    b(this, Pe, void 0);
    //    #structs: Map<string, StructFragment>;
    b(this, xt, void 0);
    let e = [];
    typeof t == "string" ? e = JSON.parse(t) : e = t, d(this, Pe, /* @__PURE__ */ new Map()), d(this, ve, /* @__PURE__ */ new Map()), d(this, xe, /* @__PURE__ */ new Map());
    const n = [];
    for (const o of e)
      try {
        n.push(cr.from(o));
      } catch (a) {
        console.log("EE", a);
      }
    M(this, {
      fragments: Object.freeze(n)
    });
    let s = null, i = !1;
    d(this, xt, this.getAbiCoder()), this.fragments.forEach((o, a) => {
      let c;
      switch (o.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          M(this, { deploy: o });
          return;
        case "fallback":
          o.inputs.length === 0 ? i = !0 : (y(!s || o.payable !== s.payable, "conflicting fallback fragments", `fragments[${a}]`, o), s = o, i = s.payable);
          return;
        case "function":
          c = l(this, Pe);
          break;
        case "event":
          c = l(this, xe);
          break;
        case "error":
          c = l(this, ve);
          break;
        default:
          return;
      }
      const u = o.format();
      c.has(u) || c.set(u, o);
    }), this.deploy || M(this, {
      deploy: Xe.from("constructor()")
    }), M(this, { fallback: s, receive: i });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(t) {
    const e = t ? "minimal" : "full";
    return this.fragments.map((s) => s.format(e));
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const t = this.fragments.map((e) => e.format("json"));
    return JSON.stringify(t.map((e) => JSON.parse(e)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return Js.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(t) {
    const e = I(this, qr, Oi).call(this, t, null, !1);
    return y(e, "no matching function", "key", t), e.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(t) {
    return !!I(this, qr, Oi).call(this, t, null, !1);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(t, e) {
    return I(this, qr, Oi).call(this, t, e || null, !0);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(t) {
    const e = Array.from(l(this, Pe).keys());
    e.sort((n, s) => n.localeCompare(s));
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      t(l(this, Pe).get(s), n);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(t) {
    const e = I(this, $r, Ii).call(this, t, null, !1);
    return y(e, "no matching event", "key", t), e.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(t) {
    return !!I(this, $r, Ii).call(this, t, null, !1);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(t, e) {
    return I(this, $r, Ii).call(this, t, e || null, !0);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(t) {
    const e = Array.from(l(this, xe).keys());
    e.sort((n, s) => n.localeCompare(s));
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      t(l(this, xe).get(s), n);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(t, e) {
    if (it(t)) {
      const s = t.toLowerCase();
      if (qc[s])
        return Qt.from(qc[s].signature);
      for (const i of l(this, ve).values())
        if (s === i.selector)
          return i;
      return null;
    }
    if (t.indexOf("(") === -1) {
      const s = [];
      for (const [i, o] of l(this, ve))
        i.split(
          "("
          /* fix:) */
        )[0] === t && s.push(o);
      if (s.length === 0)
        return t === "Error" ? Qt.from("error Error(string)") : t === "Panic" ? Qt.from("error Panic(uint256)") : null;
      if (s.length > 1) {
        const i = s.map((o) => JSON.stringify(o.format())).join(", ");
        y(!1, `ambiguous error description (i.e. ${i})`, "name", t);
      }
      return s[0];
    }
    if (t = Qt.from(t).format(), t === "Error(string)")
      return Qt.from("error Error(string)");
    if (t === "Panic(uint256)")
      return Qt.from("error Panic(uint256)");
    const n = l(this, ve).get(t);
    return n || null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(t) {
    const e = Array.from(l(this, ve).keys());
    e.sort((n, s) => n.localeCompare(s));
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      t(l(this, ve).get(s), n);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(t, e) {
    return l(this, xt).decode(t, e);
  }
  _encodeParams(t, e) {
    return l(this, xt).encode(t, e);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(t) {
    return this._encodeParams(this.deploy.inputs, t || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(t, e) {
    if (typeof t == "string") {
      const n = this.getError(t);
      y(n, "unknown error", "fragment", t), t = n;
    }
    return y(at(e, 0, 4) === t.selector, `data signature does not match error ${t.name}.`, "data", e), this._decodeParams(t.inputs, at(e, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(t, e) {
    if (typeof t == "string") {
      const n = this.getError(t);
      y(n, "unknown error", "fragment", t), t = n;
    }
    return pt([
      t.selector,
      this._encodeParams(t.inputs, e || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(t, e) {
    if (typeof t == "string") {
      const n = this.getFunction(t);
      y(n, "unknown function", "fragment", t), t = n;
    }
    return y(at(e, 0, 4) === t.selector, `data signature does not match function ${t.name}.`, "data", e), this._decodeParams(t.inputs, at(e, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(t, e) {
    if (typeof t == "string") {
      const n = this.getFunction(t);
      y(n, "unknown function", "fragment", t), t = n;
    }
    return pt([
      t.selector,
      this._encodeParams(t.inputs, e || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(t, e) {
    if (typeof t == "string") {
      const i = this.getFunction(t);
      y(i, "unknown function", "fragment", t), t = i;
    }
    let n = "invalid length for result data";
    const s = Ht(e);
    if (s.length % 32 === 0)
      try {
        return l(this, xt).decode(t.outputs, s);
      } catch {
        n = "could not decode result data";
      }
    P(!1, n, "BAD_DATA", {
      value: F(s),
      info: { method: t.name, signature: t.format() }
    });
  }
  makeError(t, e) {
    const n = X(t, "data"), s = Js.getBuiltinCallException("call", e, n), i = "execution reverted (unknown custom error)";
    if (s.message.startsWith(i)) {
      const a = F(n.slice(0, 4)), c = this.getError(a);
      if (c)
        try {
          const u = l(this, xt).decode(c.inputs, n.slice(4));
          s.revert = {
            name: c.name,
            signature: c.format(),
            args: u
          }, s.reason = s.revert.signature, s.message = `execution reverted: ${s.reason}`;
        } catch {
          s.message = "execution reverted (coult not decode custom error)";
        }
    }
    const o = this.parseTransaction(e);
    return o && (s.invocation = {
      method: o.name,
      signature: o.signature,
      args: o.args
    }), s;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(t, e) {
    if (typeof t == "string") {
      const n = this.getFunction(t);
      y(n, "unknown function", "fragment", t), t = n;
    }
    return F(l(this, xt).encode(t.outputs, e || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(t, e) {
    if (typeof t == "string") {
      const i = this.getEvent(t);
      y(i, "unknown event", "eventFragment", t), t = i;
    }
    P(e.length <= t.inputs.length, `too many arguments for ${t.format()}`, "UNEXPECTED_ARGUMENT", { count: e.length, expectedCount: t.inputs.length });
    const n = [];
    t.anonymous || n.push(t.topicHash);
    const s = (i, o) => i.type === "string" ? or(o) : i.type === "bytes" ? st(F(o)) : (i.type === "bool" && typeof o == "boolean" ? o = o ? "0x01" : "0x00" : i.type.match(/^u?int/) ? o = On(o) : i.type.match(/^bytes/) ? o = Of(o, 32) : i.type === "address" && l(this, xt).encode(["address"], [o]), ir(F(o), 32));
    for (e.forEach((i, o) => {
      const a = t.inputs[o];
      if (!a.indexed) {
        y(i == null, "cannot filter non-indexed parameters; must be null", "contract." + a.name, i);
        return;
      }
      i == null ? n.push(null) : a.baseType === "array" || a.baseType === "tuple" ? y(!1, "filtering with tuples or arrays not supported", "contract." + a.name, i) : Array.isArray(i) ? n.push(i.map((c) => s(a, c))) : n.push(s(a, i));
    }); n.length && n[n.length - 1] === null; )
      n.pop();
    return n;
  }
  encodeEventLog(t, e) {
    if (typeof t == "string") {
      const o = this.getEvent(t);
      y(o, "unknown event", "eventFragment", t), t = o;
    }
    const n = [], s = [], i = [];
    return t.anonymous || n.push(t.topicHash), y(e.length === t.inputs.length, "event arguments/values mismatch", "values", e), t.inputs.forEach((o, a) => {
      const c = e[a];
      if (o.indexed)
        if (o.type === "string")
          n.push(or(c));
        else if (o.type === "bytes")
          n.push(st(c));
        else {
          if (o.baseType === "tuple" || o.baseType === "array")
            throw new Error("not implemented");
          n.push(l(this, xt).encode([o.type], [c]));
        }
      else
        s.push(o), i.push(c);
    }), {
      data: l(this, xt).encode(s, i),
      topics: n
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(t, e, n) {
    if (typeof t == "string") {
      const w = this.getEvent(t);
      y(w, "unknown event", "eventFragment", t), t = w;
    }
    if (n != null && !t.anonymous) {
      const w = t.topicHash;
      y(it(n[0], 32) && n[0].toLowerCase() === w, "fragment/topic mismatch", "topics[0]", n[0]), n = n.slice(1);
    }
    const s = [], i = [], o = [];
    t.inputs.forEach((w, E) => {
      w.indexed ? w.type === "string" || w.type === "bytes" || w.baseType === "tuple" || w.baseType === "array" ? (s.push(At.from({ type: "bytes32", name: w.name })), o.push(!0)) : (s.push(w), o.push(!1)) : (i.push(w), o.push(!1));
    });
    const a = n != null ? l(this, xt).decode(s, pt(n)) : null, c = l(this, xt).decode(i, e, !0), u = [], f = [];
    let h = 0, g = 0;
    return t.inputs.forEach((w, E) => {
      let m = null;
      if (w.indexed)
        if (a == null)
          m = new Zc(null);
        else if (o[E])
          m = new Zc(a[g++]);
        else
          try {
            m = a[g++];
          } catch (x) {
            m = x;
          }
      else
        try {
          m = c[h++];
        } catch (x) {
          m = x;
        }
      u.push(m), f.push(w.name || null);
    }), Ui.fromItems(u, f);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(t) {
    const e = X(t.data, "tx.data"), n = L(t.value != null ? t.value : 0, "tx.value"), s = this.getFunction(F(e.slice(0, 4)));
    if (!s)
      return null;
    const i = l(this, xt).decode(s.inputs, e.slice(4));
    return new Lp(s, s.selector, i, n);
  }
  parseCallResult(t) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(t) {
    const e = this.getEvent(t.topics[0]);
    return !e || e.anonymous ? null : new Fp(e, e.topicHash, this.decodeEventLog(e, t.data, t.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(t) {
    const e = F(t), n = this.getError(at(e, 0, 4));
    if (!n)
      return null;
    const s = l(this, xt).decode(n.inputs, at(e, 4));
    return new Mp(n, n.selector, s);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(t) {
    return t instanceof Pr ? t : typeof t == "string" ? new Pr(JSON.parse(t)) : typeof t.format == "function" ? new Pr(t.format("json")) : new Pr(t);
  }
};
ve = new WeakMap(), xe = new WeakMap(), Pe = new WeakMap(), xt = new WeakMap(), qr = new WeakSet(), Oi = function(t, e, n) {
  if (it(t)) {
    const i = t.toLowerCase();
    for (const o of l(this, Pe).values())
      if (i === o.selector)
        return o;
    return null;
  }
  if (t.indexOf("(") === -1) {
    const i = [];
    for (const [o, a] of l(this, Pe))
      o.split(
        "("
        /* fix:) */
      )[0] === t && i.push(a);
    if (e) {
      const o = e.length > 0 ? e[e.length - 1] : null;
      let a = e.length, c = !0;
      Tt.isTyped(o) && o.type === "overrides" && (c = !1, a--);
      for (let u = i.length - 1; u >= 0; u--) {
        const f = i[u].inputs.length;
        f !== a && (!c || f !== a - 1) && i.splice(u, 1);
      }
      for (let u = i.length - 1; u >= 0; u--) {
        const f = i[u].inputs;
        for (let h = 0; h < e.length; h++)
          if (Tt.isTyped(e[h])) {
            if (h >= f.length) {
              if (e[h].type === "overrides")
                continue;
              i.splice(u, 1);
              break;
            }
            if (e[h].type !== f[h].baseType) {
              i.splice(u, 1);
              break;
            }
          }
      }
    }
    if (i.length === 1 && e && e.length !== i[0].inputs.length) {
      const o = e[e.length - 1];
      (o == null || Array.isArray(o) || typeof o != "object") && i.splice(0, 1);
    }
    if (i.length === 0)
      return null;
    if (i.length > 1 && n) {
      const o = i.map((a) => JSON.stringify(a.format())).join(", ");
      y(!1, `ambiguous function description (i.e. matches ${o})`, "key", t);
    }
    return i[0];
  }
  const s = l(this, Pe).get(Ie.from(t).format());
  return s || null;
}, $r = new WeakSet(), Ii = function(t, e, n) {
  if (it(t)) {
    const i = t.toLowerCase();
    for (const o of l(this, xe).values())
      if (i === o.topicHash)
        return o;
    return null;
  }
  if (t.indexOf("(") === -1) {
    const i = [];
    for (const [o, a] of l(this, xe))
      o.split(
        "("
        /* fix:) */
      )[0] === t && i.push(a);
    if (e) {
      for (let o = i.length - 1; o >= 0; o--)
        i[o].inputs.length < e.length && i.splice(o, 1);
      for (let o = i.length - 1; o >= 0; o--) {
        const a = i[o].inputs;
        for (let c = 0; c < e.length; c++)
          if (Tt.isTyped(e[c]) && e[c].type !== a[c].baseType) {
            i.splice(o, 1);
            break;
          }
      }
    }
    if (i.length === 0)
      return null;
    if (i.length > 1 && n) {
      const o = i.map((a) => JSON.stringify(a.format())).join(", ");
      y(!1, `ambiguous event description (i.e. matches ${o})`, "key", t);
    }
    return i[0];
  }
  const s = l(this, xe).get(Oe.from(t).format());
  return s || null;
};
let na = Pr;
const Sl = BigInt(0);
function Ss(r) {
  return r ?? null;
}
function Ct(r) {
  return r == null ? null : r.toString();
}
class $c {
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(t, e, n) {
    /**
     *  The gas price for legacy networks.
     */
    A(this, "gasPrice");
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    A(this, "maxFeePerGas");
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    A(this, "maxPriorityFeePerGas");
    M(this, {
      gasPrice: Ss(t),
      maxFeePerGas: Ss(e),
      maxPriorityFeePerGas: Ss(n)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice: t, maxFeePerGas: e, maxPriorityFeePerGas: n } = this;
    return {
      _type: "FeeData",
      gasPrice: Ct(t),
      maxFeePerGas: Ct(e),
      maxPriorityFeePerGas: Ct(n)
    };
  }
}
function _i(r) {
  const t = {};
  r.to && (t.to = r.to), r.from && (t.from = r.from), r.data && (t.data = F(r.data));
  const e = "chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const s of e)
    !(s in r) || r[s] == null || (t[s] = L(r[s], `request.${s}`));
  const n = "type,nonce".split(/,/);
  for (const s of n)
    !(s in r) || r[s] == null || (t[s] = V(r[s], `request.${s}`));
  return r.accessList && (t.accessList = lr(r.accessList)), "blockTag" in r && (t.blockTag = r.blockTag), "enableCcipRead" in r && (t.enableCcipRead = !!r.enableCcipRead), "customData" in r && (t.customData = r.customData), t;
}
var Je;
class Gp {
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(t, e) {
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    A(this, "provider");
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    A(this, "number");
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    A(this, "hash");
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    A(this, "timestamp");
    /**
     *  The block hash of the parent block.
     */
    A(this, "parentHash");
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    A(this, "nonce");
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    A(this, "difficulty");
    /**
     *  The total gas limit for this block.
     */
    A(this, "gasLimit");
    /**
     *  The total gas used in this block.
     */
    A(this, "gasUsed");
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    A(this, "miner");
    /**
     *  Any extra data the validator wished to include.
     */
    A(this, "extraData");
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    A(this, "baseFeePerGas");
    b(this, Je, void 0);
    d(this, Je, t.transactions.map((n) => typeof n != "string" ? new js(n, e) : n)), M(this, {
      provider: e,
      hash: Ss(t.hash),
      number: t.number,
      timestamp: t.timestamp,
      parentHash: t.parentHash,
      nonce: t.nonce,
      difficulty: t.difficulty,
      gasLimit: t.gasLimit,
      gasUsed: t.gasUsed,
      miner: t.miner,
      extraData: t.extraData,
      baseFeePerGas: Ss(t.baseFeePerGas)
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return l(this, Je).map((t) => typeof t == "string" ? t : t.hash);
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const t = l(this, Je).slice();
    return t.length === 0 ? [] : (P(typeof t[0] == "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    }), t);
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas: t, difficulty: e, extraData: n, gasLimit: s, gasUsed: i, hash: o, miner: a, nonce: c, number: u, parentHash: f, timestamp: h, transactions: g } = this;
    return {
      _type: "Block",
      baseFeePerGas: Ct(t),
      difficulty: Ct(e),
      extraData: n,
      gasLimit: Ct(s),
      gasUsed: Ct(i),
      hash: o,
      miner: a,
      nonce: c,
      number: u,
      parentHash: f,
      timestamp: h,
      transactions: g
    };
  }
  [Symbol.iterator]() {
    let t = 0;
    const e = this.transactions;
    return {
      next: () => t < this.length ? {
        value: e[t++],
        done: !1
      } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return l(this, Je).length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    return this.timestamp == null ? null : new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(t) {
    let e;
    if (typeof t == "number")
      e = l(this, Je)[t];
    else {
      const n = t.toLowerCase();
      for (const s of l(this, Je))
        if (typeof s == "string") {
          if (s !== n)
            continue;
          e = s;
          break;
        } else {
          if (s.hash === n)
            continue;
          e = s;
          break;
        }
    }
    if (e == null)
      throw new Error("no such tx");
    return typeof e == "string" ? await this.provider.getTransaction(e) : e;
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(t) {
    const e = this.prefetchedTransactions;
    if (typeof t == "number")
      return e[t];
    t = t.toLowerCase();
    for (const n of e)
      if (n.hash === t)
        return n;
    y(!1, "no matching transaction", "indexOrHash", t);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined())
      throw new Error("");
    return Qp(this);
  }
}
Je = new WeakMap();
class li {
  /**
   *  @_ignore:
   */
  constructor(t, e) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    A(this, "provider");
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    A(this, "transactionHash");
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    A(this, "blockHash");
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    A(this, "blockNumber");
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    A(this, "removed");
    /**
     *  The address of the contract that emitted this log.
     */
    A(this, "address");
    /**
     *  The data included in this log when it was emitted.
     */
    A(this, "data");
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    A(this, "topics");
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    A(this, "index");
    /**
     *  The index within the transaction of this log.
     */
    A(this, "transactionIndex");
    this.provider = e;
    const n = Object.freeze(t.topics.slice());
    M(this, {
      transactionHash: t.transactionHash,
      blockHash: t.blockHash,
      blockNumber: t.blockNumber,
      removed: t.removed,
      address: t.address,
      data: t.data,
      topics: n,
      index: t.index,
      transactionIndex: t.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address: t, blockHash: e, blockNumber: n, data: s, index: i, removed: o, topics: a, transactionHash: c, transactionIndex: u } = this;
    return {
      _type: "log",
      address: t,
      blockHash: e,
      blockNumber: n,
      data: s,
      index: i,
      removed: o,
      topics: a,
      transactionHash: c,
      transactionIndex: u
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const t = await this.provider.getBlock(this.blockHash);
    return P(!!t, "failed to find transaction", "UNKNOWN_ERROR", {}), t;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const t = await this.provider.getTransaction(this.transactionHash);
    return P(!!t, "failed to find transaction", "UNKNOWN_ERROR", {}), t;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const t = await this.provider.getTransactionReceipt(this.transactionHash);
    return P(!!t, "failed to find transaction receipt", "UNKNOWN_ERROR", {}), t;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return Hp(this);
  }
}
var Xs;
class Ul {
  /**
   *  @_ignore:
   */
  constructor(t, e) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    A(this, "provider");
    /**
     *  The address the transaction was send to.
     */
    A(this, "to");
    /**
     *  The sender of the transaction.
     */
    A(this, "from");
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    A(this, "contractAddress");
    /**
     *  The transaction hash.
     */
    A(this, "hash");
    /**
     *  The index of this transaction within the block transactions.
     */
    A(this, "index");
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    A(this, "blockHash");
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    A(this, "blockNumber");
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    A(this, "logsBloom");
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    A(this, "gasUsed");
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    A(this, "cumulativeGasUsed");
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    A(this, "gasPrice");
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    A(this, "type");
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    A(this, "status");
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    A(this, "root");
    b(this, Xs, void 0);
    d(this, Xs, Object.freeze(t.logs.map((s) => new li(s, e))));
    let n = Sl;
    t.effectiveGasPrice != null ? n = t.effectiveGasPrice : t.gasPrice != null && (n = t.gasPrice), M(this, {
      provider: e,
      to: t.to,
      from: t.from,
      contractAddress: t.contractAddress,
      hash: t.hash,
      index: t.index,
      blockHash: t.blockHash,
      blockNumber: t.blockNumber,
      logsBloom: t.logsBloom,
      gasUsed: t.gasUsed,
      cumulativeGasUsed: t.cumulativeGasUsed,
      gasPrice: n,
      type: t.type,
      //byzantium: tx.byzantium,
      status: t.status,
      root: t.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return l(this, Xs);
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to: t,
      from: e,
      contractAddress: n,
      hash: s,
      index: i,
      blockHash: o,
      blockNumber: a,
      logsBloom: c,
      logs: u,
      //byzantium, 
      status: f,
      root: h
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash: o,
      blockNumber: a,
      //byzantium, 
      contractAddress: n,
      cumulativeGasUsed: Ct(this.cumulativeGasUsed),
      from: e,
      gasPrice: Ct(this.gasPrice),
      gasUsed: Ct(this.gasUsed),
      hash: s,
      index: i,
      logs: u,
      logsBloom: c,
      root: h,
      status: f,
      to: t
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let t = 0;
    return {
      next: () => t < this.length ? { value: this.logs[t++], done: !1 } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const t = await this.provider.getBlock(this.blockHash);
    if (t == null)
      throw new Error("TODO");
    return t;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const t = await this.provider.getTransaction(this.hash);
    if (t == null)
      throw new Error("TODO");
    return t;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return Fl(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(t) {
    return P(!t || t.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" }), Dl(this, t);
  }
}
Xs = new WeakMap();
var gn;
const Qa = class Qa {
  /**
   *  @_ignore:
   */
  constructor(t, e) {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    A(this, "provider");
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    A(this, "blockNumber");
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    A(this, "blockHash");
    /**
     *  The index within the block that this transaction resides at.
     */
    A(this, "index");
    /**
     *  The transaction hash.
     */
    A(this, "hash");
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    A(this, "type");
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    A(this, "to");
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    A(this, "from");
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    A(this, "nonce");
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    A(this, "gasLimit");
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    A(this, "gasPrice");
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    A(this, "maxPriorityFeePerGas");
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    A(this, "maxFeePerGas");
    /**
     *  The data.
     */
    A(this, "data");
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    A(this, "value");
    /**
     *  The chain ID.
     */
    A(this, "chainId");
    /**
     *  The signature.
     */
    A(this, "signature");
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    A(this, "accessList");
    b(this, gn, void 0);
    this.provider = e, this.blockNumber = t.blockNumber != null ? t.blockNumber : null, this.blockHash = t.blockHash != null ? t.blockHash : null, this.hash = t.hash, this.index = t.index, this.type = t.type, this.from = t.from, this.to = t.to || null, this.gasLimit = t.gasLimit, this.nonce = t.nonce, this.data = t.data, this.value = t.value, this.gasPrice = t.gasPrice, this.maxPriorityFeePerGas = t.maxPriorityFeePerGas != null ? t.maxPriorityFeePerGas : null, this.maxFeePerGas = t.maxFeePerGas != null ? t.maxFeePerGas : null, this.chainId = t.chainId, this.signature = t.signature, this.accessList = t.accessList != null ? t.accessList : null, d(this, gn, -1);
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber: t, blockHash: e, index: n, hash: s, type: i, to: o, from: a, nonce: c, data: u, signature: f, accessList: h } = this;
    return {
      _type: "TransactionReceipt",
      accessList: h,
      blockNumber: t,
      blockHash: e,
      chainId: Ct(this.chainId),
      data: u,
      from: a,
      gasLimit: Ct(this.gasLimit),
      gasPrice: Ct(this.gasPrice),
      hash: s,
      maxFeePerGas: Ct(this.maxFeePerGas),
      maxPriorityFeePerGas: Ct(this.maxPriorityFeePerGas),
      nonce: c,
      signature: f,
      to: o,
      index: n,
      type: i,
      value: Ct(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let t = this.blockNumber;
    if (t == null) {
      const n = await this.getTransaction();
      n && (t = n.blockNumber);
    }
    if (t == null)
      return null;
    const e = this.provider.getBlock(t);
    if (e == null)
      throw new Error("TODO");
    return e;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx: e, blockNumber: n } = await Bt({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      return e == null || e.blockNumber == null ? 0 : n - e.blockNumber + 1;
    }
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(t, e) {
    const n = t ?? 1, s = e ?? 0;
    let i = l(this, gn), o = -1, a = i === -1;
    const c = async () => {
      if (a)
        return null;
      const { blockNumber: g, nonce: w } = await Bt({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (w < this.nonce) {
        i = g;
        return;
      }
      if (a)
        return null;
      const E = await this.getTransaction();
      if (!(E && E.blockNumber != null))
        for (o === -1 && (o = i - 3, o < l(this, gn) && (o = l(this, gn))); o <= g; ) {
          if (a)
            return null;
          const m = await this.provider.getBlock(o, !0);
          if (m == null)
            return;
          for (const x of m)
            if (x === this.hash)
              return;
          for (let x = 0; x < m.length; x++) {
            const v = await m.getTransaction(x);
            if (v.from === this.from && v.nonce === this.nonce) {
              if (a)
                return null;
              const B = await this.provider.getTransactionReceipt(v.hash);
              if (B == null || g - B.blockNumber + 1 < n)
                return;
              let T = "replaced";
              v.data === this.data && v.to === this.to && v.value === this.value ? T = "repriced" : v.data === "0x" && v.from === v.to && v.value === Sl && (T = "cancelled"), P(!1, "transaction was replaced", "TRANSACTION_REPLACED", {
                cancelled: T === "replaced" || T === "cancelled",
                reason: T,
                replacement: v.replaceableTransaction(i),
                hash: v.hash,
                receipt: B
              });
            }
          }
          o++;
        }
    }, u = (g) => {
      if (g == null || g.status !== 0)
        return g;
      P(!1, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: g.to,
          from: g.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: g
      });
    }, f = await this.provider.getTransactionReceipt(this.hash);
    if (n === 0)
      return u(f);
    if (f) {
      if (await f.confirmations() >= n)
        return u(f);
    } else if (await c(), n === 0)
      return null;
    return await new Promise((g, w) => {
      const E = [], m = () => {
        E.forEach((v) => v());
      };
      if (E.push(() => {
        a = !0;
      }), s > 0) {
        const v = setTimeout(() => {
          m(), w(dt("wait for transaction timeout", "TIMEOUT"));
        }, s);
        E.push(() => {
          clearTimeout(v);
        });
      }
      const x = async (v) => {
        if (await v.confirmations() >= n) {
          m();
          try {
            g(u(v));
          } catch (B) {
            w(B);
          }
        }
      };
      if (E.push(() => {
        this.provider.off(this.hash, x);
      }), this.provider.on(this.hash, x), i >= 0) {
        const v = async () => {
          try {
            await c();
          } catch (B) {
            if (se(B, "TRANSACTION_REPLACED")) {
              m(), w(B);
              return;
            }
          }
          a || this.provider.once("block", v);
        };
        E.push(() => {
          this.provider.off("block", v);
        }), this.provider.once("block", v);
      }
    });
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    return P(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), Fl(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(t) {
    return P(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), P(!t || t.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), Dl(this, t);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(t) {
    y(Number.isInteger(t) && t >= 0, "invalid startBlock", "startBlock", t);
    const e = new Qa(this, this.provider);
    return d(e, gn, t), e;
  }
};
gn = new WeakMap();
let js = Qa;
function Qp(r) {
  return { orphan: "drop-block", hash: r.hash, number: r.number };
}
function Dl(r, t) {
  return { orphan: "reorder-transaction", tx: r, other: t };
}
function Fl(r) {
  return { orphan: "drop-transaction", tx: r };
}
function Hp(r) {
  return { orphan: "drop-log", log: {
    transactionHash: r.transactionHash,
    blockHash: r.blockHash,
    blockNumber: r.blockNumber,
    address: r.address,
    data: r.data,
    topics: Object.freeze(r.topics.slice()),
    index: r.index
  } };
}
class Sa extends li {
  /**
   * @_ignore:
   */
  constructor(e, n, s) {
    super(e, e.provider);
    /**
     *  The Contract Interface.
     */
    A(this, "interface");
    /**
     *  The matching event.
     */
    A(this, "fragment");
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    A(this, "args");
    const i = n.decodeEventLog(s, e.data, e.topics);
    M(this, { args: i, fragment: s, interface: n });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
class Ll extends li {
  /**
   * @_ignore:
   */
  constructor(e, n) {
    super(e, e.provider);
    /**
     *  The error encounted when trying to decode the log.
     */
    A(this, "error");
    M(this, { error: n });
  }
}
var ts;
class _p extends Ul {
  /**
   *  @_ignore:
   */
  constructor(e, n, s) {
    super(s, n);
    b(this, ts, void 0);
    d(this, ts, e);
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((e) => {
      const n = e.topics.length ? l(this, ts).getEvent(e.topics[0]) : null;
      if (n)
        try {
          return new Sa(e, l(this, ts), n);
        } catch (s) {
          return new Ll(e, s);
        }
      return e;
    });
  }
}
ts = new WeakMap();
var qs;
class Ua extends js {
  /**
   *  @_ignore:
   */
  constructor(e, n, s) {
    super(s, n);
    b(this, qs, void 0);
    d(this, qs, e);
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(e) {
    const n = await super.wait(e);
    return n == null ? null : new _p(l(this, qs), this.provider, n);
  }
}
qs = new WeakMap();
class Ml extends wu {
  /**
   *  @_event:
   */
  constructor(e, n, s, i) {
    super(e, n, s);
    /**
     *  The log with no matching events.
     */
    A(this, "log");
    M(this, { log: i });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class Vp extends Ml {
  /**
   *  @_ignore:
   */
  constructor(t, e, n, s, i) {
    super(t, e, n, new Sa(i, t.interface, s));
    const o = t.interface.decodeEventLog(s, this.log.data, this.log.topics);
    M(this, { args: o, fragment: s });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
const tu = BigInt(0);
function Gl(r) {
  return r && typeof r.call == "function";
}
function Ql(r) {
  return r && typeof r.estimateGas == "function";
}
function fo(r) {
  return r && typeof r.resolveName == "function";
}
function Hl(r) {
  return r && typeof r.sendTransaction == "function";
}
function _l(r) {
  if (r != null) {
    if (fo(r))
      return r;
    if (r.provider)
      return r.provider;
  }
}
var $s;
class Jp {
  constructor(t, e, n) {
    b(this, $s, void 0);
    A(this, "fragment");
    if (M(this, { fragment: e }), e.inputs.length < n.length)
      throw new Error("too many arguments");
    const s = ur(t.runner, "resolveName"), i = fo(s) ? s : null;
    d(this, $s, async function() {
      const o = await Promise.all(e.inputs.map((a, c) => n[c] == null ? null : a.walkAsync(n[c], (f, h) => f === "address" ? Array.isArray(h) ? Promise.all(h.map((g) => St(g, i))) : St(h, i) : h)));
      return t.interface.encodeFilterTopics(e, o);
    }());
  }
  getTopicFilter() {
    return l(this, $s);
  }
}
$s = new WeakMap();
function ur(r, t) {
  return r == null ? null : typeof r[t] == "function" ? r : r.provider && typeof r.provider[t] == "function" ? r.provider : null;
}
function Ln(r) {
  return r == null ? null : r.provider || null;
}
async function Vl(r, t) {
  const e = Tt.dereference(r, "overrides");
  y(typeof e == "object", "invalid overrides parameter", "overrides", r);
  const n = _i(e);
  return y(n.to == null || (t || []).indexOf("to") >= 0, "cannot override to", "overrides.to", n.to), y(n.data == null || (t || []).indexOf("data") >= 0, "cannot override data", "overrides.data", n.data), n.from && (n.from = n.from), n;
}
async function jp(r, t, e) {
  const n = ur(r, "resolveName"), s = fo(n) ? n : null;
  return await Promise.all(t.map((i, o) => i.walkAsync(e[o], (a, c) => (c = Tt.dereference(c, a), a === "address" ? St(c, s) : c))));
}
function zp(r) {
  const t = async function(o) {
    const a = await Vl(o, ["data"]);
    a.to = await r.getAddress(), a.from && (a.from = await St(a.from, _l(r.runner)));
    const c = r.interface, u = L(a.value || tu, "overrides.value") === tu, f = (a.data || "0x") === "0x";
    c.fallback && !c.fallback.payable && c.receive && !f && !u && y(!1, "cannot send data to receive or send value to non-payable fallback", "overrides", o), y(c.fallback || f, "cannot send data to receive-only contract", "overrides.data", a.data);
    const h = c.receive || c.fallback && c.fallback.payable;
    return y(h || u, "cannot send value to non-payable fallback", "overrides.value", a.value), y(c.fallback || f, "cannot send data to receive-only contract", "overrides.data", a.data), a;
  }, e = async function(o) {
    const a = ur(r.runner, "call");
    P(Gl(a), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const c = await t(o);
    try {
      return await a.call(c);
    } catch (u) {
      throw ma(u) && u.data ? r.interface.makeError(u.data, c) : u;
    }
  }, n = async function(o) {
    const a = r.runner;
    P(Hl(a), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const c = await a.sendTransaction(await t(o)), u = Ln(r.runner);
    return new Ua(r.interface, u, c);
  }, s = async function(o) {
    const a = ur(r.runner, "estimateGas");
    return P(Ql(a), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await a.estimateGas(await t(o));
  }, i = async (o) => await n(o);
  return M(i, {
    _contract: r,
    estimateGas: s,
    populateTransaction: t,
    send: n,
    staticCall: e
  }), i;
}
function Kp(r, t) {
  const e = function(...u) {
    const f = r.interface.getFunction(t, u);
    return P(f, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: t, args: u }
    }), f;
  }, n = async function(...u) {
    const f = e(...u);
    let h = {};
    if (f.inputs.length + 1 === u.length && (h = await Vl(u.pop()), h.from && (h.from = await St(h.from, _l(r.runner)))), f.inputs.length !== u.length)
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    const g = await jp(r.runner, f.inputs, u);
    return Object.assign({}, h, await Bt({
      to: r.getAddress(),
      data: r.interface.encodeFunctionData(f, g)
    }));
  }, s = async function(...u) {
    const f = await a(...u);
    return f.length === 1 ? f[0] : f;
  }, i = async function(...u) {
    const f = r.runner;
    P(Hl(f), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const h = await f.sendTransaction(await n(...u)), g = Ln(r.runner);
    return new Ua(r.interface, g, h);
  }, o = async function(...u) {
    const f = ur(r.runner, "estimateGas");
    return P(Ql(f), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await f.estimateGas(await n(...u));
  }, a = async function(...u) {
    const f = ur(r.runner, "call");
    P(Gl(f), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const h = await n(...u);
    let g = "0x";
    try {
      g = await f.call(h);
    } catch (E) {
      throw ma(E) && E.data ? r.interface.makeError(E.data, h) : E;
    }
    const w = e(...u);
    return r.interface.decodeFunctionResult(w, g);
  }, c = async (...u) => e(...u).constant ? await s(...u) : await i(...u);
  return M(c, {
    name: r.interface.getFunctionName(t),
    _contract: r,
    _key: t,
    getFragment: e,
    estimateGas: o,
    populateTransaction: n,
    send: i,
    staticCall: s,
    staticCallResult: a
  }), Object.defineProperty(c, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const u = r.interface.getFunction(t);
      return P(u, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: t }
      }), u;
    }
  }), c;
}
function Wp(r, t) {
  const e = function(...s) {
    const i = r.interface.getEvent(t, s);
    return P(i, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: t, args: s }
    }), i;
  }, n = function(...s) {
    return new Jp(r, e(...s), s);
  };
  return M(n, {
    name: r.interface.getEventName(t),
    _contract: r,
    _key: t,
    getFragment: e
  }), Object.defineProperty(n, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const s = r.interface.getEvent(t);
      return P(s, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: t }
      }), s;
    }
  }), n;
}
const Vi = Symbol.for("_ethersInternal_contract"), Jl = /* @__PURE__ */ new WeakMap();
function Yp(r, t) {
  Jl.set(r[Vi], t);
}
function Vt(r) {
  return Jl.get(r[Vi]);
}
function Zp(r) {
  return r && typeof r == "object" && "getTopicFilter" in r && typeof r.getTopicFilter == "function" && r.fragment;
}
async function Da(r, t) {
  let e, n = null;
  if (Array.isArray(t)) {
    const i = function(o) {
      if (it(o, 32))
        return o;
      const a = r.interface.getEvent(o);
      return y(a, "unknown fragment", "name", o), a.topicHash;
    };
    e = t.map((o) => o == null ? null : Array.isArray(o) ? o.map(i) : i(o));
  } else
    t === "*" ? e = [null] : typeof t == "string" ? it(t, 32) ? e = [t] : (n = r.interface.getEvent(t), y(n, "unknown fragment", "event", t), e = [n.topicHash]) : Zp(t) ? e = await t.getTopicFilter() : "fragment" in t ? (n = t.fragment, e = [n.topicHash]) : y(!1, "unknown event name", "event", t);
  e = e.map((i) => {
    if (i == null)
      return null;
    if (Array.isArray(i)) {
      const o = Array.from(new Set(i.map((a) => a.toLowerCase())).values());
      return o.length === 1 ? o[0] : (o.sort(), o);
    }
    return i.toLowerCase();
  });
  const s = e.map((i) => i == null ? "null" : Array.isArray(i) ? i.join("|") : i).join("&");
  return { fragment: n, tag: s, topics: e };
}
async function Is(r, t) {
  const { subs: e } = Vt(r);
  return e.get((await Da(r, t)).tag) || null;
}
async function eu(r, t, e) {
  const n = Ln(r.runner);
  P(n, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation: t });
  const { fragment: s, tag: i, topics: o } = await Da(r, e), { addr: a, subs: c } = Vt(r);
  let u = c.get(i);
  if (!u) {
    const h = { address: a || r, topics: o }, g = (x) => {
      let v = s;
      if (v == null)
        try {
          v = r.interface.getEvent(x.topics[0]);
        } catch {
        }
      if (v) {
        const B = v, T = s ? r.interface.decodeEventLog(s, x.data, x.topics) : [];
        sa(r, e, T, (H) => new Vp(r, H, e, B, x));
      } else
        sa(r, e, [], (B) => new Ml(r, B, e, x));
    };
    let w = [];
    u = { tag: i, listeners: [], start: () => {
      w.length || w.push(n.on(h, g));
    }, stop: async () => {
      if (w.length == 0)
        return;
      let x = w;
      w = [], await Promise.all(x), n.off(h, g);
    } }, c.set(i, u);
  }
  return u;
}
let ra = Promise.resolve();
async function Xp(r, t, e, n) {
  await ra;
  const s = await Is(r, t);
  if (!s)
    return !1;
  const i = s.listeners.length;
  return s.listeners = s.listeners.filter(({ listener: o, once: a }) => {
    const c = Array.from(e);
    n && c.push(n(a ? null : o));
    try {
      o.call(r, ...c);
    } catch {
    }
    return !a;
  }), s.listeners.length === 0 && (s.stop(), Vt(r).subs.delete(s.tag)), i > 0;
}
async function sa(r, t, e, n) {
  try {
    await ra;
  } catch {
  }
  const s = Xp(r, t, e, n);
  return ra = s, await s;
}
const Ei = ["then"];
var Yg;
const Ds = class Ds {
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(t, e, n, s) {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    A(this, "target");
    /**
     *  The contract Interface.
     */
    A(this, "interface");
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    A(this, "runner");
    /**
     *  All the Events available on this contract.
     */
    A(this, "filters");
    /**
     *  @_ignore:
     */
    A(this, Yg);
    /**
     *  The fallback or receive function if any.
     */
    A(this, "fallback");
    y(typeof t == "string" || zu(t), "invalid value for Contract target", "target", t), n == null && (n = null);
    const i = na.from(e);
    M(this, { target: t, runner: n, interface: i }), Object.defineProperty(this, Vi, { value: {} });
    let o, a = null, c = null;
    if (s) {
      const h = Ln(n);
      c = new Ua(this.interface, h, s);
    }
    let u = /* @__PURE__ */ new Map();
    if (typeof t == "string")
      if (it(t))
        a = t, o = Promise.resolve(t);
      else {
        const h = ur(n, "resolveName");
        if (!fo(h))
          throw dt("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        o = h.resolveName(t).then((g) => {
          if (g == null)
            throw dt("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: t
            });
          return Vt(this).addr = g, g;
        });
      }
    else
      o = t.getAddress().then((h) => {
        if (h == null)
          throw new Error("TODO");
        return Vt(this).addr = h, h;
      });
    Yp(this, { addrPromise: o, addr: a, deployTx: c, subs: u });
    const f = new Proxy({}, {
      get: (h, g, w) => {
        if (typeof g == "symbol" || Ei.indexOf(g) >= 0)
          return Reflect.get(h, g, w);
        try {
          return this.getEvent(g);
        } catch (E) {
          if (!se(E, "INVALID_ARGUMENT") || E.argument !== "key")
            throw E;
        }
      },
      has: (h, g) => Ei.indexOf(g) >= 0 ? Reflect.has(h, g) : Reflect.has(h, g) || this.interface.hasEvent(String(g))
    });
    return M(this, { filters: f }), M(this, {
      fallback: i.receive || i.fallback ? zp(this) : null
    }), new Proxy(this, {
      get: (h, g, w) => {
        if (typeof g == "symbol" || g in h || Ei.indexOf(g) >= 0)
          return Reflect.get(h, g, w);
        try {
          return h.getFunction(g);
        } catch (E) {
          if (!se(E, "INVALID_ARGUMENT") || E.argument !== "key")
            throw E;
        }
      },
      has: (h, g) => typeof g == "symbol" || g in h || Ei.indexOf(g) >= 0 ? Reflect.has(h, g) : h.interface.hasFunction(g)
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(t) {
    return new Ds(this.target, this.interface, t);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(t) {
    return new Ds(t, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await Vt(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const t = Ln(this.runner);
    P(t, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const e = await t.getCode(await this.getAddress());
    return e === "0x" ? null : e;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const t = this.deploymentTransaction();
    if (t)
      return await t.wait(), this;
    if (await this.getDeployedCode() != null)
      return this;
    const n = Ln(this.runner);
    return P(n != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" }), new Promise((s, i) => {
      const o = async () => {
        try {
          if (await this.getDeployedCode() != null)
            return s(this);
          n.once("block", o);
        } catch (a) {
          i(a);
        }
      };
      o();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return Vt(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(t) {
    return typeof t != "string" && (t = t.format()), Kp(this, t);
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(t) {
    return typeof t != "string" && (t = t.format()), Wp(this, t);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(t) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(t, e, n) {
    e == null && (e = 0), n == null && (n = "latest");
    const { addr: s, addrPromise: i } = Vt(this), o = s || await i, { fragment: a, topics: c } = await Da(this, t), u = { address: o, topics: c, fromBlock: e, toBlock: n }, f = Ln(this.runner);
    return P(f, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" }), (await f.getLogs(u)).map((h) => {
      let g = a;
      if (g == null)
        try {
          g = this.interface.getEvent(h.topics[0]);
        } catch {
        }
      if (g)
        try {
          return new Sa(h, this.interface, g);
        } catch (w) {
          return new Ll(h, w);
        }
      return new li(h, f);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(t, e) {
    const n = await eu(this, "on", t);
    return n.listeners.push({ listener: e, once: !1 }), n.start(), this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(t, e) {
    const n = await eu(this, "once", t);
    return n.listeners.push({ listener: e, once: !0 }), n.start(), this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(t, ...e) {
    return await sa(this, t, e, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(t) {
    if (t) {
      const s = await Is(this, t);
      return s ? s.listeners.length : 0;
    }
    const { subs: e } = Vt(this);
    let n = 0;
    for (const { listeners: s } of e.values())
      n += s.length;
    return n;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(t) {
    if (t) {
      const s = await Is(this, t);
      return s ? s.listeners.map(({ listener: i }) => i) : [];
    }
    const { subs: e } = Vt(this);
    let n = [];
    for (const { listeners: s } of e.values())
      n = n.concat(s.map(({ listener: i }) => i));
    return n;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(t, e) {
    const n = await Is(this, t);
    if (!n)
      return this;
    if (e) {
      const s = n.listeners.map(({ listener: i }) => i).indexOf(e);
      s >= 0 && n.listeners.splice(s, 1);
    }
    return (e == null || n.listeners.length === 0) && (n.stop(), Vt(this).subs.delete(n.tag)), this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(t) {
    if (t) {
      const e = await Is(this, t);
      if (!e)
        return this;
      e.stop(), Vt(this).subs.delete(e.tag);
    } else {
      const { subs: e } = Vt(this);
      for (const { tag: n, stop: s } of e.values())
        s(), e.delete(n);
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(t, e) {
    return await this.on(t, e);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(t, e) {
    return await this.off(t, e);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(t) {
    class e extends Ds {
      constructor(s, i = null) {
        super(s, t, i);
      }
    }
    return e;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(t, e, n) {
    return n == null && (n = null), new this(t, e, n);
  }
};
Yg = Vi;
let ia = Ds;
function qp() {
  return ia;
}
class Tn extends qp() {
}
function Do(r) {
  return r.match(/^ipfs:\/\/ipfs\//i) ? r = r.substring(12) : r.match(/^ipfs:\/\//i) ? r = r.substring(7) : y(!1, "unsupported IPFS format", "link", r), `https://gateway.ipfs.io/ipfs/${r}`;
}
class $p {
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(t) {
    /**
     *  The name.
     */
    A(this, "name");
    M(this, { name: t });
  }
  connect(t) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(t) {
    return !1;
  }
  /**
   *  Resovles to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(t, e) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resovles to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(t, e) {
    throw new Error("unsupported coin");
  }
}
const jl = new RegExp("^(ipfs)://(.*)$", "i"), nu = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  jl,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
var yn, Kn, mn, Ar, qi, zl;
const Nr = class Nr {
  constructor(t, e, n) {
    b(this, mn);
    /**
     *  The connected provider.
     */
    A(this, "provider");
    /**
     *  The address of the resolver.
     */
    A(this, "address");
    /**
     *  The name this resolver was resolved against.
     */
    A(this, "name");
    // For EIP-2544 names, the ancestor that provided the resolver
    b(this, yn, void 0);
    b(this, Kn, void 0);
    M(this, { provider: t, address: e, name: n }), d(this, yn, null), d(this, Kn, new Tn(e, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], t));
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    return l(this, yn) == null && d(this, yn, (async () => {
      try {
        return await l(this, Kn).supportsInterface("0x9061b923");
      } catch (t) {
        if (se(t, "CALL_EXCEPTION"))
          return !1;
        throw d(this, yn, null), t;
      }
    })()), await l(this, yn);
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(t) {
    if (t == null && (t = 60), t === 60)
      try {
        const i = await I(this, mn, Ar).call(this, "addr(bytes32)");
        return i == null || i === Wo ? null : i;
      } catch (i) {
        if (se(i, "CALL_EXCEPTION"))
          return null;
        throw i;
      }
    if (t >= 0 && t < 2147483648) {
      let i = t + 2147483648;
      const o = await I(this, mn, Ar).call(this, "addr(bytes32,uint)", [i]);
      if (it(o, 20))
        return W(o);
    }
    let e = null;
    for (const i of this.provider.plugins)
      if (i instanceof $p && i.supportsCoinType(t)) {
        e = i;
        break;
      }
    if (e == null)
      return null;
    const n = await I(this, mn, Ar).call(this, "addr(bytes32,uint)", [t]);
    if (n == null || n === "0x")
      return null;
    const s = await e.decodeAddress(t, n);
    if (s != null)
      return s;
    P(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${t})`,
      info: { coinType: t, data: n }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(t) {
    const e = await I(this, mn, Ar).call(this, "text(bytes32,string)", [t]);
    return e == null || e === "0x" ? null : e;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const t = await I(this, mn, Ar).call(this, "contenthash(bytes32)");
    if (t == null || t === "0x")
      return null;
    const e = t.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (e) {
      const s = e[1] === "e3010170" ? "ipfs" : "ipns", i = parseInt(e[4], 16);
      if (e[5].length === i * 2)
        return `${s}://${kf("0x" + e[2])}`;
    }
    const n = t.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (n && n[1].length === 64)
      return `bzz://${n[1]}`;
    P(!1, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data: t }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    return (await this._getAvatar()).url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const t = [{ type: "name", value: this.name }];
    try {
      const e = await this.getText("avatar");
      if (e == null)
        return t.push({ type: "!avatar", value: "" }), { url: null, linkage: t };
      t.push({ type: "avatar", value: e });
      for (let n = 0; n < nu.length; n++) {
        const s = e.match(nu[n]);
        if (s == null)
          continue;
        const i = s[1].toLowerCase();
        switch (i) {
          case "https":
          case "data":
            return t.push({ type: "url", value: e }), { linkage: t, url: e };
          case "ipfs": {
            const o = Do(e);
            return t.push({ type: "ipfs", value: e }), t.push({ type: "url", value: o }), { linkage: t, url: o };
          }
          case "erc721":
          case "erc1155": {
            const o = i === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            t.push({ type: i, value: e });
            const a = await this.getAddress();
            if (a == null)
              return t.push({ type: "!owner", value: "" }), { url: null, linkage: t };
            const c = (s[2] || "").split("/");
            if (c.length !== 2)
              return t.push({ type: `!${i}caip`, value: s[2] || "" }), { url: null, linkage: t };
            const u = c[1], f = new Tn(c[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (i === "erc721") {
              const m = await f.ownerOf(u);
              if (a !== m)
                return t.push({ type: "!owner", value: m }), { url: null, linkage: t };
              t.push({ type: "owner", value: m });
            } else if (i === "erc1155") {
              const m = await f.balanceOf(a, u);
              if (!m)
                return t.push({ type: "!balance", value: "0" }), { url: null, linkage: t };
              t.push({ type: "balance", value: m.toString() });
            }
            let h = await f[o](u);
            if (h == null || h === "0x")
              return t.push({ type: "!metadata-url", value: "" }), { url: null, linkage: t };
            t.push({ type: "metadata-url-base", value: h }), i === "erc1155" && (h = h.replace("{id}", On(u, 32).substring(2)), t.push({ type: "metadata-url-expanded", value: h })), h.match(/^ipfs:/i) && (h = Do(h)), t.push({ type: "metadata-url", value: h });
            let g = {};
            const w = await new In(h).send();
            w.assertOk();
            try {
              g = w.bodyJson;
            } catch {
              try {
                t.push({ type: "!metadata", value: w.bodyText });
              } catch {
                const v = w.body;
                return v && t.push({ type: "!metadata", value: F(v) }), { url: null, linkage: t };
              }
              return { url: null, linkage: t };
            }
            if (!g)
              return t.push({ type: "!metadata", value: "" }), { url: null, linkage: t };
            t.push({ type: "metadata", value: JSON.stringify(g) });
            let E = g.image;
            if (typeof E != "string")
              return t.push({ type: "!imageUrl", value: "" }), { url: null, linkage: t };
            if (!E.match(/^(https:\/\/|data:)/i)) {
              if (E.match(jl) == null)
                return t.push({ type: "!imageUrl-ipfs", value: E }), { url: null, linkage: t };
              t.push({ type: "imageUrl-ipfs", value: E }), E = Do(E);
            }
            return t.push({ type: "url", value: E }), { linkage: t, url: E };
          }
        }
      }
    } catch {
    }
    return { linkage: t, url: null };
  }
  static async getEnsAddress(t) {
    const e = await t.getNetwork(), n = e.getPlugin("org.ethers.plugins.network.Ens");
    return P(n, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network: e }
    }), n.address;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(t, e) {
    var s;
    let n = e;
    for (; ; ) {
      if (n === "" || n === "." || e !== "eth" && n === "eth")
        return null;
      const i = await I(s = Nr, qi, zl).call(s, t, n);
      if (i != null) {
        const o = new Nr(t, i, e);
        return n !== e && !await o.supportsWildcard() ? null : o;
      }
      n = n.split(".").slice(1).join(".");
    }
  }
};
yn = new WeakMap(), Kn = new WeakMap(), mn = new WeakSet(), Ar = async function(t, e) {
  e = (e || []).slice();
  const n = l(this, Kn).interface;
  e.unshift(ta(this.name));
  let s = null;
  await this.supportsWildcard() && (s = n.getFunction(t), P(s, "missing fragment", "UNKNOWN_ERROR", {
    info: { funcName: t }
  }), e = [
    sp(this.name),
    n.encodeFunctionData(s, e)
  ], t = "resolve(bytes,bytes)"), e.push({
    enableCcipRead: !0
  });
  try {
    const i = await l(this, Kn)[t](...e);
    return s ? n.decodeFunctionResult(s, i)[0] : i;
  } catch (i) {
    if (!se(i, "CALL_EXCEPTION"))
      throw i;
  }
  return null;
}, qi = new WeakSet(), zl = async function(t, e) {
  const n = await Nr.getEnsAddress(t);
  try {
    const i = await new Tn(n, [
      "function resolver(bytes32) view returns (address)"
    ], t).resolver(ta(e), {
      enableCcipRead: !0
    });
    return i === Wo ? null : i;
  } catch (s) {
    throw s;
  }
  return null;
}, b(Nr, qi);
let Ji = Nr;
const ru = BigInt(0);
function nt(r, t) {
  return function(e) {
    return e == null ? t : r(e);
  };
}
function Fa(r) {
  return (t) => {
    if (!Array.isArray(t))
      throw new Error("not an array");
    return t.map((e) => r(e));
  };
}
function fi(r, t) {
  return (e) => {
    const n = {};
    for (const s in r) {
      let i = s;
      if (t && s in t && !(i in e)) {
        for (const o of t[s])
          if (o in e) {
            i = o;
            break;
          }
      }
      try {
        const o = r[s](e[i]);
        o !== void 0 && (n[s] = o);
      } catch (o) {
        const a = o instanceof Error ? o.message : "not-an-error";
        P(!1, `invalid value for value.${s} (${a})`, "BAD_DATA", { value: e });
      }
    }
    return n;
  };
}
function tg(r) {
  switch (r) {
    case !0:
    case "true":
      return !0;
    case !1:
    case "false":
      return !1;
  }
  y(!1, `invalid boolean; ${JSON.stringify(r)}`, "value", r);
}
function bs(r) {
  return y(it(r, !0), "invalid data", "value", r), r;
}
function ie(r) {
  return y(it(r, 32), "invalid hash", "value", r), r;
}
const eg = fi({
  address: W,
  blockHash: ie,
  blockNumber: V,
  data: bs,
  index: V,
  removed: nt(tg, !1),
  topics: Fa(ie),
  transactionHash: ie,
  transactionIndex: V
}, {
  index: ["logIndex"]
});
function ng(r) {
  return eg(r);
}
const rg = fi({
  hash: nt(ie),
  parentHash: ie,
  number: V,
  timestamp: V,
  nonce: nt(bs),
  difficulty: L,
  gasLimit: L,
  gasUsed: L,
  miner: nt(W),
  extraData: bs,
  baseFeePerGas: nt(L)
});
function sg(r) {
  const t = rg(r);
  return t.transactions = r.transactions.map((e) => typeof e == "string" ? e : Kl(e)), t;
}
const ig = fi({
  transactionIndex: V,
  blockNumber: V,
  transactionHash: ie,
  address: W,
  topics: Fa(ie),
  data: bs,
  index: V,
  blockHash: ie
}, {
  index: ["logIndex"]
});
function og(r) {
  return ig(r);
}
const ag = fi({
  to: nt(W, null),
  from: nt(W, null),
  contractAddress: nt(W, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: V,
  root: nt(F),
  gasUsed: L,
  logsBloom: nt(bs),
  blockHash: ie,
  hash: ie,
  logs: Fa(og),
  blockNumber: V,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: L,
  effectiveGasPrice: nt(L),
  status: nt(V),
  type: nt(V, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function cg(r) {
  return ag(r);
}
function Kl(r) {
  r.to && L(r.to) === ru && (r.to = "0x0000000000000000000000000000000000000000");
  const t = fi({
    hash: ie,
    type: (e) => e === "0x" || e == null ? 0 : V(e),
    accessList: nt(lr, null),
    blockHash: nt(ie, null),
    blockNumber: nt(V, null),
    transactionIndex: nt(V, null),
    //confirmations: allowNull(getNumber, null),
    from: W,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: nt(L),
    maxPriorityFeePerGas: nt(L),
    maxFeePerGas: nt(L),
    gasLimit: L,
    to: nt(W, null),
    value: L,
    nonce: V,
    data: bs,
    creates: nt(W, null),
    chainId: nt(L, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"]
  })(r);
  if (t.to == null && t.creates == null && (t.creates = ad(t)), (r.type === 1 || r.type === 2) && r.accessList == null && (t.accessList = []), r.signature ? t.signature = ye.from(r.signature) : t.signature = ye.from(r), t.chainId == null) {
    const e = t.signature.legacyChainId;
    e != null && (t.chainId = e);
  }
  return t.blockHash && L(t.blockHash) === ru && (t.blockHash = null), t;
}
const ug = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class hi {
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(t) {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    A(this, "name");
    M(this, { name: t });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new hi(this.name);
  }
}
class ho extends hi {
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(e, n) {
    e == null && (e = 0);
    super(`org.ethers.network.plugins.GasCost#${e || 0}`);
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    A(this, "effectiveBlock");
    /**
     *  The transactions base fee.
     */
    A(this, "txBase");
    /**
     *  The fee for creating a new account.
     */
    A(this, "txCreate");
    /**
     *  The fee per zero-byte in the data.
     */
    A(this, "txDataZero");
    /**
     *  The fee per non-zero-byte in the data.
     */
    A(this, "txDataNonzero");
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    A(this, "txAccessListStorageKey");
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    A(this, "txAccessListAddress");
    const s = { effectiveBlock: e };
    function i(o, a) {
      let c = (n || {})[o];
      c == null && (c = a), y(typeof c == "number", `invalud value for ${o}`, "costs", n), s[o] = c;
    }
    i("txBase", 21e3), i("txCreate", 32e3), i("txDataZero", 4), i("txDataNonzero", 16), i("txAccessListStorageKey", 1900), i("txAccessListAddress", 2400), M(this, s);
  }
  clone() {
    return new ho(this.effectiveBlock, this);
  }
}
class po extends hi {
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(e, n) {
    super("org.ethers.plugins.network.Ens");
    /**
     *  The ENS Registrty Contract address.
     */
    A(this, "address");
    /**
     *  The chain ID that the ENS contract lives on.
     */
    A(this, "targetNetwork");
    M(this, {
      address: e || ug,
      targetNetwork: n ?? 1
    });
  }
  clone() {
    return new po(this.address, this.targetNetwork);
  }
}
var ti, ei;
class Wl extends hi {
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(e, n) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    b(this, ti, void 0);
    b(this, ei, void 0);
    d(this, ti, e), d(this, ei, n);
  }
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return l(this, ti);
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return l(this, ei);
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
}
ti = new WeakMap(), ei = new WeakMap();
const Fo = /* @__PURE__ */ new Map();
var es, ns, wn;
const Cr = class Cr {
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(t, e) {
    b(this, es, void 0);
    b(this, ns, void 0);
    b(this, wn, void 0);
    d(this, es, t), d(this, ns, L(e)), d(this, wn, /* @__PURE__ */ new Map());
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return l(this, es);
  }
  set name(t) {
    d(this, es, t);
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return l(this, ns);
  }
  set chainId(t) {
    d(this, ns, L(t, "chainId"));
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(t) {
    if (t == null)
      return !1;
    if (typeof t == "string") {
      try {
        return this.chainId === L(t);
      } catch {
      }
      return this.name === t;
    }
    if (typeof t == "number" || typeof t == "bigint") {
      try {
        return this.chainId === L(t);
      } catch {
      }
      return !1;
    }
    if (typeof t == "object") {
      if (t.chainId != null) {
        try {
          return this.chainId === L(t.chainId);
        } catch {
        }
        return !1;
      }
      return t.name != null ? this.name === t.name : !1;
    }
    return !1;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(l(this, wn).values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(t) {
    if (l(this, wn).get(t.name))
      throw new Error(`cannot replace existing plugin: ${t.name} `);
    return l(this, wn).set(t.name, t.clone()), this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(t) {
    return l(this, wn).get(t) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(t) {
    return this.plugins.filter((e) => e.name.split("#")[0] === t);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const t = new Cr(this.name, this.chainId);
    return this.plugins.forEach((e) => {
      t.attachPlugin(e.clone());
    }), t;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(t) {
    const e = this.getPlugin("org.ethers.plugins.network.GasCost") || new ho();
    let n = e.txBase;
    if (t.to == null && (n += e.txCreate), t.data)
      for (let s = 2; s < t.data.length; s += 2)
        t.data.substring(s, s + 2) === "00" ? n += e.txDataZero : n += e.txDataNonzero;
    if (t.accessList) {
      const s = lr(t.accessList);
      for (const i in s)
        n += e.txAccessListAddress + e.txAccessListStorageKey * s[i].storageKeys.length;
    }
    return n;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(t) {
    if (fg(), t == null)
      return Cr.from("mainnet");
    if (typeof t == "number" && (t = BigInt(t)), typeof t == "string" || typeof t == "bigint") {
      const e = Fo.get(t);
      if (e)
        return e();
      if (typeof t == "bigint")
        return new Cr("unknown", t);
      y(!1, "unknown network", "network", t);
    }
    if (typeof t.clone == "function")
      return t.clone();
    if (typeof t == "object") {
      y(typeof t.name == "string" && typeof t.chainId == "number", "invalid network object name or chainId", "network", t);
      const e = new Cr(t.name, t.chainId);
      return (t.ensAddress || t.ensNetwork != null) && e.attachPlugin(new po(t.ensAddress, t.ensNetwork)), e;
    }
    y(!1, "invalid network", "network", t);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(t, e) {
    typeof t == "number" && (t = BigInt(t));
    const n = Fo.get(t);
    n && y(!1, `conflicting network for ${JSON.stringify(n.name)}`, "nameOrChainId", t), Fo.set(t, e);
  }
};
es = new WeakMap(), ns = new WeakMap(), wn = new WeakMap();
let qe = Cr;
function su(r, t) {
  const e = String(r);
  if (!e.match(/^[0-9.]+$/))
    throw new Error(`invalid gwei value: ${r}`);
  const n = e.split(".");
  if (n.length === 1 && n.push(""), n.length !== 2)
    throw new Error(`invalid gwei value: ${r}`);
  for (; n[1].length < t; )
    n[1] += "0";
  if (n[1].length > 9) {
    let s = BigInt(n[1].substring(0, 9));
    n[1].substring(9).match(/^0+$/) || s++, n[1] = s.toString();
  }
  return BigInt(n[0] + n[1]);
}
function iu(r) {
  return new Wl(r, async (t, e, n) => {
    n.setHeader("User-Agent", "ethers");
    let s;
    try {
      const [i, o] = await Promise.all([
        n.send(),
        t()
      ]);
      s = i;
      const a = s.bodyJson.standard;
      return {
        gasPrice: o.gasPrice,
        maxFeePerGas: su(a.maxFee, 9),
        maxPriorityFeePerGas: su(a.maxPriorityFee, 9)
      };
    } catch (i) {
      P(!1, `error encountered with polygon gas station (${JSON.stringify(n.url)})`, "SERVER_ERROR", { request: n, response: s, error: i });
    }
  });
}
function lg(r) {
  return new Wl("data:", async (t, e, n) => {
    const s = await t();
    if (s.maxFeePerGas == null || s.maxPriorityFeePerGas == null)
      return s;
    const i = s.maxFeePerGas - s.maxPriorityFeePerGas;
    return {
      gasPrice: s.gasPrice,
      maxFeePerGas: i + r,
      maxPriorityFeePerGas: r
    };
  });
}
let ou = !1;
function fg() {
  if (ou)
    return;
  ou = !0;
  function r(t, e, n) {
    const s = function() {
      const i = new qe(t, e);
      return n.ensNetwork != null && i.attachPlugin(new po(null, n.ensNetwork)), i.attachPlugin(new ho()), (n.plugins || []).forEach((o) => {
        i.attachPlugin(o);
      }), i;
    };
    qe.register(t, s), qe.register(e, s), n.altNames && n.altNames.forEach((i) => {
      qe.register(i, s);
    });
  }
  r("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }), r("ropsten", 3, { ensNetwork: 3 }), r("rinkeby", 4, { ensNetwork: 4 }), r("goerli", 5, { ensNetwork: 5 }), r("kovan", 42, { ensNetwork: 42 }), r("sepolia", 11155111, {}), r("classic", 61, {}), r("classicKotti", 6, {}), r("arbitrum", 42161, {
    ensNetwork: 1
  }), r("arbitrum-goerli", 421613, {}), r("bnb", 56, { ensNetwork: 1 }), r("bnbt", 97, {}), r("linea", 59144, { ensNetwork: 1 }), r("linea-goerli", 59140, {}), r("matic", 137, {
    ensNetwork: 1,
    plugins: [
      iu("https://gasstation.polygon.technology/v2")
    ]
  }), r("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      iu("https://gasstation-testnet.polygon.technology/v2")
    ]
  }), r("optimism", 10, {
    ensNetwork: 1,
    plugins: [
      lg(BigInt("1000000"))
    ]
  }), r("optimism-goerli", 420, {}), r("xdai", 100, { ensNetwork: 1 });
}
function oa(r) {
  return JSON.parse(JSON.stringify(r));
}
var je, te, An, Ne, rs, Bi;
class hg {
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(t) {
    b(this, rs);
    b(this, je, void 0);
    b(this, te, void 0);
    b(this, An, void 0);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    b(this, Ne, void 0);
    d(this, je, t), d(this, te, null), d(this, An, 4e3), d(this, Ne, -2);
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return l(this, An);
  }
  set pollingInterval(t) {
    d(this, An, t);
  }
  start() {
    l(this, te) || (d(this, te, l(this, je)._setTimeout(I(this, rs, Bi).bind(this), l(this, An))), I(this, rs, Bi).call(this));
  }
  stop() {
    l(this, te) && (l(this, je)._clearTimeout(l(this, te)), d(this, te, null));
  }
  pause(t) {
    this.stop(), t && d(this, Ne, -2);
  }
  resume() {
    this.start();
  }
}
je = new WeakMap(), te = new WeakMap(), An = new WeakMap(), Ne = new WeakMap(), rs = new WeakSet(), Bi = async function() {
  try {
    const t = await l(this, je).getBlockNumber();
    if (l(this, Ne) === -2) {
      d(this, Ne, t);
      return;
    }
    if (t !== l(this, Ne)) {
      for (let e = l(this, Ne) + 1; e <= t; e++) {
        if (l(this, te) == null)
          return;
        await l(this, je).emit("block", e);
      }
      d(this, Ne, t);
    }
  } catch {
  }
  l(this, te) != null && d(this, te, l(this, je)._setTimeout(I(this, rs, Bi).bind(this), l(this, An)));
};
var Wn, Yn, bn;
class Yl {
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(t) {
    b(this, Wn, void 0);
    b(this, Yn, void 0);
    b(this, bn, void 0);
    d(this, Wn, t), d(this, bn, !1), d(this, Yn, (e) => {
      this._poll(e, l(this, Wn));
    });
  }
  /**
   *  Called on every new block.
   */
  async _poll(t, e) {
    throw new Error("sub-classes must override this");
  }
  start() {
    l(this, bn) || (d(this, bn, !0), l(this, Yn).call(this, -2), l(this, Wn).on("block", l(this, Yn)));
  }
  stop() {
    l(this, bn) && (d(this, bn, !1), l(this, Wn).off("block", l(this, Yn)));
  }
  pause(t) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
Wn = new WeakMap(), Yn = new WeakMap(), bn = new WeakMap();
var $i;
class dg extends Yl {
  constructor(e, n) {
    super(e);
    b(this, $i, void 0);
    d(this, $i, oa(n));
  }
  async _poll(e, n) {
    throw new Error("@TODO");
  }
}
$i = new WeakMap();
var ss;
class pg extends Yl {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(e, n) {
    super(e);
    b(this, ss, void 0);
    d(this, ss, n);
  }
  async _poll(e, n) {
    const s = await n.getTransactionReceipt(l(this, ss));
    s && n.emit(l(this, ss), s);
  }
}
ss = new WeakMap();
var ze, is, os, En, ee, to, Zl;
class La {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(t, e) {
    b(this, to);
    b(this, ze, void 0);
    b(this, is, void 0);
    b(this, os, void 0);
    b(this, En, void 0);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    b(this, ee, void 0);
    d(this, ze, t), d(this, is, oa(e)), d(this, os, I(this, to, Zl).bind(this)), d(this, En, !1), d(this, ee, -2);
  }
  start() {
    l(this, En) || (d(this, En, !0), l(this, ee) === -2 && l(this, ze).getBlockNumber().then((t) => {
      d(this, ee, t);
    }), l(this, ze).on("block", l(this, os)));
  }
  stop() {
    l(this, En) && (d(this, En, !1), l(this, ze).off("block", l(this, os)));
  }
  pause(t) {
    this.stop(), t && d(this, ee, -2);
  }
  resume() {
    this.start();
  }
}
ze = new WeakMap(), is = new WeakMap(), os = new WeakMap(), En = new WeakMap(), ee = new WeakMap(), to = new WeakSet(), Zl = async function(t) {
  if (l(this, ee) === -2)
    return;
  const e = oa(l(this, is));
  e.fromBlock = l(this, ee) + 1, e.toBlock = t;
  const n = await l(this, ze).getLogs(e);
  if (n.length === 0) {
    l(this, ee) < t - 60 && d(this, ee, t - 60);
    return;
  }
  for (const s of n)
    l(this, ze).emit(l(this, is), s), d(this, ee, s.blockNumber);
};
const gg = BigInt(2), yg = 10;
function vi(r) {
  return r && typeof r.then == "function";
}
function Ri(r, t) {
  return r + ":" + JSON.stringify(t, (e, n) => {
    if (n == null)
      return "null";
    if (typeof n == "bigint")
      return `bigint:${n.toString()}`;
    if (typeof n == "string")
      return n.toLowerCase();
    if (typeof n == "object" && !Array.isArray(n)) {
      const s = Object.keys(n);
      return s.sort(), s.reduce((i, o) => (i[o] = n[o], i), {});
    }
    return n;
  });
}
class Xl {
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(t) {
    /**
     *  The name fof the event.
     */
    A(this, "name");
    M(this, { name: t });
  }
  start() {
  }
  stop() {
  }
  pause(t) {
  }
  resume() {
  }
}
function mg(r) {
  return JSON.parse(JSON.stringify(r));
}
function aa(r) {
  return r = Array.from(new Set(r).values()), r.sort(), r;
}
async function Lo(r, t) {
  if (r == null)
    throw new Error("invalid event");
  if (Array.isArray(r) && (r = { topics: r }), typeof r == "string")
    switch (r) {
      case "block":
      case "pending":
      case "debug":
      case "error":
      case "network":
        return { type: r, tag: r };
    }
  if (it(r, 32)) {
    const e = r.toLowerCase();
    return { type: "transaction", tag: Ri("tx", { hash: e }), hash: e };
  }
  if (r.orphan) {
    const e = r;
    return { type: "orphan", tag: Ri("orphan", e), filter: mg(e) };
  }
  if (r.address || r.topics) {
    const e = r, n = {
      topics: (e.topics || []).map((s) => s == null ? null : Array.isArray(s) ? aa(s.map((i) => i.toLowerCase())) : s.toLowerCase())
    };
    if (e.address) {
      const s = [], i = [], o = (a) => {
        it(a) ? s.push(a) : i.push((async () => {
          s.push(await St(a, t));
        })());
      };
      Array.isArray(e.address) ? e.address.forEach(o) : o(e.address), i.length && await Promise.all(i), n.address = aa(s.map((a) => a.toLowerCase()));
    }
    return { filter: n, tag: Ri("event", n), type: "event" };
  }
  y(!1, "unknown ProviderEvent", "event", r);
}
function Mo() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const wg = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
var Pt, vn, Nt, as, zt, Zn, xn, Ke, ni, ne, cs, us, Ft, Zt, ri, ca, si, ua, Xn, Bs, ii, la, qn, Rs, ls, ki;
class Ag {
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(t, e) {
    // Shares multiple identical requests made during the same 250ms
    b(this, Ft);
    b(this, ri);
    b(this, si);
    // Account
    b(this, Xn);
    b(this, ii);
    b(this, qn);
    b(this, ls);
    b(this, Pt, void 0);
    b(this, vn, void 0);
    // null=unpaused, true=paused+dropWhilePaused, false=paused
    b(this, Nt, void 0);
    b(this, as, void 0);
    b(this, zt, void 0);
    b(this, Zn, void 0);
    b(this, xn, void 0);
    // The most recent block number if running an event or -1 if no "block" event
    b(this, Ke, void 0);
    b(this, ni, void 0);
    b(this, ne, void 0);
    b(this, cs, void 0);
    b(this, us, void 0);
    if (d(this, us, Object.assign({}, wg, e || {})), t === "any")
      d(this, Zn, !0), d(this, zt, null);
    else if (t) {
      const n = qe.from(t);
      d(this, Zn, !1), d(this, zt, Promise.resolve(n)), setTimeout(() => {
        this.emit("network", n, null);
      }, 0);
    } else
      d(this, Zn, !1), d(this, zt, null);
    d(this, Ke, -1), d(this, xn, /* @__PURE__ */ new Map()), d(this, Pt, /* @__PURE__ */ new Map()), d(this, vn, /* @__PURE__ */ new Map()), d(this, Nt, null), d(this, as, !1), d(this, ni, 1), d(this, ne, /* @__PURE__ */ new Map()), d(this, cs, !1);
  }
  get pollingInterval() {
    return l(this, us).pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(l(this, vn).values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(t) {
    if (l(this, vn).get(t.name))
      throw new Error(`cannot replace existing plugin: ${t.name} `);
    return l(this, vn).set(t.name, t.connect(this)), this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(t) {
    return l(this, vn).get(t) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return l(this, cs);
  }
  set disableCcipRead(t) {
    d(this, cs, !!t);
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(t, e, n) {
    if (this.disableCcipRead || n.length === 0 || t.to == null)
      return null;
    const s = t.to.toLowerCase(), i = e.toLowerCase(), o = [];
    for (let a = 0; a < n.length; a++) {
      const c = n[a], u = c.replace("{sender}", s).replace("{data}", i), f = new In(u);
      c.indexOf("{data}") === -1 && (f.body = { data: i, sender: s }), this.emit("debug", { action: "sendCcipReadFetchRequest", request: f, index: a, urls: n });
      let h = "unknown error";
      const g = await f.send();
      try {
        const w = g.bodyJson;
        if (w.data)
          return this.emit("debug", { action: "receiveCcipReadFetchResult", request: f, result: w }), w.data;
        w.message && (h = w.message), this.emit("debug", { action: "receiveCcipReadFetchError", request: f, result: w });
      } catch {
      }
      P(g.statusCode < 400 || g.statusCode >= 500, `response not found during CCIP fetch: ${h}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: t, info: { url: c, errorMessage: h } }), o.push(h);
    }
    P(!1, `error encountered during CCIP fetch: ${o.map((a) => JSON.stringify(a)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: t,
      info: { urls: n, errorMessages: o }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(t, e) {
    return new Gp(sg(t), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(t, e) {
    return new li(ng(t), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(t, e) {
    return new Ul(cg(t), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(t, e) {
    return new js(Kl(t), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    P(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(t) {
    P(!1, `unsupported method: ${t.method}`, "UNSUPPORTED_OPERATION", {
      operation: t.method,
      info: t
    });
  }
  // State
  async getBlockNumber() {
    const t = V(await I(this, Ft, Zt).call(this, { method: "getBlockNumber" }), "%response");
    return l(this, Ke) >= 0 && d(this, Ke, t), t;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(t) {
    return St(t, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(t) {
    if (t == null)
      return "latest";
    switch (t) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return t;
    }
    if (it(t))
      return it(t, 32) ? t : vr(t);
    if (typeof t == "bigint" && (t = V(t, "blockTag")), typeof t == "number")
      return t >= 0 ? vr(t) : l(this, Ke) >= 0 ? vr(l(this, Ke) + t) : this.getBlockNumber().then((e) => vr(e + t));
    y(!1, "invalid blockTag", "blockTag", t);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(t) {
    const e = (t.topics || []).map((c) => c == null ? null : Array.isArray(c) ? aa(c.map((u) => u.toLowerCase())) : c.toLowerCase()), n = "blockHash" in t ? t.blockHash : void 0, s = (c, u, f) => {
      let h;
      switch (c.length) {
        case 0:
          break;
        case 1:
          h = c[0];
          break;
        default:
          c.sort(), h = c;
      }
      if (n && (u != null || f != null))
        throw new Error("invalid filter");
      const g = {};
      return h && (g.address = h), e.length && (g.topics = e), u && (g.fromBlock = u), f && (g.toBlock = f), n && (g.blockHash = n), g;
    };
    let i = [];
    if (t.address)
      if (Array.isArray(t.address))
        for (const c of t.address)
          i.push(this._getAddress(c));
      else
        i.push(this._getAddress(t.address));
    let o;
    "fromBlock" in t && (o = this._getBlockTag(t.fromBlock));
    let a;
    return "toBlock" in t && (a = this._getBlockTag(t.toBlock)), i.filter((c) => typeof c != "string").length || o != null && typeof o != "string" || a != null && typeof a != "string" ? Promise.all([Promise.all(i), o, a]).then((c) => s(c[0], c[1], c[2])) : s(i, o, a);
  }
  /**
   *  Returns or resovles to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(t) {
    const e = _i(t), n = [];
    if (["to", "from"].forEach((s) => {
      if (e[s] == null)
        return;
      const i = St(e[s], this);
      vi(i) ? n.push(async function() {
        e[s] = await i;
      }()) : e[s] = i;
    }), e.blockTag != null) {
      const s = this._getBlockTag(e.blockTag);
      vi(s) ? n.push(async function() {
        e.blockTag = await s;
      }()) : e.blockTag = s;
    }
    return n.length ? async function() {
      return await Promise.all(n), e;
    }() : e;
  }
  async getNetwork() {
    if (l(this, zt) == null) {
      const s = this._detectNetwork().then((i) => (this.emit("network", i, null), i), (i) => {
        throw l(this, zt) === s && d(this, zt, null), i;
      });
      return d(this, zt, s), (await s).clone();
    }
    const t = l(this, zt), [e, n] = await Promise.all([
      t,
      this._detectNetwork()
      // The actual connected network
    ]);
    return e.chainId !== n.chainId && (l(this, Zn) ? (this.emit("network", n, e), l(this, zt) === t && d(this, zt, Promise.resolve(n))) : P(!1, `network changed: ${e.chainId} => ${n.chainId} `, "NETWORK_ERROR", {
      event: "changed"
    })), e.clone();
  }
  async getFeeData() {
    const t = await this.getNetwork(), e = async () => {
      const { _block: s, gasPrice: i } = await Bt({
        _block: I(this, ii, la).call(this, "latest", !1),
        gasPrice: (async () => {
          try {
            const u = await I(this, Ft, Zt).call(this, { method: "getGasPrice" });
            return L(u, "%response");
          } catch {
          }
          return null;
        })()
      });
      let o = null, a = null;
      const c = this._wrapBlock(s, t);
      return c && c.baseFeePerGas && (a = BigInt("1000000000"), o = c.baseFeePerGas * gg + a), new $c(i, o, a);
    }, n = t.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (n) {
      const s = new In(n.url), i = await n.processFunc(e, this, s);
      return new $c(i.gasPrice, i.maxFeePerGas, i.maxPriorityFeePerGas);
    }
    return await e();
  }
  async estimateGas(t) {
    let e = this._getTransactionRequest(t);
    return vi(e) && (e = await e), L(await I(this, Ft, Zt).call(this, {
      method: "estimateGas",
      transaction: e
    }), "%response");
  }
  async call(t) {
    const { tx: e, blockTag: n } = await Bt({
      tx: this._getTransactionRequest(t),
      blockTag: this._getBlockTag(t.blockTag)
    });
    return await I(this, si, ua).call(this, I(this, ri, ca).call(this, e, n, t.enableCcipRead ? 0 : -1));
  }
  async getBalance(t, e) {
    return L(await I(this, Xn, Bs).call(this, { method: "getBalance" }, t, e), "%response");
  }
  async getTransactionCount(t, e) {
    return V(await I(this, Xn, Bs).call(this, { method: "getTransactionCount" }, t, e), "%response");
  }
  async getCode(t, e) {
    return F(await I(this, Xn, Bs).call(this, { method: "getCode" }, t, e));
  }
  async getStorage(t, e, n) {
    const s = L(e, "position");
    return F(await I(this, Xn, Bs).call(this, { method: "getStorage", position: s }, t, n));
  }
  // Write
  async broadcastTransaction(t) {
    const { blockNumber: e, hash: n, network: s } = await Bt({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: t
      }),
      network: this.getNetwork()
    }), i = Qi.from(t);
    if (i.hash !== n)
      throw new Error("@TODO: the returned hash did not match");
    return this._wrapTransactionResponse(i, s).replaceableTransaction(e);
  }
  // Queries
  async getBlock(t, e) {
    const { network: n, params: s } = await Bt({
      network: this.getNetwork(),
      params: I(this, ii, la).call(this, t, !!e)
    });
    return s == null ? null : this._wrapBlock(s, n);
  }
  async getTransaction(t) {
    const { network: e, params: n } = await Bt({
      network: this.getNetwork(),
      params: I(this, Ft, Zt).call(this, { method: "getTransaction", hash: t })
    });
    return n == null ? null : this._wrapTransactionResponse(n, e);
  }
  async getTransactionReceipt(t) {
    const { network: e, params: n } = await Bt({
      network: this.getNetwork(),
      params: I(this, Ft, Zt).call(this, { method: "getTransactionReceipt", hash: t })
    });
    if (n == null)
      return null;
    if (n.gasPrice == null && n.effectiveGasPrice == null) {
      const s = await I(this, Ft, Zt).call(this, { method: "getTransaction", hash: t });
      if (s == null)
        throw new Error("report this; could not find tx or effectiveGasPrice");
      n.effectiveGasPrice = s.gasPrice;
    }
    return this._wrapTransactionReceipt(n, e);
  }
  async getTransactionResult(t) {
    const { result: e } = await Bt({
      network: this.getNetwork(),
      result: I(this, Ft, Zt).call(this, { method: "getTransactionResult", hash: t })
    });
    return e == null ? null : F(e);
  }
  // Bloom-filter Queries
  async getLogs(t) {
    let e = this._getFilter(t);
    vi(e) && (e = await e);
    const { network: n, params: s } = await Bt({
      network: this.getNetwork(),
      params: I(this, Ft, Zt).call(this, { method: "getLogs", filter: e })
    });
    return s.map((i) => this._wrapLog(i, n));
  }
  // ENS
  _getProvider(t) {
    P(!1, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(t) {
    return await Ji.fromName(this, t);
  }
  async getAvatar(t) {
    const e = await this.getResolver(t);
    return e ? await e.getAvatar() : null;
  }
  async resolveName(t) {
    const e = await this.getResolver(t);
    return e ? await e.getAddress() : null;
  }
  async lookupAddress(t) {
    t = W(t);
    const e = ta(t.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const n = await Ji.getEnsAddress(this), i = await new Tn(n, [
        "function resolver(bytes32) view returns (address)"
      ], this).resolver(e);
      if (i == null || i === Wo)
        return null;
      const a = await new Tn(i, [
        "function name(bytes32) view returns (string)"
      ], this).name(e);
      return await this.resolveName(a) !== t ? null : a;
    } catch (n) {
      if (se(n, "BAD_DATA") && n.value === "0x" || se(n, "CALL_EXCEPTION"))
        return null;
      throw n;
    }
    return null;
  }
  async waitForTransaction(t, e, n) {
    const s = e ?? 1;
    return s === 0 ? this.getTransactionReceipt(t) : new Promise(async (i, o) => {
      let a = null;
      const c = async (u) => {
        try {
          const f = await this.getTransactionReceipt(t);
          if (f != null && u - f.blockNumber + 1 >= s) {
            i(f), a && (clearTimeout(a), a = null);
            return;
          }
        } catch (f) {
          console.log("EEE", f);
        }
        this.once("block", c);
      };
      n != null && (a = setTimeout(() => {
        a != null && (a = null, this.off("block", c), o(dt("timeout", "TIMEOUT", { reason: "timeout" })));
      }, n)), c(await this.getBlockNumber());
    });
  }
  async waitForBlock(t) {
    P(!1, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(t) {
    const e = l(this, ne).get(t);
    e && (e.timer && clearTimeout(e.timer), l(this, ne).delete(t));
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(t, e) {
    e == null && (e = 0);
    const n = xs(this, ni)._++, s = () => {
      l(this, ne).delete(n), t();
    };
    if (this.paused)
      l(this, ne).set(n, { timer: null, func: s, time: e });
    else {
      const i = setTimeout(s, e);
      l(this, ne).set(n, { timer: i, func: s, time: Mo() });
    }
    return n;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(t) {
    for (const e of l(this, Pt).values())
      t(e.subscriber);
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(t) {
    switch (t.type) {
      case "debug":
      case "error":
      case "network":
        return new Xl(t.type);
      case "block": {
        const e = new hg(this);
        return e.pollingInterval = this.pollingInterval, e;
      }
      case "event":
        return new La(this, t.filter);
      case "transaction":
        return new pg(this, t.hash);
      case "orphan":
        return new dg(this, t.filter);
    }
    throw new Error(`unsupported event: ${t.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(t, e) {
    for (const n of l(this, Pt).values())
      if (n.subscriber === t) {
        n.started && n.subscriber.stop(), n.subscriber = e, n.started && e.start(), l(this, Nt) != null && e.pause(l(this, Nt));
        break;
      }
  }
  async on(t, e) {
    const n = await I(this, ls, ki).call(this, t);
    return n.listeners.push({ listener: e, once: !1 }), n.started || (n.subscriber.start(), n.started = !0, l(this, Nt) != null && n.subscriber.pause(l(this, Nt))), this;
  }
  async once(t, e) {
    const n = await I(this, ls, ki).call(this, t);
    return n.listeners.push({ listener: e, once: !0 }), n.started || (n.subscriber.start(), n.started = !0, l(this, Nt) != null && n.subscriber.pause(l(this, Nt))), this;
  }
  async emit(t, ...e) {
    const n = await I(this, qn, Rs).call(this, t, e);
    if (!n || n.listeners.length === 0)
      return !1;
    const s = n.listeners.length;
    return n.listeners = n.listeners.filter(({ listener: i, once: o }) => {
      const a = new wu(this, o ? null : i, t);
      try {
        i.call(this, ...e, a);
      } catch {
      }
      return !o;
    }), n.listeners.length === 0 && (n.started && n.subscriber.stop(), l(this, Pt).delete(n.tag)), s > 0;
  }
  async listenerCount(t) {
    if (t) {
      const n = await I(this, qn, Rs).call(this, t);
      return n ? n.listeners.length : 0;
    }
    let e = 0;
    for (const { listeners: n } of l(this, Pt).values())
      e += n.length;
    return e;
  }
  async listeners(t) {
    if (t) {
      const n = await I(this, qn, Rs).call(this, t);
      return n ? n.listeners.map(({ listener: s }) => s) : [];
    }
    let e = [];
    for (const { listeners: n } of l(this, Pt).values())
      e = e.concat(n.map(({ listener: s }) => s));
    return e;
  }
  async off(t, e) {
    const n = await I(this, qn, Rs).call(this, t);
    if (!n)
      return this;
    if (e) {
      const s = n.listeners.map(({ listener: i }) => i).indexOf(e);
      s >= 0 && n.listeners.splice(s, 1);
    }
    return (!e || n.listeners.length === 0) && (n.started && n.subscriber.stop(), l(this, Pt).delete(n.tag)), this;
  }
  async removeAllListeners(t) {
    if (t) {
      const { tag: e, started: n, subscriber: s } = await I(this, ls, ki).call(this, t);
      n && s.stop(), l(this, Pt).delete(e);
    } else
      for (const [e, { started: n, subscriber: s }] of l(this, Pt))
        n && s.stop(), l(this, Pt).delete(e);
    return this;
  }
  // Alias for "on"
  async addListener(t, e) {
    return await this.on(t, e);
  }
  // Alias for "off"
  async removeListener(t, e) {
    return this.off(t, e);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return l(this, as);
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const t of l(this, ne).keys())
      this._clearTimeout(t);
    d(this, as, !0);
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return l(this, Nt) != null;
  }
  set paused(t) {
    !!t !== this.paused && (this.paused ? this.resume() : this.pause(!1));
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(t) {
    if (d(this, Ke, -1), l(this, Nt) != null) {
      if (l(this, Nt) == !!t)
        return;
      P(!1, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((e) => e.pause(t)), d(this, Nt, !!t);
    for (const e of l(this, ne).values())
      e.timer && clearTimeout(e.timer), e.time = Mo() - e.time;
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (l(this, Nt) != null) {
      this._forEachSubscriber((t) => t.resume()), d(this, Nt, null);
      for (const t of l(this, ne).values()) {
        let e = t.time;
        e < 0 && (e = 0), t.time = Mo(), setTimeout(t.func, e);
      }
    }
  }
}
Pt = new WeakMap(), vn = new WeakMap(), Nt = new WeakMap(), as = new WeakMap(), zt = new WeakMap(), Zn = new WeakMap(), xn = new WeakMap(), Ke = new WeakMap(), ni = new WeakMap(), ne = new WeakMap(), cs = new WeakMap(), us = new WeakMap(), Ft = new WeakSet(), Zt = async function(t) {
  const e = l(this, us).cacheTimeout;
  if (e < 0)
    return await this._perform(t);
  const n = Ri(t.method, t);
  let s = l(this, xn).get(n);
  return s || (s = this._perform(t), l(this, xn).set(n, s), setTimeout(() => {
    l(this, xn).get(n) === s && l(this, xn).delete(n);
  }, e)), await s;
}, ri = new WeakSet(), ca = async function(t, e, n) {
  P(n < yg, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
    reason: "TOO_MANY_REDIRECTS",
    transaction: Object.assign({}, t, { blockTag: e, enableCcipRead: !0 })
  });
  const s = _i(t);
  try {
    return F(await this._perform({ method: "call", transaction: s, blockTag: e }));
  } catch (i) {
    if (!this.disableCcipRead && ma(i) && i.data && n >= 0 && e === "latest" && s.to != null && at(i.data, 0, 4) === "0x556f1830") {
      const o = i.data, a = await St(s.to, this);
      let c;
      try {
        c = Pg(at(i.data, 4));
      } catch (h) {
        P(!1, h.message, "OFFCHAIN_FAULT", {
          reason: "BAD_DATA",
          transaction: s,
          info: { data: o }
        });
      }
      P(c.sender.toLowerCase() === a.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
        action: "call",
        data: o,
        reason: "OffchainLookup",
        transaction: s,
        invocation: null,
        revert: {
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          name: "OffchainLookup",
          args: c.errorArgs
        }
      });
      const u = await this.ccipReadFetch(s, c.calldata, c.urls);
      P(u != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
        reason: "FETCH_FAILED",
        transaction: s,
        info: { data: i.data, errorArgs: c.errorArgs }
      });
      const f = {
        to: a,
        data: pt([c.selector, xg([u, c.extraData])])
      };
      this.emit("debug", { action: "sendCcipReadCall", transaction: f });
      try {
        const h = await I(this, ri, ca).call(this, f, e, n + 1);
        return this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, f), result: h }), h;
      } catch (h) {
        throw this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, f), error: h }), h;
      }
    }
    throw i;
  }
}, si = new WeakSet(), ua = async function(t) {
  const { value: e } = await Bt({
    network: this.getNetwork(),
    value: t
  });
  return e;
}, Xn = new WeakSet(), Bs = async function(t, e, n) {
  let s = this._getAddress(e), i = this._getBlockTag(n);
  return (typeof s != "string" || typeof i != "string") && ([s, i] = await Promise.all([s, i])), await I(this, si, ua).call(this, I(this, Ft, Zt).call(this, Object.assign(t, { address: s, blockTag: i })));
}, ii = new WeakSet(), la = async function(t, e) {
  if (it(t, 32))
    return await I(this, Ft, Zt).call(this, {
      method: "getBlock",
      blockHash: t,
      includeTransactions: e
    });
  let n = this._getBlockTag(t);
  return typeof n != "string" && (n = await n), await I(this, Ft, Zt).call(this, {
    method: "getBlock",
    blockTag: n,
    includeTransactions: e
  });
}, qn = new WeakSet(), Rs = async function(t, e) {
  let n = await Lo(t, this);
  return n.type === "event" && e && e.length > 0 && e[0].removed === !0 && (n = await Lo({ orphan: "drop-log", log: e[0] }, this)), l(this, Pt).get(n.tag) || null;
}, ls = new WeakSet(), ki = async function(t) {
  const e = await Lo(t, this), n = e.tag;
  let s = l(this, Pt).get(n);
  return s || (s = { subscriber: this._getSubscriber(e), tag: n, addressableMap: /* @__PURE__ */ new WeakMap(), nameMap: /* @__PURE__ */ new Map(), started: !1, listeners: [] }, l(this, Pt).set(n, s)), s;
};
function bg(r, t) {
  try {
    const e = fa(r, t);
    if (e)
      return Aa(e);
  } catch {
  }
  return null;
}
function fa(r, t) {
  if (r === "0x")
    return null;
  try {
    const e = V(at(r, t, t + 32)), n = V(at(r, e, e + 32));
    return at(r, e + 32, e + 32 + n);
  } catch {
  }
  return null;
}
function au(r) {
  const t = Kt(r);
  if (t.length > 32)
    throw new Error("internal; should not happen");
  const e = new Uint8Array(32);
  return e.set(t, 32 - t.length), e;
}
function Eg(r) {
  if (r.length % 32 === 0)
    return r;
  const t = new Uint8Array(Math.ceil(r.length / 32) * 32);
  return t.set(r), t;
}
const vg = new Uint8Array([]);
function xg(r) {
  const t = [];
  let e = 0;
  for (let n = 0; n < r.length; n++)
    t.push(vg), e += 32;
  for (let n = 0; n < r.length; n++) {
    const s = X(r[n]);
    t[n] = au(e), t.push(au(s.length)), t.push(Eg(s)), e += 32 + Math.ceil(s.length / 32) * 32;
  }
  return pt(t);
}
const cu = "0x0000000000000000000000000000000000000000000000000000000000000000";
function Pg(r) {
  const t = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  P(Tr(r) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const e = at(r, 0, 32);
  P(at(e, 0, 12) === at(cu, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  }), t.sender = at(e, 12);
  try {
    const n = [], s = V(at(r, 32, 64)), i = V(at(r, s, s + 32)), o = at(r, s + 32);
    for (let a = 0; a < i; a++) {
      const c = bg(o, a * 32);
      if (c == null)
        throw new Error("abort");
      n.push(c);
    }
    t.urls = n;
  } catch {
    P(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const n = fa(r, 64);
    if (n == null)
      throw new Error("abort");
    t.calldata = n;
  } catch {
    P(!1, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  P(at(r, 100, 128) === at(cu, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  }), t.selector = at(r, 96, 100);
  try {
    const n = fa(r, 128);
    if (n == null)
      throw new Error("abort");
    t.extraData = n;
  } catch {
    P(!1, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  return t.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((n) => t[n]), t;
}
function gr(r, t) {
  if (r.provider)
    return r.provider;
  P(!1, "missing provider", "UNSUPPORTED_OPERATION", { operation: t });
}
async function uu(r, t) {
  let e = _i(t);
  if (e.to != null && (e.to = St(e.to, r)), e.from != null) {
    const n = e.from;
    e.from = Promise.all([
      r.getAddress(),
      St(n, r)
    ]).then(([s, i]) => (y(s.toLowerCase() === i.toLowerCase(), "transaction from mismatch", "tx.from", i), s));
  } else
    e.from = r.getAddress();
  return await Bt(e);
}
class Ng {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(t) {
    /**
     *  The provider this signer is connected to.
     */
    A(this, "provider");
    M(this, { provider: t || null });
  }
  async getNonce(t) {
    return gr(this, "getTransactionCount").getTransactionCount(await this.getAddress(), t);
  }
  async populateCall(t) {
    return await uu(this, t);
  }
  async populateTransaction(t) {
    const e = gr(this, "populateTransaction"), n = await uu(this, t);
    n.nonce == null && (n.nonce = await this.getNonce("pending")), n.gasLimit == null && (n.gasLimit = await this.estimateGas(n));
    const s = await this.provider.getNetwork();
    if (n.chainId != null) {
      const o = L(n.chainId);
      y(o === s.chainId, "transaction chainId mismatch", "tx.chainId", t.chainId);
    } else
      n.chainId = s.chainId;
    const i = n.maxFeePerGas != null || n.maxPriorityFeePerGas != null;
    if (n.gasPrice != null && (n.type === 2 || i) ? y(!1, "eip-1559 transaction do not support gasPrice", "tx", t) : (n.type === 0 || n.type === 1) && i && y(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", t), (n.type === 2 || n.type == null) && n.maxFeePerGas != null && n.maxPriorityFeePerGas != null)
      n.type = 2;
    else if (n.type === 0 || n.type === 1) {
      const o = await e.getFeeData();
      P(o.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      }), n.gasPrice == null && (n.gasPrice = o.gasPrice);
    } else {
      const o = await e.getFeeData();
      if (n.type == null)
        if (o.maxFeePerGas != null && o.maxPriorityFeePerGas != null)
          if (n.type = 2, n.gasPrice != null) {
            const a = n.gasPrice;
            delete n.gasPrice, n.maxFeePerGas = a, n.maxPriorityFeePerGas = a;
          } else
            n.maxFeePerGas == null && (n.maxFeePerGas = o.maxFeePerGas), n.maxPriorityFeePerGas == null && (n.maxPriorityFeePerGas = o.maxPriorityFeePerGas);
        else
          o.gasPrice != null ? (P(!i, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          }), n.gasPrice == null && (n.gasPrice = o.gasPrice), n.type = 0) : P(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
      else
        n.type === 2 && (n.maxFeePerGas == null && (n.maxFeePerGas = o.maxFeePerGas), n.maxPriorityFeePerGas == null && (n.maxPriorityFeePerGas = o.maxPriorityFeePerGas));
    }
    return await Bt(n);
  }
  async estimateGas(t) {
    return gr(this, "estimateGas").estimateGas(await this.populateCall(t));
  }
  async call(t) {
    return gr(this, "call").call(await this.populateCall(t));
  }
  async resolveName(t) {
    return await gr(this, "resolveName").resolveName(t);
  }
  async sendTransaction(t) {
    const e = gr(this, "sendTransaction"), n = await this.populateTransaction(t);
    delete n.from;
    const s = Qi.from(n);
    return await e.broadcastTransaction(await this.signTransaction(s));
  }
}
function Cg(r) {
  return JSON.parse(JSON.stringify(r));
}
var Lt, Ce, $n, Pn, tr, fs, oi, ha, ai, da;
class ql {
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(t) {
    b(this, oi);
    b(this, ai);
    b(this, Lt, void 0);
    b(this, Ce, void 0);
    b(this, $n, void 0);
    b(this, Pn, void 0);
    b(this, tr, void 0);
    b(this, fs, void 0);
    d(this, Lt, t), d(this, Ce, null), d(this, $n, I(this, oi, ha).bind(this)), d(this, Pn, !1), d(this, tr, null), d(this, fs, !1);
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(t) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(t, e) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(t) {
    throw new Error("subclasses must override this");
  }
  start() {
    l(this, Pn) || (d(this, Pn, !0), I(this, oi, ha).call(this, -2));
  }
  stop() {
    l(this, Pn) && (d(this, Pn, !1), d(this, fs, !0), I(this, ai, da).call(this), l(this, Lt).off("block", l(this, $n)));
  }
  pause(t) {
    t && I(this, ai, da).call(this), l(this, Lt).off("block", l(this, $n));
  }
  resume() {
    this.start();
  }
}
Lt = new WeakMap(), Ce = new WeakMap(), $n = new WeakMap(), Pn = new WeakMap(), tr = new WeakMap(), fs = new WeakMap(), oi = new WeakSet(), ha = async function(t) {
  try {
    l(this, Ce) == null && d(this, Ce, this._subscribe(l(this, Lt)));
    let e = null;
    try {
      e = await l(this, Ce);
    } catch (i) {
      if (!se(i, "UNSUPPORTED_OPERATION") || i.operation !== "eth_newFilter")
        throw i;
    }
    if (e == null) {
      d(this, Ce, null), l(this, Lt)._recoverSubscriber(this, this._recover(l(this, Lt)));
      return;
    }
    const n = await l(this, Lt).getNetwork();
    if (l(this, tr) || d(this, tr, n), l(this, tr).chainId !== n.chainId)
      throw new Error("chaid changed");
    if (l(this, fs))
      return;
    const s = await l(this, Lt).send("eth_getFilterChanges", [e]);
    await this._emitResults(l(this, Lt), s);
  } catch (e) {
    console.log("@TODO", e);
  }
  l(this, Lt).once("block", l(this, $n));
}, ai = new WeakSet(), da = function() {
  const t = l(this, Ce);
  t && (d(this, Ce, null), t.then((e) => {
    l(this, Lt).send("eth_uninstallFilter", [e]);
  }));
};
var er;
class Tg extends ql {
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(e, n) {
    super(e);
    b(this, er, void 0);
    d(this, er, Cg(n));
  }
  _recover(e) {
    return new La(e, l(this, er));
  }
  async _subscribe(e) {
    return await e.send("eth_newFilter", [l(this, er)]);
  }
  async _emitResults(e, n) {
    for (const s of n)
      e.emit(l(this, er), e._wrapLog(s, e._network));
  }
}
er = new WeakMap();
class Og extends ql {
  async _subscribe(t) {
    return await t.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(t, e) {
    for (const n of e)
      t.emit("pending", n);
  }
}
const Ig = "bigint,boolean,function,number,string,symbol".split(/,/g);
function Si(r) {
  if (r == null || Ig.indexOf(typeof r) >= 0 || typeof r.getAddress == "function")
    return r;
  if (Array.isArray(r))
    return r.map(Si);
  if (typeof r == "object")
    return Object.keys(r).reduce((t, e) => (t[e] = r[e], t), {});
  throw new Error(`should not happen: ${r} (${typeof r})`);
}
function Bg(r) {
  return new Promise((t) => {
    setTimeout(t, r);
  });
}
function yr(r) {
  return r && r.toLowerCase();
}
function lu(r) {
  return r && typeof r.pollingInterval == "number";
}
const Rg = {
  polling: !1,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class Go extends Ng {
  constructor(e, n) {
    super(e);
    A(this, "address");
    n = W(n), M(this, { address: n });
  }
  connect(e) {
    P(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(e) {
    return await this.populateCall(e);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(e) {
    const n = Si(e), s = [];
    if (n.from) {
      const o = n.from;
      s.push((async () => {
        const a = await St(o, this.provider);
        y(a != null && a.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", e), n.from = a;
      })());
    } else
      n.from = this.address;
    if (n.gasLimit == null && s.push((async () => {
      n.gasLimit = await this.provider.estimateGas({ ...n, from: this.address });
    })()), n.to != null) {
      const o = n.to;
      s.push((async () => {
        n.to = await St(o, this.provider);
      })());
    }
    s.length && await Promise.all(s);
    const i = this.provider.getRpcTransaction(n);
    return this.provider.send("eth_sendTransaction", [i]);
  }
  async sendTransaction(e) {
    const n = await this.provider.getBlockNumber(), s = await this.sendUncheckedTransaction(e);
    return await new Promise((i, o) => {
      const a = [1e3, 100], c = async () => {
        const u = await this.provider.getTransaction(s);
        if (u != null) {
          i(u.replaceableTransaction(n));
          return;
        }
        this.provider._setTimeout(() => {
          c();
        }, a.pop() || 4e3);
      };
      c();
    });
  }
  async signTransaction(e) {
    const n = Si(e);
    if (n.from) {
      const i = await St(n.from, this.provider);
      y(i != null && i.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", e), n.from = i;
    } else
      n.from = this.address;
    const s = this.provider.getRpcTransaction(n);
    return await this.provider.send("eth_signTransaction", [s]);
  }
  async signMessage(e) {
    const n = typeof e == "string" ? $e(e) : e;
    return await this.provider.send("personal_sign", [
      F(n),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(e, n, s) {
    const i = Si(s), o = await Hi.resolveNames(e, n, i, async (a) => {
      const c = await St(a);
      return y(c != null, "TypedData does not support null address", "value", a), c;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(Hi.getPayload(o.domain, n, o.value))
    ]);
  }
  async unlock(e) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      e,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(e) {
    const n = typeof e == "string" ? $e(e) : e;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      F(n)
    ]);
  }
}
var nr, hs, We, Te, pe, Ye, ci, pa;
class kg extends Ag {
  constructor(e, n) {
    super(e, n);
    b(this, ci);
    b(this, nr, void 0);
    // The next ID to use for the JSON-RPC ID field
    b(this, hs, void 0);
    // Payloads are queued and triggered in batches using the drainTimer
    b(this, We, void 0);
    b(this, Te, void 0);
    b(this, pe, void 0);
    b(this, Ye, void 0);
    d(this, hs, 1), d(this, nr, Object.assign({}, Rg, n || {})), d(this, We, []), d(this, Te, null), d(this, Ye, null);
    {
      let i = null;
      const o = new Promise((a) => {
        i = a;
      });
      d(this, pe, { promise: o, resolve: i });
    }
    const s = this._getOption("staticNetwork");
    s && (y(e == null || s.matches(e), "staticNetwork MUST match network object", "options", n), d(this, Ye, s));
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(e) {
    return l(this, nr)[e];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    return P(l(this, Ye), "network is not available yet", "NETWORK_ERROR"), l(this, Ye);
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(e) {
    if (e.method === "call" || e.method === "estimateGas") {
      let s = e.transaction;
      if (s && s.type != null && L(s.type) && s.maxFeePerGas == null && s.maxPriorityFeePerGas == null) {
        const i = await this.getFeeData();
        i.maxFeePerGas == null && i.maxPriorityFeePerGas == null && (e = Object.assign({}, e, {
          transaction: Object.assign({}, s, { type: void 0 })
        }));
      }
    }
    const n = this.getRpcRequest(e);
    return n != null ? await this.send(n.method, n.args) : super._perform(e);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const e = this._getOption("staticNetwork");
    if (e)
      return e;
    if (this.ready)
      return qe.from(L(await this.send("eth_chainId", [])));
    const n = {
      id: xs(this, hs)._++,
      method: "eth_chainId",
      params: [],
      jsonrpc: "2.0"
    };
    this.emit("debug", { action: "sendRpcPayload", payload: n });
    let s;
    try {
      s = (await this._send(n))[0];
    } catch (i) {
      throw this.emit("debug", { action: "receiveRpcError", error: i }), i;
    }
    if (this.emit("debug", { action: "receiveRpcResult", result: s }), "result" in s)
      return qe.from(L(s.result));
    throw this.getRpcError(n, s);
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    l(this, pe) == null || l(this, pe).resolve == null || (l(this, pe).resolve(), d(this, pe, null), (async () => {
      for (; l(this, Ye) == null && !this.destroyed; )
        try {
          d(this, Ye, await this._detectNetwork());
        } catch (e) {
          if (this.destroyed)
            break;
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"), this.emit("error", dt("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error: e } })), await Bg(1e3);
        }
      I(this, ci, pa).call(this);
    })());
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (l(this, pe) != null)
      return await l(this, pe).promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(e) {
    return e.type === "pending" ? new Og(this) : e.type === "event" ? this._getOption("polling") ? new La(this, e.filter) : new Tg(this, e.filter) : e.type === "orphan" && e.filter.orphan === "drop-log" ? new Xl("orphan") : super._getSubscriber(e);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return l(this, pe) == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(e) {
    const n = {};
    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((s) => {
      if (e[s] == null)
        return;
      let i = s;
      s === "gasLimit" && (i = "gas"), n[i] = vr(L(e[s], `tx.${s}`));
    }), ["from", "to", "data"].forEach((s) => {
      e[s] != null && (n[s] = F(e[s]));
    }), e.accessList && (n.accessList = lr(e.accessList)), n;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(e) {
    switch (e.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [yr(e.address), e.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [yr(e.address), e.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [yr(e.address), e.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            yr(e.address),
            "0x" + e.position.toString(16),
            e.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [e.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in e)
          return {
            method: "eth_getBlockByNumber",
            args: [e.blockTag, !!e.includeTransactions]
          };
        if ("blockHash" in e)
          return {
            method: "eth_getBlockByHash",
            args: [e.blockHash, !!e.includeTransactions]
          };
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [e.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [e.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(e.transaction), e.blockTag]
        };
      case "estimateGas":
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(e.transaction)]
        };
      case "getLogs":
        return e.filter && e.filter.address != null && (Array.isArray(e.filter.address) ? e.filter.address = e.filter.address.map(yr) : e.filter.address = yr(e.filter.address)), { method: "eth_getLogs", args: [e.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(e, n) {
    const { method: s } = e, { error: i } = n;
    if (s === "eth_estimateGas" && i.message) {
      const c = i.message;
      if (!c.match(/revert/i) && c.match(/insufficient funds/i))
        return dt("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: e.params[0],
          info: { payload: e, error: i }
        });
    }
    if (s === "eth_call" || s === "eth_estimateGas") {
      const c = ga(i), u = Js.getBuiltinCallException(s === "eth_call" ? "call" : "estimateGas", e.params[0], c ? c.data : null);
      return u.info = { error: i, payload: e }, u;
    }
    const o = JSON.stringify(Ug(i));
    if (typeof i.message == "string" && i.message.match(/user denied|ethers-user-denied/i))
      return dt("user rejected action", "ACTION_REJECTED", {
        action: {
          eth_sign: "signMessage",
          personal_sign: "signMessage",
          eth_signTypedData_v4: "signTypedData",
          eth_signTransaction: "signTransaction",
          eth_sendTransaction: "sendTransaction",
          eth_requestAccounts: "requestAccess",
          wallet_requestAccounts: "requestAccess"
        }[s] || "unknown",
        reason: "rejected",
        info: { payload: e, error: i }
      });
    if (s === "eth_sendRawTransaction" || s === "eth_sendTransaction") {
      const c = e.params[0];
      if (o.match(/insufficient funds|base fee exceeds gas limit/i))
        return dt("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction: c,
          info: { error: i }
        });
      if (o.match(/nonce/i) && o.match(/too low/i))
        return dt("nonce has already been used", "NONCE_EXPIRED", { transaction: c, info: { error: i } });
      if (o.match(/replacement transaction/i) && o.match(/underpriced/i))
        return dt("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction: c, info: { error: i } });
      if (o.match(/only replay-protected/i))
        return dt("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: s,
          info: { transaction: c, info: { error: i } }
        });
    }
    let a = !!o.match(/the method .* does not exist/i);
    return a || i && i.details && i.details.startsWith("Unauthorized method:") && (a = !0), a ? dt("unsupported operation", "UNSUPPORTED_OPERATION", {
      operation: e.method,
      info: { error: i, payload: e }
    }) : dt("could not coalesce error", "UNKNOWN_ERROR", { error: i, payload: e });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(e, n) {
    if (this.destroyed)
      return Promise.reject(dt("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: e }));
    const s = xs(this, hs)._++, i = new Promise((o, a) => {
      l(this, We).push({
        resolve: o,
        reject: a,
        payload: { method: e, params: n, id: s, jsonrpc: "2.0" }
      });
    });
    return I(this, ci, pa).call(this), i;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(e) {
    e == null && (e = 0);
    const n = this.send("eth_accounts", []);
    if (typeof e == "number") {
      const i = await n;
      if (e >= i.length)
        throw new Error("no such account");
      return new Go(this, i[e]);
    }
    const { accounts: s } = await Bt({
      network: this.getNetwork(),
      accounts: n
    });
    e = W(e);
    for (const i of s)
      if (W(i) === e)
        return new Go(this, e);
    throw new Error("invalid account");
  }
  async listAccounts() {
    return (await this.send("eth_accounts", [])).map((n) => new Go(this, n));
  }
  destroy() {
    l(this, Te) && (clearTimeout(l(this, Te)), d(this, Te, null));
    for (const { payload: e, reject: n } of l(this, We))
      n(dt("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: e.method }));
    d(this, We, []), super.destroy();
  }
}
nr = new WeakMap(), hs = new WeakMap(), We = new WeakMap(), Te = new WeakMap(), pe = new WeakMap(), Ye = new WeakMap(), ci = new WeakSet(), pa = function() {
  if (l(this, Te))
    return;
  const e = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
  d(this, Te, setTimeout(() => {
    d(this, Te, null);
    const n = l(this, We);
    for (d(this, We, []); n.length; ) {
      const s = [n.shift()];
      for (; n.length && s.length !== l(this, nr).batchMaxCount; )
        if (s.push(n.shift()), JSON.stringify(s.map((o) => o.payload)).length > l(this, nr).batchMaxSize) {
          n.unshift(s.pop());
          break;
        }
      (async () => {
        const i = s.length === 1 ? s[0].payload : s.map((o) => o.payload);
        this.emit("debug", { action: "sendRpcPayload", payload: i });
        try {
          const o = await this._send(i);
          this.emit("debug", { action: "receiveRpcResult", result: o });
          for (const { resolve: a, reject: c, payload: u } of s) {
            if (this.destroyed) {
              c(dt("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: u.method }));
              continue;
            }
            const f = o.filter((h) => h.id === u.id)[0];
            if (f == null) {
              const h = dt("missing response for request", "BAD_DATA", {
                value: o,
                info: { payload: u }
              });
              this.emit("error", h), c(h);
              continue;
            }
            if ("error" in f) {
              c(this.getRpcError(u, f));
              continue;
            }
            a(f.result);
          }
        } catch (o) {
          this.emit("debug", { action: "receiveRpcError", error: o });
          for (const { reject: a } of s)
            a(o);
        }
      })();
    }
  }, e));
};
var Nn;
class Sg extends kg {
  constructor(e, n) {
    super(e, n);
    b(this, Nn, void 0);
    d(this, Nn, 4e3);
  }
  _getSubscriber(e) {
    const n = super._getSubscriber(e);
    return lu(n) && (n.pollingInterval = l(this, Nn)), n;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return l(this, Nn);
  }
  set pollingInterval(e) {
    if (!Number.isInteger(e) || e < 0)
      throw new Error("invalid interval");
    d(this, Nn, e), this._forEachSubscriber((n) => {
      lu(n) && (n.pollingInterval = l(this, Nn));
    });
  }
}
Nn = new WeakMap();
function ga(r) {
  if (r == null)
    return null;
  if (typeof r.message == "string" && r.message.match(/revert/i) && it(r.data))
    return { message: r.message, data: r.data };
  if (typeof r == "object") {
    for (const t in r) {
      const e = ga(r[t]);
      if (e)
        return e;
    }
    return null;
  }
  if (typeof r == "string")
    try {
      return ga(JSON.parse(r));
    } catch {
    }
  return null;
}
function ya(r, t) {
  if (r != null) {
    if (typeof r.message == "string" && t.push(r.message), typeof r == "object")
      for (const e in r)
        ya(r[e], t);
    if (typeof r == "string")
      try {
        return ya(JSON.parse(r), t);
      } catch {
      }
  }
}
function Ug(r) {
  const t = [];
  return ya(r, t), t;
}
var ds;
class Dg extends Sg {
  /**
   *  Connnect to the %%ethereum%% provider, optionally forcing the
   *  %%network%%.
   */
  constructor(e, n) {
    super(n, { batchMaxCount: 1 });
    b(this, ds, void 0);
    d(this, ds, async (s, i) => {
      const o = { method: s, params: i };
      this.emit("debug", { action: "sendEip1193Request", payload: o });
      try {
        const a = await e.request(o);
        return this.emit("debug", { action: "receiveEip1193Result", result: a }), a;
      } catch (a) {
        const c = new Error(a.message);
        throw c.code = a.code, c.data = a.data, c.payload = o, this.emit("debug", { action: "receiveEip1193Error", error: c }), c;
      }
    });
  }
  async send(e, n) {
    return await this._start(), await super.send(e, n);
  }
  async _send(e) {
    y(!Array.isArray(e), "EIP-1193 does not support batch request", "payload", e);
    try {
      const n = await l(this, ds).call(this, e.method, e.params || []);
      return [{ id: e.id, result: n }];
    } catch (n) {
      return [{
        id: e.id,
        error: { code: n.code, data: n.data, message: n.message }
      }];
    }
  }
  getRpcError(e, n) {
    switch (n = JSON.parse(JSON.stringify(n)), n.error.code || -1) {
      case 4001:
        n.error.message = `ethers-user-denied: ${n.error.message}`;
        break;
      case 4200:
        n.error.message = `ethers-unsupported: ${n.error.message}`;
        break;
    }
    return super.getRpcError(e, n);
  }
  /**
   *  Resolves to ``true`` if the provider manages the %%address%%.
   */
  async hasSigner(e) {
    e == null && (e = 0);
    const n = await this.send("eth_accounts", []);
    return typeof e == "number" ? n.length > e : (e = e.toLowerCase(), n.filter((s) => s.toLowerCase() === e).length !== 0);
  }
  async getSigner(e) {
    if (e == null && (e = 0), !await this.hasSigner(e))
      try {
        await l(this, ds).call(this, "eth_requestAccounts", []);
      } catch (n) {
        const s = n.payload;
        throw this.getRpcError(s, { id: s.id, error: n });
      }
    return await super.getSigner(e);
  }
}
ds = new WeakMap();
const go = new Dg(window.ethereum);
let xi, Pi;
async function ji() {
  return xi ? Promise.resolve(xi) : Pi || (Pi = new Promise(async (r) => {
    await window.ethereum.enable(), xi = await go.getSigner(), r(xi);
  }), Pi);
}
function Fg({
  activating: r,
  activationFunctions: t,
  selectedFunctionId: e,
  balance: n
}) {
  return console.log(t, e), /* @__PURE__ */ q.jsxs(q.Fragment, { children: [
    /* @__PURE__ */ q.jsx(
      "div",
      {
        className: r === "unactivated" ? "opacity-100" : "opacity-0",
        children: /* @__PURE__ */ q.jsxs("p", { className: "text-sm text-center", children: [
          t[e].context,
          /* @__PURE__ */ q.jsx("br", {}),
          /* @__PURE__ */ q.jsx("br", {}),
          t[e].description,
          /* @__PURE__ */ q.jsx("br", {}),
          /* @__PURE__ */ q.jsx("br", {}),
          "Reward:",
          " ",
          String(
            t[e].multiplier * t[e].weightInWatt
          ),
          " ",
          "Verification WATT"
        ] })
      }
    ),
    r === "activating" && /* @__PURE__ */ q.jsx(
      "img",
      {
        src: "./assets/loading.png",
        alt: "Loading...",
        className: "absolute top-16 w-20 h-20"
      }
    ),
    r === "activated" && /* @__PURE__ */ q.jsxs("div", { children: [
      "activated $",
      n,
      " WATTS"
    ] })
  ] });
}
const Lg = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_poC",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint256",
        name: "activationFunctionId",
        type: "uint256"
      }
    ],
    name: "ActivationFunctionApproved",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint256",
        name: "activationFunctionId",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "address",
        name: "developer",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "string",
        name: "context",
        type: "string"
      }
    ],
    name: "ActivationFunctionRegistered",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "addr",
        type: "address"
      }
    ],
    name: "DebugAddress",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "activationFunctionId",
        type: "uint256"
      }
    ],
    name: "activate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "activationFunctions",
    outputs: [
      {
        internalType: "address",
        name: "issuer",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      },
      {
        internalType: "enum NewcoinEncoder.WattType",
        name: "wattType",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "multiplier",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "contextId",
        type: "bytes32"
      },
      {
        internalType: "string",
        name: "context",
        type: "string"
      },
      {
        internalType: "string",
        name: "description",
        type: "string"
      },
      {
        internalType: "address",
        name: "addrss",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "weightInWatt",
        type: "uint256"
      },
      {
        internalType: "bool",
        name: "isAsync",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "activationFunctionId",
        type: "uint256"
      }
    ],
    name: "approveActivationFunction",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "activationFunctionId",
        type: "uint256"
      }
    ],
    name: "canMint",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getApprovedActivationFunctions",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "issuer",
            type: "address"
          },
          {
            internalType: "bool",
            name: "approved",
            type: "bool"
          },
          {
            internalType: "enum NewcoinEncoder.WattType",
            name: "wattType",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "multiplier",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "contextId",
            type: "bytes32"
          },
          {
            internalType: "string",
            name: "context",
            type: "string"
          },
          {
            internalType: "string",
            name: "description",
            type: "string"
          },
          {
            internalType: "address",
            name: "addrss",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "weightInWatt",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "isAsync",
            type: "bool"
          }
        ],
        internalType: "struct NewcoinEncoder.ActivationFunction[]",
        name: "",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "conditionMet",
        type: "bool"
      },
      {
        internalType: "uint256",
        name: "activationFunctionId",
        type: "uint256"
      }
    ],
    name: "oracleResponse",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "poC",
    outputs: [
      {
        internalType: "contract EnergyMinterMock",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum NewcoinEncoder.WattType",
        name: "_wattType",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "_multiplier",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "_contextId",
        type: "bytes32"
      },
      {
        internalType: "string",
        name: "_context",
        type: "string"
      },
      {
        internalType: "string",
        name: "_description",
        type: "string"
      },
      {
        internalType: "address",
        name: "_addrss",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_weightInWatt",
        type: "uint256"
      },
      {
        internalType: "bool",
        name: "_isAsync",
        type: "bool"
      }
    ],
    name: "registerActivationFunction",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
], Mg = "0x84387e3ad062D683BFc7eD2Eeaf2C30B27Bd3d05", $l = new Tn(
  Mg,
  Lg,
  go
), Gg = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "bytes32",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "ChainlinkCancelled",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "bytes32",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "ChainlinkFulfilled",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "bytes32",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "ChainlinkRequested",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "OwnershipTransferRequested",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "requester",
        type: "address"
      }
    ],
    name: "RequestFulfilled",
    type: "event"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_activationFunctionId",
        type: "uint256"
      }
    ],
    name: "activate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "requestId",
        type: "bytes32"
      },
      {
        internalType: "bool",
        name: "data",
        type: "bool"
      }
    ],
    name: "fulfill",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getFeeInHundredthsOfLink",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getJobId",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getOracleAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "passportHolders",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "request",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    name: "requesters",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "response",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_feeInHundredthsOfLink",
        type: "uint256"
      }
    ],
    name: "setFeeInHundredthsOfLink",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_feeInJuels",
        type: "uint256"
      }
    ],
    name: "setFeeInJuels",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_jobId",
        type: "string"
      }
    ],
    name: "setJobId",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_oracleAddress",
        type: "address"
      }
    ],
    name: "setOracleAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "withdrawLink",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], Qg = "0xf192Ee5a9fB9AE3A8dee79669CFd2BA8C8441d9c", Hg = new Tn(
  Qg,
  Gg,
  go
), _g = [
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint8",
        name: "id",
        type: "uint8"
      }
    ],
    name: "balanceOfEnergy",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOfWatts",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint8",
        name: "id",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "mint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    name: "neuralTokenBalances",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "wattBalances",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
], Vg = "0xf272Fe62eEdCBCf7221D8451a68a85c3AF4fAcFe", Jg = new Tn(
  Vg,
  _g,
  go
);
function zi(r, t, e) {
  const [n, s] = kn(e);
  return hu(() => {
    let i = !1;
    const o = r();
    if (o != null)
      return o.then((a) => {
        i || s(a);
      }), () => {
        i = !0;
      };
  }, t), n;
}
const tf = ({
  setActivating: r,
  setBalance: t,
  selectedFunctionId: e,
  contractType: n,
  contractAddress: s
}) => {
  const i = async (a) => {
    const c = await ji();
    let {
      selectedFunctionId: u,
      contractType: f,
      contractAddress: h
      // params 
    } = a || {};
    f = f || n || "guildAFContract", h = h || s || "";
    const g = typeof u < "u" ? u : e;
    try {
      await Hg.connect(
        c
      ).request(), setTimeout(async () => {
        try {
          await (await $l.connect(
            c
          ).activate(g)).wait(), o();
        } catch (E) {
          console.log("Error during activation: ", E);
        }
      }, 6e4);
    } catch (w) {
      console.log("Error during request: ", w);
    }
    r("activating");
  }, o = async () => {
    const a = zi(ji, []), c = Jg.connect(
      a
    );
    try {
      const u = await a.getAddress(), f = await c.balanceOfWatts(u);
      console.log("Balance of Watts: ", f.toString()), t(f.toString()), r("activated");
    } catch (u) {
      console.log("Error fetching balance: ", u);
    }
  };
  return {
    activate: i
  };
};
function jg({
  activating: r,
  setActivating: t,
  setBalance: e,
  selectedFunctionId: n,
  render: s
}) {
  const i = zi(ji, []), { activate: o } = tf({
    activating: r,
    setActivating: t,
    setBalance: e,
    selectedFunctionId: n
  }), a = s || ((c) => /* @__PURE__ */ q.jsx("button", { ...c }));
  return i ? /* @__PURE__ */ q.jsx(
    a,
    {
      onClick: () => o(),
      className: `py-2 px-4 text-white rounded-full w-40 ${r === "activating" ? "bg-gray-400" : "bg-black"}`,
      disabled: r === "activating",
      children: r === "activating" ? "Activating" : "Activate"
    }
  ) : /* @__PURE__ */ q.jsx(q.Fragment, { children: "Wait..." });
}
function zg({
  activationFunctions: r,
  setSelectedFunctionId: t,
  selectedFunctionId: e
}) {
  const n = (s) => {
    const i = Number(s.target.value);
    t(i);
  };
  return hu(() => {
    console.log(e);
  }, [e]), /* @__PURE__ */ q.jsxs(
    "select",
    {
      onChange: n,
      value: e,
      className: `py-2 px-4 text-xs text-black rounded-full w-40 border border-black ${e ? "bg-gray-200" : "bg-white"}`,
      children: [
        /* @__PURE__ */ q.jsx("option", { value: "", disabled: !0, children: "Select an activation function" }),
        r.map((s, i) => /* @__PURE__ */ q.jsxs("option", { value: i, children: [
          s.context,
          " ",
          s.id
        ] }, s.id))
      ]
    }
  );
}
const Kg = (r, t) => {
  const [e, n] = kn("unactivated"), [s, i] = kn("0"), [o, a] = kn(0), [c, u] = kn(!1), [f, h] = kn(!1), [g, w] = kn(!1), E = () => u(!0), m = zi(async () => {
    if (!(c || t))
      return Promise.resolve();
    h(!0);
    const D = await ji();
    return h(!1), w(!!D), D;
  }, [c, t]), v = zi(async () => {
    if (!m)
      return;
    const k = await $l.connect(
      m
    ).getApprovedActivationFunctions();
    return console.log(k), k;
  }, [m, r], []) || [], B = /* @__PURE__ */ q.jsx(
    zg,
    {
      selectedFunctionId: o,
      setSelectedFunctionId: a,
      activationFunctions: v
    }
  ), T = /* @__PURE__ */ q.jsx(
    Fg,
    {
      activating: e,
      activationFunctions: v,
      selectedFunctionId: o,
      balance: s
    }
  ), H = {
    activating: e,
    setActivating: n,
    balance: s,
    setBalance: i,
    selectedFunctionId: o
  }, G = /* @__PURE__ */ q.jsx(
    jg,
    {
      ...H
    }
  ), { activate: U } = tf(H);
  return {
    activate: U,
    activationFunctions: v,
    setActivating: n,
    activating: e,
    selectedFunctionId: o,
    setSelectedFunctionId: a,
    balance: s,
    setBalance: i,
    button: G,
    panel: T,
    dropDown: B,
    connect: E,
    isConnecting: f,
    isConnected: g,
    signer: m
  };
};
function Wg() {
  const {
    activationFunctions: r,
    setActivating: t,
    activating: e,
    selectedFunctionId: n,
    setSelectedFunctionId: s,
    balance: i,
    setBalance: o,
    connect: a,
    button: c,
    panel: u,
    dropDown: f,
    isConnected: h
  } = Kg("0x84387e3ad062D683BFc7eD2Eeaf2C30B27Bd3d05");
  return /* @__PURE__ */ q.jsx("div", { className: "min-h-screen flex items-center justify-center", children: /* @__PURE__ */ q.jsxs("div", { className: "relative flex flex-col items-center justify-between pl-2 pr-2 pt-8 pb-8 border border-black w-64 h-96", children: [
    !h && /* @__PURE__ */ q.jsx("button", { onClick: () => a(), children: "connect" }),
    /* @__PURE__ */ q.jsx("br", {}),
    /* @__PURE__ */ q.jsx("br", {}),
    r.length > 0 && /* @__PURE__ */ q.jsx(q.Fragment, { children: /* @__PURE__ */ q.jsxs(q.Fragment, { children: [
      e != "activating" && f,
      u,
      c
    ] }) })
  ] }) });
}
const $g = Wg;
export {
  $g as ActivationByContractAddress,
  Wg as default,
  Kg as useActivationFunctions,
  tf as useButton
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWYtd2lkZ2V0LmpzIiwic291cmNlcyI6WyIuLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1ydW50aW1lLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL192ZXJzaW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3Byb3BlcnRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXJyb3JzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2RhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvbWF0aHMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTU4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2Jhc2U2NC1icm93c2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2V2ZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy91dGY4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2dldHVybC1icm93c2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2ZldGNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3JscC1kZWNvZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcmxwLWVuY29kZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8va2VjY2FrLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29uc3RhbnRzL2FkZHJlc3Nlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvaGFzaGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9zaWduYXR1cmUuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25pbmcta2V5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FkZHJlc3MvYWRkcmVzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2NvbnRyYWN0LWFkZHJlc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9jaGVja3MuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL3R5cGVkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYWRkcmVzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2Fub255bW91cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYm9vbGVhbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2J5dGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvZml4ZWQtYnl0ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udWxsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvbnVtYmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvc3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvdHVwbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9pZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AYWRyYWZmeS9lbnMtbm9ybWFsaXplL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvbmFtZWhhc2guanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYWNjZXNzbGlzdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9hZGRyZXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvdHlwZWQtZGF0YS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvZnJhZ21lbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9hYmktY29kZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ludGVyZmFjZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3Qvd3JhcHBlcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3QvY29udHJhY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Vucy1yZXNvbHZlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvZm9ybWF0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wbHVnaW5zLW5ldHdvcmsuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL25ldHdvcmsuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3N1YnNjcmliZXItcG9sbGluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXNpZ25lci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc3Vic2NyaWJlci1maWx0ZXJpZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItanNvbnJwYy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItYnJvd3Nlci5qcyIsIi4uL3NyYy9jb250cmFjdHMvZXRoZXJzUHJvdmlkZXIudHMiLCIuLi9zcmMvY29tcG9uZW50cy9QYW5lbC50c3giLCIuLi9zcmMvY29udHJhY3RzL0VuY29kZXJDb250cmFjdC9hYmkudHMiLCIuLi9zcmMvY29udHJhY3RzL0VuY29kZXJDb250cmFjdC9jb250cmFjdC50cyIsIi4uL3NyYy9jb250cmFjdHMvZ3VpbGRBRkNvbnRyYWN0L2FiaS50cyIsIi4uL3NyYy9jb250cmFjdHMvZ3VpbGRBRkNvbnRyYWN0L2NvbnRyYWN0LnRzIiwiLi4vc3JjL2NvbnRyYWN0cy93YXR0c0NvbnRyYWN0L2FiaS50cyIsIi4uL3NyYy9jb250cmFjdHMvd2F0dHNDb250cmFjdC9jb250cmFjdC50cyIsIi4uL3NyYy91dGlscy91c2VBc3luY01lbW8udHMiLCIuLi9zcmMvY29tcG9uZW50cy9CdXR0b24udHN4IiwiLi4vc3JjL2NvbXBvbmVudHMvRHJvcGRvd24udHN4IiwiLi4vc3JjL0FwcC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXG4gKiByZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7cmVxdWlyZShcIm9iamVjdC1hc3NpZ25cIik7dmFyIGY9cmVxdWlyZShcInJlYWN0XCIpLGc9NjAxMDM7ZXhwb3J0cy5GcmFnbWVudD02MDEwNztpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yKXt2YXIgaD1TeW1ib2wuZm9yO2c9aChcInJlYWN0LmVsZW1lbnRcIik7ZXhwb3J0cy5GcmFnbWVudD1oKFwicmVhY3QuZnJhZ21lbnRcIil9dmFyIG09Zi5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lcixuPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkscD17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuZnVuY3Rpb24gcShjLGEsayl7dmFyIGIsZD17fSxlPW51bGwsbD1udWxsO3ZvaWQgMCE9PWsmJihlPVwiXCIrayk7dm9pZCAwIT09YS5rZXkmJihlPVwiXCIrYS5rZXkpO3ZvaWQgMCE9PWEucmVmJiYobD1hLnJlZik7Zm9yKGIgaW4gYSluLmNhbGwoYSxiKSYmIXAuaGFzT3duUHJvcGVydHkoYikmJihkW2JdPWFbYl0pO2lmKGMmJmMuZGVmYXVsdFByb3BzKWZvcihiIGluIGE9Yy5kZWZhdWx0UHJvcHMsYSl2b2lkIDA9PT1kW2JdJiYoZFtiXT1hW2JdKTtyZXR1cm57JCR0eXBlb2Y6Zyx0eXBlOmMsa2V5OmUscmVmOmwscHJvcHM6ZCxfb3duZXI6bS5jdXJyZW50fX1leHBvcnRzLmpzeD1xO2V4cG9ydHMuanN4cz1xO1xuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjJcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG4vLyBldmVuIHdpdGggdGhlIHByb2QgdHJhbnNmb3JtLiBUaGlzIG1lYW5zIHRoYXQganN4REVWIGlzIHB1cmVseVxuLy8gb3B0LWluIGJlaGF2aW9yIGZvciBiZXR0ZXIgbWVzc2FnZXMgYnV0IHRoYXQgd2Ugd29uJ3Qgc3RvcFxuLy8gZ2l2aW5nIHlvdSB3YXJuaW5ncyBpZiB5b3UgdXNlIHByb2R1Y3Rpb24gYXBpcy5cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25TdGF0aWModHlwZSwgcHJvcHMsIGtleSkge1xuICB7XG4gICAgcmV0dXJuIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWModHlwZSwgcHJvcHMsIGtleSkge1xuICB7XG4gICAgcmV0dXJuIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGZhbHNlKTtcbiAgfVxufVxuXG52YXIganN4ID0gIGpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyA7IC8vIHdlIG1heSB3YW50IHRvIHNwZWNpYWwgY2FzZSBqc3hzIGludGVybmFsbHkgdG8gdGFrZSBhZHZhbnRhZ2Ugb2Ygc3RhdGljIGNoaWxkcmVuLlxuLy8gZm9yIG5vdyB3ZSBjYW4gc2hpcCBpZGVudGljYWwgcHJvZCBmdW5jdGlvbnNcblxudmFyIGpzeHMgPSAganN4V2l0aFZhbGlkYXRpb25TdGF0aWMgO1xuXG5leHBvcnRzLmpzeCA9IGpzeDtcbmV4cG9ydHMuanN4cyA9IGpzeHM7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qIERvIE5PVCBtb2RpZnkgdGhpcyBmaWxlOyBzZWUgL3NyYy50cy9fYWRtaW4vdXBkYXRlLXZlcnNpb24udHMgKi9cbi8qKlxuICogIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgRXRoZXJzLlxuICovXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiNi44LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCIsIi8qKlxuICogIFByb3BlcnR5IGhlbHBlciBmdW5jdGlvbnMuXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6UHJvcGVydGllcyAgW2Fib3V0LXByb3BlcnRpZXNdXG4gKi9cbmZ1bmN0aW9uIGNoZWNrVHlwZSh2YWx1ZSwgdHlwZSwgbmFtZSkge1xuICAgIGNvbnN0IHR5cGVzID0gdHlwZS5zcGxpdChcInxcIikubWFwKHQgPT4gdC50cmltKCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYW55XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaW52YWxpZCB2YWx1ZSBmb3IgdHlwZSAke3R5cGV9YCk7XG4gICAgZXJyb3IuY29kZSA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiO1xuICAgIGVycm9yLmFyZ3VtZW50ID0gYHZhbHVlLiR7bmFtZX1gO1xuICAgIGVycm9yLnZhbHVlID0gdmFsdWU7XG4gICAgdGhyb3cgZXJyb3I7XG59XG4vKipcbiAqICBSZXNvbHZlcyB0byBhIG5ldyBvYmplY3QgdGhhdCBpcyBhIGNvcHkgb2YgJSV2YWx1ZSUlLCBidXQgd2l0aCBhbGxcbiAqICB2YWx1ZXMgcmVzb2x2ZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlUHJvcGVydGllcyh2YWx1ZSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGtleXMubWFwKChrKSA9PiBQcm9taXNlLnJlc29sdmUodmFsdWVba10pKSk7XG4gICAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKChhY2N1bSwgdiwgaW5kZXgpID0+IHtcbiAgICAgICAgYWNjdW1ba2V5c1tpbmRleF1dID0gdjtcbiAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIHt9KTtcbn1cbi8qKlxuICogIEFzc2lnbnMgdGhlICUldmFsdWVzJSUgdG8gJSV0YXJnZXQlJSBhcyByZWFkLW9ubHkgdmFsdWVzLlxuICpcbiAqICBJdCAlJXR5cGVzJSUgaXMgc3BlY2lmaWVkLCB0aGUgdmFsdWVzIGFyZSBjaGVja2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHZhbHVlcywgdHlwZXMpIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gdmFsdWVzKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHZhbHVlc1trZXldO1xuICAgICAgICBjb25zdCB0eXBlID0gKHR5cGVzID8gdHlwZXNba2V5XSA6IG51bGwpO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgY2hlY2tUeXBlKHZhbHVlLCB0eXBlLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZSwgd3JpdGFibGU6IGZhbHNlIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnRpZXMuanMubWFwIiwiLyoqXG4gKiAgQWxsIGVycm9ycyBpbiBldGhlcnMgaW5jbHVkZSBwcm9wZXJ0aWVzIHRvIGVuc3VyZSB0aGV5IGFyZSBib3RoXG4gKiAgaHVtYW4tcmVhZGFibGUgKGkuZS4gYGAubWVzc2FnZWBgKSBhbmQgbWFjaGluZS1yZWFkYWJsZSAoaS5lLiBgYC5jb2RlYGApLlxuICpcbiAqICBUaGUgW1tpc0Vycm9yXV0gZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gY2hlY2sgdGhlIGVycm9yIGBgY29kZWBgIGFuZFxuICogIHByb3ZpZGUgYSB0eXBlIGd1YXJkIGZvciB0aGUgcHJvcGVydGllcyBwcmVzZW50IG9uIHRoYXQgZXJyb3IgaW50ZXJmYWNlLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS91dGlscy9lcnJvcnM6RXJyb3JzICBbYWJvdXQtZXJyb3JzXVxuICovXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL192ZXJzaW9uLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiWyBcIiArICh2YWx1ZS5tYXAoc3RyaW5naWZ5KSkuam9pbihcIiwgXCIpICsgXCIgXVwiO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGNvbnN0IEhFWCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gSEVYW3ZhbHVlW2ldID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IEhFWFt2YWx1ZVtpXSAmIDB4Zl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiAodmFsdWUudG9KU09OKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkodmFsdWUudG9KU09OKCkpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgICAgICBrZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBcInsgXCIgKyBrZXlzLm1hcCgoaykgPT4gYCR7c3RyaW5naWZ5KGspfTogJHtzdHJpbmdpZnkodmFsdWVba10pfWApLmpvaW4oXCIsIFwiKSArIFwiIH1cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYFsgQ09VTEQgTk9UIFNFUklBTElaRSBdYDtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgJSVlcnJvciUlIG1hdGNoZXMgYW4gZXJyb3IgdGhyb3duIGJ5IGV0aGVyc1xuICogIHRoYXQgbWF0Y2hlcyB0aGUgZXJyb3IgJSVjb2RlJSUuXG4gKlxuICogIEluIFR5cGVTY3JpcHQgZW52b3Jub21lbnRzLCB0aGlzIGNhbiBiZSB1c2VkIHRvIGNoZWNrIHRoYXQgJSVlcnJvciUlXG4gKiAgbWF0Y2hlcyBhbiBFdGhlcnNFcnJvciB0eXBlLCB3aGljaCBtZWFucyB0aGUgZXhwZWN0ZWQgcHJvcGVydGllcyB3aWxsXG4gKiAgYmUgc2V0LlxuICpcbiAqICBAU2VlIFtFcnJvckNvZGVzXShhcGk6RXJyb3JDb2RlKVxuICogIEBleGFtcGxlXG4gKiAgICB0cnkge1xuICogICAgICAvLyBjb2RlLi4uLlxuICogICAgfSBjYXRjaCAoZSkge1xuICogICAgICBpZiAoaXNFcnJvcihlLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gKiAgICAgICAgICAvLyBUaGUgVHlwZSBHdWFyZCBoYXMgdmFsaWRhdGVkIHRoaXMgb2JqZWN0XG4gKiAgICAgICAgICBjb25zb2xlLmxvZyhlLmRhdGEpO1xuICogICAgICB9XG4gKiAgICB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Vycm9yKGVycm9yLCBjb2RlKSB7XG4gICAgcmV0dXJuIChlcnJvciAmJiBlcnJvci5jb2RlID09PSBjb2RlKTtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJWVycm9yJSUgaXMgYSBbW0NhbGxFeGNlcHRpb25FcnJvcl0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NhbGxFeGNlcHRpb24oZXJyb3IpIHtcbiAgICByZXR1cm4gaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKTtcbn1cbi8qKlxuICogIFJldHVybnMgYSBuZXcgRXJyb3IgY29uZmlndXJlZCB0byB0aGUgZm9ybWF0IGV0aGVycyBlbWl0cyBlcnJvcnMsIHdpdGhcbiAqICB0aGUgJSVtZXNzYWdlJSUsIFtbYXBpOkVycm9yQ29kZV1dICUlY29kZSUlIGFuZCBhZGRpdGlvYW5sIHByb3BlcnRpZXNcbiAqICBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgRXRoZXJzRXJyb3IuXG4gKlxuICogIEVhY2ggZXJyb3IgaW4gZXRoZXJzIGluY2x1ZGVzIHRoZSB2ZXJzaW9uIG9mIGV0aGVycywgYVxuICogIG1hY2hpbmUtcmVhZGFibGUgW1tFcnJvckNvZGVdXSwgYW5kIGRlcG5lZGluZyBvbiAlJWNvZGUlJSwgYWRkaXRpb25hbFxuICogIHJlcXVpcmVkIHByb3BlcnRpZXMuIFRoZSBlcnJvciBtZXNzYWdlIHdpbGwgYWxzbyBpbmNsdWRlIHRoZSAlJW1lZWFnZSUlLFxuICogIGV0aGVycyB2ZXJzaW9uLCAlJWNvZGUlJSBhbmQgYWxsIGFkaXRpb25hbCBwcm9wZXJ0aWVzLCBzZXJpYWxpemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIGluZm8pIHtcbiAgICBsZXQgc2hvcnRNZXNzYWdlID0gbWVzc2FnZTtcbiAgICB7XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBbXTtcbiAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgIGlmIChcIm1lc3NhZ2VcIiBpbiBpbmZvIHx8IFwiY29kZVwiIGluIGluZm8gfHwgXCJuYW1lXCIgaW4gaW5mbykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsdWUgd2lsbCBvdmVyd3JpdGUgcG9wdWxhdGVkIHZhbHVlczogJHtzdHJpbmdpZnkoaW5mbyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJzaG9ydE1lc3NhZ2VcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAoaW5mb1trZXldKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRldGFpbHMucHVzaChrZXkgKyBcIj1cIiArIHN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1NTVwiLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKGtleSArIFwiPVtjb3VsZCBub3Qgc2VyaWFsaXplIG9iamVjdF1cIik7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRldGFpbHMucHVzaChgY29kZT0ke2NvZGV9YCk7XG4gICAgICAgIGRldGFpbHMucHVzaChgdmVyc2lvbj0ke3ZlcnNpb259YCk7XG4gICAgICAgIGlmIChkZXRhaWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoXCIgKyBkZXRhaWxzLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBlcnJvcjtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSBcIklOVkFMSURfQVJHVU1FTlRcIjpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFR5cGVFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTlVNRVJJQ19GQVVMVFwiOlxuICAgICAgICBjYXNlIFwiQlVGRkVSX09WRVJSVU5cIjpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFJhbmdlRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKGVycm9yLCB7IGNvZGUgfSk7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihlcnJvciwgaW5mbyk7XG4gICAgfVxuICAgIGlmIChlcnJvci5zaG9ydE1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKGVycm9yLCB7IHNob3J0TWVzc2FnZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xufVxuLyoqXG4gKiAgVGhyb3dzIGFuIEV0aGVyc0Vycm9yIHdpdGggJSVtZXNzYWdlJSUsICUlY29kZSUlIGFuZCBhZGRpdGlvbmFsIGVycm9yXG4gKiAgJSVpbmZvJSUgd2hlbiAlJWNoZWNrJSUgaXMgZmFsc2lzaC4uXG4gKlxuICogIEBzZWUgW1thcGk6bWFrZUVycm9yXV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChjaGVjaywgbWVzc2FnZSwgY29kZSwgaW5mbykge1xuICAgIGlmICghY2hlY2spIHtcbiAgICAgICAgdGhyb3cgbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIGluZm8pO1xuICAgIH1cbn1cbi8qKlxuICogIEEgc2ltcGxlIGhlbHBlciB0byBzaW1wbHkgZW5zdXJpbmcgcHJvdmlkZWQgYXJndW1lbnRzIG1hdGNoIGV4cGVjdGVkXG4gKiAgY29uc3RyYWludHMsIHRocm93aW5nIGlmIG5vdC5cbiAqXG4gKiAgSW4gVHlwZVNjcmlwdCBlbnZpcm9ubWVudHMsIHRoZSAlJWNoZWNrJSUgaGFzIGJlZW4gYXNzZXJ0ZWQgdHJ1ZSwgc29cbiAqICBhbnkgZnVydGhlciBjb2RlIGRvZXMgbm90IG5lZWQgYWRkaXRpb25hbCBjb21waWxlLXRpbWUgY2hlY2tzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0QXJndW1lbnQoY2hlY2ssIG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgYXNzZXJ0KGNoZWNrLCBtZXNzYWdlLCBcIklOVkFMSURfQVJHVU1FTlRcIiwgeyBhcmd1bWVudDogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50Q291bnQoY291bnQsIGV4cGVjdGVkQ291bnQsIG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlID0gXCI6IFwiICsgbWVzc2FnZTtcbiAgICB9XG4gICAgYXNzZXJ0KGNvdW50ID49IGV4cGVjdGVkQ291bnQsIFwibWlzc2luZyBhcmd1ZW1udFwiICsgbWVzc2FnZSwgXCJNSVNTSU5HX0FSR1VNRU5UXCIsIHtcbiAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgfSk7XG4gICAgYXNzZXJ0KGNvdW50IDw9IGV4cGVjdGVkQ291bnQsIFwidG9vIG1hbnkgYXJndWVtbnRzXCIgKyBtZXNzYWdlLCBcIlVORVhQRUNURURfQVJHVU1FTlRcIiwge1xuICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICB9KTtcbn1cbmNvbnN0IF9ub3JtYWxpemVGb3JtcyA9IFtcIk5GRFwiLCBcIk5GQ1wiLCBcIk5GS0RcIiwgXCJORktDXCJdLnJlZHVjZSgoYWNjdW0sIGZvcm0pID0+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBHZW5lcmFsIHRlc3QgZm9yIG5vcm1hbGl6ZVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKFwidGVzdFwiLm5vcm1hbGl6ZShmb3JtKSAhPT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZFwiKTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGlmIChmb3JtID09PSBcIk5GRFwiKSB7XG4gICAgICAgICAgICBjb25zdCBjaGVjayA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlOSkubm9ybWFsaXplKFwiTkZEXCIpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4NjUsIDB4MDMwMSk7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmIChjaGVjayAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJicm9rZW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB9XG4gICAgICAgIGFjY3VtLnB1c2goZm9ybSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIGFjY3VtO1xufSwgW10pO1xuLyoqXG4gKiAgVGhyb3dzIGlmIHRoZSBub3JtYWxpemF0aW9uICUlZm9ybSUlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROb3JtYWxpemUoZm9ybSkge1xuICAgIGFzc2VydChfbm9ybWFsaXplRm9ybXMuaW5kZXhPZihmb3JtKSA+PSAwLCBcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICBvcGVyYXRpb246IFwiU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgaW5mbzogeyBmb3JtIH1cbiAgICB9KTtcbn1cbi8qKlxuICogIE1hbnkgY2xhc3NlcyB1c2UgZmlsZS1zY29wZWQgdmFsdWVzIHRvIGd1YXJkIHRoZSBjb25zdHJ1Y3RvcixcbiAqICBtYWtpbmcgaXQgZWZmZWN0aXZlbHkgcHJpdmF0ZS4gVGhpcyBmYWNpbGl0YXRlcyB0aGF0IHBhdHRlcm5cbiAqICBieSBlbnN1cmluZyB0aGUgJSVnaXZlbkdhdXJkJSUgbWF0Y2hlcyB0aGUgZmlsZS1zY29wZWQgJSVndWFyZCUlLFxuICogIHRocm93aW5nIGlmIG5vdCwgaW5kaWNhdGluZyB0aGUgJSVjbGFzc05hbWUlJSBpZiBwcm92aWRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFByaXZhdGUoZ2l2ZW5HdWFyZCwgZ3VhcmQsIGNsYXNzTmFtZSkge1xuICAgIGlmIChjbGFzc05hbWUgPT0gbnVsbCkge1xuICAgICAgICBjbGFzc05hbWUgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAoZ2l2ZW5HdWFyZCAhPT0gZ3VhcmQpIHtcbiAgICAgICAgbGV0IG1ldGhvZCA9IGNsYXNzTmFtZSwgb3BlcmF0aW9uID0gXCJuZXdcIjtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgbWV0aG9kICs9IFwiLlwiO1xuICAgICAgICAgICAgb3BlcmF0aW9uICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgYHByaXZhdGUgY29uc3RydWN0b3I7IHVzZSAke21ldGhvZH1mcm9tKiBtZXRob2RzYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiLCIvKipcbiAqICBTb21lIGRhdGEgaGVscGVycy5cbiAqXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6RGF0YSBIZWxwZXJzICBbYWJvdXQtZGF0YV1cbiAqL1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZnVuY3Rpb24gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCBjb3B5KSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5tYXRjaCgvXjB4KFswLTlhLWZdWzAtOWEtZl0pKiQvaSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoKHZhbHVlLmxlbmd0aCAtIDIpIC8gMik7XG4gICAgICAgIGxldCBvZmZzZXQgPSAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0ICsgMiksIDE2KTtcbiAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgQnl0ZXNMaWtlIHZhbHVlXCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG4vKipcbiAqICBHZXQgYSB0eXBlZCBVaW50OEFycmF5IGZvciAlJXZhbHVlJSUuIElmIGFscmVhZHkgYSBVaW50OEFycmF5XG4gKiAgdGhlIG9yaWdpbmFsICUldmFsdWUlJSBpcyByZXR1cm5lZDsgaWYgYSBjb3B5IGlzIHJlcXVpcmVkIHVzZVxuICogIFtbZ2V0Qnl0ZXNDb3B5XV0uXG4gKlxuICogIEBzZWU6IGdldEJ5dGVzQ29weVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qnl0ZXModmFsdWUsIG5hbWUpIHtcbiAgICByZXR1cm4gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCBmYWxzZSk7XG59XG4vKipcbiAqICBHZXQgYSB0eXBlZCBVaW50OEFycmF5IGZvciAlJXZhbHVlJSUsIGNyZWF0aW5nIGEgY29weSBpZiBuZWNlc3NhcnlcbiAqICB0byBwcmV2ZW50IGFueSBtb2RpZmljYXRpb25zIG9mIHRoZSByZXR1cm5lZCB2YWx1ZSBmcm9tIGJlaW5nXG4gKiAgcmVmbGVjdGVkIGVsc2V3aGVyZS5cbiAqXG4gKiAgQHNlZTogZ2V0Qnl0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJ5dGVzQ29weSh2YWx1ZSwgbmFtZSkge1xuICAgIHJldHVybiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIHRydWUpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIFtbSGV4U3RyaW5nXV0uXG4gKlxuICogIElmICUlbGVuZ3RoJSUgaXMgYGB0cnVlYGAgb3IgYSAvL251bWJlci8vLCBpdCBhbHNvIGNoZWNrcyB0aGF0XG4gKiAgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVsZW5ndGglJSAoaWYgYSAvL251bWJlci8vKVxuICogIGJ5dGVzIG9mIGRhdGEgKGUuZy4gYGAweDEyMzRgYCBpcyAyIGJ5dGVzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChsZW5ndGgpID09PSBcIm51bWJlclwiICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoID09PSB0cnVlICYmICh2YWx1ZS5sZW5ndGggJSAyKSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIHJlcHJlc2VudGF0aW9uIG9mIGFyYml0cmFyeVxuICogIGRhdGEgKGkuZS4gYSB2YWxpZCBbW0RhdGFIZXhTdHJpbmddXSBvciBhIFVpbnQ4QXJyYXkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlc0xpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gKGlzSGV4U3RyaW5nKHZhbHVlLCB0cnVlKSB8fCAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSk7XG59XG5jb25zdCBIZXhDaGFyYWN0ZXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4vKipcbiAqICBSZXR1cm5zIGEgW1tEYXRhSGV4U3RyaW5nXV0gcmVwcmVzZW50YXRpb24gb2YgJSVkYXRhJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhsaWZ5KGRhdGEpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2ID0gYnl0ZXNbaV07XG4gICAgICAgIHJlc3VsdCArPSBIZXhDaGFyYWN0ZXJzWyh2ICYgMHhmMCkgPj4gNF0gKyBIZXhDaGFyYWN0ZXJzW3YgJiAweDBmXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBbW0RhdGFIZXhTdHJpbmddXSBieSBjb25jYXRlbmF0aW5nIGFsbCB2YWx1ZXNcbiAqICB3aXRoaW4gJSVkYXRhJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQoZGF0YXMpIHtcbiAgICByZXR1cm4gXCIweFwiICsgZGF0YXMubWFwKChkKSA9PiBoZXhsaWZ5KGQpLnN1YnN0cmluZygyKSkuam9pbihcIlwiKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIGxlbmd0aCBvZiAlJWRhdGElJSwgaW4gYnl0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRhTGVuZ3RoKGRhdGEpIHtcbiAgICBpZiAoaXNIZXhTdHJpbmcoZGF0YSwgdHJ1ZSkpIHtcbiAgICAgICAgcmV0dXJuIChkYXRhLmxlbmd0aCAtIDIpIC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJ5dGVzKGRhdGEpLmxlbmd0aDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBbW0RhdGFIZXhTdHJpbmddXSBieSBzbGljaW5nICUlZGF0YSUlIGZyb20gdGhlICUlc3RhcnQlJVxuICogIG9mZnNldCB0byB0aGUgJSVlbmQlJSBvZmZzZXQuXG4gKlxuICogIEJ5IGRlZmF1bHQgJSVzdGFydCUlIGlzIDAgYW5kICUlZW5kJSUgaXMgdGhlIGxlbmd0aCBvZiAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGFTbGljZShkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcbiAgICBpZiAoZW5kICE9IG51bGwgJiYgZW5kID4gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjYW5ub3Qgc2xpY2UgYmV5b25kIGRhdGEgYm91bmRzXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBieXRlcywgbGVuZ3RoOiBieXRlcy5sZW5ndGgsIG9mZnNldDogZW5kXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShieXRlcy5zbGljZSgoc3RhcnQgPT0gbnVsbCkgPyAwIDogc3RhcnQsIChlbmQgPT0gbnVsbCkgPyBieXRlcy5sZW5ndGggOiBlbmQpKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gcmVzdWx0IGJ5IHN0cmlwcGluZyBhbGwgKipsZWFkaW5nKipcbiAqKiB6ZXJvIGJ5dGVzIGZyb20gJSVkYXRhJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFplcm9zTGVmdChkYXRhKSB7XG4gICAgbGV0IGJ5dGVzID0gaGV4bGlmeShkYXRhKS5zdWJzdHJpbmcoMik7XG4gICAgd2hpbGUgKGJ5dGVzLnN0YXJ0c1dpdGgoXCIwMFwiKSkge1xuICAgICAgICBieXRlcyA9IGJ5dGVzLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGJ5dGVzO1xufVxuZnVuY3Rpb24gemVyb1BhZChkYXRhLCBsZW5ndGgsIGxlZnQpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgIGFzc2VydChsZW5ndGggPj0gYnl0ZXMubGVuZ3RoLCBcInBhZGRpbmcgZXhjZWVkcyBkYXRhIGxlbmd0aFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgYnVmZmVyOiBuZXcgVWludDhBcnJheShieXRlcyksXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICBvZmZzZXQ6IGxlbmd0aCArIDFcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIHJlc3VsdC5maWxsKDApO1xuICAgIGlmIChsZWZ0KSB7XG4gICAgICAgIHJlc3VsdC5zZXQoYnl0ZXMsIGxlbmd0aCAtIGJ5dGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQuc2V0KGJ5dGVzLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVkYXRhJSUgcGFkZGVkIG9uIHRoZSAqKmxlZnQqKlxuICogIHRvICUlbGVuZ3RoJSUgYnl0ZXMuXG4gKlxuICogIElmICUlZGF0YSUlIGFscmVhZHkgZXhjZWVkcyAlJWxlbmd0aCUlLCBhIFtbQnVmZmVyT3ZlcnJ1bkVycm9yXV0gaXNcbiAqICB0aHJvd24uXG4gKlxuICogIFRoaXMgcGFkcyBkYXRhIHRoZSBzYW1lIGFzICoqdmFsdWVzKiogYXJlIGluIFNvbGlkaXR5XG4gKiAgKGUuZy4gYGB1aW50MTI4YGApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gemVyb1BhZFZhbHVlKGRhdGEsIGxlbmd0aCkge1xuICAgIHJldHVybiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgdHJ1ZSk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIFtbRGF0YUhleFN0cmluZ11dIG9mICUlZGF0YSUlIHBhZGRlZCBvbiB0aGUgKipyaWdodCoqXG4gKiAgdG8gJSVsZW5ndGglJSBieXRlcy5cbiAqXG4gKiAgSWYgJSVkYXRhJSUgYWxyZWFkeSBleGNlZWRzICUlbGVuZ3RoJSUsIGEgW1tCdWZmZXJPdmVycnVuRXJyb3JdXSBpc1xuICogIHRocm93bi5cbiAqXG4gKiAgVGhpcyBwYWRzIGRhdGEgdGhlIHNhbWUgYXMgKipieXRlcyoqIGFyZSBpbiBTb2xpZGl0eVxuICogIChlLmcuIGBgYnl0ZXMxNmBgKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHplcm9QYWRCeXRlcyhkYXRhLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gemVyb1BhZChkYXRhLCBsZW5ndGgsIGZhbHNlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEuanMubWFwIiwiLyoqXG4gKiAgU29tZSBtYXRoZW1hdGljIG9wZXJhdGlvbnMuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOk1hdGggSGVscGVycyAgW2Fib3V0LW1hdGhzXVxuICovXG5pbXBvcnQgeyBoZXhsaWZ5LCBpc0J5dGVzTGlrZSB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuLy9jb25zdCBCTl9NYXgyNTYgPSAoQk5fMSA8PCBCaWdJbnQoMjU2KSkgLSBCTl8xO1xuLy8gSUVFRSA3NTQgc3VwcG9ydCA1My1iaXRzIG9mIG1hbnRpc3NhXG5jb25zdCBtYXhWYWx1ZSA9IDB4MWZmZmZmZmZmZmZmZmY7XG4vKipcbiAqICBDb252ZXJ0ICUldmFsdWUlJSBmcm9tIGEgdHdvcy1jb21wbGltZW50IHJlcHJlc2VudGF0aW9uIG9mICUld2lkdGglJVxuICogIGJpdHMgdG8gaXRzIHZhbHVlLlxuICpcbiAqICBJZiB0aGUgaGlnaGVzdCBiaXQgaXMgYGAxYGAsIHRoZSByZXN1bHQgd2lsbCBiZSBuZWdhdGl2ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Ud29zKF92YWx1ZSwgX3dpZHRoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCB3aWR0aCA9IEJpZ0ludChnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpKTtcbiAgICBhc3NlcnQoKHZhbHVlID4+IHdpZHRoKSA9PT0gQk5fMCwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICBvcGVyYXRpb246IFwiZnJvbVR3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgIH0pO1xuICAgIC8vIFRvcCBiaXQgc2V0OyB0cmVhdCBhcyBhIG5lZ2F0aXZlIHZhbHVlXG4gICAgaWYgKHZhbHVlID4+ICh3aWR0aCAtIEJOXzEpKSB7XG4gICAgICAgIGNvbnN0IG1hc2sgPSAoQk5fMSA8PCB3aWR0aCkgLSBCTl8xO1xuICAgICAgICByZXR1cm4gLSgoKH52YWx1ZSkgJiBtYXNrKSArIEJOXzEpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqICBDb252ZXJ0ICUldmFsdWUlJSB0byBhIHR3b3MtY29tcGxpbWVudCByZXByZXNlbnRhdGlvbiBvZlxuICogICUld2lkdGglJSBiaXRzLlxuICpcbiAqICBUaGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIHBvc2l0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Ud29zKF92YWx1ZSwgX3dpZHRoKSB7XG4gICAgbGV0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCB3aWR0aCA9IEJpZ0ludChnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpKTtcbiAgICBjb25zdCBsaW1pdCA9IChCTl8xIDw8ICh3aWR0aCAtIEJOXzEpKTtcbiAgICBpZiAodmFsdWUgPCBCTl8wKSB7XG4gICAgICAgIHZhbHVlID0gLXZhbHVlO1xuICAgICAgICBhc3NlcnQodmFsdWUgPD0gbGltaXQsIFwidG9vIGxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtYXNrID0gKEJOXzEgPDwgd2lkdGgpIC0gQk5fMTtcbiAgICAgICAgcmV0dXJuICgofnZhbHVlKSAmIG1hc2spICsgQk5fMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydCh2YWx1ZSA8IGxpbWl0LCBcInRvbyBoaWdoXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9Ud29zXCIsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogIE1hc2sgJSV2YWx1ZSUlIHdpdGggYSBiaXRtYXNrIG9mICUlYml0cyUlIG9uZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXNrKF92YWx1ZSwgX2JpdHMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IGJpdHMgPSBCaWdJbnQoZ2V0TnVtYmVyKF9iaXRzLCBcImJpdHNcIikpO1xuICAgIHJldHVybiB2YWx1ZSAmICgoQk5fMSA8PCBiaXRzKSAtIEJOXzEpO1xufVxuLyoqXG4gKiAgR2V0cyBhIEJpZ0ludCBmcm9tICUldmFsdWUlJS4gSWYgaXQgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3JcbiAqICBhIEJpZ0ludCwgdGhlbiBhbiBBcmd1bWVudEVycm9yIHdpbGwgYmUgdGhyb3duIGZvciAlJW5hbWUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJpZ0ludCh2YWx1ZSwgbmFtZSkge1xuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOiByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcInVuZGVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gLW1heFZhbHVlICYmIHZhbHVlIDw9IG1heFZhbHVlLCBcIm92ZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbMF0gPT09IFwiLVwiICYmIHZhbHVlWzFdICE9PSBcIi1cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLUJpZ0ludCh2YWx1ZS5zdWJzdHJpbmcoMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIEJpZ051bWJlcmlzaCBzdHJpbmc6ICR7ZS5tZXNzYWdlfWAsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgQmlnTnVtYmVyaXNoIHZhbHVlXCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG4vKipcbiAqICBSZXR1cm5zICUldmFsdWUlJSBhcyBhIGJpZ2ludCwgdmFsaWRhdGluZyBpdCBpcyB2YWxpZCBhcyBhIGJpZ2ludFxuICogIHZhbHVlIGFuZCB0aGF0IGl0IGlzIHBvc2l0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VWludCh2YWx1ZSwgbmFtZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGdldEJpZ0ludCh2YWx1ZSwgbmFtZSk7XG4gICAgYXNzZXJ0KHJlc3VsdCA+PSBCTl8wLCBcInVuc2lnbmVkIHZhbHVlIGNhbm5vdCBiZSBuZWdhdGl2ZVwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICBmYXVsdDogXCJvdmVyZmxvd1wiLCBvcGVyYXRpb246IFwiZ2V0VWludFwiLCB2YWx1ZVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBOaWJibGVzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4vKlxuICogQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnSW50LiBJZiAlJXZhbHVlJSUgaXMgYSBVaW50OEFycmF5LCBpdFxuICogaXMgdHJlYXRlZCBhcyBCaWcgRW5kaWFuIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JpZ0ludCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHgwXCI7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiA+PiA0XTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBOaWJibGVzW3YgJiAweDBmXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50KHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBnZXRCaWdJbnQodmFsdWUpO1xufVxuLyoqXG4gKiAgR2V0cyBhIC8vbnVtYmVyLy8gZnJvbSAlJXZhbHVlJSUuIElmIGl0IGlzIGFuIGludmFsaWQgdmFsdWUgZm9yXG4gKiAgYSAvL251bWJlci8vLCB0aGVuIGFuIEFyZ3VtZW50RXJyb3Igd2lsbCBiZSB0aHJvd24gZm9yICUlbmFtZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TnVtYmVyKHZhbHVlLCBuYW1lKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSwgXCJ1bmRlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXROdW1iZXIoQmlnSW50KHZhbHVlKSwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBudW1lcmljIHN0cmluZzogJHtlLm1lc3NhZ2V9YCwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBudW1lcmljIHZhbHVlXCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBudW1iZXIuIElmICUldmFsdWUlJSBpcyBhIFVpbnQ4QXJyYXksIGl0XG4gKiAgaXMgdHJlYXRlZCBhcyBCaWcgRW5kaWFuIGRhdGEuIFRocm93cyBpZiB0aGUgdmFsdWUgaXMgbm90IHNhZmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBnZXROdW1iZXIodG9CaWdJbnQodmFsdWUpKTtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIEJpZyBFbmRpYW4gaGV4c3RyaW5nLCBvcHRpb25hbGx5IHBhZGRlZCB0b1xuICogICUld2lkdGglJSBieXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmVIZXgoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGxldCByZXN1bHQgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgaWYgKF93aWR0aCA9PSBudWxsKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgdmFsdWUgaXMgb2YgZXZlbiBsZW5ndGhcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpO1xuICAgICAgICBhc3NlcnQod2lkdGggKiAyID49IHJlc3VsdC5sZW5ndGgsIGB2YWx1ZSBleGNlZWRzIHdpZHRoICgke3dpZHRofSBiaXRzKWAsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9CZUhleFwiLFxuICAgICAgICAgICAgZmF1bHQ6IFwib3ZlcmZsb3dcIixcbiAgICAgICAgICAgIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFBhZCB0aGUgdmFsdWUgdG8gdGhlIHJlcXVpcmVkIHdpZHRoXG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgKHdpZHRoICogMikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWcgRW5kaWFuIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JlQXJyYXkoX3ZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBpZiAodmFsdWUgPT09IEJOXzApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtdKTtcbiAgICB9XG4gICAgbGV0IGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogMjtcbiAgICAgICAgcmVzdWx0W2ldID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIDIpLCAxNik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tIZXhTdHJpbmddXSBmb3IgJSV2YWx1ZSUlIHNhZmUgdG8gdXNlIGFzIGEgLy9RdWFudGl0eS8vLlxuICpcbiAqICBBIC8vUXVhbnRpdHkvLyBkb2VzIG5vdCBoYXZlIGFuZCBsZWFkaW5nIDAgdmFsdWVzIHVubGVzcyB0aGUgdmFsdWUgaXNcbiAqICB0aGUgbGl0ZXJhbCB2YWx1ZSBgMHgwYC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgZm9yIEpTU09OLVJQQ1xuICogIG51bWVyaWMgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9RdWFudGl0eSh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSBoZXhsaWZ5KGlzQnl0ZXNMaWtlKHZhbHVlKSA/IHZhbHVlIDogdG9CZUFycmF5KHZhbHVlKSkuc3Vic3RyaW5nKDIpO1xuICAgIHdoaWxlIChyZXN1bHQuc3RhcnRzV2l0aChcIjBcIikpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCA9PT0gXCJcIikge1xuICAgICAgICByZXN1bHQgPSBcIjBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGhzLmpzLm1hcCIsIi8qKlxuICogIFRoZSBbQmFzZTU4IEVuY29kaW5nXShsaW5rLWJhc2U1OCkgc2NoZW1lIGFsbG93cyBhICoqbnVtZXJpYyoqIHZhbHVlXG4gKiAgdG8gYmUgZW5jb2RlZCBhcyBhIGNvbXBhY3Qgc3RyaW5nIHVzaW5nIGEgcmFkaXggb2YgNTggdXNpbmcgb25seVxuICogIGFscGhhLW51bWVyaWMgY2hhcmFjdGVycy4gQ29uZnVzaW5nbHkgc2ltaWxhciBjaGFyYWN0ZXJzIGFyZSBvbWl0dGVkXG4gKiAgKGkuZS4gYGBcImwwT1wiYGApLlxuICpcbiAqICBOb3RlIHRoYXQgQmFzZTU4IGVuY29kZXMgYSAqKm51bWVyaWMqKiB2YWx1ZSwgbm90IGFyYml0cmFyeSBieXRlcyxcbiAqICBzaW5jZSBhbnkgemVyby1ieXRlcyBvbiB0aGUgbGVmdCB3b3VsZCBnZXQgcmVtb3ZlZC4gVG8gbWl0aWdhdGUgdGhpc1xuICogIGlzc3VlIG1vc3Qgc2NoZW1lcyB0aGF0IHVzZSBCYXNlNTggY2hvb3NlIHNwZWNpZmljIGhpZ2gtb3JkZXIgdmFsdWVzXG4gKiAgdG8gZW5zdXJlIG5vbi16ZXJvIHByZWZpeGVzLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS91dGlsczpCYXNlNTggRW5jb2RpbmcgW2Fib3V0LWJhc2U1OF1cbiAqL1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgdG9CaWdJbnQgfSBmcm9tIFwiLi9tYXRocy5qc1wiO1xuY29uc3QgQWxwaGFiZXQgPSBcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIjtcbmxldCBMb29rdXAgPSBudWxsO1xuZnVuY3Rpb24gZ2V0QWxwaGEobGV0dGVyKSB7XG4gICAgaWYgKExvb2t1cCA9PSBudWxsKSB7XG4gICAgICAgIExvb2t1cCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFscGhhYmV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBMb29rdXBbQWxwaGFiZXRbaV1dID0gQmlnSW50KGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IExvb2t1cFtsZXR0ZXJdO1xuICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdCAhPSBudWxsLCBgaW52YWxpZCBiYXNlNTggdmFsdWVgLCBcImxldHRlclwiLCBsZXR0ZXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fNTggPSBCaWdJbnQoNTgpO1xuLyoqXG4gKiAgRW5jb2RlICUldmFsdWUlJSBhcyBhIEJhc2U1OC1lbmNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJhc2U1OChfdmFsdWUpIHtcbiAgICBsZXQgdmFsdWUgPSB0b0JpZ0ludChnZXRCeXRlcyhfdmFsdWUpKTtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0ID0gQWxwaGFiZXRbTnVtYmVyKHZhbHVlICUgQk5fNTgpXSArIHJlc3VsdDtcbiAgICAgICAgdmFsdWUgLz0gQk5fNTg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBEZWNvZGUgdGhlIEJhc2U1OC1lbmNvZGVkICUldmFsdWUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJhc2U1OCh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSBCTl8wO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICo9IEJOXzU4O1xuICAgICAgICByZXN1bHQgKz0gZ2V0QWxwaGEodmFsdWVbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTU4LmpzLm1hcCIsIi8vIHV0aWxzL2Jhc2U2NC1icm93c2VyXG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCYXNlNjQodGV4dERhdGEpIHtcbiAgICB0ZXh0RGF0YSA9IGF0b2IodGV4dERhdGEpO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0ZXh0RGF0YS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSA9IHRleHREYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBnZXRCeXRlcyhkYXRhKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVCYXNlNjQoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEpO1xuICAgIGxldCB0ZXh0RGF0YSA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRleHREYXRhICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVtpXSk7XG4gICAgfVxuICAgIHJldHVybiBidG9hKHRleHREYXRhKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U2NC1icm93c2VyLmpzLm1hcCIsIi8qKlxuICogIEV2ZW50cyBhbGxvdyBmb3IgYXBwbGljYXRpb25zIHRvIHVzZSB0aGUgb2JzZXJ2ZXIgcGF0dGVybiwgd2hpY2hcbiAqICBhbGxvd3Mgc3Vic2NyaWJpbmcgYW5kIHB1Ymxpc2hpbmcgZXZlbnRzLCBvdXRzaWRlIHRoZSBub3JtYWxcbiAqICBleGVjdXRpb24gcGF0aHMuXG4gKlxuICogIEBfc2VjdGlvbiBhcGkvdXRpbHMvZXZlbnRzOkV2ZW50cyAgW2Fib3V0LWV2ZW50c11cbiAqL1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuL3Byb3BlcnRpZXMuanNcIjtcbi8qKlxuICogIFdoZW4gYW4gW1tFdmVudEVtaXR0ZXJhYmxlXV0gdHJpZ2dlcnMgYSBbW0xpc3RlbmVyXV0sIHRoZVxuICogIGNhbGxiYWNrIGFsd2F5cyBhaGFzIG9uZSBhZGRpdGlvbmFsIGFyZ3VtZW50IHBhc3NlZCwgd2hpY2ggaXNcbiAqICBhbiAqKkV2ZW50UGF5bG9hZCoqLlxuICovXG5leHBvcnQgY2xhc3MgRXZlbnRQYXlsb2FkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGV2ZW50IGZpbHRlci5cbiAgICAgKi9cbiAgICBmaWx0ZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSAqKkV2ZW50RW1pdHRlcmFibGUqKi5cbiAgICAgKi9cbiAgICBlbWl0dGVyO1xuICAgICNsaXN0ZW5lcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqRXZlbnRQYXlsb2FkKiogZm9yICUlZW1pdHRlciUlIHdpdGhcbiAgICAgKiAgdGhlICUlbGlzdGVuZXIlJSBhbmQgZm9yICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZW1pdHRlciwgbGlzdGVuZXIsIGZpbHRlcikge1xuICAgICAgICB0aGlzLiNsaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZW1pdHRlciwgZmlsdGVyIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVW5yZWdpc3RlciB0aGUgdHJpZ2dlcmVkIGxpc3RlbmVyIGZvciBmdXR1cmUgZXZlbnRzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUxpc3RlbmVyKCkge1xuICAgICAgICBpZiAodGhpcy4jbGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuZW1pdHRlci5vZmYodGhpcy5maWx0ZXIsIHRoaXMuI2xpc3RlbmVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudHMuanMubWFwIiwiLyoqXG4gKiAgVXNpbmcgc3RyaW5ncyBpbiBFdGhlcmV1bSAob3IgYW55IHNlY3VyaXR5LWJhc2Qgc3lzdGVtKSByZXF1aXJlc1xuICogIGFkZGl0aW9uYWwgY2FyZS4gVGhlc2UgdXRpbGl0aWVzIGF0dGVtcHQgdG8gbWl0aWdhdGUgc29tZSBvZiB0aGVcbiAqICBzYWZldHkgaXNzdWVzIGFzIHdlbGwgYXMgcHJvdmlkZSB0aGUgYWJpbGl0eSB0byByZWNvdmVyIGFuZCBhbmFseXNlXG4gKiAgc3RyaW5ncy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpTdHJpbmdzIGFuZCBVVEYtOCAgW2Fib3V0LXN0cmluZ3NdXG4gKi9cbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQsIGFzc2VydE5vcm1hbGl6ZSB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZnVuY3Rpb24gZXJyb3JGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgY29kZXBvaW50IGF0IG9mZnNldCAke29mZnNldH07ICR7cmVhc29ufWAsIFwiYnl0ZXNcIiwgYnl0ZXMpO1xufVxuZnVuY3Rpb24gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gaW52YWxpZCBwcmVmaXggKGluY2x1ZGluZyBzdHJheSBjb250aW51YXRpb24pLCBza2lwIGFueSBhZGRpdGlvbmFsIGNvbnRpbnVhdGlvbiBieXRlc1xuICAgIGlmIChyZWFzb24gPT09IFwiQkFEX1BSRUZJWFwiIHx8IHJlYXNvbiA9PT0gXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCIpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBvID0gb2Zmc2V0ICsgMTsgbyA8IGJ5dGVzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXNbb10gPj4gNiAhPT0gMHgwMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICAvLyBUaGlzIGJ5dGUgcnVucyB1cyBwYXN0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc28ganVzdCBqdW1wIHRvIHRoZSBlbmRcbiAgICAvLyAoYnV0IHRoZSBmaXJzdCBieXRlIHdhcyByZWFkIGFscmVhZHkgcmVhZCBhbmQgdGhlcmVmb3JlIHNraXBwZWQpXG4gICAgaWYgKHJlYXNvbiA9PT0gXCJPVkVSUlVOXCIpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLmxlbmd0aCAtIG9mZnNldCAtIDE7XG4gICAgfVxuICAgIC8vIE5vdGhpbmcgdG8gc2tpcFxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gcmVwbGFjZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIE92ZXJsb25nIHJlcHJlc2VudGF0aW9ucyBhcmUgb3RoZXJ3aXNlIFwidmFsaWRcIiBjb2RlIHBvaW50czsganVzdCBub24tZGVpc3Rpbmd0aXNoZWRcbiAgICBpZiAocmVhc29uID09PSBcIk9WRVJMT05HXCIpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChiYWRDb2RlcG9pbnQpID09PSBcIm51bWJlclwiLCBcImludmFsaWQgYmFkIGNvZGUgcG9pbnQgZm9yIHJlcGxhY2VtZW50XCIsIFwiYmFkQ29kZXBvaW50XCIsIGJhZENvZGVwb2ludCk7XG4gICAgICAgIG91dHB1dC5wdXNoKGJhZENvZGVwb2ludCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLyBQdXQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpbnRvIHRoZSBvdXRwdXRcbiAgICBvdXRwdXQucHVzaCgweGZmZmQpO1xuICAgIC8vIE90aGVyd2lzZSwgcHJvY2VzcyBhcyBpZiBpZ25vcmluZyBlcnJvcnNcbiAgICByZXR1cm4gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KTtcbn1cbi8qKlxuICogIEEgaGFuZGZ1bCBvZiBwb3B1bGFyLCBidWlsdC1pbiBVVEYtOCBlcnJvciBoYW5kbGluZyBzdHJhdGVnaWVzLlxuICpcbiAqICAqKmBgXCJlcnJvclwiYGAqKiAtIHRocm93cyBvbiBBTlkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZSBvclxuICogIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzICh0aGlzIGlzIHRoZSBkZWZhdWx0KVxuICpcbiAqICAqKmBgXCJpZ25vcmVcImBgKiogLSBzaWxlbnRseSBkcm9wcyBhbnkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZVxuICogIGFuZCBhY2NlcHRzIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzXG4gKlxuICogICoqYGBcInJlcGxhY2VcImBgKiogLSByZXBsYWNlIGFueSBpbGxlZ2FsIFVURi04IHNlcXVlbmNlIHdpdGggdGhlXG4gKiAgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyIChpLmUuIGBgXCJcXFxcdWZmZmRcImBgKSBhbmQgYWNjZXB0c1xuICogIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzXG4gKlxuICogIEByZXR1cm5zOiBSZWNvcmQ8XCJlcnJvclwiIHwgXCJpZ25vcmVcIiB8IFwicmVwbGFjZVwiLCBVdGY4RXJyb3JGdW5jPlxuICovXG5leHBvcnQgY29uc3QgVXRmOEVycm9yRnVuY3MgPSBPYmplY3QuZnJlZXplKHtcbiAgICBlcnJvcjogZXJyb3JGdW5jLFxuICAgIGlnbm9yZTogaWdub3JlRnVuYyxcbiAgICByZXBsYWNlOiByZXBsYWNlRnVuY1xufSk7XG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzMzU2NDkzL2RlY29kZS11dGYtOC13aXRoLWphdmFzY3JpcHQjMTM2OTE0OTlcbmZ1bmN0aW9uIGdldFV0ZjhDb2RlUG9pbnRzKF9ieXRlcywgb25FcnJvcikge1xuICAgIGlmIChvbkVycm9yID09IG51bGwpIHtcbiAgICAgICAgb25FcnJvciA9IFV0ZjhFcnJvckZ1bmNzLmVycm9yO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKF9ieXRlcywgXCJieXRlc1wiKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gSW52YWxpZCBieXRlcyBhcmUgaWdub3JlZFxuICAgIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGMgPSBieXRlc1tpKytdO1xuICAgICAgICAvLyAweHh4IHh4eHhcbiAgICAgICAgaWYgKGMgPj4gNyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aWJ5dGU7IGhvdyBtYW55IGJ5dGVzIGxlZnQgZm9yIHRoaXMgY2hhcmFjdGVyP1xuICAgICAgICBsZXQgZXh0cmFMZW5ndGggPSBudWxsO1xuICAgICAgICBsZXQgb3ZlcmxvbmdNYXNrID0gbnVsbDtcbiAgICAgICAgLy8gMTEweCB4eHh4IDEweHggeHh4eFxuICAgICAgICBpZiAoKGMgJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAxO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZjtcbiAgICAgICAgICAgIC8vIDExMTAgeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAyO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZmY7XG4gICAgICAgICAgICAvLyAxMTExIDB4eHggMTB4eCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDM7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweGZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKGMgJiAweGMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIlVORVhQRUNURURfQ09OVElOVUVcIiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiQkFEX1BSRUZJWFwiLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB3ZSBoYXZlIGVub3VnaCBieXRlcyBpbiBvdXIgZGF0YT9cbiAgICAgICAgaWYgKGkgLSAxICsgZXh0cmFMZW5ndGggPj0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVkVSUlVOXCIsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGVuZ3RoIHByZWZpeCBmcm9tIHRoZSBjaGFyXG4gICAgICAgIGxldCByZXMgPSBjICYgKCgxIDw8ICg4IC0gZXh0cmFMZW5ndGggLSAxKSkgLSAxKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBleHRyYUxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dENoYXIgPSBieXRlc1tpXTtcbiAgICAgICAgICAgIC8vIEludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgICAgIGlmICgobmV4dENoYXIgJiAweGMwKSAhPSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiTUlTU0lOR19DT05USU5VRVwiLCBpLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgcmVzID0gKHJlcyA8PCA2KSB8IChuZXh0Q2hhciAmIDB4M2YpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBhYm92ZSBsb29wIGZvciBpbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heGltdW0gY29kZSBwb2ludFxuICAgICAgICBpZiAocmVzID4gMHgxMGZmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk9VVF9PRl9SQU5HRVwiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIFVURi0xNiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgIGlmIChyZXMgPj0gMHhkODAwICYmIHJlcyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIlVURjE2X1NVUlJPR0FURVwiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJsb25nIHNlcXVlbmNlcyAobW9yZSBieXRlcyB0aGFuIG5lZWRlZClcbiAgICAgICAgaWYgKHJlcyA8PSBvdmVybG9uZ01hc2spIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk9WRVJMT05HXCIsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODcyOTQwNS9ob3ctdG8tY29udmVydC11dGY4LXN0cmluZy10by1ieXRlLWFycmF5XG4vKipcbiAqICBSZXR1cm5zIHRoZSBVVEYtOCBieXRlIHJlcHJlc2VudGF0aW9uIG9mICUlc3RyJSUuXG4gKlxuICogIElmICUlZm9ybSUlIGlzIHNwZWNpZmllZCwgdGhlIHN0cmluZyBpcyBub3JtYWxpemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4Qnl0ZXMoc3RyLCBmb3JtKSB7XG4gICAgaWYgKGZvcm0gIT0gbnVsbCkge1xuICAgICAgICBhc3NlcnROb3JtYWxpemUoZm9ybSk7XG4gICAgICAgIHN0ciA9IHN0ci5ub3JtYWxpemUoZm9ybSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiA2KSB8IDB4YzApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmYzAwKSA9PSAweGQ4MDApIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnN0IGMyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpIDwgc3RyLmxlbmd0aCAmJiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSwgXCJpbnZhbGlkIHN1cnJvZ2F0ZSBwYWlyXCIsIFwic3RyXCIsIHN0cik7XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgICAgICAgY29uc3QgcGFpciA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciA+PiAxOCkgfCAweGYwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiAxMikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChwYWlyID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChwYWlyICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDEyKSB8IDB4ZTApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChjID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbn1cbjtcbi8vZXhwb3J0IFxuZnVuY3Rpb24gX3RvVXRmOFN0cmluZyhjb2RlUG9pbnRzKSB7XG4gICAgcmV0dXJuIGNvZGVQb2ludHMubWFwKChjb2RlUG9pbnQpID0+IHtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApLCAoKGNvZGVQb2ludCAmIDB4M2ZmKSArIDB4ZGMwMCkpO1xuICAgIH0pLmpvaW4oXCJcIik7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50ZWQgYnkgdGhlIFVURi04IGRhdGEgJSVieXRlcyUlLlxuICpcbiAqICBXaGVuICUlb25FcnJvciUlIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgaXQgaXMgY2FsbGVkIG9uIFVURi04XG4gKiAgZXJyb3JzIGFsbG93aW5nIHJlY292ZXJ5IHVzaW5nIHRoZSBbW1V0ZjhFcnJvckZ1bmNdXSBBUEkuXG4gKiAgKGRlZmF1bHQ6IFtlcnJvcl0oVXRmOEVycm9yRnVuY3MpKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4U3RyaW5nKGJ5dGVzLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuIF90b1V0ZjhTdHJpbmcoZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIFVURi04IGNvZGUtcG9pbnRzIGZvciAlJXN0ciUlLlxuICpcbiAqICBJZiAlJWZvcm0lJSBpcyBzcGVjaWZpZWQsIHRoZSBzdHJpbmcgaXMgbm9ybWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOENvZGVQb2ludHMoc3RyLCBmb3JtKSB7XG4gICAgcmV0dXJuIGdldFV0ZjhDb2RlUG9pbnRzKHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRmOC5qcy5tYXAiLCJpbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbi8vIEBUT0RPOiB0aW1lb3V0IGlzIGNvbXBsZXRlbHkgaWdub3JlZDsgc3RhcnQgYSBQcm9taXNlLmFueSB3aXRoIGEgcmVqZWN0P1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUdldFVybChvcHRpb25zKSB7XG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0VXJsKHJlcSwgX3NpZ25hbCkge1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHJlcS51cmwuc3BsaXQoXCI6XCIpWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGFzc2VydChwcm90b2NvbCA9PT0gXCJodHRwXCIgfHwgcHJvdG9jb2wgPT09IFwiaHR0cHNcIiwgYHVuc3VwcG9ydGVkIHByb3RvY29sICR7cHJvdG9jb2x9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgaW5mbzogeyBwcm90b2NvbCB9LFxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlcXVlc3RcIlxuICAgICAgICB9KTtcbiAgICAgICAgYXNzZXJ0KHByb3RvY29sID09PSBcImh0dHBzXCIgfHwgIXJlcS5jcmVkZW50aWFscyB8fCByZXEuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uLCBcImluc2VjdXJlIGF1dGhvcml6ZWQgY29ubmVjdGlvbnMgdW5zdXBwb3J0ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlcXVlc3RcIlxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHNpZ25hbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKF9zaWduYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgICBzaWduYWwgPSBjb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgICAgIF9zaWduYWwuYWRkTGlzdGVuZXIoKCkgPT4geyBjb250cm9sbGVyLmFib3J0KCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluaXQgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IHJlcS5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhBcnJheS5mcm9tKHJlcSkpLFxuICAgICAgICAgICAgYm9keTogcmVxLmJvZHkgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2lnbmFsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBmZXRjaChyZXEudXJsLCBpbml0KTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICByZXNwLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BCb2R5ID0gYXdhaXQgcmVzcC5hcnJheUJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBib2R5ID0gKHJlc3BCb2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KHJlc3BCb2R5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3Auc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZTogcmVzcC5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgaGVhZGVycywgYm9keVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZ2V0VXJsO1xufVxuLy8gQFRPRE86IHJlbW92ZSBpbiB2NzsgcHJvdmlkZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRcbmNvbnN0IGRlZmF1bHRHZXRVcmwgPSBjcmVhdGVHZXRVcmwoe30pO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVybChyZXEsIF9zaWduYWwpIHtcbiAgICByZXR1cm4gZGVmYXVsdEdldFVybChyZXEsIF9zaWduYWwpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0dXJsLWJyb3dzZXIuanMubWFwIiwiLyoqXG4gKiAgRmV0Y2hpbmcgY29udGVudCBmcm9tIHRoZSB3ZWIgaXMgZW52aXJvbm1lbnQtc3BlY2lmaWMsIHNvIEV0aGVyc1xuICogIHByb3ZpZGVzIGFuIGFic3RyYWN0aW9uIHRoZSBlYWNoIGVudmlyb25tZW50IGNhbiBpbXBsZW1lbnQgdG8gcHJvdmlkZVxuICogIHRoaXMgc2VydmljZS5cbiAqXG4gKiAgT24gW05vZGUuanNdKGxpbmstbm9kZSksIHRoZSBgYGh0dHBgYCBhbmQgYGBodHRwc2BgIGxpYnMgYXJlIHVzZWQgdG9cbiAqICBjcmVhdGUgYSByZXF1ZXN0IG9iamVjdCwgcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIGFuZCBwcm9jZXNzIGRhdGFcbiAqICBhbmQgcG9wdWxhdGUgdGhlIFtbRmV0Y2hSZXNwb25zZV1dLlxuICpcbiAqICBJbiBhIGJyb3dzZXIsIHRoZSBbRE9NIGZldGNoXShsaW5rLWpzLWZldGNoKSBpcyB1c2VkLCBhbmQgdGhlIHJlc3VsdGluZ1xuICogIGBgUHJvbWlzZWBgIGlzIHdhaXRlZCBvbiB0byByZXRyZWl2ZSB0aGUgcGF5bG9hZC5cbiAqXG4gKiAgVGhlIFtbRmV0Y2hSZXF1ZXN0XV0gaXMgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIG1hbnkgY29tbW9uIHNpdHVhdGlvbnMsXG4gKiAgc3VjaCBhcyByZWRpcmVjdHMsIHNlcnZlciB0aHJvdHRsaW5nLCBhdXRoZW50Y2F0aW9uLCBldGMuXG4gKlxuICogIEl0IGFsc28gaGFuZGxlcyBjb21tb24gZ2F0ZXdheXMsIHN1Y2ggYXMgSVBGUyBhbmQgZGF0YSBVUklzLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzL2ZldGNoaW5nOkZldGNoaW5nIFdlYiBDb250ZW50ICBbYWJvdXQtZmV0Y2hdXG4gKi9cbmltcG9ydCB7IGRlY29kZUJhc2U2NCwgZW5jb2RlQmFzZTY0IH0gZnJvbSBcIi4vYmFzZTY0LmpzXCI7XG5pbXBvcnQgeyBoZXhsaWZ5IH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuL3Byb3BlcnRpZXMuanNcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi91dGY4LmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVHZXRVcmwgfSBmcm9tIFwiLi9nZXR1cmwuanNcIjtcbmNvbnN0IE1BWF9BVFRFTVBUUyA9IDEyO1xuY29uc3QgU0xPVF9JTlRFUlZBTCA9IDI1MDtcbi8vIFRoZSBnbG9iYWwgRmV0Y2hHZXRVcmxGdW5jIGltcGxlbWVudGF0aW9uLlxubGV0IGRlZmF1bHRHZXRVcmxGdW5jID0gY3JlYXRlR2V0VXJsKCk7XG5jb25zdCByZURhdGEgPSBuZXcgUmVnRXhwKFwiXmRhdGE6KFteOzpdKik/KDtiYXNlNjQpPywoLiopJFwiLCBcImlcIik7XG5jb25zdCByZUlwZnMgPSBuZXcgUmVnRXhwKFwiXmlwZnM6L1xcLyhpcGZzLyk/KC4qKSRcIiwgXCJpXCIpO1xuLy8gSWYgbG9ja2VkLCBuZXcgR2F0ZXdheXMgY2Fubm90IGJlIGFkZGVkXG5sZXQgbG9ja2VkID0gZmFsc2U7XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0Jhc2ljc19vZl9IVFRQL0RhdGFfVVJMc1xuYXN5bmMgZnVuY3Rpb24gZGF0YUdhdGV3YXlGdW5jKHVybCwgc2lnbmFsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVEYXRhKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZSgyMDAsIFwiT0tcIiwge1xuICAgICAgICAgICAgXCJjb250ZW50LXR5cGVcIjogKG1hdGNoWzFdIHx8IFwidGV4dC9wbGFpblwiKSxcbiAgICAgICAgfSwgKG1hdGNoWzJdID8gZGVjb2RlQmFzZTY0KG1hdGNoWzNdKSA6IHVucGVyY2VudChtYXRjaFszXSkpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZSg1OTksIFwiQkFEIFJFUVVFU1QgKGludmFsaWQgZGF0YTogVVJJKVwiLCB7fSwgbnVsbCwgbmV3IEZldGNoUmVxdWVzdCh1cmwpKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tGZXRjaEdhdGV3YXlGdW5jXV0gZm9yIGZldGNoaW5nIGNvbnRlbnQgZnJvbSBhIHN0YW5kYXJkXG4gKiAgSVBGUyBnYXRld2F5IGhvc3RlZCBhdCAlJWJhc2VVcmwlJS5cbiAqL1xuZnVuY3Rpb24gZ2V0SXBmc0dhdGV3YXlGdW5jKGJhc2VVcmwpIHtcbiAgICBhc3luYyBmdW5jdGlvbiBnYXRld2F5SXBmcyh1cmwsIHNpZ25hbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVJcGZzKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGxpbmtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVxdWVzdChgJHtiYXNlVXJsfSR7bWF0Y2hbMl19YCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UoNTk5LCBcIkJBRCBSRVFVRVNUIChpbnZhbGlkIElQRlMgVVJJKVwiLCB7fSwgbnVsbCwgbmV3IEZldGNoUmVxdWVzdCh1cmwpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2F0ZXdheUlwZnM7XG59XG5jb25zdCBHYXRld2F5cyA9IHtcbiAgICBcImRhdGFcIjogZGF0YUdhdGV3YXlGdW5jLFxuICAgIFwiaXBmc1wiOiBnZXRJcGZzR2F0ZXdheUZ1bmMoXCJodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvXCIpXG59O1xuY29uc3QgZmV0Y2hTaWduYWxzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaENhbmNlbFNpZ25hbCB7XG4gICAgI2xpc3RlbmVycztcbiAgICAjY2FuY2VsbGVkO1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuI2NhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBmZXRjaFNpZ25hbHMuc2V0KHJlcXVlc3QsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgbGlzdGVuZXIoKTsgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIGFzc2VydCghdGhpcy4jY2FuY2VsbGVkLCBcInNpbmdhbCBhbHJlYWR5IGNhbmNlbGxlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZmV0Y2hDYW5jZWxTaWduYWwuYWRkQ2FuY2VsTGlzdGVuZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICBnZXQgY2FuY2VsbGVkKCkgeyByZXR1cm4gdGhpcy4jY2FuY2VsbGVkOyB9XG4gICAgY2hlY2tTaWduYWwoKSB7XG4gICAgICAgIGFzc2VydCghdGhpcy5jYW5jZWxsZWQsIFwiY2FuY2VsbGVkXCIsIFwiQ0FOQ0VMTEVEXCIsIHt9KTtcbiAgICB9XG59XG4vLyBDaGVjayB0aGUgc2lnbmFsLCB0aHJvd2luZyBpZiBpdCBpcyBjYW5jZWxsZWRcbmZ1bmN0aW9uIGNoZWNrU2lnbmFsKHNpZ25hbCkge1xuICAgIGlmIChzaWduYWwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHNpZ25hbDsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgfVxuICAgIHNpZ25hbC5jaGVja1NpZ25hbCgpO1xuICAgIHJldHVybiBzaWduYWw7XG59XG4vKipcbiAqICBSZXByZXNlbnRzIGEgcmVxdWVzdCBmb3IgYSByZXNvdXJjZSB1c2luZyBhIFVSSS5cbiAqXG4gKiAgQnkgZGVmYXVsdCwgdGhlIHN1cHBvcnRlZCBzY2hlbWVzIGFyZSBgYEhUVFBgYCwgYGBIVFRQU2BgLCBgYGRhdGE6YGAsXG4gKiAgYW5kIGBgSVBGUzpgYC5cbiAqXG4gKiAgQWRkaXRpb25hbCBzY2hlbWVzIGNhbiBiZSBhZGRlZCBnbG9iYWxseSB1c2luZyBbW3JlZ2lzdGVyR2F0ZXdheV1dLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QoXCJodHRwczovL3d3dy5yaWNtb28uY29tXCIpXG4gKiAgICByZXNwID0gYXdhaXQgcmVxLnNlbmQoKVxuICogICAgcmVzcC5ib2R5Lmxlbmd0aFxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgY2xhc3MgRmV0Y2hSZXF1ZXN0IHtcbiAgICAjYWxsb3dJbnNlY3VyZTtcbiAgICAjZ3ppcDtcbiAgICAjaGVhZGVycztcbiAgICAjbWV0aG9kO1xuICAgICN0aW1lb3V0O1xuICAgICN1cmw7XG4gICAgI2JvZHk7XG4gICAgI2JvZHlUeXBlO1xuICAgICNjcmVkcztcbiAgICAvLyBIb29rc1xuICAgICNwcmVmbGlnaHQ7XG4gICAgI3Byb2Nlc3M7XG4gICAgI3JldHJ5O1xuICAgICNzaWduYWw7XG4gICAgI3Rocm90dGxlO1xuICAgICNnZXRVcmxGdW5jO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmV0Y2ggVVJJIHRvIHJlcXVyZXN0LlxuICAgICAqL1xuICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLiN1cmw7IH1cbiAgICBzZXQgdXJsKHVybCkge1xuICAgICAgICB0aGlzLiN1cmwgPSBTdHJpbmcodXJsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBmZXRjaCBib2R5LCBpZiBhbnksIHRvIHNlbmQgYXMgdGhlIHJlcXVlc3QgYm9keS4gLy8oZGVmYXVsdDogbnVsbCkvL1xuICAgICAqXG4gICAgICogIFdoZW4gc2V0dGluZyBhIGJvZHksIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBhdXRvbWF0aWNhbGx5XG4gICAgICogIHNldCBhbmQgd2lsbCBiZSB1c2VkIGlmICoqbm90IG92ZXJyaWRkZW4qKiBieSBzZXR0aW5nIGEgY3VzdG9tXG4gICAgICogIGhlYWRlci5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBudWxsLCB0aGUgYm9keSBpcyBjbGVhcmVkIChhbG9uZyB3aXRoIHRoZVxuICAgICAqICBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCkgYW5kIHRoZSAuXG4gICAgICpcbiAgICAgKiAgSWYgJSVib2R5JSUgaXMgYSBzdHJpbmcsIHRoZSBpbnRyaW5jaXMgYGBDb250ZW50LVR5cGVgYCBpcyBzZXQgdG9cbiAgICAgKiAgYGB0ZXh0L3BsYWluYGAuXG4gICAgICpcbiAgICAgKiAgSWYgJSVib2R5JSUgaXMgYSBVaW50OEFycmF5LCB0aGUgaW50cmluY2lzIGBgQ29udGVudC1UeXBlYGAgaXMgc2V0IHRvXG4gICAgICogIGBgYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtYGAuXG4gICAgICpcbiAgICAgKiAgSWYgJSVib2R5JSUgaXMgYW55IG90aGVyIG9iamVjdCwgdGhlIGludHJpbmNpcyBgYENvbnRlbnQtVHlwZWBgIGlzXG4gICAgICogIHNldCB0byBgYGFwcGxpY2F0aW9uL2pzb25gYC5cbiAgICAgKi9cbiAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgaWYgKHRoaXMuI2JvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuI2JvZHkpO1xuICAgIH1cbiAgICBzZXQgYm9keShib2R5KSB7XG4gICAgICAgIGlmIChib2R5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGJvZHkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLiNib2R5ID0gdG9VdGY4Qnl0ZXMoYm9keSk7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IFwidGV4dC9wbGFpblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLiNib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGJvZHkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aGlzLiNib2R5ID0gdG9VdGY4Qnl0ZXMoSlNPTi5zdHJpbmdpZnkoYm9keSkpO1xuICAgICAgICAgICAgdGhpcy4jYm9keVR5cGUgPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYm9keVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSByZXF1ZXN0IGhhcyBhIGJvZHkuXG4gICAgICovXG4gICAgaGFzQm9keSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEhUVFAgbWV0aG9kIHRvIHVzZSB3aGVuIHJlcXVlc3RpbmcgdGhlIFVSSS4gSWYgbm8gbWV0aG9kXG4gICAgICogIGhhcyBiZWVuIGV4cGxpY2l0bHkgc2V0LCB0aGVuIGBgR0VUYGAgaXMgdXNlZCBpZiB0aGUgYm9keSBpc1xuICAgICAqICBudWxsIGFuZCBgYFBPU1RgYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZ2V0IG1ldGhvZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI21ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI21ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNCb2R5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlBPU1RcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJHRVRcIjtcbiAgICB9XG4gICAgc2V0IG1ldGhvZChtZXRob2QpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21ldGhvZCA9IFN0cmluZyhtZXRob2QpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgaGVhZGVycyB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIHJlcXVlc3RpbmcgdGhlIFVSSS4gQWxsXG4gICAgICogIGtleXMgYXJlIGxvd2VyLWNhc2UuXG4gICAgICpcbiAgICAgKiAgVGhpcyBvYmplY3QgaXMgYSBjb3B5LCBzbyBhbnkgY2huYWdlcyB3aWxsICoqTk9UKiogYmUgcmVmbGVjdGVkXG4gICAgICogIGluIHRoZSBgYEZldGNoUmVxdWVzdGBgLlxuICAgICAqXG4gICAgICogIFRvIHNldCBhIGhlYWRlciBlbnRyeSwgdXNlIHRoZSBgYHNldEhlYWRlcmBgIG1ldGhvZC5cbiAgICAgKi9cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpO1xuICAgICAgICBpZiAodGhpcy4jY3JlZHMpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdID0gYEJhc2ljICR7ZW5jb2RlQmFzZTY0KHRvVXRmOEJ5dGVzKHRoaXMuI2NyZWRzKSl9YDtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGlmICh0aGlzLmFsbG93R3ppcCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImFjY2VwdC1lbmNvZGluZ1wiXSA9IFwiZ3ppcFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID09IG51bGwgJiYgdGhpcy4jYm9keVR5cGUpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSB0aGlzLiNib2R5VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib2R5KSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl0gPSBTdHJpbmcodGhpcy5ib2R5Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGhlYWRlciBmb3IgJSVrZXklJSwgaWdub3JpbmcgY2FzZS5cbiAgICAgKi9cbiAgICBnZXRIZWFkZXIoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU2V0IHRoZSBoZWFkZXIgZm9yICUla2V5JSUgdG8gJSV2YWx1ZSUlLiBBbGwgdmFsdWVzIGFyZSBjb2VyY2VkXG4gICAgICogIHRvIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIHNldEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2hlYWRlcnNbU3RyaW5nKGtleSkudG9Mb3dlckNhc2UoKV0gPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2xlYXIgYWxsIGhlYWRlcnMsIHJlc2V0dGluZyBhbGwgaW50cmluc2ljIGhlYWRlcnMuXG4gICAgICovXG4gICAgY2xlYXJIZWFkZXJzKCkge1xuICAgICAgICB0aGlzLiNoZWFkZXJzID0ge307XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5oZWFkZXJzO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycyk7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBba2V5LCBoZWFkZXJzW2tleV1dLCBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdmFsdWUgdGhhdCB3aWxsIGJlIHNlbnQgZm9yIHRoZSBgYEF1dGhvcml6YXRpb25gYCBoZWFkZXIuXG4gICAgICpcbiAgICAgKiAgVG8gc2V0IHRoZSBjcmVkZW50aWFscywgdXNlIHRoZSBgYHNldENyZWRlbnRpYWxzYGAgbWV0aG9kLlxuICAgICAqL1xuICAgIGdldCBjcmVkZW50aWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NyZWRzIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTZXRzIGFuIGBgQXV0aG9yaXphdGlvbmBgIGZvciAlJXVzZXJuYW1lJSUgd2l0aCAlJXBhc3N3b3JkJSUuXG4gICAgICovXG4gICAgc2V0Q3JlZGVudGlhbHModXNlcm5hbWUsIHBhc3N3b3JkKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCF1c2VybmFtZS5tYXRjaCgvOi8pLCBcImludmFsaWQgYmFzaWMgYXV0aGVudGljYXRpb24gdXNlcm5hbWVcIiwgXCJ1c2VybmFtZVwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIHRoaXMuI2NyZWRzID0gYCR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuYWJsZSBhbmQgcmVxdWVzdCBnemlwLWVuY29kZWQgcmVzcG9uc2VzLiBUaGUgcmVzcG9uc2Ugd2lsbFxuICAgICAqICBhdXRvbWF0aWNhbGx5IGJlIGRlY29tcHJlc3NlZC4gLy8oZGVmYXVsdDogdHJ1ZSkvL1xuICAgICAqL1xuICAgIGdldCBhbGxvd0d6aXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnemlwO1xuICAgIH1cbiAgICBzZXQgYWxsb3dHemlwKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2d6aXAgPSAhIXZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxsb3cgYGBBdXRoZW50aWNhdGlvbmBgIGNyZWRlbnRpYWxzIHRvIGJlIHNlbnQgb3ZlciBpbnNlY3VyZVxuICAgICAqICBjaGFubmVscy4gLy8oZGVmYXVsdDogZmFsc2UpLy9cbiAgICAgKi9cbiAgICBnZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiNhbGxvd0luc2VjdXJlO1xuICAgIH1cbiAgICBzZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2FsbG93SW5zZWN1cmUgPSAhIXZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRpbWVvdXQgKGluIG1pbGxpc2Vjb25kcykgdG8gd2FpdCBmb3IgYSBjb21wbGVyZSByZXNwb25zZS5cbiAgICAgKiAgLy8oZGVmYXVsdDogNSBtaW51dGVzKS8vXG4gICAgICovXG4gICAgZ2V0IHRpbWVvdXQoKSB7IHJldHVybiB0aGlzLiN0aW1lb3V0OyB9XG4gICAgc2V0IHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0aW1lb3V0ID49IDAsIFwidGltZW91dCBtdXN0IGJlIG5vbi16ZXJvXCIsIFwidGltZW91dFwiLCB0aW1lb3V0KTtcbiAgICAgICAgdGhpcy4jdGltZW91dCA9IHRpbWVvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBwcmlvciB0byBlYWNoIHJlcXVlc3QsIGZvciBleGFtcGxlXG4gICAgICogIGR1cmluZyBhIHJlZGlyZWN0aW9uIG9yIHJldHJ5IGluIGNhc2Ugb2Ygc2VydmVyIHRocm90dGxpbmcuXG4gICAgICpcbiAgICAgKiAgVGhpcyBvZmZlcnMgYW4gb3Bwb3J0dW5pdHkgdG8gcG9wdWxhdGUgaGVhZGVycyBvciB1cGRhdGVcbiAgICAgKiAgY29udGVudCBiZWZvcmUgc2VuZGluZyBhIHJlcXVlc3QuXG4gICAgICovXG4gICAgZ2V0IHByZWZsaWdodEZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwcmVmbGlnaHQgfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0IHByZWZsaWdodEZ1bmMocHJlZmxpZ2h0KSB7XG4gICAgICAgIHRoaXMuI3ByZWZsaWdodCA9IHByZWZsaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIGVhY2ggcmVzcG9uc2UsIG9mZmVyaW5nIGFuXG4gICAgICogIG9wcG9ydHVuaXR5IHRvIHByb3ZpZGUgY2xpZW50LWxldmVsIHRocm90dGxpbmcgb3IgdXBkYXRpbmdcbiAgICAgKiAgcmVzcG9uc2UgZGF0YS5cbiAgICAgKlxuICAgICAqICBBbnkgZXJyb3IgdGhyb3duIGluIHRoaXMgY2F1c2VzIHRoZSBgYHNlbmQoKWBgIHRvIHRocm93LlxuICAgICAqXG4gICAgICogIFRvIHNjaGVkdWxlIGEgcmV0cnkgYXR0ZW1wdCAoYXNzdW1pbmcgdGhlIG1heGltdW0gcmV0cnkgbGltaXRcbiAgICAgKiAgaGFzIG5vdCBiZWVuIHJlYWNoZWQpLCB1c2UgW1tyZXNwb25zZS50aHJvd1Rocm90dGxlRXJyb3JdXS5cbiAgICAgKi9cbiAgICBnZXQgcHJvY2Vzc0Z1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwcm9jZXNzIHx8IG51bGw7XG4gICAgfVxuICAgIHNldCBwcm9jZXNzRnVuYyhwcm9jZXNzKSB7XG4gICAgICAgIHRoaXMuI3Byb2Nlc3MgPSBwcm9jZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZWFjaCByZXRyeSBhdHRlbXB0LlxuICAgICAqL1xuICAgIGdldCByZXRyeUZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZXRyeSB8fCBudWxsO1xuICAgIH1cbiAgICBzZXQgcmV0cnlGdW5jKHJldHJ5KSB7XG4gICAgICAgIHRoaXMuI3JldHJ5ID0gcmV0cnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBmZXRjaCBjb250ZW50IGZyb20gSFRUUCBhbmRcbiAgICAgKiAgSFRUUFMgVVJMcyBhbmQgaXMgcGxhdGZvcm0gc3BlY2lmaWMgKGUuZy4gbm9kZWpzIHZzXG4gICAgICogIGJyb3dzZXJzKS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGJ5IGRlZmF1bHQgdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIGdsb2JhbCBnZXRVcmxcbiAgICAgKiAgZnVuY3Rpb24sIHdoaWNoIGNhbiBiZSBjaGFuZ2VkIHVzaW5nIFtbcmVnaXN0ZXJHZXRVcmxdXS5cbiAgICAgKiAgSWYgdGhpcyBoYXMgYmVlbiBzZXQsIHNldHRpbmcgaXMgdG8gYGBudWxsYGAgd2lsbCBjYXVzZVxuICAgICAqICB0aGlzIEZldGNoUmVxdWVzdCAoYW5kIGFueSBmdXR1cmUgY2xvbmVzKSB0byByZXZlcnQgYmFjayB0b1xuICAgICAqICB1c2luZyB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgZ2xvYmFsIGdldFVybCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICBTZXR0aW5nIHRoaXMgaXMgZ2VuZXJhbGx5IG5vdCBuZWNlc3NhcnksIGJ1dCBtYXkgYmUgdXNlZnVsXG4gICAgICogIGZvciBkZXZlbG9wZXJzIHRoYXQgd2lzaCB0byBpbnRlcmNlcHQgcmVxdWVzdHMgb3IgdG9cbiAgICAgKiAgY29uZmlndXJlZ2UgYSBwcm94eSBvciBvdGhlciBhZ2VudC5cbiAgICAgKi9cbiAgICBnZXQgZ2V0VXJsRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldFVybEZ1bmMgfHwgZGVmYXVsdEdldFVybEZ1bmM7XG4gICAgfVxuICAgIHNldCBnZXRVcmxGdW5jKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2dldFVybEZ1bmMgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBGZXRjaFJlcXVlc3QgaW5zdGFuY2Ugd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICBPbmNlIGNyZWF0ZWQsIGVhY2ggcHJvcGVydHkgbWF5IGJlIHNldCBiZWZvcmUgaXNzdWluZyBhXG4gICAgICogIGBgLnNlbmQoKWBgIHRvIG1ha2UgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgICAgIHRoaXMuI3VybCA9IFN0cmluZyh1cmwpO1xuICAgICAgICB0aGlzLiNhbGxvd0luc2VjdXJlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2d6aXAgPSB0cnVlO1xuICAgICAgICB0aGlzLiNoZWFkZXJzID0ge307XG4gICAgICAgIHRoaXMuI21ldGhvZCA9IFwiXCI7XG4gICAgICAgIHRoaXMuI3RpbWVvdXQgPSAzMDAwMDA7XG4gICAgICAgIHRoaXMuI3Rocm90dGxlID0ge1xuICAgICAgICAgICAgc2xvdEludGVydmFsOiBTTE9UX0lOVEVSVkFMLFxuICAgICAgICAgICAgbWF4QXR0ZW1wdHM6IE1BWF9BVFRFTVBUU1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiNnZXRVcmxGdW5jID0gbnVsbDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgPEZldGNoUmVxdWVzdCBtZXRob2Q9JHtKU09OLnN0cmluZ2lmeSh0aGlzLm1ldGhvZCl9IHVybD0ke0pTT04uc3RyaW5naWZ5KHRoaXMudXJsKX0gaGVhZGVycz0ke0pTT04uc3RyaW5naWZ5KHRoaXMuaGVhZGVycyl9IGJvZHk9JHt0aGlzLiNib2R5ID8gaGV4bGlmeSh0aGlzLiNib2R5KSA6IFwibnVsbFwifT5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVXBkYXRlIHRoZSB0aHJvdHRsZSBwYXJhbWV0ZXJzIHVzZWQgdG8gZGV0ZXJtaW5lIG1heGltdW1cbiAgICAgKiAgYXR0ZW1wdHMgYW5kIGV4cG9uZW50aWFsLWJhY2tvZmYgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBzZXRUaHJvdHRsZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5zbG90SW50ZXJ2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jdGhyb3R0bGUuc2xvdEludGVydmFsID0gcGFyYW1zLnNsb3RJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLm1heEF0dGVtcHRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI3Rocm90dGxlLm1heEF0dGVtcHRzID0gcGFyYW1zLm1heEF0dGVtcHRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICNzZW5kKGF0dGVtcHQsIGV4cGlyZXMsIGRlbGF5LCBfcmVxdWVzdCwgX3Jlc3BvbnNlKSB7XG4gICAgICAgIGlmIChhdHRlbXB0ID49IHRoaXMuI3Rocm90dGxlLm1heEF0dGVtcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3BvbnNlLm1ha2VTZXJ2ZXJFcnJvcihcImV4Y2VlZGVkIG1heGltdW0gcmV0cnkgbGltaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGdldFRpbWUoKSA8PSBleHBpcmVzLCBcInRpbWVvdXRcIiwgXCJUSU1FT1VUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXF1ZXN0LnNlbmRcIiwgcmVhc29uOiBcInRpbWVvdXRcIiwgcmVxdWVzdDogX3JlcXVlc3RcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHdhaXQoZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXEgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGNvbnN0IHNjaGVtZSA9IChyZXEudXJsLnNwbGl0KFwiOlwiKVswXSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBQcm9jZXNzIGFueSBHYXRld2F5c1xuICAgICAgICBpZiAoc2NoZW1lIGluIEdhdGV3YXlzKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBHYXRld2F5c1tzY2hlbWVdKHJlcS51cmwsIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBGZXRjaFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NGdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb2Nlc3NGdW5jKHJlcSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIHByb2Nlc3Npbmc7IHRocm93IGEgNXh4IHNlcnZlciBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnRocm90dGxlID09IG51bGwgfHwgdHlwZW9mIChlcnJvci5zdGFsbCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5tYWtlU2VydmVyRXJyb3IoXCJlcnJvciBpbiBwb3N0LXByb2Nlc3NpbmcgZnVuY3Rpb25cIiwgZXJyb3IpLmFzc2VydE9rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGhyb3R0bGluZ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIGEgcHJlZmxpZ2h0IGZ1bmN0aW9uOyB1cGRhdGUgdGhlIHJlcXVlc3RcbiAgICAgICAgaWYgKHRoaXMucHJlZmxpZ2h0RnVuYykge1xuICAgICAgICAgICAgcmVxID0gYXdhaXQgdGhpcy5wcmVmbGlnaHRGdW5jKHJlcSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuZ2V0VXJsRnVuYyhyZXEsIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gbmV3IEZldGNoUmVzcG9uc2UocmVzcC5zdGF0dXNDb2RlLCByZXNwLnN0YXR1c01lc3NhZ2UsIHJlc3AuaGVhZGVycywgcmVzcC5ib2R5LCBfcmVxdWVzdCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDEgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAyKSB7XG4gICAgICAgICAgICAvLyBSZWRpcmVjdFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb24gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLnJlZGlyZWN0KGxvY2F0aW9uKS4jc2VuZChhdHRlbXB0ICsgMSwgZXhwaXJlcywgMCwgX3JlcXVlc3QsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAvLyBUaGluZ3Mgd29uJ3QgZ2V0IGFueSBiZXR0ZXIgb24gYW5vdGhlciBhdHRlbXB0OyBhYm9ydFxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQyOSkge1xuICAgICAgICAgICAgLy8gVGhyb3R0bGVcbiAgICAgICAgICAgIGlmICh0aGlzLnJldHJ5RnVuYyA9PSBudWxsIHx8IChhd2FpdCB0aGlzLnJldHJ5RnVuYyhyZXEsIHJlc3BvbnNlLCBhdHRlbXB0KSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXRyeUFmdGVyID0gcmVzcG9uc2UuaGVhZGVyc1tcInJldHJ5LWFmdGVyXCJdO1xuICAgICAgICAgICAgICAgIGxldCBkZWxheSA9IHRoaXMuI3Rocm90dGxlLnNsb3RJbnRlcnZhbCAqIE1hdGgudHJ1bmMoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChyZXRyeUFmdGVyKSA9PT0gXCJzdHJpbmdcIiAmJiByZXRyeUFmdGVyLm1hdGNoKC9eWzEtOV1bMC05XSokLykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBwYXJzZUludChyZXRyeUFmdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5jbG9uZSgpLiNzZW5kKGF0dGVtcHQgKyAxLCBleHBpcmVzLCBkZWxheSwgX3JlcXVlc3QsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9jZXNzRnVuYykge1xuICAgICAgICAgICAgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm9jZXNzRnVuYyhyZXEsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBwcm9jZXNzaW5nOyB0aHJvdyBhIDV4eCBzZXJ2ZXIgZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IudGhyb3R0bGUgPT0gbnVsbCB8fCB0eXBlb2YgKGVycm9yLnN0YWxsKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5tYWtlU2VydmVyRXJyb3IoXCJlcnJvciBpbiBwb3N0LXByb2Nlc3NpbmcgZnVuY3Rpb25cIiwgZXJyb3IpLmFzc2VydE9rKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRocm90dGxlXG4gICAgICAgICAgICAgICAgbGV0IGRlbGF5ID0gdGhpcy4jdGhyb3R0bGUuc2xvdEludGVydmFsICogTWF0aC50cnVuYyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpO1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3Iuc3RhbGwgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxheSA9IGVycm9yLnN0YWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLmNsb25lKCkuI3NlbmQoYXR0ZW1wdCArIDEsIGV4cGlyZXMsIGRlbGF5LCBfcmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSByZXNwb25zZSBieSBzZW5kaW5nIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIHNlbmQoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLiNzaWduYWwgPT0gbnVsbCwgXCJyZXF1ZXN0IGFscmVhZHkgc2VudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmZXRjaFJlcXVlc3Quc2VuZFwiIH0pO1xuICAgICAgICB0aGlzLiNzaWduYWwgPSBuZXcgRmV0Y2hDYW5jZWxTaWduYWwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNzZW5kKDAsIGdldFRpbWUoKSArIHRoaXMudGltZW91dCwgMCwgdGhpcywgbmV3IEZldGNoUmVzcG9uc2UoMCwgXCJcIiwge30sIG51bGwsIHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENhbmNlbHMgdGhlIGluZmxpZ2h0IHJlc3BvbnNlLCBjYXVzaW5nIGEgYGBDQU5DRUxMRURgYFxuICAgICAqICBlcnJvciB0byBiZSByZWplY3RlZCBmcm9tIHRoZSBbW3NlbmRdXS5cbiAgICAgKi9cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLiNzaWduYWwgIT0gbnVsbCwgXCJyZXF1ZXN0IGhhcyBub3QgYmVlbiBzZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImZldGNoUmVxdWVzdC5jYW5jZWxcIiB9KTtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gZmV0Y2hTaWduYWxzLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKCFzaWduYWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgc2lnbmFsOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBzaWduYWwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGZXRjaFJlcXVlc3RdXSB0aGF0IHJlcHJlc2VudHMgdGhlIHJlZGlyZWN0aW9uXG4gICAgICogIHRvICUlbG9jYXRpb24lJS5cbiAgICAgKi9cbiAgICByZWRpcmVjdChsb2NhdGlvbikge1xuICAgICAgICAvLyBSZWRpcmVjdGlvbjsgZm9yIG5vdyB3ZSBvbmx5IHN1cHBvcnQgYWJzb2x1dGUgbG9jYXRhaW9uc1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy51cmwuc3BsaXQoXCI6XCIpWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGxvY2F0aW9uLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBEb24ndCBhbGxvdyByZWRpcmVjdGluZzpcbiAgICAgICAgLy8gLSBub24tR0VUIHJlcXVlc3RzXG4gICAgICAgIC8vIC0gZG93bmdyYWRpbmcgdGhlIHNlY3VyaXR5IChlLmcuIGh0dHBzID0+IGh0dHApXG4gICAgICAgIC8vIC0gdG8gbm9uLUhUVFAgKG9yIG5vbi1IVFRQUykgcHJvdG9jb2xzIFt0aGlzIGNvdWxkIGJlIHJlbGF4ZWQ/XVxuICAgICAgICBhc3NlcnQodGhpcy5tZXRob2QgPT09IFwiR0VUXCIgJiYgKGN1cnJlbnQgIT09IFwiaHR0cHNcIiB8fCB0YXJnZXQgIT09IFwiaHR0cFwiKSAmJiBsb2NhdGlvbi5tYXRjaCgvXmh0dHBzPzovKSwgYHVuc3VwcG9ydGVkIHJlZGlyZWN0YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBgcmVkaXJlY3QoJHt0aGlzLm1ldGhvZH0gJHtKU09OLnN0cmluZ2lmeSh0aGlzLnVybCl9ID0+ICR7SlNPTi5zdHJpbmdpZnkobG9jYXRpb24pfSlgXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgcmVxdWVzdCwgd2l0aCBhIG5ldyBVUkxcbiAgICAgICAgY29uc3QgcmVxID0gbmV3IEZldGNoUmVxdWVzdChsb2NhdGlvbik7XG4gICAgICAgIHJlcS5tZXRob2QgPSBcIkdFVFwiO1xuICAgICAgICByZXEuYWxsb3dHemlwID0gdGhpcy5hbGxvd0d6aXA7XG4gICAgICAgIHJlcS50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgICByZXEuI2hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuI2JvZHkpIHtcbiAgICAgICAgICAgIHJlcS4jYm9keSA9IG5ldyBVaW50OEFycmF5KHRoaXMuI2JvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJlcS4jYm9keVR5cGUgPSB0aGlzLiNib2R5VHlwZTtcbiAgICAgICAgLy8gRG8gbm90IGZvcndhcmQgY3JlZGVudGlhbHMgdW5sZXNzIG9uIHRoZSBzYW1lIGRvbWFpbjsgb25seSBhYnNvbHV0ZVxuICAgICAgICAvL3JlcS5hbGxvd0luc2VjdXJlID0gZmFsc2U7XG4gICAgICAgIC8vIHBhdGhzIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkOyBtYXkgd2FudCBhIHdheSB0byBzcGVjaWZ5IHRvIGZvcndhcmQ/XG4gICAgICAgIC8vc2V0U3RvcmUocmVxLiNwcm9wcywgXCJjcmVkc1wiLCBnZXRTdG9yZSh0aGlzLiNwcm9zLCBcImNyZWRzXCIpKTtcbiAgICAgICAgcmV0dXJuIHJlcTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBjb3B5IG9mIHRoaXMgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgRmV0Y2hSZXF1ZXN0KHRoaXMudXJsKTtcbiAgICAgICAgLy8gUHJlc2VydmUgXCJkZWZhdWx0IG1ldGhvZFwiIChpLmUuIG51bGwpXG4gICAgICAgIGNsb25lLiNtZXRob2QgPSB0aGlzLiNtZXRob2Q7XG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBib2R5XCIgd2l0aCB0eXBlLCBjb3B5aW5nIHRoZSBVaW50OEFycmF5IGlzIHByZXNlbnRcbiAgICAgICAgaWYgKHRoaXMuI2JvZHkpIHtcbiAgICAgICAgICAgIGNsb25lLiNib2R5ID0gdGhpcy4jYm9keTtcbiAgICAgICAgfVxuICAgICAgICBjbG9uZS4jYm9keVR5cGUgPSB0aGlzLiNib2R5VHlwZTtcbiAgICAgICAgLy8gUHJlc2VydmUgXCJkZWZhdWx0IGhlYWRlcnNcIlxuICAgICAgICBjbG9uZS4jaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpO1xuICAgICAgICAvLyBDcmVkZW50aWFscyBpcyByZWFkb25seSwgc28gd2UgY29weSBpbnRlcm5hbGx5XG4gICAgICAgIGNsb25lLiNjcmVkcyA9IHRoaXMuI2NyZWRzO1xuICAgICAgICBpZiAodGhpcy5hbGxvd0d6aXApIHtcbiAgICAgICAgICAgIGNsb25lLmFsbG93R3ppcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmUudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKSB7XG4gICAgICAgICAgICBjbG9uZS5hbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNsb25lLiNwcmVmbGlnaHQgPSB0aGlzLiNwcmVmbGlnaHQ7XG4gICAgICAgIGNsb25lLiNwcm9jZXNzID0gdGhpcy4jcHJvY2VzcztcbiAgICAgICAgY2xvbmUuI3JldHJ5ID0gdGhpcy4jcmV0cnk7XG4gICAgICAgIGNsb25lLiNnZXRVcmxGdW5jID0gdGhpcy4jZ2V0VXJsRnVuYztcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgTG9ja3MgYWxsIHN0YXRpYyBjb25maWd1cmF0aW9uIGZvciBnYXRld2F5cyBhbmQgRmV0Y2hHZXRVcmxGdW5jXG4gICAgICogIHJlZ2lzdHJhdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgbG9ja0NvbmZpZygpIHtcbiAgICAgICAgbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgY3VycmVudCBHYXRld2F5IGZ1bmN0aW9uIGZvciAlJXNjaGVtZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRHYXRld2F5KHNjaGVtZSkge1xuICAgICAgICByZXR1cm4gR2F0ZXdheXNbc2NoZW1lLnRvTG93ZXJDYXNlKCldIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVc2UgdGhlICUlZnVuYyUlIHdoZW4gZmV0Y2hpbmcgVVJJcyB1c2luZyAlJXNjaGVtZSUlLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGFmZmVjdHMgYWxsIHJlcXVlc3RzIGdsb2JhbGx5LlxuICAgICAqXG4gICAgICogIElmIFtbbG9ja0NvbmZpZ11dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2hhbmdlIGlzIG1hZGUgYW5kIHRoaXNcbiAgICAgKiAgdGhyb3dzLlxuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlckdhdGV3YXkoc2NoZW1lLCBmdW5jKSB7XG4gICAgICAgIHNjaGVtZSA9IHNjaGVtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc2NoZW1lID09PSBcImh0dHBcIiB8fCBzY2hlbWUgPT09IFwiaHR0cHNcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgaW50ZXJjZXB0ICR7c2NoZW1lfTsgdXNlIHJlZ2lzdGVyR2V0VXJsYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2F0ZXdheXMgbG9ja2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIEdhdGV3YXlzW3NjaGVtZV0gPSBmdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVXNlICUlZ2V0VXJsJSUgd2hlbiBmZXRjaGluZyBVUklzIG92ZXIgSFRUUCBhbmQgSFRUUFMgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgYWZmZWN0cyBhbGwgcmVxdWVzdHMgZ2xvYmFsbHkuXG4gICAgICpcbiAgICAgKiAgSWYgW1tsb2NrQ29uZmlnXV0gaGFzIGJlZW4gY2FsbGVkLCBubyBjaGFuZ2UgaXMgbWFkZSBhbmQgdGhpc1xuICAgICAqICB0aHJvd3MuXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyR2V0VXJsKGdldFVybCkge1xuICAgICAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnYXRld2F5cyBsb2NrZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdEdldFVybEZ1bmMgPSBnZXRVcmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgZ2V0VXJsIGZ1bmN0aW9uIHRoYXQgZmV0Y2hlcyBjb250ZW50IGZyb20gSFRUUCBhbmRcbiAgICAgKiAgSFRUUFMgVVJMcy5cbiAgICAgKlxuICAgICAqICBUaGUgYXZhaWxhYmxlICUlb3B0aW9ucyUlIGFyZSBkZXBlbmRlbnQgb24gdGhlIHBsYXRmb3JtXG4gICAgICogIGltcGxlbWVudGF0aW9uIG9mIHRoZSBkZWZhdWx0IGdldFVybCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBnZW5lcmFsbHkgc29tZXRoaW5nIHRoYXQgaXMgbmVlZGVkLCBidXQgaXMgdXNlZnVsXG4gICAgICogIHdoZW4gdHJ5aW5nIHRvIGN1c3RvbWl6ZSBzaW1wbGUgYmVoYXZpb3VyIHdoZW4gZmV0Y2hpbmcgSFRUUFxuICAgICAqICBjb250ZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVHZXRVcmxGdW5jKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUdldFVybChvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBcImZldGNoXCIgZGF0YSBVUklzLlxuICAgICAqXG4gICAgICogIE5vdGUgdGhhdCB0aGlzIGlzIGF1dG9tYXRpY2FsbHkgZG9uZSBpbnRlcm5hbGx5IHRvIHN1cHBvcnRcbiAgICAgKiAgZGF0YSBVUklzLCBzbyBpdCBpcyBub3QgbmVjZXNzYXJ5IHRvIHJlZ2lzdGVyIGl0LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgbm90IGdlbmVyYWxseSBzb21ldGhpbmcgdGhhdCBpcyBuZWVkZWQsIGJ1dCBtYXlcbiAgICAgKiAgYmUgdXNlZnVsIGluIGEgd3JhcHBlciB0byBwZXJmb20gY3VzdG9tIGRhdGEgVVJJIGZ1bmN0aW9uYWxpdHkuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZURhdGFHYXRld2F5KCkge1xuICAgICAgICByZXR1cm4gZGF0YUdhdGV3YXlGdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBmZXRjaCBJUEZTICh1bnZhbGlkYXRlZCkgZnJvbVxuICAgICAqICBhIGN1c3RvbSBnYXRld2F5IGJhc2VVcmwuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlZmF1bHQgSVBGUyBnYXRld2F5IHVzZWQgaW50ZXJuYWxseSBpc1xuICAgICAqICBgYFwiaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzL1wiYGAuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUlwZnNHYXRld2F5RnVuYyhiYXNlVXJsKSB7XG4gICAgICAgIHJldHVybiBnZXRJcGZzR2F0ZXdheUZ1bmMoYmFzZVVybCk7XG4gICAgfVxufVxuO1xuLyoqXG4gKiAgVGhlIHJlc3BvbnNlIGZvciBhIEZldGNoUkVxdWVzdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEZldGNoUmVzcG9uc2Uge1xuICAgICNzdGF0dXNDb2RlO1xuICAgICNzdGF0dXNNZXNzYWdlO1xuICAgICNoZWFkZXJzO1xuICAgICNib2R5O1xuICAgICNyZXF1ZXN0O1xuICAgICNlcnJvcjtcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGA8RmV0Y2hSZXNwb25zZSBzdGF0dXM9JHt0aGlzLnN0YXR1c0NvZGV9IGJvZHk9JHt0aGlzLiNib2R5ID8gaGV4bGlmeSh0aGlzLiNib2R5KSA6IFwibnVsbFwifT5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIHN0YXR1cyBjb2RlLlxuICAgICAqL1xuICAgIGdldCBzdGF0dXNDb2RlKCkgeyByZXR1cm4gdGhpcy4jc3RhdHVzQ29kZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2Ugc3RhdHVzIG1lc3NhZ2UuXG4gICAgICovXG4gICAgZ2V0IHN0YXR1c01lc3NhZ2UoKSB7IHJldHVybiB0aGlzLiNzdGF0dXNNZXNzYWdlOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBoZWFkZXJzLiBBbGwga2V5cyBhcmUgbG93ZXItY2FzZS5cbiAgICAgKi9cbiAgICBnZXQgaGVhZGVycygpIHsgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBib2R5LCBvciBgYG51bGxgYCBpZiB0aGVyZSB3YXMgbm8gYm9keS5cbiAgICAgKi9cbiAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KHRoaXMuI2JvZHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGJvZHkgYXMgYSBVVEYtOCBlbmNvZGVkIHN0cmluZywgb3IgdGhlIGVtcHR5XG4gICAgICogIHN0cmluZyAoaS5lLiBgYFwiXCJgYCkgaWYgdGhlcmUgd2FzIG5vIGJvZHkuXG4gICAgICpcbiAgICAgKiAgQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBib2R5IGlzIGludmFsaWQgVVRGLTggZGF0YS5cbiAgICAgKi9cbiAgICBnZXQgYm9keVRleHQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgPT0gbnVsbCkgPyBcIlwiIDogdG9VdGY4U3RyaW5nKHRoaXMuI2JvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInJlc3BvbnNlIGJvZHkgaXMgbm90IHZhbGlkIFVURi04IGRhdGFcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJib2R5VGV4dFwiLCBpbmZvOiB7IHJlc3BvbnNlOiB0aGlzIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgYm9keSwgZGVjb2RlZCBhcyBKU09OLlxuICAgICAqXG4gICAgICogIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgYm9keSBpcyBpbnZhbGlkIEpTT04tZW5jb2RlZCBkYXRhXG4gICAgICogIG9yIGlmIHRoZXJlIHdhcyBubyBib2R5LlxuICAgICAqL1xuICAgIGdldCBib2R5SnNvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuYm9keVRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInJlc3BvbnNlIGJvZHkgaXMgbm90IHZhbGlkIEpTT05cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJib2R5SnNvblwiLCBpbmZvOiB7IHJlc3BvbnNlOiB0aGlzIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5oZWFkZXJzO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycyk7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBba2V5LCBoZWFkZXJzW2tleV1dLCBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMsIGJvZHksIHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy4jc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICAgIHRoaXMuI3N0YXR1c01lc3NhZ2UgPSBzdGF0dXNNZXNzYWdlO1xuICAgICAgICB0aGlzLiNoZWFkZXJzID0gT2JqZWN0LmtleXMoaGVhZGVycykucmVkdWNlKChhY2N1bSwgaykgPT4ge1xuICAgICAgICAgICAgYWNjdW1bay50b0xvd2VyQ2FzZSgpXSA9IFN0cmluZyhoZWFkZXJzW2tdKTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLiNib2R5ID0gKChib2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KGJvZHkpKTtcbiAgICAgICAgdGhpcy4jcmVxdWVzdCA9IChyZXF1ZXN0IHx8IG51bGwpO1xuICAgICAgICB0aGlzLiNlcnJvciA9IHsgbWVzc2FnZTogXCJcIiB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgUmVzcG9uc2Ugd2l0aCBtYXRjaGluZyBoZWFkZXJzIGFuZCBib2R5LCBidXQgd2l0aFxuICAgICAqICBhbiBlcnJvciBzdGF0dXMgY29kZSAoaS5lLiA1OTkpIGFuZCAlJW1lc3NhZ2UlJSB3aXRoIGFuXG4gICAgICogIG9wdGlvbmFsICUlZXJyb3IlJS5cbiAgICAgKi9cbiAgICBtYWtlU2VydmVyRXJyb3IobWVzc2FnZSwgZXJyb3IpIHtcbiAgICAgICAgbGV0IHN0YXR1c01lc3NhZ2U7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGAke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9YDtcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2UgPSBgQ0xJRU5UIEVTQ0FMQVRFRCBTRVJWRVIgRVJST1IgKCR7bWVzc2FnZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2UgPSBgQ0xJRU5UIEVTQ0FMQVRFRCBTRVJWRVIgRVJST1IgKCR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX07ICR7bWVzc2FnZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBGZXRjaFJlc3BvbnNlKDU5OSwgc3RhdHVzTWVzc2FnZSwgdGhpcy5oZWFkZXJzLCB0aGlzLmJvZHksIHRoaXMuI3JlcXVlc3QgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmVzcG9uc2UuI2Vycm9yID0geyBtZXNzYWdlLCBlcnJvciB9O1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiBjYWxsZWQgd2l0aGluIGEgW3JlcXVlc3QucHJvY2Vzc0Z1bmNdKEZldGNoUmVxdWVzdC1wcm9jZXNzRnVuYylcbiAgICAgKiAgY2FsbCwgY2F1c2VzIHRoZSByZXF1ZXN0IHRvIHJldHJ5IGFzIGlmIHRocm90dGxlZCBmb3IgJSVzdGFsbCUlXG4gICAgICogIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICB0aHJvd1Rocm90dGxlRXJyb3IobWVzc2FnZSwgc3RhbGwpIHtcbiAgICAgICAgaWYgKHN0YWxsID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YWxsID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKHN0YWxsKSAmJiBzdGFsbCA+PSAwLCBcImludmFsaWQgc3RhbGwgdGltZW91dFwiLCBcInN0YWxsXCIsIHN0YWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlIHx8IFwidGhyb3R0bGluZyByZXF1ZXN0c1wiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBzdGFsbCwgdGhyb3R0bGU6IHRydWUgfSk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBoZWFkZXIgdmFsdWUgZm9yICUla2V5JSUsIGlnbm9yaW5nIGNhc2UuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBvZiB0aGUgcmVzcG9uc2UgaGFzIGEgYm9keS5cbiAgICAgKi9cbiAgICBoYXNCb2R5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVxdWVzdCBtYWRlIGZvciB0aGlzIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIGdldCByZXF1ZXN0KCkgeyByZXR1cm4gdGhpcy4jcmVxdWVzdDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyByZXNwb25zZSB3YXMgYSBzdWNjZXNzIHN0YXR1c0NvZGUuXG4gICAgICovXG4gICAgb2soKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jZXJyb3IubWVzc2FnZSA9PT0gXCJcIiAmJiB0aGlzLnN0YXR1c0NvZGUgPj0gMjAwICYmIHRoaXMuc3RhdHVzQ29kZSA8IDMwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaHJvd3MgYSBgYFNFUlZFUl9FUlJPUmBgIGlmIHRoaXMgcmVzcG9uc2UgaXMgbm90IG9rLlxuICAgICAqL1xuICAgIGFzc2VydE9rKCkge1xuICAgICAgICBpZiAodGhpcy5vaygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgbWVzc2FnZSwgZXJyb3IgfSA9IHRoaXMuI2Vycm9yO1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGBzZXJ2ZXIgcmVzcG9uc2UgJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBtZXNzYWdlLCBcIlNFUlZFUl9FUlJPUlwiLCB7XG4gICAgICAgICAgICByZXF1ZXN0OiAodGhpcy5yZXF1ZXN0IHx8IFwidW5rbm93biByZXF1ZXN0XCIpLCByZXNwb25zZTogdGhpcywgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VGltZSgpIHsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7IH1cbmZ1bmN0aW9uIHVucGVyY2VudCh2YWx1ZSkge1xuICAgIHJldHVybiB0b1V0ZjhCeXRlcyh2YWx1ZS5yZXBsYWNlKC8lKFswLTlhLWZdWzAtOWEtZl0pL2dpLCAoYWxsLCBjb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGNvZGUsIDE2KSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gd2FpdChkZWxheSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2guanMubWFwIiwiLy9TZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvUkxQXG5pbXBvcnQgeyBoZXhsaWZ5IH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5mdW5jdGlvbiBoZXhsaWZ5Qnl0ZSh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuZnVuY3Rpb24gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IChyZXN1bHQgKiAyNTYpICsgZGF0YVtvZmZzZXQgKyBpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIGNoaWxkT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAoY2hpbGRPZmZzZXQgPCBvZmZzZXQgKyAxICsgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBfZGVjb2RlKGRhdGEsIGNoaWxkT2Zmc2V0KTtcbiAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZC5yZXN1bHQpO1xuICAgICAgICBjaGlsZE9mZnNldCArPSBkZWNvZGVkLmNvbnN1bWVkO1xuICAgICAgICBhc3NlcnQoY2hpbGRPZmZzZXQgPD0gb2Zmc2V0ICsgMSArIGxlbmd0aCwgXCJjaGlsZCBkYXRhIHRvbyBzaG9ydFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgICAgIGJ1ZmZlcjogZGF0YSwgbGVuZ3RoLCBvZmZzZXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG59XG4vLyByZXR1cm5zIHsgY29uc3VtZWQ6IG51bWJlciwgcmVzdWx0OiBPYmplY3QgfVxuZnVuY3Rpb24gX2RlY29kZShkYXRhLCBvZmZzZXQpIHtcbiAgICBhc3NlcnQoZGF0YS5sZW5ndGggIT09IDAsIFwiZGF0YSB0b28gc2hvcnRcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgIGJ1ZmZlcjogZGF0YSwgbGVuZ3RoOiAwLCBvZmZzZXQ6IDFcbiAgICB9KTtcbiAgICBjb25zdCBjaGVja09mZnNldCA9IChvZmZzZXQpID0+IHtcbiAgICAgICAgYXNzZXJ0KG9mZnNldCA8PSBkYXRhLmxlbmd0aCwgXCJkYXRhIHNob3J0IHNlZ21lbnQgdG9vIHNob3J0XCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGg6IGRhdGEubGVuZ3RoLCBvZmZzZXRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBBcnJheSB3aXRoIGV4dHJhIGxlbmd0aCBwcmVmaXhcbiAgICBpZiAoZGF0YVtvZmZzZXRdID49IDB4ZjgpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoTGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhmNztcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCArIDEsIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCwgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YzApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhjMDtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBvZmZzZXQgKyAxLCBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhiOCkge1xuICAgICAgICBjb25zdCBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGI3O1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweDgwKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4ODA7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBoZXhsaWZ5KGRhdGEuc2xpY2Uob2Zmc2V0ICsgMSwgb2Zmc2V0ICsgMSArIGxlbmd0aCkpO1xuICAgICAgICByZXR1cm4geyBjb25zdW1lZDogKDEgKyBsZW5ndGgpLCByZXN1bHQ6IHJlc3VsdCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBjb25zdW1lZDogMSwgcmVzdWx0OiBoZXhsaWZ5Qnl0ZShkYXRhW29mZnNldF0pIH07XG59XG4vKipcbiAqICBEZWNvZGVzICUlZGF0YSUlIGludG8gdGhlIHN0cnVjdHVyZWQgZGF0YSBpdCByZXByZXNlbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlUmxwKF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XG4gICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgMCk7XG4gICAgYXNzZXJ0QXJndW1lbnQoZGVjb2RlZC5jb25zdW1lZCA9PT0gZGF0YS5sZW5ndGgsIFwidW5leHBlY3RlZCBqdW5rIGFmdGVyIHJscCBwYXlsb2FkXCIsIFwiZGF0YVwiLCBfZGF0YSk7XG4gICAgcmV0dXJuIGRlY29kZWQucmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmxwLWRlY29kZS5qcy5tYXAiLCIvL1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9STFBcbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuZnVuY3Rpb24gYXJyYXlpZnlJbnRlZ2VyKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG4gICAgICAgIHZhbHVlID4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2VuY29kZShvYmplY3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGxldCBwYXlsb2FkID0gW107XG4gICAgICAgIG9iamVjdC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcGF5bG9hZCA9IHBheWxvYWQuY29uY2F0KF9lbmNvZGUoY2hpbGQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXlsb2FkLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICAgICAgcGF5bG9hZC51bnNoaWZ0KDB4YzAgKyBwYXlsb2FkLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheWlmeUludGVnZXIocGF5bG9hZC5sZW5ndGgpO1xuICAgICAgICBsZW5ndGgudW5zaGlmdCgweGY3ICsgbGVuZ3RoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBsZW5ndGguY29uY2F0KHBheWxvYWQpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZ2V0Qnl0ZXMob2JqZWN0LCBcIm9iamVjdFwiKSk7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAxICYmIGRhdGFbMF0gPD0gMHg3Zikge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YS5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgZGF0YS51bnNoaWZ0KDB4ODAgKyBkYXRhLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGggPSBhcnJheWlmeUludGVnZXIoZGF0YS5sZW5ndGgpO1xuICAgIGxlbmd0aC51bnNoaWZ0KDB4YjcgKyBsZW5ndGgubGVuZ3RoKTtcbiAgICByZXR1cm4gbGVuZ3RoLmNvbmNhdChkYXRhKTtcbn1cbmNvbnN0IG5pYmJsZXMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qKlxuICogIEVuY29kZXMgJSVvYmplY3QlJSBhcyBhbiBSTFAtZW5jb2RlZCBbW0RhdGFIZXhTdHJpbmddXS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVJscChvYmplY3QpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgIGZvciAoY29uc3QgdiBvZiBfZW5jb2RlKG9iamVjdCkpIHtcbiAgICAgICAgcmVzdWx0ICs9IG5pYmJsZXNbdiA+PiA0XTtcbiAgICAgICAgcmVzdWx0ICs9IG5pYmJsZXNbdiAmIDB4Zl07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ybHAtZW5jb2RlLmpzLm1hcCIsImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGNvbmNhdCwgZ2V0Qnl0ZXNDb3B5LCBnZXROdW1iZXIsIGhleGxpZnksIHRvQmVBcnJheSwgdG9CaWdJbnQsIHRvTnVtYmVyLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG4vKipcbiAqIEBfaWdub3JlOlxuICovXG5leHBvcnQgY29uc3QgV29yZFNpemUgPSAzMjtcbmNvbnN0IFBhZGRpbmcgPSBuZXcgVWludDhBcnJheShXb3JkU2l6ZSk7XG4vLyBQcm9wZXJ0aWVzIHVzZWQgdG8gaW1tZWRpYXRlIHBhc3MgdGhyb3VnaCB0byB0aGUgdW5kZXJseWluZyBvYmplY3Rcbi8vIC0gYHRoZW5gIGlzIHVzZWQgdG8gZGV0ZWN0IGlmIGFuIG9iamVjdCBpcyBhIFByb21pc2UgZm9yIGF3YWl0XG5jb25zdCBwYXNzUHJvcGVydGllcyA9IFtcInRoZW5cIl07XG5jb25zdCBfZ3VhcmQgPSB7fTtcbmZ1bmN0aW9uIHRocm93RXJyb3IobmFtZSwgZXJyb3IpIHtcbiAgICBjb25zdCB3cmFwcGVkID0gbmV3IEVycm9yKGBkZWZlcnJlZCBlcnJvciBkdXJpbmcgQUJJIGRlY29kaW5nIHRyaWdnZXJlZCBhY2Nlc3NpbmcgJHtuYW1lfWApO1xuICAgIHdyYXBwZWQuZXJyb3IgPSBlcnJvcjtcbiAgICB0aHJvdyB3cmFwcGVkO1xufVxuLyoqXG4gKiAgQSBbW1Jlc3VsdF1dIGlzIGEgc3ViLWNsYXNzIG9mIEFycmF5LCB3aGljaCBhbGxvd3MgYWNjZXNzaW5nIGFueVxuICogIG9mIGl0cyB2YWx1ZXMgZWl0aGVyIHBvc2l0aW9uYWxseSBieSBpdHMgaW5kZXggb3IsIGlmIGtleXMgYXJlXG4gKiAgcHJvdmlkZWQgYnkgaXRzIG5hbWUuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvYWJpXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXN1bHQgZXh0ZW5kcyBBcnJheSB7XG4gICAgI25hbWVzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gVG8gcHJvcGVybHkgc3ViLWNsYXNzIEFycmF5IHNvIHRoZSBvdGhlciBidWlsdC1pblxuICAgICAgICAvLyBmdW5jdGlvbnMgd29yaywgdGhlIGNvbnN0cnVjdG9yIGhhcyB0byBiZWhhdmUgZmFpcmx5XG4gICAgICAgIC8vIHdlbGwuIFNvLCBpbiB0aGUgZXZlbnQgd2UgYXJlIGNyZWF0ZWQgdmlhIGZyb21JdGVtcygpXG4gICAgICAgIC8vIHdlIGJ1aWxkIHRoZSByZWFkLW9ubHkgUmVzdWx0IG9iamVjdCB3ZSB3YW50LCBidXQgb25cbiAgICAgICAgLy8gYW55IG90aGVyIGlucHV0LCB3ZSB1c2UgdGhlIGRlZmF1bHQgY29uc3RydWN0b3JcbiAgICAgICAgLy8gY29uc3RydWN0b3IoZ3VhcmQ6IGFueSwgaXRlbXM6IEFycmF5PGFueT4sIGtleXM/OiBBcnJheTxudWxsIHwgc3RyaW5nPik7XG4gICAgICAgIGNvbnN0IGd1YXJkID0gYXJnc1swXTtcbiAgICAgICAgbGV0IGl0ZW1zID0gYXJnc1sxXTtcbiAgICAgICAgbGV0IG5hbWVzID0gKGFyZ3NbMl0gfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGxldCB3cmFwID0gdHJ1ZTtcbiAgICAgICAgaWYgKGd1YXJkICE9PSBfZ3VhcmQpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gYXJncztcbiAgICAgICAgICAgIG5hbWVzID0gW107XG4gICAgICAgICAgICB3cmFwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FuJ3QganVzdCBwYXNzIGluIC4uLml0ZW1zIHNpbmNlIGFuIGFycmF5IG9mIGxlbmd0aCAxXG4gICAgICAgIC8vIGlzIGEgc3BlY2lhbCBjYXNlIGluIHRoZSBzdXBlci5cbiAgICAgICAgc3VwZXIoaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHsgdGhpc1tpbmRleF0gPSBpdGVtOyB9KTtcbiAgICAgICAgLy8gRmluZCBhbGwgdW5pcXVlIGtleXNcbiAgICAgICAgY29uc3QgbmFtZUNvdW50cyA9IG5hbWVzLnJlZHVjZSgoYWNjdW0sIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYWNjdW0uc2V0KG5hbWUsIChhY2N1bS5nZXQobmFtZSkgfHwgMCkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwgKG5ldyBNYXAoKSkpO1xuICAgICAgICAvLyBSZW1vdmUgYW55IGtleSB0aGF0cyBub3QgdW5pcXVlXG4gICAgICAgIHRoaXMuI25hbWVzID0gT2JqZWN0LmZyZWV6ZShpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiBuYW1lQ291bnRzLmdldChuYW1lKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKCF3cmFwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSB3cmFwcGVkIFJlc3VsdCBpcyBpbW11dGFibGVcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgLy8gUHJveHkgaW5kaWNlcyBhbmQgbmFtZXMgc28gd2UgY2FuIHRyYXAgZGVmZXJyZWQgZXJyb3JzXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluZGV4IGFjY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldE51bWJlcihwcm9wLCBcIiVpbmRleFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByZXN1bHQgcmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGFyZ2V0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2luZGV4fWAsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyBpbXBvcnRhbnQgY2hlY2tzIChsaWtlIGB0aGVuYCBmb3IgUHJvbWlzZSkgdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICBpZiAocGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0YXJnZXRbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgZnVuY3Rpb25zIHdvcmsgd2l0aCBwcml2YXRlIHZhcmlhYmxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eSNub19wcml2YXRlX3Byb3BlcnR5X2ZvcndhcmRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSgodGhpcyA9PT0gcmVjZWl2ZXIpID8gdGFyZ2V0IDogdGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEocHJvcCBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NzaWJsZSBuYW1lIGFjY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmdldFZhbHVlLmFwcGx5KCh0aGlzID09PSByZWNlaXZlcikgPyB0YXJnZXQgOiB0aGlzLCBbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBSZXN1bHQgYXMgYSBub3JtYWwgQXJyYXkuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIHRoZXJlIGFyZSBhbnkgb3V0c3RhbmRpbmcgZGVmZXJyZWRcbiAgICAgKiAgZXJyb3JzLlxuICAgICAqL1xuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpbmRleH1gLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIFJlc3VsdCBhcyBhbiBPYmplY3Qgd2l0aCBlYWNoIG5hbWUtdmFsdWUgcGFpci5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgaWYgYW55IHZhbHVlIGlzIHVubmFtZWQsIG9yIGlmIHRoZXJlIGFyZVxuICAgICAqICBhbnkgb3V0c3RhbmRpbmcgZGVmZXJyZWQgZXJyb3JzLlxuICAgICAqL1xuICAgIHRvT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbmFtZXMucmVkdWNlKChhY2N1bSwgbmFtZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGFzc2VydChuYW1lICE9IG51bGwsIFwidmFsdWUgYXQgaW5kZXggJHsgaW5kZXggfSB1bm5hbWVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwidG9PYmplY3QoKVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFkZCB2YWx1ZXMgZm9yIG5hbWVzIHRoYXQgZG9uJ3QgY29uZmxpY3RcbiAgICAgICAgICAgIGlmICghKG5hbWUgaW4gYWNjdW0pKSB7XG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSB0aGlzLmdldFZhbHVlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZVxuICAgICAqL1xuICAgIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCArPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICAgICAgZW5kICs9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgICAgICAgICBlbmQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW10sIG5hbWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzW2ldKTtcbiAgICAgICAgICAgIG5hbWVzLnB1c2godGhpcy4jbmFtZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KF9ndWFyZCwgcmVzdWx0LCBuYW1lcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZVxuICAgICAqL1xuICAgIGZpbHRlcihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXSwgbmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2l9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBpdGVtLCBpLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIG5hbWVzLnB1c2godGhpcy4jbmFtZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KF9ndWFyZCwgcmVzdWx0LCBuYW1lcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZVxuICAgICAqL1xuICAgIG1hcChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2l9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGl0ZW0sIGksIHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdmFsdWUgZm9yICUlbmFtZSUlLlxuICAgICAqXG4gICAgICogIFNpbmNlIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgYSBrZXkgd2hvc2UgbmFtZSBjb25mbGljdHMgd2l0aFxuICAgICAqICBhIG1ldGhvZCBvbiBhIFtbUmVzdWx0XV0gb3IgaXRzIHN1cGVyY2xhc3MgQXJyYXksIG9yIGFueVxuICAgICAqICBKYXZhU2NyaXB0IGtleXdvcmQsIHRoaXMgZW5zdXJlcyBhbGwgbmFtZWQgdmFsdWVzIGFyZSBzdGlsbFxuICAgICAqICBhY2Nlc3NpYmxlIGJ5IG5hbWUuXG4gICAgICovXG4gICAgZ2V0VmFsdWUobmFtZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuI25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgdmFsdWUuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tSZXN1bHRdXSBmb3IgJSVpdGVtcyUlIHdpdGggZWFjaCBlbnRyeVxuICAgICAqICBhbHNvIGFjY2Vzc2libGUgYnkgaXRzIGNvcnJlc3BvbmRpbmcgbmFtZSBpbiAlJWtleXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUl0ZW1zKGl0ZW1zLCBrZXlzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KF9ndWFyZCwgaXRlbXMsIGtleXMpO1xuICAgIH1cbn1cbi8qKlxuICogIFJldHVybnMgYWxsIGVycm9ycyBmb3VuZCBpbiBhIFtbUmVzdWx0XV0uXG4gKlxuICogIFNpbmNlIGNlcnRhaW4gZXJyb3JzIGVuY291bnRlcmVkIHdoZW4gY3JlYXRpbmcgYSBbW1Jlc3VsdF1dIGRvXG4gKiAgbm90IGltcGFjdCB0aGUgYWJpbGl0eSB0byBjb250aW51ZSBwYXJzaW5nIGRhdGEsIHRoZXkgYXJlXG4gKiAgZGVmZXJyZWQgdW50aWwgdGhleSBhcmUgYWN0dWFsbHkgYWNjZXNzZWQuIEhlbmNlIGEgZmF1bHR5IHN0cmluZ1xuICogIGluIGFuIEV2ZW50IHRoYXQgaXMgbmV2ZXIgdXNlZCBkb2VzIG5vdCBpbXBhY3QgdGhlIHByb2dyYW0gZmxvdy5cbiAqXG4gKiAgSG93ZXZlciwgc29tZXRpbWVzIGl0IG1heSBiZSB1c2VmdWwgdG8gYWNjZXNzLCBpZGVudGlmeSBvclxuICogIHZhbGlkYXRlIGNvcnJlY3RuZXNzIG9mIGEgW1tSZXN1bHRdXS5cbiAqXG4gKiAgQF9kb2Nsb2MgYXBpL2FiaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZXN1bHRFcnJvcnMocmVzdWx0KSB7XG4gICAgLy8gRmluZCB0aGUgZmlyc3QgZXJyb3IgKGlmIGFueSlcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCBjaGVja0Vycm9ycyA9IGZ1bmN0aW9uIChwYXRoLCBvYmplY3QpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoLnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZFBhdGgucHVzaChrZXkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGVja0Vycm9ycyhjaGlsZFBhdGgsIG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgcGF0aDogY2hpbGRQYXRoLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNoZWNrRXJyb3JzKFtdLCByZXN1bHQpO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGxldCBieXRlcyA9IHRvQmVBcnJheSh2YWx1ZSk7XG4gICAgYXNzZXJ0KGJ5dGVzLmxlbmd0aCA8PSBXb3JkU2l6ZSwgXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwgeyBidWZmZXI6IGJ5dGVzLCBsZW5ndGg6IFdvcmRTaXplLCBvZmZzZXQ6IGJ5dGVzLmxlbmd0aCB9KTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBXb3JkU2l6ZSkge1xuICAgICAgICBieXRlcyA9IGdldEJ5dGVzQ29weShjb25jYXQoW1BhZGRpbmcuc2xpY2UoYnl0ZXMubGVuZ3RoICUgV29yZFNpemUpLCBieXRlc10pKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIENvZGVyIHtcbiAgICAvLyBUaGUgY29kZXIgbmFtZTpcbiAgICAvLyAgIC0gYWRkcmVzcywgdWludDI1NiwgdHVwbGUsIGFycmF5LCBldGMuXG4gICAgbmFtZTtcbiAgICAvLyBUaGUgZnVsbHkgZXhwYW5kZWQgdHlwZSwgaW5jbHVkaW5nIGNvbXBvc2l0ZSB0eXBlczpcbiAgICAvLyAgIC0gYWRkcmVzcywgdWludDI1NiwgdHVwbGUoYWRkcmVzcyxieXRlcyksIHVpbnQyNTZbM11bNF1bXSwgIGV0Yy5cbiAgICB0eXBlO1xuICAgIC8vIFRoZSBsb2NhbE5hbWUgYm91bmQgaW4gdGhlIHNpZ25hdHVyZSwgaW4gdGhpcyBleGFtcGxlIGl0IGlzIFwiYmF6XCI6XG4gICAgLy8gICAtIHR1cGxlKGFkZHJlc3MgZm9vLCB1aW50IGJhcikgYmF6XG4gICAgbG9jYWxOYW1lO1xuICAgIC8vIFdoZXRoZXIgdGhpcyB0eXBlIGlzIGR5bmFtaWM6XG4gICAgLy8gIC0gRHluYW1pYzogYnl0ZXMsIHN0cmluZywgYWRkcmVzc1tdLCB0dXBsZShib29sZWFuW10pLCBldGMuXG4gICAgLy8gIC0gTm90IER5bmFtaWM6IGFkZHJlc3MsIHVpbnQyNTYsIGJvb2xlYW5bM10sIHR1cGxlKGFkZHJlc3MsIHVpbnQ4KVxuICAgIGR5bmFtaWM7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJzdHJpbmdcIiwgdHlwZTogXCJzdHJpbmdcIiwgbG9jYWxOYW1lOiBcInN0cmluZ1wiLCBkeW5hbWljOiBcImJvb2xlYW5cIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Rocm93RXJyb3IobWVzc2FnZSwgdmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIG1lc3NhZ2UsIHRoaXMubG9jYWxOYW1lLCB2YWx1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIFdyaXRlciB7XG4gICAgLy8gQW4gYXJyYXkgb2YgV29yZFNpemUgbGVuZ3RoZWQgb2JqZWN0cyB0byBjb25jYXRlbmF0aW9uXG4gICAgI2RhdGE7XG4gICAgI2RhdGFMZW5ndGg7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuI2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy4jZGF0YUxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KHRoaXMuI2RhdGEpO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jZGF0YUxlbmd0aDsgfVxuICAgICN3cml0ZURhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLiNkYXRhLnB1c2goZGF0YSk7XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgYXBwZW5kV3JpdGVyKHdyaXRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy4jd3JpdGVEYXRhKGdldEJ5dGVzQ29weSh3cml0ZXIuZGF0YSkpO1xuICAgIH1cbiAgICAvLyBBcnJheWlzaCBpdGVtOyBwYWQgb24gdGhlIHJpZ2h0IHRvICpuZWFyZXN0KiBXb3JkU2l6ZVxuICAgIHdyaXRlQnl0ZXModmFsdWUpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KHZhbHVlKTtcbiAgICAgICAgY29uc3QgcGFkZGluZ09mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIFdvcmRTaXplO1xuICAgICAgICBpZiAocGFkZGluZ09mZnNldCkge1xuICAgICAgICAgICAgYnl0ZXMgPSBnZXRCeXRlc0NvcHkoY29uY2F0KFtieXRlcywgUGFkZGluZy5zbGljZShwYWRkaW5nT2Zmc2V0KV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jd3JpdGVEYXRhKGJ5dGVzKTtcbiAgICB9XG4gICAgLy8gTnVtZXJpYyBpdGVtOyBwYWQgb24gdGhlIGxlZnQgKnRvKiBXb3JkU2l6ZVxuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShnZXRWYWx1ZSh2YWx1ZSkpO1xuICAgIH1cbiAgICAvLyBJbnNlcnRzIGEgbnVtZXJpYyBwbGFjZS1ob2xkZXIsIHJldHVybmluZyBhIGNhbGxiYWNrIHRoYXQgY2FuXG4gICAgLy8gYmUgdXNlZCB0byBhc2p1c3QgdGhlIHZhbHVlIGxhdGVyXG4gICAgd3JpdGVVcGRhdGFibGVWYWx1ZSgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy4jZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMuI2RhdGEucHVzaChQYWRkaW5nKTtcbiAgICAgICAgdGhpcy4jZGF0YUxlbmd0aCArPSBXb3JkU2l6ZTtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jZGF0YVtvZmZzZXRdID0gZ2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWFkZXIge1xuICAgIC8vIEFsbG93cyBpbmNvbXBsZXRlIHVucGFkZGVkIGRhdGEgdG8gYmUgcmVhZDsgb3RoZXJ3aXNlIGFuIGVycm9yXG4gICAgLy8gaXMgcmFpc2VkIGlmIGF0dGVtcHRpbmcgdG8gb3ZlcnJ1biB0aGUgYnVmZmVyLiBUaGlzIGlzIHJlcXVpcmVkXG4gICAgLy8gdG8gZGVhbCB3aXRoIGFuIG9sZCBTb2xpZGl0eSBidWcsIGluIHdoaWNoIGV2ZW50IGRhdGEgZm9yXG4gICAgLy8gZXh0ZXJuYWwgKG5vdCBwdWJsaWMgdGhvZ3VoKSB3YXMgdGlnaHRseSBwYWNrZWQuXG4gICAgYWxsb3dMb29zZTtcbiAgICAjZGF0YTtcbiAgICAjb2Zmc2V0O1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGFsbG93TG9vc2UpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFsbG93TG9vc2U6ICEhYWxsb3dMb29zZSB9KTtcbiAgICAgICAgdGhpcy4jZGF0YSA9IGdldEJ5dGVzQ29weShkYXRhKTtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7IHJldHVybiBoZXhsaWZ5KHRoaXMuI2RhdGEpOyB9XG4gICAgZ2V0IGRhdGFMZW5ndGgoKSB7IHJldHVybiB0aGlzLiNkYXRhLmxlbmd0aDsgfVxuICAgIGdldCBjb25zdW1lZCgpIHsgcmV0dXJuIHRoaXMuI29mZnNldDsgfVxuICAgIGdldCBieXRlcygpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuI2RhdGEpOyB9XG4gICAgI3BlZWtCeXRlcyhvZmZzZXQsIGxlbmd0aCwgbG9vc2UpIHtcbiAgICAgICAgbGV0IGFsaWduZWRMZW5ndGggPSBNYXRoLmNlaWwobGVuZ3RoIC8gV29yZFNpemUpICogV29yZFNpemU7XG4gICAgICAgIGlmICh0aGlzLiNvZmZzZXQgKyBhbGlnbmVkTGVuZ3RoID4gdGhpcy4jZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93TG9vc2UgJiYgbG9vc2UgJiYgdGhpcy4jb2Zmc2V0ICsgbGVuZ3RoIDw9IHRoaXMuI2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYWxpZ25lZExlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJkYXRhIG91dC1vZi1ib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogZ2V0Qnl0ZXNDb3B5KHRoaXMuI2RhdGEpLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHRoaXMuI2RhdGEubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jZGF0YS5zbGljZSh0aGlzLiNvZmZzZXQsIHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBzdWItcmVhZGVyIHdpdGggdGhlIHNhbWUgdW5kZXJseWluZyBkYXRhLCBidXQgb2Zmc2V0XG4gICAgc3ViUmVhZGVyKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlYWRlcih0aGlzLiNkYXRhLnNsaWNlKHRoaXMuI29mZnNldCArIG9mZnNldCksIHRoaXMuYWxsb3dMb29zZSk7XG4gICAgfVxuICAgIC8vIFJlYWQgYnl0ZXNcbiAgICByZWFkQnl0ZXMobGVuZ3RoLCBsb29zZSkge1xuICAgICAgICBsZXQgYnl0ZXMgPSB0aGlzLiNwZWVrQnl0ZXMoMCwgbGVuZ3RoLCAhIWxvb3NlKTtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgLy8gQFRPRE86IE1ha2Ugc3VyZSB0aGUgbGVuZ3RoLi5lbmQgYnl0ZXMgYXJlIGFsbCAwP1xuICAgICAgICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gUmVhZCBhIG51bWVyaWMgdmFsdWVzXG4gICAgcmVhZFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdG9CaWdJbnQodGhpcy5yZWFkQnl0ZXMoV29yZFNpemUpKTtcbiAgICB9XG4gICAgcmVhZEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdG9OdW1iZXIodGhpcy5yZWFkQnl0ZXMoV29yZFNpemUpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1jb2Rlci5qcy5tYXAiLCJmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmZ1bmN0aW9uIGhhc2goaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydCB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCIsImV4cG9ydCBjb25zdCBjcnlwdG8gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCIsIi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuZXhwb3J0IGNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBpZiAoIXU4YShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBVaW50OEFycmF5LCBnb3QgJHt0eXBlb2YgZGF0YX1gKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmxlbmd0aCwgMCkpO1xuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gICAgYXJyYXlzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaWYgKCF1OGEoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByO1xufVxuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmV4cG9ydCBjbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmNvbnN0IHRvU3RyID0ge30udG9TdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiB0b1N0ci5jYWxsKG9wdHMpICE9PSAnW29iamVjdCBPYmplY3RdJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsImltcG9ydCB7IGhhc2ggYXMgYXNzZXJ0SGFzaCwgYnl0ZXMgYXMgYXNzZXJ0Qnl0ZXMsIGV4aXN0cyBhcyBhc3NlcnRFeGlzdHMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gSE1BQyAoUkZDIDIxMDQpXG5leHBvcnQgY2xhc3MgSE1BQyBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIF9rZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICBhc3NlcnRIYXNoKGhhc2gpO1xuICAgICAgICBjb25zdCBrZXkgPSB0b0J5dGVzKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIHBhZC5maWxsKDApO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgIGFzc2VydEV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFzc2VydEV4aXN0cyh0aGlzKTtcbiAgICAgICAgYXNzZXJ0Qnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCIsImltcG9ydCB7IGV4aXN0cywgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIGNyZWF0ZVZpZXcsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBCYXNlIFNIQTIgY2xhc3MgKFJGQyA2MjM0KVxuZXhwb3J0IGNsYXNzIFNIQTIgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIG91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gY3JlYXRlVmlldyhvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaGEyLmpzLm1hcCIsImltcG9ydCB7IFNIQTIgfSBmcm9tICcuL19zaGEyLmpzJztcbmltcG9ydCB7IHJvdHIsIHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMi0yNTYgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzIHRvIGV4ZWN1dGUgYmlydGhkYXkgYXR0YWNrLlxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5jb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IElWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IElWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBJVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IElWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBJVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IElWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gcm90cihXMTUsIDcpIF4gcm90cihXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSByb3RyKEUsIDYpIF4gcm90cihFLCAxMSkgXiByb3RyKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSByb3RyKEEsIDIpIF4gcm90cihBLCAxMykgXiByb3RyKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn1cbi8vIENvbnN0YW50cyBmcm9tIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGZcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiLCJjb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB7IGZyb21CaWcsIHNwbGl0LCB0b0JpZywgc2hyU0gsIHNoclNMLCByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsIHJvdHIzMkgsIHJvdHIzMkwsIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCwgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLCB9O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIiwiaW1wb3J0IHsgYnl0ZXMsIGV4aXN0cywgbnVtYmVyLCBvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgcm90bEJILCByb3RsQkwsIHJvdGxTSCwgcm90bFNMLCBzcGxpdCB9IGZyb20gJy4vX3U2NC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB1MzIsIHRvQnl0ZXMsIHdyYXBDb25zdHJ1Y3Rvciwgd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBTSEEzIChrZWNjYWspIGlzIGJhc2VkIG9uIGEgbmV3IGRlc2lnbjogYmFzaWNhbGx5LCB0aGUgaW50ZXJuYWwgc3RhdGUgaXMgYmlnZ2VyIHRoYW4gb3V0cHV0IHNpemUuXG4vLyBJdCdzIGNhbGxlZCBhIHNwb25nZSBmdW5jdGlvbi5cbi8vIFZhcmlvdXMgcGVyIHJvdW5kIGNvbnN0YW50cyBjYWxjdWxhdGlvbnNcbmNvbnN0IFtTSEEzX1BJLCBTSEEzX1JPVEwsIF9TSEEzX0lPVEFdID0gW1tdLCBbXSwgW11dO1xuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpO1xuY29uc3QgXzduID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg3KTtcbmNvbnN0IF8yNTZuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyNTYpO1xuY29uc3QgXzB4NzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgweDcxKTtcbmZvciAobGV0IHJvdW5kID0gMCwgUiA9IF8xbiwgeCA9IDEsIHkgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgLy8gUGlcbiAgICBbeCwgeV0gPSBbeSwgKDIgKiB4ICsgMyAqIHkpICUgNV07XG4gICAgU0hBM19QSS5wdXNoKDIgKiAoNSAqIHkgKyB4KSk7XG4gICAgLy8gUm90YXRpb25hbFxuICAgIFNIQTNfUk9UTC5wdXNoKCgoKHJvdW5kICsgMSkgKiAocm91bmQgKyAyKSkgLyAyKSAlIDY0KTtcbiAgICAvLyBJb3RhXG4gICAgbGV0IHQgPSBfMG47XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgUiA9ICgoUiA8PCBfMW4pIF4gKChSID4+IF83bikgKiBfMHg3MW4pKSAlIF8yNTZuO1xuICAgICAgICBpZiAoUiAmIF8ybilcbiAgICAgICAgICAgIHQgXj0gXzFuIDw8ICgoXzFuIDw8IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoaikpIC0gXzFuKTtcbiAgICB9XG4gICAgX1NIQTNfSU9UQS5wdXNoKHQpO1xufVxuY29uc3QgW1NIQTNfSU9UQV9ILCBTSEEzX0lPVEFfTF0gPSAvKiBAX19QVVJFX18gKi8gc3BsaXQoX1NIQTNfSU9UQSwgdHJ1ZSk7XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkgoaCwgbCwgcykgOiByb3RsU0goaCwgbCwgcykpO1xuY29uc3Qgcm90bEwgPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/IHJvdGxCTChoLCBsLCBzKSA6IHJvdGxTTChoLCBsLCBzKSk7XG4vLyBTYW1lIGFzIGtlY2Nha2YxNjAwLCBidXQgYWxsb3dzIHRvIHNraXAgc29tZSByb3VuZHNcbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWtQKHMsIHJvdW5kcyA9IDI0KSB7XG4gICAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheSg1ICogMik7XG4gICAgLy8gTk9URTogYWxsIGluZGljZXMgYXJlIHgyIHNpbmNlIHdlIHN0b3JlIHN0YXRlIGFzIHUzMiBpbnN0ZWFkIG9mIHU2NCAoYmlnaW50cyB0byBzbG93IGluIGpzKVxuICAgIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAgICAgLy8gVGhldGEgzrhcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgQlt4XSA9IHNbeF0gXiBzW3ggKyAxMF0gXiBzW3ggKyAyMF0gXiBzW3ggKyAzMF0gXiBzW3ggKyA0MF07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHggKz0gMikge1xuICAgICAgICAgICAgY29uc3QgaWR4MSA9ICh4ICsgOCkgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IGlkeDAgPSAoeCArIDIpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBCMCA9IEJbaWR4MF07XG4gICAgICAgICAgICBjb25zdCBCMSA9IEJbaWR4MCArIDFdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChCMCwgQjEsIDEpIF4gQltpZHgxXTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoQjAsIEIxLCAxKSBeIEJbaWR4MSArIDFdO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgICAgIHNbeCArIHldIF49IFRoO1xuICAgICAgICAgICAgICAgIHNbeCArIHkgKyAxXSBePSBUbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSaG8gKM+BKSBhbmQgUGkgKM+AKVxuICAgICAgICBsZXQgY3VySCA9IHNbMl07XG4gICAgICAgIGxldCBjdXJMID0gc1szXTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaGlmdCA9IFNIQTNfUk9UTFt0XTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBQSSA9IFNIQTNfUElbdF07XG4gICAgICAgICAgICBjdXJIID0gc1tQSV07XG4gICAgICAgICAgICBjdXJMID0gc1tQSSArIDFdO1xuICAgICAgICAgICAgc1tQSV0gPSBUaDtcbiAgICAgICAgICAgIHNbUEkgKyAxXSA9IFRsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoaSAoz4cpXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBCW3hdID0gc1t5ICsgeF07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgc1t5ICsgeF0gXj0gfkJbKHggKyAyKSAlIDEwXSAmIEJbKHggKyA0KSAlIDEwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJb3RhICjOuSlcbiAgICAgICAgc1swXSBePSBTSEEzX0lPVEFfSFtyb3VuZF07XG4gICAgICAgIHNbMV0gXj0gU0hBM19JT1RBX0xbcm91bmRdO1xuICAgIH1cbiAgICBCLmZpbGwoMCk7XG59XG5leHBvcnQgY2xhc3MgS2VjY2FrIGV4dGVuZHMgSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICBudW1iZXIob3V0cHV0TGVuKTtcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xuICAgICAgICBpZiAoMCA+PSB0aGlzLmJsb2NrTGVuIHx8IHRoaXMuYmxvY2tMZW4gPj0gMjAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGEzIHN1cHBvcnRzIG9ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xuICAgICAgICB0aGlzLnN0YXRlMzIgPSB1MzIodGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIGtlY2NhaygpIHtcbiAgICAgICAga2VjY2FrUCh0aGlzLnN0YXRlMzIsIHRoaXMucm91bmRzKTtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2U7IGkrKylcbiAgICAgICAgICAgICAgICBzdGF0ZVt0aGlzLnBvcysrXSBePSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUsIHN1ZmZpeCwgcG9zLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgLy8gRG8gdGhlIHBhZGRpbmdcbiAgICAgICAgc3RhdGVbcG9zXSBePSBzdWZmaXg7XG4gICAgICAgIGlmICgoc3VmZml4ICYgMHg4MCkgIT09IDAgJiYgcG9zID09PSBibG9ja0xlbiAtIDEpXG4gICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICBzdGF0ZVtibG9ja0xlbiAtIDFdIF49IDB4ODA7XG4gICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgfVxuICAgIHdyaXRlSW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgYnl0ZXMob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgIG51bWJlcihieXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnhvZkludG8obmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgcm91bmRzLCBlbmFibGVYT0YgfSA9IHRoaXM7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xuICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0by5wb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcbiAgICAgICAgdG8ucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBTdWZmaXggY2FuIGNoYW5nZSBpbiBjU0hBS0VcbiAgICAgICAgdG8uc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5jb25zdCBnZW4gPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4pKTtcbmV4cG9ydCBjb25zdCBzaGEzXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICogU0hBMy0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhM18yNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDEzNiwgMjU2IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hhM18zODQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hhM181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfMjI0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBrZWNjYWstMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIFNIQTMtMjU2LlxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfMzg0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCAxMDQsIDM4NCAvIDgpO1xuZXhwb3J0IGNvbnN0IGtlY2Nha181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDcyLCA1MTIgLyA4KTtcbmNvbnN0IGdlblNoYWtlID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XG5leHBvcnQgY29uc3Qgc2hha2UxMjggPSAvKiBAX19QVVJFX18gKi8gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KTtcbmV4cG9ydCBjb25zdCBzaGFrZTI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW5TaGFrZSgweDFmLCAxMzYsIDI1NiAvIDgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMy5qcy5tYXAiLCIvKipcbiAqICBDcnlwdG9ncmFwaGljIGhhc2hpbmcgZnVuY3Rpb25zXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpIYXNoIEZ1bmN0aW9ucyBbYWJvdXQtY3J5cHRvLWhhc2hpbmddXG4gKi9cbmltcG9ydCB7IGtlY2Nha18yNTYgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX2tlY2NhazI1NiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIGtlY2Nha18yNTYoZGF0YSk7XG59O1xubGV0IF9fa2VjY2FrMjU2ID0gX2tlY2NhazI1Njtcbi8qKlxuICogIENvbXB1dGUgdGhlIGNyeXB0b2dyYXBoaWMgS0VDQ0FLMjU2IGhhc2ggb2YgJSVkYXRhJSUuXG4gKlxuICogIFRoZSAlJWRhdGElJSAqKm11c3QqKiBiZSBhIGRhdGEgcmVwcmVzZW50YXRpb24sIHRvIGNvbXB1dGUgdGhlXG4gKiAgaGFzaCBvZiBVVEYtOCBkYXRhIHVzZSB0aGUgW1tpZF1dIGZ1bmN0aW9uLlxuICpcbiAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBrZWNjYWsyNTYoXCIweFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIGtlY2NhazI1NihcIjB4MTMzN1wiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIGtlY2NhazI1NihuZXcgVWludDhBcnJheShbIDB4MTMsIDB4MzcgXSkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gU3RyaW5ncyBhcmUgYXNzdW1lZCB0byBiZSBEYXRhSGV4U3RyaW5nLCBvdGhlcndpc2UgaXQgd2lsbFxuICogICAgLy8gdGhyb3cuIFRvIGhhc2ggVVRGLTggZGF0YSwgc2VlIHRoZSBub3RlIGFib3ZlLlxuICogICAga2VjY2FrMjU2KFwiSGVsbG8gV29ybGRcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrMjU2KF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XG4gICAgcmV0dXJuIGhleGxpZnkoX19rZWNjYWsyNTYoZGF0YSkpO1xufVxua2VjY2FrMjU2Ll8gPSBfa2VjY2FrMjU2O1xua2VjY2FrMjU2LmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZCA9IHRydWU7IH07XG5rZWNjYWsyNTYucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtlY2NhazI1NiBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fa2VjY2FrMjU2ID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKGtlY2NhazI1Nik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZWNjYWsuanMubWFwIiwiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh1OGEoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGIxLCBiMikge1xuICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgdGltaW5nIGF0dGFja3MgaGVyZVxuICAgIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYjEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChiMVtpXSAhPT0gYjJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGJpdFNldCA9IChuLCBwb3MsIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgXCIke3R5cGV9XCIsIGV4cGVjdGVkIGZ1bmN0aW9uYCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSAke1N0cmluZyhmaWVsZE5hbWUpfT0ke3ZhbH0gKCR7dHlwZW9mIHZhbH0pLCBleHBlY3RlZCAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBVdGlsaXRpZXMgZm9yIG1vZHVsYXIgYXJpdGhtZXRpY3MgYW5kIGZpbml0ZSBmaWVsZHNcbmltcG9ydCB7IGJpdE1hc2ssIG51bWJlclRvQnl0ZXNCRSwgbnVtYmVyVG9CeXRlc0xFLCBieXRlc1RvTnVtYmVyQkUsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIHZhbGlkYXRlT2JqZWN0LCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF80biA9IEJpZ0ludCg0KSwgXzVuID0gQmlnSW50KDUpLCBfOG4gPSBCaWdJbnQoOCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF85biA9IEJpZ0ludCg5KSwgXzE2biA9IEJpZ0ludCgxNik7XG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcbmV4cG9ydCBmdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogQGV4YW1wbGVcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG4gKi9cbi8vIFRPRE86IHVzZSBmaWVsZCB2ZXJzaW9uICYmIHJlbW92ZVxuZXhwb3J0IGZ1bmN0aW9uIHBvdyhudW0sIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBpZiAobW9kdWxvIDw9IF8wbiB8fCBwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlci9tb2R1bG8gPiAwJyk7XG4gICAgaWYgKG1vZHVsbyA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gXzBuO1xuICAgIGxldCByZXMgPSBfMW47XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHJlcyA9IChyZXMgKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBudW0gPSAobnVtICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIERvZXMgeCBeICgyIF4gcG93ZXIpIG1vZCBwLiBwb3cyKDMwLCA0KSA9PSAzMCBeICgyIF4gNClcbmV4cG9ydCBmdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gSW52ZXJzZXMgbnVtYmVyIG92ZXIgbW9kdWxvXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuIHx8IG1vZHVsbyA8PSBfMG4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJzLCBnb3Qgbj0ke251bWJlcn0gbW9kPSR7bW9kdWxvfWApO1xuICAgIH1cbiAgICAvLyBFdWNsaWRlYW4gR0NEIGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vXG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG4vKipcbiAqIFRvbmVsbGktU2hhbmtzIHNxdWFyZSByb290IHNlYXJjaCBhbGdvcml0aG0uXG4gKiAxLiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTIpXG4gKiAyLiBTcXVhcmUgUm9vdHMgZnJvbSAxOyAyNCwgNTEsIDEwIHRvIERhbiBTaGFua3NcbiAqIFdpbGwgc3RhcnQgYW4gaW5maW5pdGUgbG9vcCBpZiBmaWVsZCBvcmRlciBQIGlzIG5vdCBwcmltZS5cbiAqIEBwYXJhbSBQIGZpZWxkIG9yZGVyXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHRha2VzIGZpZWxkIEZwIChjcmVhdGVkIGZyb20gUCkgYW5kIG51bWJlciBuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b25lbGxpU2hhbmtzKFApIHtcbiAgICAvLyBMZWdlbmRyZSBjb25zdGFudDogdXNlZCB0byBjYWxjdWxhdGUgTGVnZW5kcmUgc3ltYm9sIChhIHwgcCksXG4gICAgLy8gd2hpY2ggZGVub3RlcyB0aGUgdmFsdWUgb2YgYV4oKHAtMSkvMikgKG1vZCBwKS5cbiAgICAvLyAoYSB8IHApIOKJoSAxICAgIGlmIGEgaXMgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gICAgY29uc3QgbGVnZW5kcmVDID0gKFAgLSBfMW4pIC8gXzJuO1xuICAgIGxldCBRLCBTLCBaO1xuICAgIC8vIFN0ZXAgMTogQnkgZmFjdG9yaW5nIG91dCBwb3dlcnMgb2YgMiBmcm9tIHAgLSAxLFxuICAgIC8vIGZpbmQgcSBhbmQgcyBzdWNoIHRoYXQgcCAtIDEgPSBxKigyXnMpIHdpdGggcSBvZGRcbiAgICBmb3IgKFEgPSBQIC0gXzFuLCBTID0gMDsgUSAlIF8ybiA9PT0gXzBuOyBRIC89IF8ybiwgUysrKVxuICAgICAgICA7XG4gICAgLy8gU3RlcCAyOiBTZWxlY3QgYSBub24tc3F1YXJlIHogc3VjaCB0aGF0ICh6IHwgcCkg4omhIC0xIGFuZCBzZXQgYyDiiaEgenFcbiAgICBmb3IgKFogPSBfMm47IFogPCBQICYmIHBvdyhaLCBsZWdlbmRyZUMsIFApICE9PSBQIC0gXzFuOyBaKyspXG4gICAgICAgIDtcbiAgICAvLyBGYXN0LXBhdGhcbiAgICBpZiAoUyA9PT0gMSkge1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpRmFzdChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gU2xvdy1wYXRoXG4gICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpU2xvdyhGcCwgbikge1xuICAgICAgICAvLyBTdGVwIDA6IENoZWNrIHRoYXQgbiBpcyBpbmRlZWQgYSBzcXVhcmU6IChuIHwgcCkgc2hvdWxkIG5vdCBiZSDiiaEgLTFcbiAgICAgICAgaWYgKEZwLnBvdyhuLCBsZWdlbmRyZUMpID09PSBGcC5uZWcoRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgbGV0IHIgPSBTO1xuICAgICAgICAvLyBUT0RPOiB3aWxsIGZhaWwgYXQgRnAyL2V0Y1xuICAgICAgICBsZXQgZyA9IEZwLnBvdyhGcC5tdWwoRnAuT05FLCBaKSwgUSk7IC8vIHdpbGwgdXBkYXRlIGJvdGggeCBhbmQgYlxuICAgICAgICBsZXQgeCA9IEZwLnBvdyhuLCBRMWRpdjIpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgc3F1YXJlIHJvb3RcbiAgICAgICAgbGV0IGIgPSBGcC5wb3cobiwgUSk7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3JcbiAgICAgICAgd2hpbGUgKCFGcC5lcWwoYiwgRnAuT05FKSkge1xuICAgICAgICAgICAgaWYgKEZwLmVxbChiLCBGcC5aRVJPKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnAuWkVSTzsgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9uZWxsaSVFMiU4MCU5M1NoYW5rc19hbGdvcml0aG0gKDQuIElmIHQgPSAwLCByZXR1cm4gciA9IDApXG4gICAgICAgICAgICAvLyBGaW5kIG0gc3VjaCBiXigyXm0pPT0xXG4gICAgICAgICAgICBsZXQgbSA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCB0MiA9IEZwLnNxcihiKTsgbSA8IHI7IG0rKykge1xuICAgICAgICAgICAgICAgIGlmIChGcC5lcWwodDIsIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHQyID0gRnAuc3FyKHQyKTsgLy8gdDIgKj0gdDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEU6IHItbS0xIGNhbiBiZSBiaWdnZXIgdGhhbiAzMiwgbmVlZCB0byBjb252ZXJ0IHRvIGJpZ2ludCBiZWZvcmUgc2hpZnQsIG90aGVyd2lzZSB0aGVyZSB3aWxsIGJlIG92ZXJmbG93XG4gICAgICAgICAgICBjb25zdCBnZSA9IEZwLnBvdyhnLCBfMW4gPDwgQmlnSW50KHIgLSBtIC0gMSkpOyAvLyBnZSA9IDJeKHItbS0xKVxuICAgICAgICAgICAgZyA9IEZwLnNxcihnZSk7IC8vIGcgPSBnZSAqIGdlXG4gICAgICAgICAgICB4ID0gRnAubXVsKHgsIGdlKTsgLy8geCAqPSBnZVxuICAgICAgICAgICAgYiA9IEZwLm11bChiLCBnKTsgLy8gYiAqPSBnXG4gICAgICAgICAgICByID0gbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgLy8gTk9URTogZGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuICAgIC8vIEZvciBleGFtcGxlIHRoZXJlIGlzIEZwU3FydE9kZC9GcFNxcnRFdmVuIHRvIGNob2ljZSByb290IGJhc2VkIG9uIG9kZG5lc3MgKHVzZWQgZm9yIGhhc2gtdG8tY3VydmUpLlxuICAgIC8vIFAg4omhIDMgKG1vZCA0KVxuICAgIC8vIOKImm4gPSBuXigoUCsxKS80KVxuICAgIGlmIChQICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gTm90IGFsbCByb290cyBwb3NzaWJsZSFcbiAgICAgICAgLy8gY29uc3QgT1JERVIgPVxuICAgICAgICAvLyAgIDB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFibjtcbiAgICAgICAgLy8gY29uc3QgTlVNID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0M21vZDQoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIC8vIFRocm93IGlmIHJvb3QqKjIgIT0gblxuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQXRraW4gYWxnb3JpdGhtIGZvciBxIOKJoSA1IChtb2QgOCksIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMClcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKSB7XG4gICAgICAgIGNvbnN0IGMxID0gKFAgLSBfNW4pIC8gXzhuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xuICAgICAgICAgICAgY29uc3QgdiA9IEZwLnBvdyhuMiwgYzEpO1xuICAgICAgICAgICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gICAgICAgICAgICBjb25zdCBpID0gRnAubXVsKEZwLm11bChudiwgXzJuKSwgdik7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQIOKJoSA5IChtb2QgMTYpXG4gICAgaWYgKFAgJSBfMTZuID09PSBfOW4pIHtcbiAgICAgICAgLy8gTk9URTogdG9uZWxsaSBpcyB0b28gc2xvdyBmb3IgYmxzLUZwMiBjYWxjdWxhdGlvbnMgZXZlbiBvbiBzdGFydFxuICAgICAgICAvLyBNZWFucyB3ZSBjYW5ub3QgdXNlIHNxcnQgZm9yIGNvbnN0YW50cyBhdCBhbGwhXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGNvbnN0IGMxID0gRnAuc3FydChGcC5uZWdhdGUoRnAuT05FKSk7IC8vICAxLiBjMSA9IHNxcnQoLTEpIGluIEYsIGkuZS4sIChjMV4yKSA9PSAtMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMyID0gRnAuc3FydChjMSk7ICAgICAgICAgICAgICAgIC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMzID0gRnAuc3FydChGcC5uZWdhdGUoYzEpKTsgICAgIC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzQgPSAoUCArIF83bikgLyBfMTZuOyAgICAgICAgICAgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICAvLyBzcXJ0ID0gKHgpID0+IHtcbiAgICAgICAgLy8gICBsZXQgdHYxID0gRnAucG93KHgsIGM0KTsgICAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcbiAgICAgICAgLy8gICBsZXQgdHYyID0gRnAubXVsKGMxLCB0djEpOyAgICAgICAgICAgLy8gIDIuIHR2MiA9IGMxICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgdHYzID0gRnAubXVsKGMyLCB0djEpOyAgICAgICAgIC8vICAzLiB0djMgPSBjMiAqIHR2MVxuICAgICAgICAvLyAgIGxldCB0djQgPSBGcC5tdWwoYzMsIHR2MSk7ICAgICAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCBlMSA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMiA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYzKSwgeCk7IC8vICA2LiAgZTIgPSAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7IC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMyA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA5LiAgZTMgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICByZXR1cm4gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAgMTAuICB6ID0gQ01PVih0djEsIHR2MiwgZTMpICAjIFNlbGVjdCB0aGUgc3FydCBmcm9tIHR2MSBhbmQgdHYyXG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgLy8gT3RoZXIgY2FzZXM6IFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICAgIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xufVxuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bSwgbW9kdWxvKSA9PiAobW9kKG51bSwgbW9kdWxvKSAmIF8xbikgPT09IF8xbjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRklFTERfRklFTERTID0gW1xuICAgICdjcmVhdGUnLCAnaXNWYWxpZCcsICdpczAnLCAnbmVnJywgJ2ludicsICdzcXJ0JywgJ3NxcicsXG4gICAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcbl07XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICAgIE9SREVSOiAnYmlnaW50JyxcbiAgICAgICAgTUFTSzogJ2JpZ2ludCcsXG4gICAgICAgIEJZVEVTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIEJJVFM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KGZpZWxkLCBvcHRzKTtcbn1cbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG4vKipcbiAqIFNhbWUgYXMgYHBvd2AgYnV0IGZvciBGcDogbm9uLWNvbnN0YW50LXRpbWUuXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFBvdyhmLCBudW0sIHBvd2VyKSB7XG4gICAgLy8gU2hvdWxkIGhhdmUgc2FtZSBzcGVlZCBhcyBwb3cgZm9yIGJpZ2ludHNcbiAgICAvLyBUT0RPOiBiZW5jaG1hcmshXG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyID4gMCcpO1xuICAgIGlmIChwb3dlciA9PT0gXzBuKVxuICAgICAgICByZXR1cm4gZi5PTkU7XG4gICAgaWYgKHBvd2VyID09PSBfMW4pXG4gICAgICAgIHJldHVybiBudW07XG4gICAgbGV0IHAgPSBmLk9ORTtcbiAgICBsZXQgZCA9IG51bTtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcCA9IGYubXVsKHAsIGQpO1xuICAgICAgICBkID0gZi5zcXIoZCk7XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSBpbnZlcnQgYW4gYXJyYXkgb2YgRmllbGQgZWxlbWVudHMuXG4gKiBgaW52KDApYCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBoZXJlOiBtYWtlIHN1cmUgdG8gdGhyb3cgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcEludmVydEJhdGNoKGYsIG51bXMpIHtcbiAgICBjb25zdCB0bXAgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBmLk9ORSk7XG4gICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxuICAgIGNvbnN0IGludmVydGVkID0gZi5pbnYobGFzdE11bHRpcGxpZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHRtcDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcERpdihmLCBsaHMsIHJocykge1xuICAgIHJldHVybiBmLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gaW52ZXJ0KHJocywgZi5PUkRFUikgOiBmLmludihyaHMpKTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZXhwb3J0IGZ1bmN0aW9uIEZwSXNTcXVhcmUoZikge1xuICAgIGNvbnN0IGxlZ2VuZHJlQ29uc3QgPSAoZi5PUkRFUiAtIF8xbikgLyBfMm47IC8vIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIHJldHVybiAoeCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gZi5wb3coeCwgbGVnZW5kcmVDb25zdCk7XG4gICAgICAgIHJldHVybiBmLmVxbChwLCBmLlpFUk8pIHx8IGYuZXFsKHAsIGYuT05FKTtcbiAgICB9O1xufVxuLy8gQ1VSVkUubiBsZW5ndGhzXG5leHBvcnQgZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XG4gICAgLy8gQml0IHNpemUsIGJ5dGUgc2l6ZSBvZiBDVVJWRS5uXG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBmaW5pdGUgZmllbGQgb3ZlciBwcmltZS4gKipOb24tcHJpbWVzIGFyZSBub3Qgc3VwcG9ydGVkLioqXG4gKiBEbyBub3QgaW5pdCBpbiBsb29wOiBzbG93LiBWZXJ5IGZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBNYWpvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zOlxuICogKiBhKSBkZW5vcm1hbGl6ZWQgb3BlcmF0aW9ucyBsaWtlIG11bE4gaW5zdGVhZCBvZiBtdWxcbiAqICogYikgc2FtZSBvYmplY3Qgc2hhcGU6IG5ldmVyIGFkZCBvciByZW1vdmUga2V5c1xuICogKiBjKSBPYmplY3QuZnJlZXplXG4gKiBAcGFyYW0gT1JERVIgcHJpbWUgcG9zaXRpdmUgYmlnaW50XG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmOiBmYWxzZSkgaWYgZW5jb2RpbmcgLyBkZWNvZGluZyBzaG91bGQgYmUgaW4gbGl0dGxlLWVuZGlhblxuICogQHBhcmFtIHJlZGVmIG9wdGlvbmFsIGZhc3RlciByZWRlZmluaXRpb25zIG9mIHNxcnQgYW5kIG90aGVyIG1ldGhvZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZpZWxkKE9SREVSLCBiaXRMZW4sIGlzTEUgPSBmYWxzZSwgcmVkZWYgPSB7fSkge1xuICAgIGlmIChPUkRFUiA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgRmllbGQgT1JERVIgPiAwLCBnb3QgJHtPUkRFUn1gKTtcbiAgICBjb25zdCB7IG5CaXRMZW5ndGg6IEJJVFMsIG5CeXRlTGVuZ3RoOiBCWVRFUyB9ID0gbkxlbmd0aChPUkRFUiwgYml0TGVuKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkIGxlbmd0aHMgb3ZlciAyMDQ4IGJ5dGVzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgY29uc3Qgc3FydFAgPSBGcFNxcnQoT1JERVIpO1xuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiBiaXRNYXNrKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAke3R5cGVvZiBudW19YCk7XG4gICAgICAgICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICAgICAgICB9LFxuICAgICAgICBpczA6IChudW0pID0+IG51bSA9PT0gXzBuLFxuICAgICAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcbiAgICAgICAgbmVnOiAobnVtKSA9PiBtb2QoLW51bSwgT1JERVIpLFxuICAgICAgICBlcWw6IChsaHMsIHJocykgPT4gbGhzID09PSByaHMsXG4gICAgICAgIHNxcjogKG51bSkgPT4gbW9kKG51bSAqIG51bSwgT1JERVIpLFxuICAgICAgICBhZGQ6IChsaHMsIHJocykgPT4gbW9kKGxocyArIHJocywgT1JERVIpLFxuICAgICAgICBzdWI6IChsaHMsIHJocykgPT4gbW9kKGxocyAtIHJocywgT1JERVIpLFxuICAgICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0sIHBvd2VyKSxcbiAgICAgICAgZGl2OiAobGhzLCByaHMpID0+IG1vZChsaHMgKiBpbnZlcnQocmhzLCBPUkRFUiksIE9SREVSKSxcbiAgICAgICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXG4gICAgICAgIHNxck46IChudW0pID0+IG51bSAqIG51bSxcbiAgICAgICAgYWRkTjogKGxocywgcmhzKSA9PiBsaHMgKyByaHMsXG4gICAgICAgIHN1Yk46IChsaHMsIHJocykgPT4gbGhzIC0gcmhzLFxuICAgICAgICBtdWxOOiAobGhzLCByaHMpID0+IGxocyAqIHJocyxcbiAgICAgICAgaW52OiAobnVtKSA9PiBpbnZlcnQobnVtLCBPUkRFUiksXG4gICAgICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHwgKChuKSA9PiBzcXJ0UChmLCBuKSksXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFRPRE86IGRvIHdlIHJlYWxseSBuZWVkIGNvbnN0YW50IGNtb3Y/XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgY29uc3QtdGltZSBiaWdpbnRzIGFueXdheSwgc28gcHJvYmFibHkgd2lsbCBiZSBub3QgdmVyeSB1c2VmdWxcbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/IG51bWJlclRvQnl0ZXNMRShudW0sIEJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0sIEJZVEVTKSksXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBCWVRFUylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZwLmZyb21CeXRlczogZXhwZWN0ZWQgJHtCWVRFU30sIGdvdCAke2J5dGVzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHJldHVybiBpc0xFID8gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSA6IGJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRFdmVuKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogU2FtZSBhcyBtYXBLZXlUb0ZpZWxkLCBidXQgYWNjZXB0cyBsZXNzIGJ5dGVzICg0MCBpbnN0ZWFkIG9mIDQ4IGZvciAzMi1ieXRlIGZpZWxkKS5cbiAqIFdoaWNoIG1ha2VzIGl0IHNsaWdodGx5IG1vcmUgYmlhc2VkLCBsZXNzIHNlY3VyZS5cbiAqIEBkZXByZWNhdGVkIHVzZSBtYXBLZXlUb0ZpZWxkIGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hUb1ByaXZhdGVTY2FsYXIoaGFzaCwgZ3JvdXBPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgaGFzaCA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlSGFzaCcsIGhhc2gpO1xuICAgIGNvbnN0IGhhc2hMZW4gPSBoYXNoLmxlbmd0aDtcbiAgICBjb25zdCBtaW5MZW4gPSBuTGVuZ3RoKGdyb3VwT3JkZXIpLm5CeXRlTGVuZ3RoICsgODtcbiAgICBpZiAobWluTGVuIDwgMjQgfHwgaGFzaExlbiA8IG1pbkxlbiB8fCBoYXNoTGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBoYXNoVG9Qcml2YXRlU2NhbGFyOiBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7aGFzaExlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckxFKGhhc2gpIDogYnl0ZXNUb051bWJlckJFKGhhc2gpO1xuICAgIHJldHVybiBtb2QobnVtLCBncm91cE9yZGVyIC0gXzFuKSArIF8xbjtcbn1cbi8qKlxuICogUmV0dXJucyB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgY29uc3VtZWQgYnkgdGhlIGZpZWxkIGVsZW1lbnQuXG4gKiBGb3IgZXhhbXBsZSwgMzIgYnl0ZXMgZm9yIHVzdWFsIDI1Ni1iaXQgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgZmllbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGlmICh0eXBlb2YgZmllbGRPcmRlciAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnQnKTtcbiAgICBjb25zdCBiaXRMZW5ndGggPSBmaWVsZE9yZGVyLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGJpdExlbmd0aCAvIDgpO1xufVxuLyoqXG4gKiBSZXR1cm5zIG1pbmltYWwgYW1vdW50IG9mIGJ5dGVzIHRoYXQgY2FuIGJlIHNhZmVseSByZWR1Y2VkXG4gKiBieSBmaWVsZCBvcmRlci5cbiAqIFNob3VsZCBiZSAyXi0xMjggZm9yIDEyOC1iaXQgY3VydmUgc3VjaCBhcyBQMjU2LlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIHRhcmdldCBoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIHJldHVybiBsZW5ndGggKyBNYXRoLmNlaWwobGVuZ3RoIC8gMik7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIENhbiB0YWtlIChuICsgbi8yKSBvciBtb3JlIGJ5dGVzIG9mIHVuaWZvcm0gaW5wdXQgZS5nLiBmcm9tIENTUFJORyBvciBLREZcbiAqIGFuZCBjb252ZXJ0IHRoZW0gaW50byBwcml2YXRlIHNjYWxhciwgd2l0aCB0aGUgbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAqIE5lZWRzIGF0IGxlYXN0IDQ4IGJ5dGVzIG9mIGlucHV0IGZvciAzMi1ieXRlIHByaXZhdGUga2V5LlxuICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXG4gKiBGSVBTIDE4Ni01LCBBLjIgaHR0cHM6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9kZXRhaWwvZmlwcy8xODYvNS9maW5hbFxuICogUkZDIDkzODAsIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNVxuICogQHBhcmFtIGhhc2ggaGFzaCBvdXRwdXQgZnJvbSBTSEEzIG9yIGEgc2ltaWxhciBmdW5jdGlvblxuICogQHBhcmFtIGdyb3VwT3JkZXIgc2l6ZSBvZiBzdWJncm91cCAtIChlLmcuIHNlY3AyNTZrMS5DVVJWRS5uKVxuICogQHBhcmFtIGlzTEUgaW50ZXJwcmV0IGhhc2ggYnl0ZXMgYXMgTEUgbnVtXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwSGFzaFRvRmllbGQoa2V5LCBmaWVsZE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIGNvbnN0IGZpZWxkTGVuID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICBjb25zdCBtaW5MZW4gPSBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIC8vIE5vIHNtYWxsIG51bWJlcnM6IG5lZWQgdG8gdW5kZXJzdGFuZCBiaWFzIHN0b3J5LiBObyBodWdlIG51bWJlcnM6IGVhc2llciB0byBkZXRlY3QgSlMgdGltaW5ncy5cbiAgICBpZiAobGVuIDwgMTYgfHwgbGVuIDwgbWluTGVuIHx8IGxlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2xlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckJFKGtleSkgOiBieXRlc1RvTnVtYmVyTEUoa2V5KTtcbiAgICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4gICAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICAgIHJldHVybiBpc0xFID8gbnVtYmVyVG9CeXRlc0xFKHJlZHVjZWQsIGZpZWxkTGVuKSA6IG51bWJlclRvQnl0ZXNCRShyZWR1Y2VkLCBmaWVsZExlbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGFyLmpzLm1hcCIsIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIEFiZWxpYW4gZ3JvdXAgdXRpbGl0aWVzXG5pbXBvcnQgeyB2YWxpZGF0ZUZpZWxkLCBuTGVuZ3RoIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG4vLyBFbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBvZiBQb2ludCBieSBzY2FsYXIuIEZyYWdpbGUuXG4vLyBTY2FsYXJzIHNob3VsZCBhbHdheXMgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyOiB0aGlzIHNob3VsZCBiZSBjaGVja2VkIGluc2lkZSBvZiBhIGN1cnZlIGl0c2VsZi5cbi8vIENyZWF0ZXMgcHJlY29tcHV0YXRpb24gdGFibGVzIGZvciBmYXN0IG11bHRpcGxpY2F0aW9uOlxuLy8gLSBwcml2YXRlIHNjYWxhciBpcyBzcGxpdCBieSBmaXhlZCBzaXplIHdpbmRvd3Mgb2YgVyBiaXRzXG4vLyAtIGV2ZXJ5IHdpbmRvdyBwb2ludCBpcyBjb2xsZWN0ZWQgZnJvbSB3aW5kb3cncyB0YWJsZSAmIGFkZGVkIHRvIGFjY3VtdWxhdG9yXG4vLyAtIHNpbmNlIHdpbmRvd3MgYXJlIGRpZmZlcmVudCwgc2FtZSBwb2ludCBpbnNpZGUgdGFibGVzIHdvbid0IGJlIGFjY2Vzc2VkIG1vcmUgdGhhbiBvbmNlIHBlciBjYWxjXG4vLyAtIGVhY2ggbXVsdGlwbGljYXRpb24gaXMgJ01hdGguY2VpbChDVVJWRV9PUkRFUiAvIPCdkYopICsgMScgcG9pbnQgYWRkaXRpb25zIChmaXhlZCBmb3IgYW55IHNjYWxhcilcbi8vIC0gKzEgd2luZG93IGlzIG5lY2Nlc3NhcnkgZm9yIHdOQUZcbi8vIC0gd05BRiByZWR1Y2VzIHRhYmxlIHNpemU6IDJ4IGxlc3MgbWVtb3J5ICsgMnggZmFzdGVyIGdlbmVyYXRpb24sIGJ1dCAxMCUgc2xvd2VyIG11bHRpcGxpY2F0aW9uXG4vLyBUT0RPOiBSZXNlYXJjaCByZXR1cm5pbmcgMmQgSlMgYXJyYXkgb2Ygd2luZG93cywgaW5zdGVhZCBvZiBhIHNpbmdsZSB3aW5kb3cuIFRoaXMgd291bGQgYWxsb3dcbi8vIHdpbmRvd3MgdG8gYmUgaW4gZGlmZmVyZW50IG1lbW9yeSBsb2NhdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiB3TkFGKGMsIGJpdHMpIHtcbiAgICBjb25zdCBjb25zdFRpbWVOZWdhdGUgPSAoY29uZGl0aW9uLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyBuZWcgOiBpdGVtO1xuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IChXKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoYml0cyAvIFcpICsgMTsgLy8gKzEsIGJlY2F1c2VcbiAgICAgICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgcmV0dXJuIHsgd2luZG93cywgd2luZG93U2l6ZSB9O1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxuICAgICAgICAvLyBub24tY29uc3QgdGltZSBtdWx0aXBsaWNhdGlvbiBsYWRkZXJcbiAgICAgICAgdW5zYWZlTGFkZGVyKGVsbSwgbikge1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZCA9IGVsbTtcbiAgICAgICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICAgICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAgICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgICAgICogMl4o8J2RiuKIkjEpICogKE1hdGguY2VpbCjwnZGbIC8g8J2RiikgKyAxKSwgd2hlcmU6XG4gICAgICAgICAqIC0g8J2RiiBpcyB0aGUgd2luZG93IHNpemVcbiAgICAgICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAgICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAgICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGVXaW5kb3coZWxtLCBXKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBwID0gZWxtO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBwO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICAvLyA9MSwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gYmFzZS5kb3VibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIGVjIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcbiAgICAgICAgICogQHBhcmFtIG4gc2NhbGFyICh3ZSBkb24ndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcbiAgICAgICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgd05BRihXLCBwcmVjb21wdXRlcywgbikge1xuICAgICAgICAgICAgLy8gVE9ETzogbWF5YmUgY2hlY2sgdGhhdCBzY2FsYXIgaXMgbGVzcyB0aGFuIGdyb3VwIG9yZGVyPyB3TkFGIGJlaGF2aW91cyBpcyB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBCdXQgbmVlZCB0byBjYXJlZnVsbHkgcmVtb3ZlIG90aGVyIGNoZWNrcyBiZWZvcmUgd05BRi4gT1JERVIgPT0gYml0cyBoZXJlXG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBmID0gYy5CQVNFO1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTsgLy8gQ3JlYXRlIG1hc2sgd2l0aCBXIG9uZXM6IDBiMTExMSBmb3IgVz00IGV0Yy5cbiAgICAgICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgICAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJpdHMgYXJlIGJpZ2dlciB0aGFuIG1heCBzaXplLCB3ZSdsbCBzcGxpdCB0aG9zZS5cbiAgICAgICAgICAgICAgICAvLyArMjI0ID0+IDI1NiAtIDMyXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgb250byBaZXJvIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIEFkZCByYW5kb20gcG9pbnQgaW5zaWRlIGN1cnJlbnQgd2luZG93IHRvIGYuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleVxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBKSVQtY29tcGlsZXIgc2hvdWxkIG5vdCBlbGltaW5hdGUgZiBoZXJlLCBzaW5jZSBpdCB3aWxsIGxhdGVyIGJlIHVzZWQgaW4gbm9ybWFsaXplWigpXG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB2YXJpYWJsZSBpcyBzdGlsbCB1bnVzZWQsIHRoZXJlIGFyZSBzb21lIGNoZWNrcyB3aGljaCB3aWxsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGNvbXBpbGVyIG5lZWRzIHRvIHByb3ZlIHRoZXkgd29uJ3QgaGFwcGVuLCB3aGljaCBpcyBoYXJkLlxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZChQLCBwcmVjb21wdXRlc01hcCwgbiwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBXID0gUC5fV0lORE9XX1NJWkUgfHwgMTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgICAgICAgbGV0IGNvbXAgPSBwcmVjb21wdXRlc01hcC5nZXQoUCk7XG4gICAgICAgICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KFAsIFcpO1xuICAgICAgICAgICAgICAgIGlmIChXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNvbXB1dGVzTWFwLnNldChQLCB0cmFuc2Zvcm0oY29tcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgY29tcCwgbik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGN1cnZlKSB7XG4gICAgdmFsaWRhdGVGaWVsZChjdXJ2ZS5GcCk7XG4gICAgdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgbjogJ2JpZ2ludCcsXG4gICAgICAgIGg6ICdiaWdpbnQnLFxuICAgICAgICBHeDogJ2ZpZWxkJyxcbiAgICAgICAgR3k6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBuQml0TGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIG5CeXRlTGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAuLi5uTGVuZ3RoKGN1cnZlLm4sIGN1cnZlLm5CaXRMZW5ndGgpLFxuICAgICAgICAuLi5jdXJ2ZSxcbiAgICAgICAgLi4ueyBwOiBjdXJ2ZS5GcC5PUkRFUiB9LFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VydmUuanMubWFwIiwiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gU2hvcnQgV2VpZXJzdHJhc3MgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGJcbmltcG9ydCAqIGFzIG1vZCBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0ICogYXMgdXQgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVCeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgd05BRiwgdmFsaWRhdGVCYXNpYyB9IGZyb20gJy4vY3VydmUuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kb21vcnBoaXNtIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZG8gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG4vLyBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzXG5jb25zdCB7IGJ5dGVzVG9OdW1iZXJCRTogYjJuLCBoZXhUb0J5dGVzOiBoMmIgfSA9IHV0O1xuZXhwb3J0IGNvbnN0IERFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgICAgICAgICBzdXBlcihtKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3BhcnNlSW50KGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9PSAweDAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnJyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgICAgIGNvbnN0IHJlcyA9IGRhdGEuc3ViYXJyYXkoMiwgbGVuICsgMik7XG4gICAgICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGgnKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAgICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgICAgICBpZiAocmVzWzBdICYgMGIxMDAwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICBpZiAocmVzWzBdID09PSAweDAwICYmICEocmVzWzFdICYgMGIxMDAwMDAwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgIHJldHVybiB7IGQ6IGIybihyZXMpLCBsOiBkYXRhLnN1YmFycmF5KGxlbiArIDIpIH07IC8vIGQgaXMgZGF0YSwgbCBpcyBsZWZ0XG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoMmIoaGV4KSA6IGhleDtcbiAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1aThhIGV4cGVjdGVkJyk7XG4gICAgICAgIGxldCBsID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsIDwgMiB8fCBkYXRhWzBdICE9IDB4MzApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgdGFnJyk7XG4gICAgICAgIGlmIChkYXRhWzFdICE9PSBsIC0gMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogaW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgICAgICBjb25zdCB7IGQ6IHIsIGw6IHNCeXRlcyB9ID0gREVSLl9wYXJzZUludChkYXRhLnN1YmFycmF5KDIpKTtcbiAgICAgICAgY29uc3QgeyBkOiBzLCBsOiByQnl0ZXNMZWZ0IH0gPSBERVIuX3BhcnNlSW50KHNCeXRlcyk7XG4gICAgICAgIGlmIChyQnl0ZXNMZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHIsIHMgfTtcbiAgICB9LFxuICAgIGhleEZyb21TaWcoc2lnKSB7XG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm8gaWYgZmlyc3QgYnl0ZSBoYXMgbmVnYXRpdmUgYml0IGVuYWJsZWQuIE1vcmUgZGV0YWlscyBpbiAnX3BhcnNlSW50J1xuICAgICAgICBjb25zdCBzbGljZSA9IChzKSA9PiAoTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSAmIDBiMTAwMCA/ICcwMCcgKyBzIDogcyk7XG4gICAgICAgIGNvbnN0IGggPSAobnVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzID0gc2xpY2UoaChzaWcucykpO1xuICAgICAgICBjb25zdCByID0gc2xpY2UoaChzaWcucikpO1xuICAgICAgICBjb25zdCBzaGwgPSBzLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHJobCA9IHIubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc2wgPSBoKHNobCk7XG4gICAgICAgIGNvbnN0IHJsID0gaChyaGwpO1xuICAgICAgICByZXR1cm4gYDMwJHtoKHJobCArIHNobCArIDQpfTAyJHtybH0ke3J9MDIke3NsfSR7c31gO1xuICAgIH0sXG59O1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxuICAgICAgICAoKF9jLCBwb2ludCwgX2lzQ29tcHJlc3NlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuY29uY2F0Qnl0ZXMoVWludDhBcnJheS5mcm9tKFsweDA0XSksIEZwLnRvQnl0ZXMoYS54KSwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgZnJvbUJ5dGVzID0gQ1VSVkUuZnJvbUJ5dGVzIHx8XG4gICAgICAgICgoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIGlmIChoZWFkICE9PSAweDA0KSB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbm9uLWNvbXByZXNzZWQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH0pO1xuICAgIC8qKlxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYVxuICAgICAqIEByZXR1cm5zIHnCslxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4MiAqIHhcbiAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4MyArIGEgKiB4ICsgYlxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cbiAgICAvLyBXZSBjaGVjayBpZiBjdXJ2ZSBlcXVhdGlvbiB3b3JrcyBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIC8vIGBhc3NlcnRWYWxpZGl0eSgpYCB3b24ndCB3b3JrOiBgaXNUb3JzaW9uRnJlZSgpYCBpcyBub3QgYXZhaWxhYmxlIGF0IHRoaXMgcG9pbnQgaW4gYmxzMTItMzgxLlxuICAgIC8vIFByb2plY3RpdmVQb2ludCBjbGFzcyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxuICAgIGlmICghRnAuZXFsKEZwLnNxcihDVVJWRS5HeSksIHdlaWVyc3RyYXNzRXF1YXRpb24oQ1VSVkUuR3gpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgZ2VuZXJhdG9yIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdiaWdpbnQnICYmIF8wbiA8IG51bSAmJiBudW0gPCBDVVJWRS5uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRHRShudW0pIHtcbiAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgYmlnaW50OiAwIDwgYmlnaW50IDwgY3VydmUubicpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZXMgaWYgcHJpdiBrZXkgaXMgdmFsaWQgYW5kIGNvbnZlcnRzIGl0IHRvIGJpZ2ludC5cbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgICAgICBrZXkgPSB1dC5ieXRlc1RvSGV4KGtleSk7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgIWxlbmd0aHMuaW5jbHVkZXMoa2V5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID1cbiAgICAgICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgICAgICAgICA6IHV0LmJ5dGVzVG9OdW1iZXJCRShlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtuQnl0ZUxlbmd0aH0gYnl0ZXMsIGhleCBvciBiaWdpbnQsIG5vdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kLm1vZChudW0sIG4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgYXNzZXJ0R0UobnVtKTsgLy8gbnVtIGluIHJhbmdlIFsxLi5OLTFdXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOiAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgdGhpcy5weCA9IHB4O1xuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuICAgICAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSkge1xuICAgICAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXG4gICAgICAgICAgICAgICAgLy8gSW4gQkxTLCBaRVJPIGNhbiBiZSBzZXJpYWxpemVkLCBzbyB3ZSBhbGxvdyBpdC5cbiAgICAgICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgd3JvbmcgcmVwcmVzZW50YXRpb24gb2YgWkVSTyBhbmQgaXMgYWx3YXlzIGludmFsaWQuXG4gICAgICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHRoaXMucHkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgaWYgKCFGcC5lcWwobGVmdCwgcmlnaHQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBwb2ludFByZWNvbXB1dGVzLCBuLCAoY29tcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2goY29tcC5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUobikge1xuICAgICAgICAgICAgY29uc3QgSSA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgYXNzZXJ0R0Uobik7IC8vIFdpbGwgdGhyb3cgb24gMFxuICAgICAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoIWVuZG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICAgICAgLy8gQXBwbHkgZW5kb21vcnBoaXNtXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGFzc2VydEdFKHNjYWxhcik7XG4gICAgICAgICAgICBsZXQgbiA9IHNjYWxhcjtcbiAgICAgICAgICAgIGxldCBwb2ludCwgZmFrZTsgLy8gRmFrZSBwb2ludCBpcyB1c2VkIHRvIGNvbnN0LXRpbWUgbXVsdFxuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuaXMwKCk7XG4gICAgICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgICAgIGlmIChpczApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICAgICAgfVxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgaXNUb3JzaW9uRnJlZSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gc3ViZ3JvdXBzLCBhbHdheXMgdG9yc2lvbi1mcmVlXG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhckNvZmFjdG9yKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpO1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTtcbiAgICBjb25zdCBfYml0cyA9IENVUlZFLm5CaXRMZW5ndGg7XG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIENVUlZFLmVuZG8gPyBNYXRoLmNlaWwoX2JpdHMgLyAyKSA6IF9iaXRzKTtcbiAgICAvLyBWYWxpZGF0ZSBpZiBnZW5lcmF0b3IgcG9pbnQgaXMgb24gY3VydmVcbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcbiAgICAgICAgaXNXaXRoaW5DdXJ2ZU9yZGVyLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkRmllbGRFbGVtZW50KG51bSkge1xuICAgICAgICByZXR1cm4gXzBuIDwgbnVtICYmIG51bSA8IEZwLk9SREVSOyAvLyAwIGlzIGJhbm5lZCBzaW5jZSBpdCdzIG5vdCBpbnZlcnRpYmxlIEZFXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLm1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludk4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLmludmVydChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBQb2ludCwgbm9ybVByaXZhdGVLZXlUb1NjYWxhciwgd2VpZXJzdHJhc3NFcXVhdGlvbiwgaXNXaXRoaW5DdXJ2ZU9yZGVyLCB9ID0gd2VpZXJzdHJhc3NQb2ludHMoe1xuICAgICAgICAuLi5DVVJWRSxcbiAgICAgICAgdG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAudG9CeXRlcyhhLngpO1xuICAgICAgICAgICAgY29uc3QgY2F0ID0gdXQuY29uY2F0Qnl0ZXM7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oW3BvaW50Lmhhc0V2ZW5ZKCkgPyAweDAyIDogMHgwM10pLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFsweDA0XSksIHgsIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcbiAgICAgICAgICAgIGlmIChsZW4gPT09IGNvbXByZXNzZWRMZW4gJiYgKGhlYWQgPT09IDB4MDIgfHwgaGVhZCA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gdXQuYnl0ZXNUb051bWJlckJFKHRhaWwpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEZpZWxkRWxlbWVudCh4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHnCsiA9IHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgICAgIGxldCB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignciBtdXN0IGJlIDAgPCByIDwgQ1VSVkUubicpO1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAwIDwgcyA8IENVUlZFLm4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICBjb25zdCBzdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAyICogY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IDIgKiB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXG4gICAgICogQ29tcHV0ZXMgc2hhcmVkIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleS5cbiAgICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwcml2YXRlQSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBzaGFyZWQgcHVibGljIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpOyAvLyBjaGVjayBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cbiAgICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IHV0LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIENVUlZFLm5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IHV0LmJpdE1hc2soQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBleHBlY3RlZCcpO1xuICAgICAgICBpZiAoIShfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSX01BU0spKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsIHRoaXMgd2lsbCBiZSB3cm9uZyBhdCBsZWFzdCBmb3IgUDUyMS5cbiAgICAvLyBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgbGF0ZXIgY2FsbCBiaXRzMm9jdGV0cywgc2luY2UgbmVzdGVkIGJpdHMyaW50IGlzIGJyb2tlbiBmb3IgY3VydmVzXG4gICAgICAgIC8vIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgZCA9IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgICAgIC8vIGV4dHJhRW50cm9weS4gUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKS5cbiAgICAgICAgaWYgKGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlcyhGcC5CWVRFUykgOiBlbnQ7IC8vIGdlbmVyYXRlIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoIH0gPSBvcHRzO1xuICAgICAgICBsZXQgX3NpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IFA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCBzZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgbW9kLnZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiLCIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbmltcG9ydCB7IGNvbmNhdEJ5dGVzLCByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiBobWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIiwiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IEZpZWxkLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgbWFwVG9DdXJ2ZVNpbXBsZVNXVSB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBpc29nZW55TWFwIH0gZnJvbSAnLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzJztcbmltcG9ydCB7IGNyZWF0ZUN1cnZlIH0gZnJvbSAnLi9fc2hvcnR3X3V0aWxzLmpzJztcbmNvbnN0IHNlY3AyNTZrMVAgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpO1xuY29uc3Qgc2VjcDI1NmsxTiA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuLyoqXG4gKiDiiJpuID0gbl4oKHArMSkvNCkgZm9yIGZpZWxkcyBwID0gMyBtb2QgNC4gV2UgdW53cmFwIHRoZSBsb29wIGFuZCBtdWx0aXBseSBiaXQtYnktYml0LlxuICogKFArMW4vNG4pLnRvU3RyaW5nKDIpIHdvdWxkIHByb2R1Y2UgYml0cyBbMjIzeCAxLCAwLCAyMnggMSwgNHggMCwgMTEsIDAwXVxuICovXG5mdW5jdGlvbiBzcXJ0TW9kKHkpIHtcbiAgICBjb25zdCBQID0gc2VjcDI1NmsxUDtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfM24gPSBCaWdJbnQoMyksIF82biA9IEJpZ0ludCg2KSwgXzExbiA9IEJpZ0ludCgxMSksIF8yMm4gPSBCaWdJbnQoMjIpO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8yM24gPSBCaWdJbnQoMjMpLCBfNDRuID0gQmlnSW50KDQ0KSwgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeSAqIHkgKiB5KSAlIFA7IC8vIHheMywgMTFcbiAgICBjb25zdCBiMyA9IChiMiAqIGIyICogeSkgJSBQOyAvLyB4XjdcbiAgICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuLCBQKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4biwgUCkgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82biwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJvb3QgPSBwb3cyKHQyLCBfMm4sIFApO1xuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwID0gRmllbGQoc2VjcDI1NmsxUCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgc3FydDogc3FydE1vZCB9KTtcbmV4cG9ydCBjb25zdCBzZWNwMjU2azEgPSBjcmVhdGVDdXJ2ZSh7XG4gICAgYTogQmlnSW50KDApLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBGcCxcbiAgICBuOiBzZWNwMjU2azFOLFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IHRydWUsXG4gICAgLyoqXG4gICAgICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAgICAgKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAgICAgKiBGb3IgcHJlY29tcHV0ZWQgd05BRiBpdCB0cmFkZXMgb2ZmIDEvMiBpbml0IHRpbWUgJiAxLzMgcmFtIGZvciAyMCUgcGVyZiBoaXQuXG4gICAgICogRXhwbGFuYXRpb246IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NlxuICAgICAqL1xuICAgIGVuZG86IHtcbiAgICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gc2VjcDI1NmsxTjtcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcbiAgICAgICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBhMTtcbiAgICAgICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTsgLy8gKDJuKioxMjhuKS50b1N0cmluZygxNilcbiAgICAgICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgICAgICAgICAgbGV0IGsxID0gbW9kKGsgLSBjMSAqIGExIC0gYzIgKiBhMiwgbik7XG4gICAgICAgICAgICBsZXQgazIgPSBtb2QoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBjb25zdCBrMm5lZyA9IGsyID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxID0gbiAtIGsxO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICAgICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhcjogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgICAgICB9LFxuICAgIH0sXG59LCBzaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBmZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxUDtcbmNvbnN0IGdlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFOO1xuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcbmZ1bmN0aW9uIHRhZ2dlZEhhc2godGFnLCAuLi5tZXNzYWdlcykge1xuICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRhZ0ggPSBzaGEyNTYoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgIH1cbiAgICByZXR1cm4gc2hhMjU2KGNvbmNhdEJ5dGVzKHRhZ1AsIC4uLm1lc3NhZ2VzKSk7XG59XG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludCkgPT4gcG9pbnQudG9SYXdCeXRlcyh0cnVlKS5zbGljZSgxKTtcbmNvbnN0IG51bVRvMzJiID0gKG4pID0+IG51bWJlclRvQnl0ZXNCRShuLCAzMik7XG5jb25zdCBtb2RQID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFQKTtcbmNvbnN0IG1vZE4gPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMU4pO1xuY29uc3QgUG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50O1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgaWYgKCFmZSh4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgeDogbmVlZCAwIDwgeCA8IHAnKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxuICAgIGNvbnN0IHh4ID0gbW9kUCh4ICogeCk7XG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKHkgJSBfMm4gIT09IF8wbilcbiAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbik7IC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gcmFuZG9tQnl0ZXMoMzIpKSB7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gZW5zdXJlQnl0ZXMoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTihieXRlc1RvTnVtYmVyQkUocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3goYnl0ZXNUb051bWJlckJFKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9IGJ5dGVzVG9OdW1iZXJCRShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoIWZlKHIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFnZShzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZSA9IGNoYWxsZW5nZShudW1UbzMyYihyKSwgcG9pbnRUb0J5dGVzKFApLCBtKTsgLy8gaW50KGNoYWxsZW5nZShieXRlcyhyKXx8Ynl0ZXMoUCl8fG0pKSVuXG4gICAgICAgIGNvbnN0IFIgPSBHbXVsQWRkKFAsIHMsIG1vZE4oLWUpKTsgLy8gUiA9IHPii4VHIC0gZeKLhVBcbiAgICAgICAgaWYgKCFSIHx8ICFSLmhhc0V2ZW5ZKCkgfHwgUi50b0FmZmluZSgpLnggIT09IHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIC1lUCA9PSAobi1lKVBcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEZhaWwgaWYgaXNfaW5maW5pdGUoUikgLyBub3QgaGFzX2V2ZW5feShSKSAvIHgoUikg4omgIHIuXG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpc29nZW55TWFwKEZwLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCB7XG4gICAgQTogQmlnSW50KCcweDNmODczMWFiZGQ2NjFhZGNhMDhhNTU1OGYwZjVkMjcyZTk1M2QzNjNjYjZmMGU1ZDQwNTQ0N2MwMWE0NDQ1MzMnKSxcbiAgICBCOiBCaWdJbnQoJzE3NzEnKSxcbiAgICBaOiBGcC5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbmNvbnN0IGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nixcbn0pKSgpO1xuZXhwb3J0IGNvbnN0IGhhc2hUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azEuanMubWFwIiwiLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIHplcm8gYWRkcmVzcy5cbiAqXG4gKiAgKCoqaS5lLioqIGBgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcImBgKVxuICovXG5leHBvcnQgY29uc3QgWmVyb0FkZHJlc3MgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzc2VzLmpzLm1hcCIsIi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSB6ZXJvIGhhc2guXG4gKlxuICogICgqKmkuZS4qKiBgYFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJgYClcbiAqL1xuZXhwb3J0IGNvbnN0IFplcm9IYXNoID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2hlcy5qcy5tYXAiLCJpbXBvcnQgeyBaZXJvSGFzaCB9IGZyb20gXCIuLi9jb25zdGFudHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YUxlbmd0aCwgZ2V0QmlnSW50LCBnZXRCeXRlcywgZ2V0TnVtYmVyLCBoZXhsaWZ5LCB0b0JlQXJyYXksIGlzSGV4U3RyaW5nLCB6ZXJvUGFkVmFsdWUsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRQcml2YXRlIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vLyBDb25zdGFudHNcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcbmNvbnN0IEJOXzI3ID0gQmlnSW50KDI3KTtcbmNvbnN0IEJOXzI4ID0gQmlnSW50KDI4KTtcbmNvbnN0IEJOXzM1ID0gQmlnSW50KDM1KTtcbmNvbnN0IF9ndWFyZCA9IHt9O1xuZnVuY3Rpb24gdG9VaW50MjU2KHZhbHVlKSB7XG4gICAgcmV0dXJuIHplcm9QYWRWYWx1ZSh0b0JlQXJyYXkodmFsdWUpLCAzMik7XG59XG4vKipcbiAqICBBIFNpZ25hdHVyZSAgQFRPRE9cbiAqXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOlNpZ25pbmdcbiAqL1xuZXhwb3J0IGNsYXNzIFNpZ25hdHVyZSB7XG4gICAgI3I7XG4gICAgI3M7XG4gICAgI3Y7XG4gICAgI25ldHdvcmtWO1xuICAgIC8qKlxuICAgICAqICBUaGUgYGByYGAgdmFsdWUgZm9yIGEgc2lnbmF1dHJlLlxuICAgICAqXG4gICAgICogIFRoaXMgcmVwcmVzZW50cyB0aGUgYGB4YGAgY29vcmRpbmF0ZSBvZiBhIFwicmVmZXJlbmNlXCIgb3JcbiAgICAgKiAgY2hhbGxlbmdlIHBvaW50LCBmcm9tIHdoaWNoIHRoZSBgYHlgYCBjYW4gYmUgY29tcHV0ZWQuXG4gICAgICovXG4gICAgZ2V0IHIoKSB7IHJldHVybiB0aGlzLiNyOyB9XG4gICAgc2V0IHIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aCh2YWx1ZSkgPT09IDMyLCBcImludmFsaWQgclwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgdGhpcy4jciA9IGhleGxpZnkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgc2BgIHZhbHVlIGZvciBhIHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBnZXQgcygpIHsgcmV0dXJuIHRoaXMuI3M7IH1cbiAgICBzZXQgcyhfdmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aChfdmFsdWUpID09PSAzMiwgXCJpbnZhbGlkIHNcIiwgXCJ2YWx1ZVwiLCBfdmFsdWUpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGhleGxpZnkoX3ZhbHVlKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKDAsIDMpKSA8IDgsIFwibm9uLWNhbm9uaWNhbCBzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB0aGlzLiNzID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGB2YGAgdmFsdWUgZm9yIGEgc2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogIFNpbmNlIGEgZ2l2ZW4gYGB4YGAgdmFsdWUgZm9yIGBgcmBgIGhhcyB0d28gcG9zc2libGUgdmFsdWVzIGZvclxuICAgICAqICBpdHMgY29ycmVzcG9uZGluIGBgeWBgLCB0aGUgYGB2YGAgaW5kaWNhdGVzIHdoaWNoIG9mIHRoZSB0d28gYGB5YGBcbiAgICAgKiAgdmFsdWVzIHRvIHVzZS5cbiAgICAgKlxuICAgICAqICBJdCBpcyBub3JtYWxpemVkIHRvIHRoZSB2YWx1ZXMgYGAyN2BgIG9yIGBgMjhgYCBmb3IgbGVnYWN5XG4gICAgICogIHB1cnBvc2VzLlxuICAgICAqL1xuICAgIGdldCB2KCkgeyByZXR1cm4gdGhpcy4jdjsgfVxuICAgIHNldCB2KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHYgPSBnZXROdW1iZXIodmFsdWUsIFwidmFsdWVcIik7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHYgPT09IDI3IHx8IHYgPT09IDI4LCBcImludmFsaWQgdlwiLCBcInZcIiwgdmFsdWUpO1xuICAgICAgICB0aGlzLiN2ID0gdjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBFSVAtMTU1IGBgdmBgIGZvciBsZWdhY3kgdHJhbnNhY3Rpb25zLiBGb3Igbm9uLWxlZ2FjeVxuICAgICAqICB0cmFuc2FjdGlvbnMsIHRoaXMgdmFsdWUgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IG5ldHdvcmtWKCkgeyByZXR1cm4gdGhpcy4jbmV0d29ya1Y7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElEIGZvciBFSVAtMTU1IGxlZ2FjeSB0cmFuc2FjdGlvbnMuIEZvciBub24tbGVnYWN5XG4gICAgICogIHRyYW5zYWN0aW9ucywgdGhpcyB2YWx1ZSBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbGVnYWN5Q2hhaW5JZCgpIHtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMubmV0d29ya1Y7XG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuZ2V0Q2hhaW5JZCh2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHlQYXJpdHlgYCBmb3IgdGhlIHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqICBTZWUgYGB2YGAgZm9yIG1vcmUgZGV0YWlscyBvbiBob3cgdGhpcyB2YWx1ZSBpcyB1c2VkLlxuICAgICAqL1xuICAgIGdldCB5UGFyaXR5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudiA9PT0gMjcpID8gMCA6IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yMDk4XV0gY29tcGFjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYGB5UGFyaXR5YGBcbiAgICAgKiAgYW5kIGBgc2BgIGNvbXBhY3RlZCBpbnRvIGEgc2luZ2xlIGBgYnl0ZXMzMmBgLlxuICAgICAqL1xuICAgIGdldCB5UGFyaXR5QW5kUygpIHtcbiAgICAgICAgLy8gVGhlIEVJUC0yMDk4IGNvbXBhY3QgcmVwcmVzZW50YXRpb25cbiAgICAgICAgY29uc3QgeVBhcml0eUFuZFMgPSBnZXRCeXRlcyh0aGlzLnMpO1xuICAgICAgICBpZiAodGhpcy55UGFyaXR5KSB7XG4gICAgICAgICAgICB5UGFyaXR5QW5kU1swXSB8PSAweDgwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHlQYXJpdHlBbmRTKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTIwOThdXSBjb21wYWN0IHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIGdldCBjb21wYWN0U2VyaWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbdGhpcy5yLCB0aGlzLnlQYXJpdHlBbmRTXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgc2VyaWFsaXplZCByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgc2VyaWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbdGhpcy5yLCB0aGlzLnMsICh0aGlzLnlQYXJpdHkgPyBcIjB4MWNcIiA6IFwiMHgxYlwiKV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgciwgcywgdikge1xuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiU2lnbmF0dXJlXCIpO1xuICAgICAgICB0aGlzLiNyID0gcjtcbiAgICAgICAgdGhpcy4jcyA9IHM7XG4gICAgICAgIHRoaXMuI3YgPSB2O1xuICAgICAgICB0aGlzLiNuZXR3b3JrViA9IG51bGw7XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICAgICAgcmV0dXJuIGBTaWduYXR1cmUgeyByOiBcIiR7dGhpcy5yfVwiLCBzOiBcIiR7dGhpcy5zfVwiLCB5UGFyaXR5OiAke3RoaXMueVBhcml0eX0sIG5ldHdvcmtWOiAke3RoaXMubmV0d29ya1Z9IH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBpZGVudGljYWwgW1tTaWduYXR1cmVdXS5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgdGhpcy5yLCB0aGlzLnMsIHRoaXMudik7XG4gICAgICAgIGlmICh0aGlzLm5ldHdvcmtWKSB7XG4gICAgICAgICAgICBjbG9uZS4jbmV0d29ya1YgPSB0aGlzLm5ldHdvcmtWO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSByZXByZXNlbnRhdGlvbiB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCBgYEpTT04uc3RyaW5naWZ5YGAuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrViA9IHRoaXMubmV0d29ya1Y7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJzaWduYXR1cmVcIixcbiAgICAgICAgICAgIG5ldHdvcmtWOiAoKG5ldHdvcmtWICE9IG51bGwpID8gbmV0d29ya1YudG9TdHJpbmcoKSA6IG51bGwpLFxuICAgICAgICAgICAgcjogdGhpcy5yLCBzOiB0aGlzLnMsIHY6IHRoaXMudixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGNoYWluIElEIGZyb20gdGhlIGBgdmBgIGluIGEgbGVnYWN5IEVJUC0xNTUgdHJhbnNhY3Rpb25zLlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkKDQ1KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkKDQ2KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hhaW5JZCh2KSB7XG4gICAgICAgIGNvbnN0IGJ2ID0gZ2V0QmlnSW50KHYsIFwidlwiKTtcbiAgICAgICAgLy8gVGhlIHYgaXMgbm90IGFuIEVJUC0xNTUgdiwgc28gaXQgaXMgdGhlIHVuc3BlY2lmaWVkIGNoYWluIElEXG4gICAgICAgIGlmICgoYnYgPT0gQk5fMjcpIHx8IChidiA9PSBCTl8yOCkpIHtcbiAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhZCB2YWx1ZSBmb3IgYW4gRUlQLTE1NSB2XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ2ID49IEJOXzM1LCBcImludmFsaWQgRUlQLTE1NSB2XCIsIFwidlwiLCB2KTtcbiAgICAgICAgcmV0dXJuIChidiAtIEJOXzM1KSAvIEJOXzI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBgYHZgYCBmb3IgYSBjaGFpbiBJRCBmb3IgYSBsZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiAgTGVnYWN5IHRyYW5zYWN0aW9ucyB3aGljaCB1c2UgW1tsaW5rLWVpcC0xNTVdXSBoaWphY2sgdGhlIGBgdmBgXG4gICAgICogIHByb3BlcnR5IHRvIGluY2x1ZGUgdGhlIGNoYWluIElELlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkVig1LCAyNylcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZFYoNSwgMjgpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGdldENoYWluSWRWKGNoYWluSWQsIHYpIHtcbiAgICAgICAgcmV0dXJuIChnZXRCaWdJbnQoY2hhaW5JZCkgKiBCTl8yKSArIEJpZ0ludCgzNSArIHYgLSAyNyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBub3JtYWxpemVkIGxlZ2FjeSB0cmFuc2FjdGlvbiBgYHZgYCBmcm9tIGEgYGB5UGFyaXJ0eWBgLFxuICAgICAqICBhIGxlZ2FjeSB0cmFuc2FjdGlvbiBgYHZgYCBvciBhIGxlZ2FjeSBbW2xpbmstZWlwLTE1NV1dIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIC8vIFRoZSB2YWx1ZXMgMCBhbmQgMSBpbXBseSB2IGlzIGFjdHVhbGx5IHlQYXJpdHlcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoMClcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBMZWdhY3kgbm9uLUVJUC0xNTU5IHRyYW5zYWN0aW9uIChpLmUuIDI3IG9yIDI4KVxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVigyNylcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBMZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbiAoaS5lLiA+PSAzNSlcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoNDYpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gSW52YWxpZCB2YWx1ZXMgdGhyb3dcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoNSlcbiAgICAgKiAgICAvL19lcnJvcjpcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Tm9ybWFsaXplZFYodikge1xuICAgICAgICBjb25zdCBidiA9IGdldEJpZ0ludCh2KTtcbiAgICAgICAgaWYgKGJ2ID09PSBCTl8wIHx8IGJ2ID09PSBCTl8yNykge1xuICAgICAgICAgICAgcmV0dXJuIDI3O1xuICAgICAgICB9XG4gICAgICAgIGlmIChidiA9PT0gQk5fMSB8fCBidiA9PT0gQk5fMjgpIHtcbiAgICAgICAgICAgIHJldHVybiAyODtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChidiA+PSBCTl8zNSwgXCJpbnZhbGlkIHZcIiwgXCJ2XCIsIHYpO1xuICAgICAgICAvLyBPdGhlcndpc2UsIEVJUC0xNTUgdiBtZWFucyBvZGQgaXMgMjcgYW5kIGV2ZW4gaXMgMjhcbiAgICAgICAgcmV0dXJuIChidiAmIEJOXzEpID8gMjcgOiAyODtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tTaWduYXR1cmVdXS5cbiAgICAgKlxuICAgICAqICBJZiBubyAlJXNpZyUlIGlzIHByb3ZpZGVkLCBhIG5ldyBbW1NpZ25hdHVyZV1dIGlzIGNyZWF0ZWRcbiAgICAgKiAgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICBJZiAlJXNpZyUlIGlzIGEgc3RyaW5nLCBpdCBpcyBwYXJzZWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20oc2lnKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFzc2VydEVycm9yKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChjaGVjaywgbWVzc2FnZSwgXCJzaWduYXR1cmVcIiwgc2lnKTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGlmIChzaWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoX2d1YXJkLCBaZXJvSGFzaCwgWmVyb0hhc2gsIDI3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChzaWcpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHNpZywgXCJzaWduYXR1cmVcIik7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDMyKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGJ5dGVzLnNsaWNlKDMyLCA2NCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IChzWzBdICYgMHg4MCkgPyAyOCA6IDI3O1xuICAgICAgICAgICAgICAgIHNbMF0gJj0gMHg3ZjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHIsIGhleGxpZnkocyksIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBieXRlcy5zbGljZSgzMiwgNjQpO1xuICAgICAgICAgICAgICAgIGFzc2VydEVycm9yKChzWzBdICYgMHg4MCkgPT09IDAsIFwibm9uLWNhbm9uaWNhbCBzXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoYnl0ZXNbNjRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHIsIGhleGxpZnkocyksIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwiaW52YWxpZCByYXcgc2lnbmF0dXJlIGxlbmd0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnIGluc3RhbmNlb2YgU2lnbmF0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2lnLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHJcbiAgICAgICAgY29uc3QgX3IgPSBzaWcucjtcbiAgICAgICAgYXNzZXJ0RXJyb3IoX3IgIT0gbnVsbCwgXCJtaXNzaW5nIHJcIik7XG4gICAgICAgIGNvbnN0IHIgPSB0b1VpbnQyNTYoX3IpO1xuICAgICAgICAvLyBHZXQgczsgYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAod2UgY2hlY2sgY29uc2lzdGVuY3kgYmVsb3cpXG4gICAgICAgIGNvbnN0IHMgPSAoZnVuY3Rpb24gKHMsIHlQYXJpdHlBbmRTKSB7XG4gICAgICAgICAgICBpZiAocyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvVWludDI1NihzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5UGFyaXR5QW5kUyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoaXNIZXhTdHJpbmcoeVBhcml0eUFuZFMsIDMyKSwgXCJpbnZhbGlkIHlQYXJpdHlBbmRTXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoeVBhcml0eUFuZFMpO1xuICAgICAgICAgICAgICAgIGJ5dGVzWzBdICY9IDB4N2Y7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwibWlzc2luZyBzXCIpO1xuICAgICAgICB9KShzaWcucywgc2lnLnlQYXJpdHlBbmRTKTtcbiAgICAgICAgYXNzZXJ0RXJyb3IoKGdldEJ5dGVzKHMpWzBdICYgMHg4MCkgPT0gMCwgXCJub24tY2Fub25pY2FsIHNcIik7XG4gICAgICAgIC8vIEdldCB2OyBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh3ZSBjaGVjayBjb25zaXN0ZW5jeSBiZWxvdylcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrViwgdiB9ID0gKGZ1bmN0aW9uIChfdiwgeVBhcml0eUFuZFMsIHlQYXJpdHkpIHtcbiAgICAgICAgICAgIGlmIChfdiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IGdldEJpZ0ludChfdik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya1Y6ICgodiA+PSBCTl8zNSkgPyB2IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgdjogU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKHYpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5UGFyaXR5QW5kUyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoaXNIZXhTdHJpbmcoeVBhcml0eUFuZFMsIDMyKSwgXCJpbnZhbGlkIHlQYXJpdHlBbmRTXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHY6ICgoZ2V0Qnl0ZXMoeVBhcml0eUFuZFMpWzBdICYgMHg4MCkgPyAyOCA6IDI3KSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlQYXJpdHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZ2V0TnVtYmVyKHlQYXJpdHksIFwic2lnLnlQYXJpdHlcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4geyB2OiAyNyB9O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiB7IHY6IDI4IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcImludmFsaWQgeVBhcml0eVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcIm1pc3NpbmcgdlwiKTtcbiAgICAgICAgfSkoc2lnLnYsIHNpZy55UGFyaXR5QW5kUywgc2lnLnlQYXJpdHkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgcywgdik7XG4gICAgICAgIGlmIChuZXR3b3JrVikge1xuICAgICAgICAgICAgcmVzdWx0LiNuZXR3b3JrViA9IG5ldHdvcmtWO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG11bHRpcGxlIG9mIHYsIHlQYXJpdHksIHlQYXJpdHlBbmRTIHdlIGdpdmVuLCBjaGVjayB0aGV5IG1hdGNoXG4gICAgICAgIGFzc2VydEVycm9yKHNpZy55UGFyaXR5ID09IG51bGwgfHwgZ2V0TnVtYmVyKHNpZy55UGFyaXR5LCBcInNpZy55UGFyaXR5XCIpID09PSByZXN1bHQueVBhcml0eSwgXCJ5UGFyaXR5IG1pc21hdGNoXCIpO1xuICAgICAgICBhc3NlcnRFcnJvcihzaWcueVBhcml0eUFuZFMgPT0gbnVsbCB8fCBzaWcueVBhcml0eUFuZFMgPT09IHJlc3VsdC55UGFyaXR5QW5kUywgXCJ5UGFyaXR5QW5kUyBtaXNtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYXR1cmUuanMubWFwIiwiLyoqXG4gKiAgQWRkIGRldGFpbHMgYWJvdXQgc2lnbmluZyBoZXJlLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86U2lnbmluZyAgW2Fib3V0LXNpZ25pbmddXG4gKi9cbmltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhTGVuZ3RoLCBnZXRCeXRlcywgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5LCB0b0JlSGV4LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4vc2lnbmF0dXJlLmpzXCI7XG4vKipcbiAqICBBICoqU2lnbmluZ0tleSoqIHByb3ZpZGVzIGhpZ2gtbGV2ZWwgYWNjZXNzIHRvIHRoZSBlbGxpcHRpYyBjdXJ2ZVxuICogIGNyeXB0b2dyYXBoeSAoRUNDKSBvcGVyYXRpb25zIGFuZCBrZXkgbWFuYWdlbWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpZ25pbmdLZXkge1xuICAgICNwcml2YXRlS2V5O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqU2lnbmluZ0tleSoqIGZvciAlJXByaXZhdGVLZXklJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlS2V5KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgocHJpdmF0ZUtleSkgPT09IDMyLCBcImludmFsaWQgcHJpdmF0ZSBrZXlcIiwgXCJwcml2YXRlS2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgdGhpcy4jcHJpdmF0ZUtleSA9IGhleGxpZnkocHJpdmF0ZUtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHJpdmF0ZSBrZXkuXG4gICAgICovXG4gICAgZ2V0IHByaXZhdGVLZXkoKSB7IHJldHVybiB0aGlzLiNwcml2YXRlS2V5OyB9XG4gICAgLyoqXG4gICAgICogIFRoZSB1bmNvbXByZXNzZWQgcHVibGljIGtleS5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBhbHdheXMgYmVnaW4gd2l0aCB0aGUgcHJlZml4IGBgMHgwNGBgIGFuZCBiZSAxMzJcbiAgICAgKiBjaGFyYWN0ZXJzIGxvbmcgKHRoZSBgYDB4YGAgcHJlZml4IGFuZCAxMzAgaGV4YWRlY2ltYWwgbmliYmxlcykuXG4gICAgICovXG4gICAgZ2V0IHB1YmxpY0tleSgpIHsgcmV0dXJuIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleSh0aGlzLiNwcml2YXRlS2V5KTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCBhbHdheXMgYmVnaW4gd2l0aCBlaXRoZXIgdGhlIHByZWZpeCBgYDB4MDJgYCBvciBgYDB4MDNgYFxuICAgICAqICBhbmQgYmUgNjggY2hhcmFjdGVycyBsb25nICh0aGUgYGAweGBgIHByZWZpeCBhbmQgMzMgaGV4YWRlY2ltYWxcbiAgICAgKiAgbmliYmxlcylcbiAgICAgKi9cbiAgICBnZXQgY29tcHJlc3NlZFB1YmxpY0tleSgpIHsgcmV0dXJuIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleSh0aGlzLiNwcml2YXRlS2V5LCB0cnVlKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHNpZ25hdHVyZSBvZiB0aGUgc2lnbmVkICUlZGlnZXN0JSUuXG4gICAgICovXG4gICAgc2lnbihkaWdlc3QpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aChkaWdlc3QpID09PSAzMiwgXCJpbnZhbGlkIGRpZ2VzdCBsZW5ndGhcIiwgXCJkaWdlc3RcIiwgZGlnZXN0KTtcbiAgICAgICAgY29uc3Qgc2lnID0gc2VjcDI1NmsxLnNpZ24oZ2V0Qnl0ZXNDb3B5KGRpZ2VzdCksIGdldEJ5dGVzQ29weSh0aGlzLiNwcml2YXRlS2V5KSwge1xuICAgICAgICAgICAgbG93UzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tKHtcbiAgICAgICAgICAgIHI6IHRvQmVIZXgoc2lnLnIsIDMyKSxcbiAgICAgICAgICAgIHM6IHRvQmVIZXgoc2lnLnMsIDMyKSxcbiAgICAgICAgICAgIHY6IChzaWcucmVjb3ZlcnkgPyAweDFjIDogMHgxYilcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBbW2xpbmstd2lraS1lY2RoXV0gc2hhcmVkIHNlY3JldCBiZXR3ZWVuIHRoaXNcbiAgICAgKiAgcHJpdmF0ZSBrZXkgYW5kIHRoZSAlJW90aGVyJSUga2V5LlxuICAgICAqXG4gICAgICogIFRoZSAlJW90aGVyJSUga2V5IG1heSBiZSBhbnkgdHlwZSBvZiBrZXksIGEgcmF3IHB1YmxpYyBrZXksXG4gICAgICogIGEgY29tcHJlc3NlZC91bmNvbXByZXNzZWQgcHViaWMga2V5IG9yIGFwcml2YXRlIGtleS5cbiAgICAgKlxuICAgICAqICBCZXN0IHByYWN0aWNlIGlzIHVzdWFsbHkgdG8gdXNlIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIG9uIHRoZVxuICAgICAqICByZXR1cm5lZCB2YWx1ZSBiZWZvcmUgdXNpbmcgaXQgYXMgYSBzeW1ldHJpYyBzZWNyZXQuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgc2lnbjEgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0LTFcIikpXG4gICAgICogICAgc2lnbjIgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0LTJcIikpXG4gICAgICpcbiAgICAgKiAgICAvLyBOb3RpY2UgdGhhdCBwcml2QS5jb21wdXRlU2hhcmVkU2VjcmV0KHB1YkIpLi4uXG4gICAgICogICAgc2lnbjEuY29tcHV0ZVNoYXJlZFNlY3JldChzaWduMi5wdWJsaWNLZXkpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gLi4uaXMgZXF1YWwgdG8gcHJpdkIuY29tcHV0ZVNoYXJlZFNlY3JldChwdWJBKS5cbiAgICAgKiAgICBzaWduMi5jb21wdXRlU2hhcmVkU2VjcmV0KHNpZ24xLnB1YmxpY0tleSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICovXG4gICAgY29tcHV0ZVNoYXJlZFNlY3JldChvdGhlcikge1xuICAgICAgICBjb25zdCBwdWJLZXkgPSBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkob3RoZXIpO1xuICAgICAgICByZXR1cm4gaGV4bGlmeShzZWNwMjU2azEuZ2V0U2hhcmVkU2VjcmV0KGdldEJ5dGVzQ29weSh0aGlzLiNwcml2YXRlS2V5KSwgZ2V0Qnl0ZXMocHViS2V5KSwgZmFsc2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIHB1YmxpYyBrZXkgZm9yICUla2V5JSUsIG9wdGlvbmFsbHkgJSVjb21wcmVzc2VkJSUuXG4gICAgICpcbiAgICAgKiAgVGhlICUla2V5JSUgbWF5IGJlIGFueSB0eXBlIG9mIGtleSwgYSByYXcgcHVibGljIGtleSwgYVxuICAgICAqICBjb21wcmVzc2VkL3VuY29tcHJlc3NlZCBwdWJsaWMga2V5IG9yIHByaXZhdGUga2V5LlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIHNpZ24gPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0XCIpKTtcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHJpdmF0ZUtleSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wcml2YXRlS2V5LCB0cnVlKVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHVibGljS2V5LCBmYWxzZSk7XG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgQ29tcHJlc3NlZCBhIHB1YmxpYyBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wdWJsaWNLZXksIHRydWUpO1xuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcHV0ZVB1YmxpY0tleShrZXksIGNvbXByZXNzZWQpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gZ2V0Qnl0ZXMoa2V5LCBcImtleVwiKTtcbiAgICAgICAgLy8gcHJpdmF0ZSBrZXlcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YktleSA9IHNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoYnl0ZXMsICEhY29tcHJlc3NlZCk7XG4gICAgICAgICAgICByZXR1cm4gaGV4bGlmeShwdWJLZXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJhdyBwdWJsaWMga2V5OyB1c2UgdW5jb21wcmVzc2VkIGtleSB3aXRoIDB4MDQgcHJlZml4XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgICAgICBjb25zdCBwdWIgPSBuZXcgVWludDhBcnJheSg2NSk7XG4gICAgICAgICAgICBwdWJbMF0gPSAweDA0O1xuICAgICAgICAgICAgcHViLnNldChieXRlcywgMSk7XG4gICAgICAgICAgICBieXRlcyA9IHB1YjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChieXRlcyk7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHBvaW50LnRvUmF3Qnl0ZXMoY29tcHJlc3NlZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcHVibGljIGtleSBmb3IgdGhlIHByaXZhdGUga2V5IHdoaWNoIHByb2R1Y2VkIHRoZVxuICAgICAqICAlJXNpZ25hdHVyZSUlIGZvciB0aGUgZ2l2ZW4gJSVkaWdlc3QlJS5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBrZXkgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0XCIpKVxuICAgICAqICAgIGRpZ2VzdCA9IGlkKFwiaGVsbG8gd29ybGRcIilcbiAgICAgKiAgICBzaWcgPSBrZXkuc2lnbihkaWdlc3QpXG4gICAgICpcbiAgICAgKiAgICAvLyBOb3RpY2UgdGhlIHNpZ25lciBwdWJsaWMga2V5Li4uXG4gICAgICogICAga2V5LnB1YmxpY0tleVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIC4uLmlzIGVxdWFsIHRvIHRoZSByZWNvdmVyZWQgcHVibGljIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkucmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZylcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZ25hdHVyZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKGRpZ2VzdCkgPT09IDMyLCBcImludmFsaWQgZGlnZXN0IGxlbmd0aFwiLCBcImRpZ2VzdFwiLCBkaWdlc3QpO1xuICAgICAgICBjb25zdCBzaWcgPSBTaWduYXR1cmUuZnJvbShzaWduYXR1cmUpO1xuICAgICAgICBsZXQgc2VjcFNpZyA9IHNlY3AyNTZrMS5TaWduYXR1cmUuZnJvbUNvbXBhY3QoZ2V0Qnl0ZXNDb3B5KGNvbmNhdChbc2lnLnIsIHNpZy5zXSkpKTtcbiAgICAgICAgc2VjcFNpZyA9IHNlY3BTaWcuYWRkUmVjb3ZlcnlCaXQoc2lnLnlQYXJpdHkpO1xuICAgICAgICBjb25zdCBwdWJLZXkgPSBzZWNwU2lnLnJlY292ZXJQdWJsaWNLZXkoZ2V0Qnl0ZXNDb3B5KGRpZ2VzdCkpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwdWJLZXkgIT0gbnVsbCwgXCJpbnZhbGlkIHNpZ25hdXRyZSBmb3IgZGlnZXN0XCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwdWJLZXkudG9IZXgoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcG9pbnQgcmVzdWx0aW5nIGZyb20gYWRkaW5nIHRoZSBlbGxpcGljIGN1cnZlIHBvaW50c1xuICAgICAqICAlJXAwJSUgYW5kICUlcDElJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBhIGNvbW1vbiBmdW5jdGlvbiBtb3N0IGRldmVsb3BlcnMgc2hvdWxkIHJlcXVpcmUsIGJ1dFxuICAgICAqICBjYW4gYmUgdXNlZnVsIGZvciBjZXJ0YWluIHByaXZhY3ktc3BlY2lmaWMgdGVjaG5pcXVlcy5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgaXQgaXMgdXNlZCBieSBbW0hETm9kZVdhbGxldF1dIHRvIGNvbXB1dGUgY2hpbGRcbiAgICAgKiAgYWRkcmVzc2VzIGZyb20gcGFyZW50IHB1YmxpYyBrZXlzIGFuZCBjaGFpbiBjb2Rlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUG9pbnRzKHAwLCBwMSwgY29tcHJlc3NlZCkge1xuICAgICAgICBjb25zdCBwdWIwID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShwMCkuc3Vic3RyaW5nKDIpKTtcbiAgICAgICAgY29uc3QgcHViMSA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkocDEpLnN1YnN0cmluZygyKSk7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwdWIwLmFkZChwdWIxKS50b0hleCghIWNvbXByZXNzZWQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25pbmcta2V5LmpzLm1hcCIsImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzM2ID0gQmlnSW50KDM2KTtcbmZ1bmN0aW9uIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgLy8gICAgaWYgKCFpc0hleFN0cmluZyhhZGRyZXNzLCAyMCkpIHtcbiAgICAvLyAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgLy8gICAgfVxuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY2hhcnMgPSBhZGRyZXNzLnN1YnN0cmluZygyKS5zcGxpdChcIlwiKTtcbiAgICBjb25zdCBleHBhbmRlZCA9IG5ldyBVaW50OEFycmF5KDQwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpKyspIHtcbiAgICAgICAgZXhwYW5kZWRbaV0gPSBjaGFyc1tpXS5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZWQgPSBnZXRCeXRlcyhrZWNjYWsyNTYoZXhwYW5kZWQpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSA+PiA0KSA+PSA4KSB7XG4gICAgICAgICAgICBjaGFyc1tpXSA9IGNoYXJzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSAmIDB4MGYpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2kgKyAxXSA9IGNoYXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBjaGFycy5qb2luKFwiXCIpO1xufVxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcm5hdGlvbmFsX0JhbmtfQWNjb3VudF9OdW1iZXJcbi8vIENyZWF0ZSBsb29rdXAgdGFibGVcbmNvbnN0IGliYW5Mb29rdXAgPSB7fTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nKGkpXSA9IFN0cmluZyhpKTtcbn1cbmZvciAobGV0IGkgPSAwOyBpIDwgMjY7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIGkpXSA9IFN0cmluZygxMCArIGkpO1xufVxuLy8gSG93IG1hbnkgZGVjaW1hbCBkaWdpdHMgY2FuIHdlIHByb2Nlc3M/IChmb3IgNjQtYml0IGZsb2F0LCB0aGlzIGlzIDE1KVxuLy8gaS5lLiBNYXRoLmZsb29yKE1hdGgubG9nMTAoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKTtcbmNvbnN0IHNhZmVEaWdpdHMgPSAxNTtcbmZ1bmN0aW9uIGliYW5DaGVja3N1bShhZGRyZXNzKSB7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9VcHBlckNhc2UoKTtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy5zdWJzdHJpbmcoNCkgKyBhZGRyZXNzLnN1YnN0cmluZygwLCAyKSArIFwiMDBcIjtcbiAgICBsZXQgZXhwYW5kZWQgPSBhZGRyZXNzLnNwbGl0KFwiXCIpLm1hcCgoYykgPT4geyByZXR1cm4gaWJhbkxvb2t1cFtjXTsgfSkuam9pbihcIlwiKTtcbiAgICAvLyBKYXZhc2NyaXB0IGNhbiBoYW5kbGUgaW50ZWdlcnMgc2FmZWx5IHVwIHRvIDE1IChkZWNpbWFsKSBkaWdpdHNcbiAgICB3aGlsZSAoZXhwYW5kZWQubGVuZ3RoID49IHNhZmVEaWdpdHMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gZXhwYW5kZWQuc3Vic3RyaW5nKDAsIHNhZmVEaWdpdHMpO1xuICAgICAgICBleHBhbmRlZCA9IHBhcnNlSW50KGJsb2NrLCAxMCkgJSA5NyArIGV4cGFuZGVkLnN1YnN0cmluZyhibG9jay5sZW5ndGgpO1xuICAgIH1cbiAgICBsZXQgY2hlY2tzdW0gPSBTdHJpbmcoOTggLSAocGFyc2VJbnQoZXhwYW5kZWQsIDEwKSAlIDk3KSk7XG4gICAgd2hpbGUgKGNoZWNrc3VtLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgY2hlY2tzdW0gPSBcIjBcIiArIGNoZWNrc3VtO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tzdW07XG59XG47XG5jb25zdCBCYXNlMzYgPSAoZnVuY3Rpb24gKCkge1xuICAgIDtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM2OyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIltpXTtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBCaWdJbnQoaSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59KSgpO1xuZnVuY3Rpb24gZnJvbUJhc2UzNih2YWx1ZSkge1xuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgcmVzdWx0ID0gQk5fMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCAqIEJOXzM2ICsgQmFzZTM2W3ZhbHVlW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBub3JtYWxpemVkIGFuZCBjaGVja3N1bWVkIGFkZHJlc3MgZm9yICUlYWRkcmVzcyUlLlxuICogIFRoaXMgYWNjZXB0cyBub24tY2hlY2tzdW0gYWRkcmVzc2VzLCBjaGVja3N1bSBhZGRyZXNzZXMgYW5kXG4gKiAgW1tnZXRJY2FwQWRkcmVzc11dIGZvcm1hdHMuXG4gKlxuICogIFRoZSBjaGVja3N1bSBpbiBFdGhlcmV1bSB1c2VzIHRoZSBjYXBpdGFsaXphdGlvbiAodXBwZXItY2FzZVxuICogIHZzIGxvd2VyLWNhc2UpIG9mIHRoZSBjaGFyYWN0ZXJzIHdpdGhpbiBhbiBhZGRyZXNzIHRvIGVuY29kZVxuICogIGl0cyBjaGVja3N1bSwgd2hpY2ggb2ZmZXJzLCBvbiBhdmVyYWdlLCBhIGNoZWNrc3VtIG9mIDE1LWJpdHMuXG4gKlxuICogIElmICUlYWRkcmVzcyUlIGNvbnRhaW5zIGJvdGggdXBwZXItY2FzZSBhbmQgbG93ZXItY2FzZSwgaXQgaXNcbiAqICBhc3N1bWVkIHRvIGFscmVhZHkgYmUgYSBjaGVja3N1bSBhZGRyZXNzIGFuZCBpdHMgY2hlY2tzdW0gaXNcbiAqICB2YWxpZGF0ZWQsIGFuZCBpZiB0aGUgYWRkcmVzcyBmYWlscyBpdHMgZXhwZWN0ZWQgY2hlY2tzdW0gYW5cbiAqICBlcnJvciBpcyB0aHJvd24uXG4gKlxuICogIElmIHlvdSB3aXNoIHRoZSBjaGVja3N1bSBvZiAlJWFkZHJlc3MlJSB0byBiZSBpZ25vcmUsIGl0IHNob3VsZFxuICogIGJlIGNvbnZlcnRlZCB0byBsb3dlci1jYXNlIChpLmUuIGBgLnRvTG93ZXJjYXNlKClgYCkgYmVmb3JlXG4gKiAgYmVpbmcgcGFzc2VkIGluLiBUaGlzIHNob3VsZCBiZSBhIHZlcnkgcmFyZSBzaXR1YXRpb24gdGhvdWdoLFxuICogIHRoYXQgeW91IHdpc2ggdG8gYnlwYXNzIHRoZSBzYWZlZ2F1cmRzIGluIHBsYWNlIHRvIHByb3RlY3RcbiAqICBhZ2FpbnN0IGFuIGFkZHJlc3MgdGhhdCBoYXMgYmVlbiBpbmNvcnJlY3RseSBjb3BpZWQgZnJvbSBhbm90aGVyXG4gKiAgc291cmNlLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIEFkZHMgdGhlIGNoZWNrc3VtICh2aWEgdXBwZXItY2FzaW5nIHNwZWNpZmljIGxldHRlcnMpXG4gKiAgICBnZXRBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJkNDMyODAzMDEyNjQ1YWMxMzZkZGQ2NGRiYTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gQ29udmVydHMgSUNBUCBhZGRyZXNzIGFuZCBhZGRzIGNoZWNrc3VtXG4gKiAgICBnZXRBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzZcIik7XG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFuIGFkZHJlc3MgY29udGFpbnMgbWl4ZWQgY2FzZSxcbiAqICAgIC8vIGJ1dCB0aGUgY2hlY2tzdW0gZmFpbHNcbiAqICAgIGdldEFkZHJlc3MoXCIweDhCYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChhZGRyZXNzKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXXs0MH0kLykpIHtcbiAgICAgICAgLy8gTWlzc2luZyB0aGUgMHggcHJlZml4XG4gICAgICAgIGlmICghYWRkcmVzcy5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBcIjB4XCIgKyBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgLy8gSXQgaXMgYSBjaGVja3N1bW1lZCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWFkZHJlc3MubWF0Y2goLyhbQS1GXS4qW2EtZl0pfChbYS1mXS4qW0EtRl0pLykgfHwgcmVzdWx0ID09PSBhZGRyZXNzLCBcImJhZCBhZGRyZXNzIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gTWF5YmUgSUNBUD8gKHdlIG9ubHkgc3VwcG9ydCBkaXJlY3QgbW9kZSlcbiAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXlhFWzAtOV17Mn1bMC05QS1aYS16XXszMCwzMX0kLykpIHtcbiAgICAgICAgLy8gSXQgaXMgYW4gSUNBUCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWRkcmVzcy5zdWJzdHJpbmcoMiwgNCkgPT09IGliYW5DaGVja3N1bShhZGRyZXNzKSwgXCJiYWQgaWNhcCBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBmcm9tQmFzZTM2KGFkZHJlc3Muc3Vic3RyaW5nKDQpKS50b1N0cmluZygxNik7XG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgNDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRDaGVja3N1bUFkZHJlc3MoXCIweFwiICsgcmVzdWx0KTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbn1cbi8qKlxuICogIFRoZSBbSUNBUCBBZGRyZXNzIGZvcm1hdF0obGluay1pY2FwKSBmb3JtYXQgaXMgYW4gZWFybHkgY2hlY2tzdW1cbiAqICBmb3JtYXQgd2hpY2ggYXR0ZW1wdHMgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBiYW5raW5nXG4gKiAgaW5kdXN0cnkgW0lCQU4gZm9ybWF0XShsaW5rLXdpa2ktaWJhbikgZm9yIGJhbmsgYWNjb3VudHMuXG4gKlxuICogIEl0IGlzIG5vIGxvbmdlciBjb21tb24gb3IgYSByZWNvbW1lbmRlZCBmb3JtYXQuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgZ2V0SWNhcEFkZHJlc3MoXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIik7XG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgZ2V0SWNhcEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIElDQVAgY2hlY2tzdW0gaXMgd3JvbmdcbiAqICAgIGdldEljYXBBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzdcIik7XG4gKiAgICAvL19lcnJvcjpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEljYXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAvL2xldCBiYXNlMzYgPSBfYmFzZTE2VG8zNihnZXRBZGRyZXNzKGFkZHJlc3MpLnN1YnN0cmluZygyKSkudG9VcHBlckNhc2UoKTtcbiAgICBsZXQgYmFzZTM2ID0gQmlnSW50KGdldEFkZHJlc3MoYWRkcmVzcykpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHdoaWxlIChiYXNlMzYubGVuZ3RoIDwgMzApIHtcbiAgICAgICAgYmFzZTM2ID0gXCIwXCIgKyBiYXNlMzY7XG4gICAgfVxuICAgIHJldHVybiBcIlhFXCIgKyBpYmFuQ2hlY2tzdW0oXCJYRTAwXCIgKyBiYXNlMzYpICsgYmFzZTM2O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiLCJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRhdGFTbGljZSwgZ2V0QmlnSW50LCBnZXRCeXRlcywgZW5jb2RlUmxwLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuL2FkZHJlc3MuanNcIjtcbi8vIGh0dHA6Ly9ldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNzYwL2hvdy1pcy10aGUtYWRkcmVzcy1vZi1hbi1ldGhlcmV1bS1jb250cmFjdC1jb21wdXRlZFxuLyoqXG4gKiAgUmV0dXJucyB0aGUgYWRkcmVzcyB0aGF0IHdvdWxkIHJlc3VsdCBmcm9tIGEgYGBDUkVBVEVgYCBmb3IgJSV0eCUlLlxuICpcbiAqICBUaGlzIGNhbiBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGFkZHJlc3MgYSBjb250cmFjdCB3aWxsIGJlXG4gKiAgZGVwbG95ZWQgdG8gYnkgYW4gRU9BIHdoZW4gc2VuZGluZyBhIGRlcGxveW1lbnQgdHJhbnNhY3Rpb24gKGkuZS5cbiAqICB3aGVuIHRoZSBgYHRvYGAgYWRkcmVzcyBpcyBgYG51bGxgYCkuXG4gKlxuICogIFRoaXMgY2FuIGFsc28gYmUgdXNlZCB0byBjb21wdXRlIHRoZSBhZGRyZXNzIGEgY29udHJhY3Qgd2lsbCBiZVxuICogIGRlcGxveWVkIHRvIGJ5IGEgY29udHJhY3QsIGJ5IHVzaW5nIHRoZSBjb250cmFjdCdzIGFkZHJlc3MgYXMgdGhlXG4gKiAgYGB0b2BgIGFuZCB0aGUgY29udHJhY3QncyBub25jZS5cbiAqXG4gKiAgQGV4YW1wbGVcbiAqICAgIGZyb20gPSBcIjB4OGJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiO1xuICogICAgbm9uY2UgPSA1O1xuICpcbiAqICAgIGdldENyZWF0ZUFkZHJlc3MoeyBmcm9tLCBub25jZSB9KTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENyZWF0ZUFkZHJlc3ModHgpIHtcbiAgICBjb25zdCBmcm9tID0gZ2V0QWRkcmVzcyh0eC5mcm9tKTtcbiAgICBjb25zdCBub25jZSA9IGdldEJpZ0ludCh0eC5ub25jZSwgXCJ0eC5ub25jZVwiKTtcbiAgICBsZXQgbm9uY2VIZXggPSBub25jZS50b1N0cmluZygxNik7XG4gICAgaWYgKG5vbmNlSGV4ID09PSBcIjBcIikge1xuICAgICAgICBub25jZUhleCA9IFwiMHhcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9uY2VIZXgubGVuZ3RoICUgMikge1xuICAgICAgICBub25jZUhleCA9IFwiMHgwXCIgKyBub25jZUhleDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vbmNlSGV4ID0gXCIweFwiICsgbm9uY2VIZXg7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZGRyZXNzKGRhdGFTbGljZShrZWNjYWsyNTYoZW5jb2RlUmxwKFtmcm9tLCBub25jZUhleF0pKSwgMTIpKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIGFkZHJlc3MgdGhhdCB3b3VsZCByZXN1bHQgZnJvbSBhIGBgQ1JFQVRFMmBgIG9wZXJhdGlvblxuICogIHdpdGggdGhlIGdpdmVuICUlZnJvbSUlLCAlJXNhbHQlJSBhbmQgJSVpbml0Q29kZUhhc2glJS5cbiAqXG4gKiAgVG8gY29tcHV0ZSB0aGUgJSVpbml0Q29kZUhhc2glJSBmcm9tIGEgY29udHJhY3QncyBpbml0IGNvZGUsIHVzZVxuICogIHRoZSBbW2tlY2NhazI1Nl1dIGZ1bmN0aW9uLlxuICpcbiAqICBGb3IgYSBxdWljayBvdmVydmlldyBhbmQgZXhhbXBsZSBvZiBgYENSRUFURTJgYCwgc2VlIFtbbGluay1yaWNtb28td2lzcHNdXS5cbiAqXG4gKiAgQGV4YW1wbGVcbiAqICAgIC8vIFRoZSBhZGRyZXNzIG9mIHRoZSBjb250cmFjdFxuICogICAgZnJvbSA9IFwiMHg4YmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCJcbiAqXG4gKiAgICAvLyBUaGUgc2FsdFxuICogICAgc2FsdCA9IGlkKFwiSGVsbG9Xb3JsZFwiKVxuICpcbiAqICAgIC8vIFRoZSBoYXNoIG9mIHRoZSBpbml0Q29kZVxuICogICAgaW5pdENvZGUgPSBcIjB4NjM5NDE5OGRmMTYwMDA1MjYxMDNmZjYwMjA2MDA0NjAxYzMzNWFmYTYwNDA1MTYwNjBmM1wiO1xuICogICAgaW5pdENvZGVIYXNoID0ga2VjY2FrMjU2KGluaXRDb2RlKVxuICpcbiAqICAgIGdldENyZWF0ZTJBZGRyZXNzKGZyb20sIHNhbHQsIGluaXRDb2RlSGFzaClcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENyZWF0ZTJBZGRyZXNzKF9mcm9tLCBfc2FsdCwgX2luaXRDb2RlSGFzaCkge1xuICAgIGNvbnN0IGZyb20gPSBnZXRBZGRyZXNzKF9mcm9tKTtcbiAgICBjb25zdCBzYWx0ID0gZ2V0Qnl0ZXMoX3NhbHQsIFwic2FsdFwiKTtcbiAgICBjb25zdCBpbml0Q29kZUhhc2ggPSBnZXRCeXRlcyhfaW5pdENvZGVIYXNoLCBcImluaXRDb2RlSGFzaFwiKTtcbiAgICBhc3NlcnRBcmd1bWVudChzYWx0Lmxlbmd0aCA9PT0gMzIsIFwic2FsdCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwic2FsdFwiLCBfc2FsdCk7XG4gICAgYXNzZXJ0QXJndW1lbnQoaW5pdENvZGVIYXNoLmxlbmd0aCA9PT0gMzIsIFwiaW5pdENvZGVIYXNoIG11c3QgYmUgMzIgYnl0ZXNcIiwgXCJpbml0Q29kZUhhc2hcIiwgX2luaXRDb2RlSGFzaCk7XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoZGF0YVNsaWNlKGtlY2NhazI1Nihjb25jYXQoW1wiMHhmZlwiLCBmcm9tLCBzYWx0LCBpbml0Q29kZUhhc2hdKSksIDEyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cmFjdC1hZGRyZXNzLmpzLm1hcCIsImltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIG9iamVjdCB3aGljaCBpbXBsZW1lbnRzIHRoZVxuICogIFtbQWRkcmVzc2FibGVdXSBpbnRlcmZhY2UuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gV2FsbGV0cyBhbmQgQWJzdHJhY3RTaWduZXIgc3ViLWNsYXNzZXNcbiAqICAgIGlzQWRkcmVzc2FibGUoV2FsbGV0LmNyZWF0ZVJhbmRvbSgpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIENvbnRyYWN0c1xuICogICAgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoXCJkYWkudG9rZW5zLmV0aGVycy5ldGhcIiwgWyBdLCBwcm92aWRlcilcbiAqICAgIGlzQWRkcmVzc2FibGUoY29udHJhY3QpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FkZHJlc3NhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmdldEFkZHJlc3MpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIGFkZHJlc3MuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gVmFsaWQgYWRkcmVzc1xuICogICAgaXNBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVmFsaWQgSUNBUCBhZGRyZXNzXG4gKiAgICBpc0FkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEludmFsaWQgY2hlY2tzdW1cbiAqICAgIGlzQWRkcmVzcyhcIjB4OEJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQmE3MlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEludmFsaWQgSUNBUCBjaGVja3N1bVxuICogICAgaXNBZGRyZXNzKFwiMHg4QmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gTm90IGFuIGFkZHJlc3MgKGFuIEVOUyBuYW1lIHJlcXVpcmVzIGEgcHJvdmlkZWQgYW5kIGFuXG4gKiAgICAvLyBhc3luY2hyb25vdXMgQVBJIHRvIGFjY2VzcylcbiAqICAgIGlzQWRkcmVzcyhcInJpY21vby5ldGhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWRkcmVzcyh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGdldEFkZHJlc3ModmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5hc3luYyBmdW5jdGlvbiBjaGVja0FkZHJlc3ModGFyZ2V0LCBwcm9taXNlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcbiAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0ID09PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgKHRhcmdldCkgIT09IFwic3RyaW5nXCIsIFwidW5jb25maWd1cmVkIG5hbWVcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7IHZhbHVlOiB0YXJnZXQgfSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgQWRkcmVzc0xpa2UgdmFsdWU7IGRpZCBub3QgcmVzb2x2ZSB0byBhIHZhbHVlIGFkZHJlc3NcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3MocmVzdWx0KTtcbn1cbi8qKlxuICogIFJlc29sdmVzIHRvIGFuIGFkZHJlc3MgZm9yIHRoZSAlJXRhcmdldCUlLCB3aGljaCBtYXkgYmUgYW55XG4gKiAgc3VwcG9ydGVkIGFkZHJlc3MgdHlwZSwgYW4gW1tBZGRyZXNzYWJsZV1dIG9yIGEgUHJvbWlzZSB3aGljaFxuICogIHJlc29sdmVzIHRvIGFuIGFkZHJlc3MuXG4gKlxuICogIElmIGFuIEVOUyBuYW1lIGlzIHByb3ZpZGVkLCBidXQgdGhhdCBuYW1lIGhhcyBub3QgYmVlbiBjb3JyZWN0bHlcbiAqICBjb25maWd1cmVkIGEgW1tVbmNvbmZpZ3VyZWROYW1lRXJyb3JdXSBpcyB0aHJvd24uXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgYWRkciA9IFwiMHg2QjE3NTQ3NEU4OTA5NEM0NERhOThiOTU0RWVkZUFDNDk1MjcxZDBGXCJcbiAqXG4gKiAgICAvLyBBZGRyZXNzZXMgYXJlIHJldHVybiBzeW5jaHJvbm91c2x5XG4gKiAgICByZXNvbHZlQWRkcmVzcyhhZGRyLCBwcm92aWRlcilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBBZGRyZXNzIHByb21pc2VzIGFyZSByZXNvbHZlZCBhc3luY2hyb25vdXNseVxuICogICAgcmVzb2x2ZUFkZHJlc3MoUHJvbWlzZS5yZXNvbHZlKGFkZHIpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEVOUyBuYW1lcyBhcmUgcmVzb2x2ZWQgYXN5bmNocm9ub3VzbHlcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwiZGFpLnRva2Vucy5ldGhlcnMuZXRoXCIsIHByb3ZpZGVyKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEFkZHJlc3NhYmxlIG9iamVjdHMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XG4gKiAgICBjb250cmFjdCA9IG5ldyBDb250cmFjdChhZGRyLCBbIF0pXG4gKiAgICByZXNvbHZlQWRkcmVzcyhjb250cmFjdCwgcHJvdmlkZXIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVW5jb25maWd1cmVkIEVOUyBuYW1lcyByZWplY3RcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIiwgcHJvdmlkZXIpXG4gKiAgICAvL19lcnJvcjpcbiAqXG4gKiAgICAvLyBFTlMgbmFtZXMgcmVxdWlyZSBhIE5hbWVSZXNvbHZlciBvYmplY3QgcGFzc2VkIGluXG4gKiAgICAvLyAobm90aWNlIHRoZSBwcm92aWRlciB3YXMgb21pdHRlZClcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUFkZHJlc3ModGFyZ2V0LCByZXNvbHZlcikge1xuICAgIGlmICh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHRhcmdldC5tYXRjaCgvXjB4WzAtOWEtZl17NDB9JC9pKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQocmVzb2x2ZXIgIT0gbnVsbCwgXCJFTlMgcmVzb2x1dGlvbiByZXF1aXJlcyBhIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lXCIgfSk7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCByZXNvbHZlci5yZXNvbHZlTmFtZSh0YXJnZXQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBZGRyZXNzYWJsZSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCB0YXJnZXQuZ2V0QWRkcmVzcygpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGFyZ2V0ICYmIHR5cGVvZiAodGFyZ2V0LnRoZW4pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHRhcmdldCk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIGFkZHJlc3NhYmxlIHZhbHVlXCIsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3MuanMubWFwIiwiLyoqXG4gKiAgQSBUeXBlZCBvYmplY3QgYWxsb3dzIGEgdmFsdWUgdG8gaGF2ZSBpdHMgdHlwZSBleHBsaWNpdGx5XG4gKiAgc3BlY2lmaWVkLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaW4gU29saWRpdHksIHRoZSB2YWx1ZSBgYDQ1YGAgY291bGQgcmVwcmVzZW50IGFcbiAqICBgYHVpbnQ4YGAgb3IgYSBgYHVpbnQyNTZgYC4gVGhlIHZhbHVlIGBgMHgxMjM0YGAgY291bGQgcmVwcmVzZW50XG4gKiAgYSBgYGJ5dGVzMmBgIG9yIGBgYnl0ZXNgYC5cbiAqXG4gKiAgU2luY2UgSmF2YVNjcmlwdCBoYXMgbm8gbWVhbmluZ2Z1bCB3YXkgdG8gZXhwbGljaXRseSBpbmZvcm0gYW55XG4gKiAgQVBJcyB3aGljaCB3aGF0IHRoZSB0eXBlIGlzLCB0aGlzIGFsbG93cyB0cmFuc3BhcmVudCBpbnRlcm9wZXJhdGlvblxuICogIHdpdGggU29sZGl0eS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvYWJpOlR5cGVkIFZhbHVlc1xuICovXG5pbXBvcnQgeyBhc3NlcnRQcml2YXRlLCBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBfZ2F1cmQgPSB7fTtcbmZ1bmN0aW9uIG4odmFsdWUsIHdpZHRoKSB7XG4gICAgbGV0IHNpZ25lZCA9IGZhbHNlO1xuICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgd2lkdGggKj0gLTE7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBDaGVjayByYW5nZSBpcyB2YWxpZCBmb3IgdmFsdWVcbiAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgYCR7c2lnbmVkID8gXCJcIiA6IFwidVwifWludCR7d2lkdGh9YCwgdmFsdWUsIHsgc2lnbmVkLCB3aWR0aCB9KTtcbn1cbmZ1bmN0aW9uIGIodmFsdWUsIHNpemUpIHtcbiAgICAvLyBAVE9ETzogQ2hlY2sgcmFuZ2UgaXMgdmFsaWQgZm9yIHZhbHVlXG4gICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIGBieXRlcyR7KHNpemUpID8gc2l6ZSA6IFwiXCJ9YCwgdmFsdWUsIHsgc2l6ZSB9KTtcbn1cbmNvbnN0IF90eXBlZFN5bWJvbCA9IFN5bWJvbC5mb3IoXCJfZXRoZXJzX3R5cGVkXCIpO1xuLyoqXG4gKiAgVGhlICoqVHlwZWQqKiBjbGFzcyB0byB3cmFwIHZhbHVlcyBwcm92aWRpbmcgZXhwbGljaXQgdHlwZSBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFR5cGVkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGUsIGFzIGEgU29saWRpdHktY29tcGF0aWJsZSB0eXBlLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgdmFsdWUuXG4gICAgICovXG4gICAgdmFsdWU7XG4gICAgI29wdGlvbnM7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIF90eXBlZFN5bWJvbDtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2F1cmQsIHR5cGUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFByaXZhdGUoX2dhdXJkLCBnYXVyZCwgXCJUeXBlZFwiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IF90eXBlZFN5bWJvbCwgdHlwZSwgdmFsdWUgfSk7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAvLyBDaGVjayB0aGUgdmFsdWUgaXMgdmFsaWRcbiAgICAgICAgdGhpcy5mb3JtYXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEZvcm1hdCB0aGUgdHlwZSBhcyBhIEh1bWFuLVJlYWRhYmxlIHR5cGUuXG4gICAgICovXG4gICAgZm9ybWF0KCkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwiZHluYW1pY0FycmF5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIGB0dXBsZSgke3RoaXMudmFsdWUubWFwKCh2KSA9PiB2LmZvcm1hdCgpKS5qb2luKFwiLFwiKX0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgYnkgdGhpcyB0eXBlLlxuICAgICAqL1xuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWluaW11bSB2YWx1ZSBmb3IgbnVtZXJpYyB0eXBlcy5cbiAgICAgKi9cbiAgICBtaW5WYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB2YWx1ZSBmb3IgbnVtZXJpYyB0eXBlcy5cbiAgICAgKi9cbiAgICBtYXhWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaXMgdGhpcyBpcyBhIFtbVHlwZWRCaWdJbnRdXS5cbiAgICAgKi9cbiAgICBpc0JpZ0ludCgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMudHlwZS5tYXRjaCgvXnU/aW50WzAtOV0rJC8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpcyB0aGlzIGlzIGEgW1tUeXBlZERhdGFdXS5cbiAgICAgKi9cbiAgICBpc0RhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuc3RhcnRzV2l0aChcImJ5dGVzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlzIHRoaXMgaXMgYSBbW1R5cGVkU3RyaW5nXV0uXG4gICAgICovXG4gICAgaXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSBcInN0cmluZ1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHR1cGxlIG5hbWUsIGlmIHRoaXMgaXMgYSB0dXBsZS4gVGhyb3dzIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgdHVwbGVOYW1lKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIm5vdCBhIHR1cGxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNvcHRpb25zO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhpcyB0eXBlIGFzIGFuIGFycmF5XG4gICAgLy8gLSBgbnVsbGAgaW5kaWNhdGVzIHRoZSBsZW5ndGggaXMgdW5mb3JjZWQsIGl0IGNvdWxkIGJlIGR5bmFtaWNcbiAgICAvLyAtIGAtMWAgaW5kaWNhdGVzIHRoZSBsZW5ndGggaXMgZHluYW1pY1xuICAgIC8vIC0gYW55IG90aGVyIHZhbHVlIGluZGljYXRlcyBpdCBpcyBhIHN0YXRpYyBhcnJheSBhbmQgaXMgaXRzIGxlbmd0aFxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IHR5cGUgb3IgYGAtMWBgIGlmIGl0IGlzIGR5bmFtaWMuXG4gICAgICpcbiAgICAgKiAgVGhyb3dzIGlmIHRoZSB0eXBlIGlzIG5vdCBhbiBhcnJheS5cbiAgICAgKi9cbiAgICBnZXQgYXJyYXlMZW5ndGgoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI29wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipUeXBlZCoqIG9mICUldHlwZSUlIHdpdGggdGhlICUldmFsdWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0eXBlLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgdHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDgodikgeyByZXR1cm4gbih2LCA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2KHYpIHsgcmV0dXJuIG4odiwgMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQodikgeyByZXR1cm4gbih2LCAyNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQzMih2KSB7IHJldHVybiBuKHYsIDMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDQwKHYpIHsgcmV0dXJuIG4odiwgNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NDgodikgeyByZXR1cm4gbih2LCA0OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ1Nih2KSB7IHJldHVybiBuKHYsIDU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDY0KHYpIHsgcmV0dXJuIG4odiwgNjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ3MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NzIodikgeyByZXR1cm4gbih2LCA3Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDgwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ4MCh2KSB7IHJldHVybiBuKHYsIDgwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50ODhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDg4KHYpIHsgcmV0dXJuIG4odiwgODgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ5NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50OTYodikgeyByZXR1cm4gbih2LCA5Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEwNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTA0KHYpIHsgcmV0dXJuIG4odiwgMTA0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTEyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMTIodikgeyByZXR1cm4gbih2LCAxMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDEyMCh2KSB7IHJldHVybiBuKHYsIDEyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEyOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTI4KHYpIHsgcmV0dXJuIG4odiwgMTI4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMzYodikgeyByZXR1cm4gbih2LCAxMzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE0NCh2KSB7IHJldHVybiBuKHYsIDE0NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE1MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTUyKHYpIHsgcmV0dXJuIG4odiwgMTUyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTYwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNjAodikgeyByZXR1cm4gbih2LCAxNjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2OCh2KSB7IHJldHVybiBuKHYsIDE2OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE3NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTc2KHYpIHsgcmV0dXJuIG4odiwgMTc2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTg0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxODQodikgeyByZXR1cm4gbih2LCAxODQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxOTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE5Mih2KSB7IHJldHVybiBuKHYsIDE5Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIwMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjAwKHYpIHsgcmV0dXJuIG4odiwgMjAwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjA4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMDgodikgeyByZXR1cm4gbih2LCAyMDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIxNih2KSB7IHJldHVybiBuKHYsIDIxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjI0KHYpIHsgcmV0dXJuIG4odiwgMjI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMzIodikgeyByZXR1cm4gbih2LCAyMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDI0MCh2KSB7IHJldHVybiBuKHYsIDI0MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQ4KHYpIHsgcmV0dXJuIG4odiwgMjQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNTYodikgeyByZXR1cm4gbih2LCAyNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludCh2KSB7IHJldHVybiBuKHYsIDI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ4KHYpIHsgcmV0dXJuIG4odiwgLTgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2KHYpIHsgcmV0dXJuIG4odiwgLTE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNCh2KSB7IHJldHVybiBuKHYsIC0yNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MzIodikgeyByZXR1cm4gbih2LCAtMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDQwKHYpIHsgcmV0dXJuIG4odiwgLTQwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ0OCh2KSB7IHJldHVybiBuKHYsIC00OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NTYodikgeyByZXR1cm4gbih2LCAtNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDY0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDY0KHYpIHsgcmV0dXJuIG4odiwgLTY0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ3MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ3Mih2KSB7IHJldHVybiBuKHYsIC03Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50ODBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ODAodikgeyByZXR1cm4gbih2LCAtODApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDg4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDg4KHYpIHsgcmV0dXJuIG4odiwgLTg4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ5NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ5Nih2KSB7IHJldHVybiBuKHYsIC05Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTA0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEwNCh2KSB7IHJldHVybiBuKHYsIC0xMDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDExMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMTIodikgeyByZXR1cm4gbih2LCAtMTEyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTIwKHYpIHsgcmV0dXJuIG4odiwgLTEyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTI4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEyOCh2KSB7IHJldHVybiBuKHYsIC0xMjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDEzNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMzYodikgeyByZXR1cm4gbih2LCAtMTM2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTQ0KHYpIHsgcmV0dXJuIG4odiwgLTE0NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTUyKHYpIHsgcmV0dXJuIG4odiwgLTE1Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTYwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2MCh2KSB7IHJldHVybiBuKHYsIC0xNjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNjgodikgeyByZXR1cm4gbih2LCAtMTY4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNzZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTc2KHYpIHsgcmV0dXJuIG4odiwgLTE3Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTg0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE4NCh2KSB7IHJldHVybiBuKHYsIC0xODQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDkyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE5Mih2KSB7IHJldHVybiBuKHYsIC0xOTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIwMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMDAodikgeyByZXR1cm4gbih2LCAtMjAwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjA4KHYpIHsgcmV0dXJuIG4odiwgLTIwOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIxNih2KSB7IHJldHVybiBuKHYsIC0yMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMjQodikgeyByZXR1cm4gbih2LCAtMjI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjMyKHYpIHsgcmV0dXJuIG4odiwgLTIzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI0MCh2KSB7IHJldHVybiBuKHYsIC0yNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNDgodikgeyByZXR1cm4gbih2LCAtMjQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjU2KHYpIHsgcmV0dXJuIG4odiwgLTI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludCh2KSB7IHJldHVybiBuKHYsIC0yNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEodikgeyByZXR1cm4gYih2LCAxKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyKHYpIHsgcmV0dXJuIGIodiwgMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMyh2KSB7IHJldHVybiBiKHYsIDMpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczQodikgeyByZXR1cm4gYih2LCA0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczVgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM1KHYpIHsgcmV0dXJuIGIodiwgNSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNih2KSB7IHJldHVybiBiKHYsIDYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzN2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczcodikgeyByZXR1cm4gYih2LCA3KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM4KHYpIHsgcmV0dXJuIGIodiwgOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM5YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzOSh2KSB7IHJldHVybiBiKHYsIDkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMCh2KSB7IHJldHVybiBiKHYsIDEwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczExYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTEodikgeyByZXR1cm4gYih2LCAxMSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEyKHYpIHsgcmV0dXJuIGIodiwgMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMyh2KSB7IHJldHVybiBiKHYsIDEzKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTQodikgeyByZXR1cm4gYih2LCAxNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxNWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE1KHYpIHsgcmV0dXJuIGIodiwgMTUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNih2KSB7IHJldHVybiBiKHYsIDE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE3YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTcodikgeyByZXR1cm4gYih2LCAxNyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE4KHYpIHsgcmV0dXJuIGIodiwgMTgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTlgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxOSh2KSB7IHJldHVybiBiKHYsIDE5KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjAodikgeyByZXR1cm4gYih2LCAyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIxKHYpIHsgcmV0dXJuIGIodiwgMjEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMih2KSB7IHJldHVybiBiKHYsIDIyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjModikgeyByZXR1cm4gYih2LCAyMyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI0KHYpIHsgcmV0dXJuIGIodiwgMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjVgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyNSh2KSB7IHJldHVybiBiKHYsIDI1KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjYodikgeyByZXR1cm4gYih2LCAyNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyN2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI3KHYpIHsgcmV0dXJuIGIodiwgMjcpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyOCh2KSB7IHJldHVybiBiKHYsIDI4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI5YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjkodikgeyByZXR1cm4gYih2LCAyOSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczMwKHYpIHsgcmV0dXJuIGIodiwgMzApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMzFgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzMSh2KSB7IHJldHVybiBiKHYsIDMxKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMzIodikgeyByZXR1cm4gYih2LCAzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYWRkcmVzc2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRyZXNzKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwiYWRkcmVzc1wiLCB2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBib29sYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJvb2wodikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJib29sXCIsICEhdik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXModikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJieXRlc1wiLCB2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBzdHJpbmdgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwic3RyaW5nXCIsIHYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGFycmF5YGAgdHlwZSBmb3IgJSV2JSUsIGFsbG93aW5nICUlZHluYW1pYyUlIGxlbmd0aC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJyYXkodiwgZHluYW1pYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJhcnJheVwiLCB2LCBkeW5hbWljKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHR1cGxlYGAgdHlwZSBmb3IgJSV2JSUsIHdpdGggdGhlIG9wdGlvbmFsICUlbmFtZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB0dXBsZSh2LCBuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcInR1cGxlXCIsIHYsIG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgb3ZlcnJpZGVzKHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwib3ZlcnJpZGVzXCIsIE9iamVjdC5hc3NpZ24oe30sIHYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBvbmx5IGlmICUldmFsdWUlJSBpcyBhIFtbVHlwZWRdXSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNUeXBlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlXG4gICAgICAgICAgICAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgJiYgXCJfdHlwZWRTeW1ib2xcIiBpbiB2YWx1ZVxuICAgICAgICAgICAgJiYgdmFsdWUuX3R5cGVkU3ltYm9sID09PSBfdHlwZWRTeW1ib2wpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIHZhbHVlIGlzIGEgW1tUeXBlZF1dIGluc3RhbmNlLCB2YWxpZGF0ZXMgdGhlIHVuZGVybHlpbmcgdmFsdWVcbiAgICAgKiAgYW5kIHJldHVybnMgaXQsIG90aGVyd2lzZSByZXR1cm5zIHZhbHVlIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdXNlZnVsIGZvciBmdW5jdGlvbnMgdGhhdCB3aXRoIHRvIGFjY2VwdCBlaXRoZXIgYSBbW1R5cGVkXV1cbiAgICAgKiAgb2JqZWN0IG9yIHZhbHVlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVyZWZlcmVuY2UodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgaWYgKFR5cGVkLmlzVHlwZWQodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0eXBlOiBleHBlY2V0ZCAke3R5cGV9LCBnb3QgJHt2YWx1ZS50eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlZC5qcy5tYXAiLCJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uLy4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IHRvQmVIZXggfSBmcm9tIFwiLi4vLi4vdXRpbHMvbWF0aHMuanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQWRkcmVzc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInN0cmluZ1wiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dFcnJvcihlcnJvci5tZXNzYWdlLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModG9CZUhleChyZWFkZXIucmVhZFZhbHVlKCksIDIwKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiLCJpbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBDbG9uZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYW4gZXhpc3RpbmcgQ29kZXIsIGJ1dCB3aXRob3V0IGEgbG9jYWxOYW1lXG4gKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBBbm9ueW1vdXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb2RlcjtcbiAgICBjb25zdHJ1Y3Rvcihjb2Rlcikge1xuICAgICAgICBzdXBlcihjb2Rlci5uYW1lLCBjb2Rlci50eXBlLCBcIl9cIiwgY29kZXIuZHluYW1pYyk7XG4gICAgICAgIHRoaXMuY29kZXIgPSBjb2RlcjtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmRlY29kZShyZWFkZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFub255bW91cy5qcy5tYXAiLCJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBpc0Vycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRBcmd1bWVudENvdW50IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIsIFJlc3VsdCwgV29yZFNpemUsIFdyaXRlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBBbm9ueW1vdXNDb2RlciB9IGZyb20gXCIuL2Fub255bW91cy5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhY2sod3JpdGVyLCBjb2RlcnMsIHZhbHVlcykge1xuICAgIGxldCBhcnJheVZhbHVlcyA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgYXJyYXlWYWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlcyAmJiB0eXBlb2YgKHZhbHVlcykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbGV0IHVuaXF1ZSA9IHt9O1xuICAgICAgICBhcnJheVZhbHVlcyA9IGNvZGVycy5tYXAoKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgYXNzZXJ0KG5hbWUsIFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIG1pc3NpbmcgbmFtZXNcIiwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IFwidmFsdWVzXCIsIGluZm86IHsgY29kZXIgfSwgdmFsdWU6IHZhbHVlcyB9KTtcbiAgICAgICAgICAgIGFzc2VydCghdW5pcXVlW25hbWVdLCBcImNhbm5vdCBlbmNvZGUgb2JqZWN0IGZvciBzaWduYXR1cmUgd2l0aCBkdXBsaWNhdGUgbmFtZXNcIiwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IFwidmFsdWVzXCIsIGluZm86IHsgY29kZXIgfSwgdmFsdWU6IHZhbHVlcyB9KTtcbiAgICAgICAgICAgIHVuaXF1ZVtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzW25hbWVdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgdHVwbGUgdmFsdWVcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChjb2RlcnMubGVuZ3RoID09PSBhcnJheVZhbHVlcy5sZW5ndGgsIFwidHlwZXMvdmFsdWUgbGVuZ3RoIG1pc21hdGNoXCIsIFwidHVwbGVcIiwgdmFsdWVzKTtcbiAgICBsZXQgc3RhdGljV3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgIGxldCBkeW5hbWljV3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgIGxldCB1cGRhdGVGdW5jcyA9IFtdO1xuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gYXJyYXlWYWx1ZXNbaW5kZXhdO1xuICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgZHluYW1pYyBvZmZzZXQgKGZvciB0aGUgZnV0dXJlIHBvaW50ZXIpXG4gICAgICAgICAgICBsZXQgZHluYW1pY09mZnNldCA9IGR5bmFtaWNXcml0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgLy8gRW5jb2RlIHRoZSBkeW5hbWljIHZhbHVlIGludG8gdGhlIGR5bmFtaWNXcml0ZXJcbiAgICAgICAgICAgIGNvZGVyLmVuY29kZShkeW5hbWljV3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRvIHBvcHVsYXRlIHRoZSBjb3JyZWN0IG9mZnNldCBvbmNlIHdlIGFyZSBkb25lXG4gICAgICAgICAgICBsZXQgdXBkYXRlRnVuYyA9IHN0YXRpY1dyaXRlci53cml0ZVVwZGF0YWJsZVZhbHVlKCk7XG4gICAgICAgICAgICB1cGRhdGVGdW5jcy5wdXNoKChiYXNlT2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRnVuYyhiYXNlT2Zmc2V0ICsgZHluYW1pY09mZnNldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvZGVyLmVuY29kZShzdGF0aWNXcml0ZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEJhY2tmaWxsIGFsbCB0aGUgZHluYW1pYyBvZmZzZXRzLCBub3cgdGhhdCB3ZSBrbm93IHRoZSBzdGF0aWMgbGVuZ3RoXG4gICAgdXBkYXRlRnVuY3MuZm9yRWFjaCgoZnVuYykgPT4geyBmdW5jKHN0YXRpY1dyaXRlci5sZW5ndGgpOyB9KTtcbiAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLmFwcGVuZFdyaXRlcihzdGF0aWNXcml0ZXIpO1xuICAgIGxlbmd0aCArPSB3cml0ZXIuYXBwZW5kV3JpdGVyKGR5bmFtaWNXcml0ZXIpO1xuICAgIHJldHVybiBsZW5ndGg7XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrKHJlYWRlciwgY29kZXJzKSB7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBrZXlzID0gW107XG4gICAgLy8gQSByZWFkZXIgYW5jaG9yZWQgdG8gdGhpcyBiYXNlXG4gICAgbGV0IGJhc2VSZWFkZXIgPSByZWFkZXIuc3ViUmVhZGVyKDApO1xuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHJlYWRlci5yZWFkSW5kZXgoKTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRSZWFkZXIgPSBiYXNlUmVhZGVyLnN1YlJlYWRlcihvZmZzZXQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZGVyLmRlY29kZShvZmZzZXRSZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2Fubm90IHJlY292ZXIgZnJvbSB0aGlzXG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQlVGRkVSX09WRVJSVU5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9IGNvZGVyLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKHJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJCVUZGRVJfT1ZFUlJVTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZlc3RpZ2F0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIGtleXMucHVzaChjb2Rlci5sb2NhbE5hbWUgfHwgbnVsbCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFJlc3VsdC5mcm9tSXRlbXModmFsdWVzLCBrZXlzKTtcbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBBcnJheUNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvZGVyO1xuICAgIGxlbmd0aDtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlciwgbGVuZ3RoLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IChjb2Rlci50eXBlICsgXCJbXCIgKyAobGVuZ3RoID49IDAgPyBsZW5ndGggOiBcIlwiKSArIFwiXVwiKTtcbiAgICAgICAgY29uc3QgZHluYW1pYyA9IChsZW5ndGggPT09IC0xIHx8IGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICBzdXBlcihcImFycmF5XCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBjb2RlciwgbGVuZ3RoIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIC8vIFZlcmlmaWVzIHRoZSBjaGlsZCBjb2RlciBpcyB2YWxpZCAoZXZlbiBpZiB0aGUgYXJyYXkgaXMgZHluYW1pYyBvciAwLWxlbmd0aClcbiAgICAgICAgY29uc3QgZGVmYXVsdENoaWxkID0gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVmYXVsdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwiYXJyYXlcIik7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJleHBlY3RlZCBhcnJheSB2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvdW50ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudENvdW50KHZhbHVlLmxlbmd0aCwgY291bnQsIFwiY29kZXIgYXJyYXlcIiArICh0aGlzLmxvY2FsTmFtZSA/IChcIiBcIiArIHRoaXMubG9jYWxOYW1lKSA6IFwiXCIpKTtcbiAgICAgICAgbGV0IGNvZGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaCh0aGlzLmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAoY291bnQgPT09IC0xKSB7XG4gICAgICAgICAgICBjb3VudCA9IHJlYWRlci5yZWFkSW5kZXgoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlcmUgaXMgKnJvdWdobHkqIGVub3VnaCBkYXRhIHRvIGVuc3VyZVxuICAgICAgICAgICAgLy8gc3RyYXkgcmFuZG9tIGRhdGEgaXMgbm90IGJlaW5nIHJlYWQgYXMgYSBsZW5ndGguIEVhY2hcbiAgICAgICAgICAgIC8vIHNsb3QgcmVxdWlyZXMgYXQgbGVhc3QgMzIgYnl0ZXMgZm9yIHRoZWlyIHZhbHVlIChvciAzMlxuICAgICAgICAgICAgLy8gYnl0ZXMgYXMgYSBsaW5rIHRvIHRoZSBkYXRhKS4gVGhpcyBjb3VsZCB1c2UgYSBtdWNoXG4gICAgICAgICAgICAvLyB0aWdodGVyIGJvdW5kLCBidXQgd2UgYXJlIGVycm9yaW5nIG9uIHRoZSBzaWRlIG9mIHNhZmV0eS5cbiAgICAgICAgICAgIGFzc2VydChjb3VudCAqIFdvcmRTaXplIDw9IHJlYWRlci5kYXRhTGVuZ3RoLCBcImluc3VmZmljaWVudCBkYXRhIGxlbmd0aFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHsgYnVmZmVyOiByZWFkZXIuYnl0ZXMsIG9mZnNldDogY291bnQgKiBXb3JkU2l6ZSwgbGVuZ3RoOiByZWFkZXIuZGF0YUxlbmd0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29kZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29kZXJzLnB1c2gobmV3IEFub255bW91c0NvZGVyKHRoaXMuY29kZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5wYWNrKHJlYWRlciwgY29kZXJzKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiLCJpbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIEJvb2xlYW5Db2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJib29sXCIsIFwiYm9vbFwiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJib29sXCIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUgPyAxIDogMCk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuICEhcmVhZGVyLnJlYWRWYWx1ZSgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb2xlYW4uanMubWFwIiwiaW1wb3J0IHsgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgRHluYW1pY0J5dGVzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHR5cGUsIGxvY2FsTmFtZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiMHhcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBnZXRCeXRlc0NvcHkodmFsdWUpO1xuICAgICAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoICs9IHdyaXRlci53cml0ZUJ5dGVzKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRCeXRlcyhyZWFkZXIucmVhZEluZGV4KCksIHRydWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBCeXRlc0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJ5dGVzXCIsIGxvY2FsTmFtZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoc3VwZXIuZGVjb2RlKHJlYWRlcikpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCIsImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJ5dGVzQ29weSwgaGV4bGlmeSB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBGaXhlZEJ5dGVzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgc2l6ZTtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBcImJ5dGVzXCIgKyBTdHJpbmcoc2l6ZSk7XG4gICAgICAgIHN1cGVyKG5hbWUsIG5hbWUsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgc2l6ZSB9LCB7IHNpemU6IFwibnVtYmVyXCIgfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIChcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKS5zdWJzdHJpbmcoMCwgMiArIHRoaXMuc2l6ZSAqIDIpO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBnZXRCeXRlc0NvcHkoVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCB0aGlzLnR5cGUpKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJpbmNvcnJlY3QgZGF0YSBsZW5ndGhcIiwgX3ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlQnl0ZXMoZGF0YSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkocmVhZGVyLnJlYWRCeXRlcyh0aGlzLnNpemUpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXhlZC1ieXRlcy5qcy5tYXAiLCJpbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5jb25zdCBFbXB0eSA9IG5ldyBVaW50OEFycmF5KFtdKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBOdWxsQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwibnVsbFwiLCBcIlwiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJub3QgbnVsbFwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKEVtcHR5KTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZWFkZXIucmVhZEJ5dGVzKDApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWxsLmpzLm1hcCIsImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGZyb21Ud29zLCBnZXRCaWdJbnQsIG1hc2ssIHRvVHdvcyB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IENvZGVyLCBXb3JkU2l6ZSB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbmNvbnN0IEJOX01BWF9VSU5UMjU2ID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIE51bWJlckNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIHNpemU7XG4gICAgc2lnbmVkO1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIHNpZ25lZCwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAoKHNpZ25lZCA/IFwiaW50XCIgOiBcInVpbnRcIikgKyAoc2l6ZSAqIDgpKTtcbiAgICAgICAgc3VwZXIobmFtZSwgbmFtZSwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBzaXplLCBzaWduZWQgfSwgeyBzaXplOiBcIm51bWJlclwiLCBzaWduZWQ6IFwiYm9vbGVhblwiIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZ2V0QmlnSW50KFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgdGhpcy50eXBlKSk7XG4gICAgICAgIC8vIENoZWNrIGJvdW5kcyBhcmUgc2FmZSBmb3IgZW5jb2RpbmdcbiAgICAgICAgbGV0IG1heFVpbnRWYWx1ZSA9IG1hc2soQk5fTUFYX1VJTlQyNTYsIFdvcmRTaXplICogOCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgbGV0IGJvdW5kcyA9IG1hc2sobWF4VWludFZhbHVlLCAodGhpcy5zaXplICogOCkgLSAxKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IGJvdW5kcyB8fCB2YWx1ZSA8IC0oYm91bmRzICsgQk5fMSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBfdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSB0b1R3b3ModmFsdWUsIDggKiBXb3JkU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPCBCTl8wIHx8IHZhbHVlID4gbWFzayhtYXhVaW50VmFsdWUsIHRoaXMuc2l6ZSAqIDgpKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gbWFzayhyZWFkZXIucmVhZFZhbHVlKCksIHRoaXMuc2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZnJvbVR3b3ModmFsdWUsIHRoaXMuc2l6ZSAqIDgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuanMubWFwIiwiaW1wb3J0IHsgdG9VdGY4Qnl0ZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCIuLi8uLi91dGlscy91dGY4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgRHluYW1pY0J5dGVzQ29kZXIgfSBmcm9tIFwiLi9ieXRlcy5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmluZ0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcInN0cmluZ1wiLCBsb2NhbE5hbWUpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuY29kZSh3cml0ZXIsIHRvVXRmOEJ5dGVzKFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJzdHJpbmdcIikpKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gdG9VdGY4U3RyaW5nKHN1cGVyLmRlY29kZShyZWFkZXIpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmcuanMubWFwIiwiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuLi8uLi91dGlscy9wcm9wZXJ0aWVzLmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuaW1wb3J0IHsgcGFjaywgdW5wYWNrIH0gZnJvbSBcIi4vYXJyYXkuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBUdXBsZUNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvZGVycztcbiAgICBjb25zdHJ1Y3Rvcihjb2RlcnMsIGxvY2FsTmFtZSkge1xuICAgICAgICBsZXQgZHluYW1pYyA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0eXBlcyA9IFtdO1xuICAgICAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlcy5wdXNoKGNvZGVyLnR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHlwZSA9IChcInR1cGxlKFwiICsgdHlwZXMuam9pbihcIixcIikgKyBcIilcIik7XG4gICAgICAgIHN1cGVyKFwidHVwbGVcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGNvZGVyczogT2JqZWN0LmZyZWV6ZShjb2RlcnMuc2xpY2UoKSkgfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIHRoaXMuY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChjb2Rlci5kZWZhdWx0VmFsdWUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBvbmx5IG91dHB1dCBuYW1lZCBwcm9wZXJ0aWVzIGZvciB1bmlxdWVseSBuYW1lZCBjb2RlcnNcbiAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSB0aGlzLmNvZGVycy5yZWR1Y2UoKGFjY3VtLCBjb2RlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2N1bVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgLy8gQWRkIG5hbWVkIHZhbHVlc1xuICAgICAgICB0aGlzLmNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgaWYgKCFuYW1lIHx8IHVuaXF1ZU5hbWVzW25hbWVdICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJfbGVuZ3RoXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXNbbmFtZV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUodmFsdWVzKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInR1cGxlXCIpO1xuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIHRoaXMuY29kZXJzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHVucGFjayhyZWFkZXIsIHRoaXMuY29kZXJzKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10dXBsZS5qcy5tYXAiLCJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiAgQSBzaW1wbGUgaGFzaGluZyBmdW5jdGlvbiB3aGljaCBvcGVyYXRlcyBvbiBVVEYtOCBzdHJpbmdzIHRvXG4gKiAgY29tcHV0ZSBhbiAzMi1ieXRlIGlkZW50aWZpZXIuXG4gKlxuICogIFRoaXMgc2ltcGx5IGNvbXB1dGVzIHRoZSBbVVRGLTggYnl0ZXNdKHRvVXRmOEJ5dGVzKSBhbmQgY29tcHV0ZXNcbiAqICB0aGUgW1trZWNjYWsyNTZdXS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBpZChcImhlbGxvIHdvcmxkXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZCh2YWx1ZSkge1xuICAgIHJldHVybiBrZWNjYWsyNTYodG9VdGY4Qnl0ZXModmFsdWUpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCIsIi8vIGNyZWF0ZWQgMjAyMy0wOS0xMlQyMjowNToxNC4yMTFaXG4vLyBjb21wcmVzc2VkIGJhc2U2NC1lbmNvZGVkIGJsb2IgZm9yIGluY2x1ZGUtZW5zIGRhdGFcbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9ibG9iL21haW4vc3JjL21ha2UuanNcbi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcyNzZWN1cml0eVxuLy8gU0hBLTI1NjogMDU2NWVkMDQ5YjljZjE2MTRiYjllMTFiYTdkOGFjNmE2ZmI5NmM4OTMyNTNkODkwZjdlMmIyODg0YjlkZWQzMlxudmFyIENPTVBSRVNTRUQkMSA9ICdBRUVVZHdtZ0RTOEJ4UUtLQVA0Qk9nRGpBVEFBbmdEVUFJTUFvQUJvQU9BQWFnQ09BRVFBaEFCTUFISUFPd0E5QUNzQU5nQW1BR0lBSGdBdUFDZ0FKd0FYQUMwQUdnQWpBQjhBTHdBVUFDa0FFZ0FlQUFrQUd3QVJBQmtBRmdBNUFDZ0FMUUFyQURjQUZRQXBBQkFBSGdBaUFCQUFHZ0FlQUJNQUdBVWhCZThCRnhSRU44c0Yyd0M1QUs1SEFXOEFyUWtEelFDdWh6YzNOemNCUDY4TkVmTUFCUWRIQnV3NUJWOEZZQUE5TXprSTlyNFpCZzdReVFBV0E5Q2VPd0xOQ2pjQ2pxa0NodUEvbG0rUkFzWFRBb1A2QVNmbkVRRHl0UUZKQWpXVkNrZVhBT3NBNmdvZEFCL2N3ZEFVRTBXbEJDTi9BUVVDUVJqRkQvTVJCakh4RFFTSmJ3MGpCelVBc3dCeG1lK3RuSWNBWXdhYkF5c0c4UUFqQUVNTW14Y0RxZ1BLUXlEWENNTXhBN2tVUXdEM05YT3JBS21GSUFBZkJDMEQzeDRCSlFEQkdkVUZBaEVnVkQ4Sm53bVFKaU5XWVV6cmcwb0FHd0FVQUIwQUZuTmNBQ2tBRmdCUDloM2dQZnNET1dES25lWTJDaGdsWDFVRFlEMzBBQnNBRkFBZEFCWnpJR1JBbndERDh3QWpBRUVNelJiRHFnTUIyc0FGWXdYcUF0Q25Bc1M0QXdwVUpLUnRGSHNhZFV6OUFNTVZid0xwQUJNMU5KRVgwWmtDZ1lNQkV5TUF4UlZ2QXVrQUV6VUJVRkF0bVV3U0F5NERCVEVSMzNFZnRRSGZTd0I1TXhKL0Fqa1dLUUx6TDhFL2N3QkI2UUg5TFFEUER0TzlBU05yaVFDNURRQU5Bd0NLMjFFRkk5MXpId0NvTDlrQnFRY0hCd2NIS3pVRG93QnZBUW9oUHZVM2ZBUWdId0N5QWM4Q0tRTUE1ek1TZXpyN1VMZ0ZtRHAvTHpWUUJnRUdBaThGWVFWZ3Q4QUZjVHRsUWhwQ1dFbWZlNXRtWjZJQUV4c0R6UTh0K1g4ckJLdFRBbHRiQW4wanN5OEJsNnV0UFdNRFRSOEVpMmtSQU5rREJyTkhOeXNEQnpFQ1FXVUFjd0ZwSjNrQWl5VWhBSjBCVWI4QUwzRWZBYmZOQXo4MUtVc0ZXd0YzWVFadEFtMEErVkVmQXpFSkRRQlJTUUN6QVFCbEFIc0FNNzBHRC92M0laV0hCd0FSS1FBeEFMc2pUd0haQWVNUEV6bVhnSUh3QUJJQUdRQThBRVVBUUR0M2dkdklFR2NRWkFrR1RSRk1kRUlWRXdLMEQ2NEw3UkVkRE5rcTA5UGdBRFN4Qi9NRFd3ZnpBMXNEV3dmekIvTURXd2Z6QTFzRFd3TmJBMXNjRXZBaTI4Z1FadzlRQkhVRmxnV1RCTjRJaXlaUkVZa0hNQWphVkJWMEpoeFBBMDBCQkNNdFNTUTdtek1USlVwTUZFMExDQVEyU215dmZVQURUekd6VlAyUXFnUFRNbGM1ZEFrR0hua1NxQUF5RDNza05iMU9obnBQY2FnS1UwKzJ0WWRKYWs1dkFzWTZzRUFBQ2lrSm0yL0RkMVlHUlJBZko2a1Erd3czQWJrQlB3M3hTOXdFOVFZL0JNMGZnUmtkRDlHVm9BaXBMZUVNOFNibkxxV0FYaVA1S29jRjhVdjRQT0VMVVZGc0QxMExhUW5uT21lQlVnTWxBUkVpandyaERUMEljUkQzQ3MxdkRla1JTUWM5QTlsSm5nQ3BCd1VMRlIwNUZia21GR0t3Q3cwNWV3Yi9Hdm9Ma3lhekV5MTdBQVhYR2lVR1VRRXRHd01BMHk3cmhiUmFOVndnVDJNR0J3c3BJOHNVckZBa0RTbEF1M2hNR2g4SEdTV3RBcFZEZEVxTFVUb2VseUg2UEVFTmFpNFhVWUFIK1R3SkdWTUxoVHlpUnE5RkVoSFdQcEU5VENKTlREQUVPWU1zTXllUENkTVBpUXk5ZkhZQlhRa2xDYlVNZFJNMUVSczN5UWc5QngweGx5Z25HUWdsUnBsZ25nVDdvd1AzRTlVRER3VkRDVVVIRndPNUhERVRNaFV0QlJHQktOc0M5emJaTHJjQ2sxYUVBUnNGenc4cEgrTVFWRWZrRHUwSW53SnBBNGNsN3dBeEZTVUFHeUtmQ0VkbkFHT1AzRk1KTHM4SXkycHdJM2dEYXhUclpSRjNCNVVPV3dlckhEY1Z3eHpsY014ZUQ0WU1LS2V6Q1Y4QmVRbWRBV01FNXdnTk5WK01wQ0JGWjFlTFhCaWZJR1ZCUTE0QUFqVU1hUldqUk1HSGZBS1BEMjhTSHdFNUFYY0hQUTBGQW5zUjhSRnZFSmtJNzRZSU5ia3ovRG9wQkZNaGh5QVZDaXNEVTJ6U0N5c20vUXo4YlFHbkVtWURFRFJCZC9KbnIyQzZLQmdCQngweXlVRmtJZlVMbGsvUkRLQWF4UmhHVkRJWjZBZkRBL2NhOXlmdVFWc0dBd09uQnhjNlVUUHlCTUVMYlFpUENVTUFUUTZuR3dmYkdHNEtkWXpVQVRXUEFidWRBMXVWaHdKemt3WTdCdzhBYXcrTEJYM3BBQ0VDcXdpbkFBa0Ewd05iQUQwQ3NRZWhBQjBBaVVVQlFRTXJNd0VsNlFLVEE1Y0lOYzhCbVRNQjl5MEVIOGNNR1FEN08yNU9Bc08xQW9CdVpxWUY0VndDa2dKTk9RRlJLUVFKVWt0VkE3TjE1UURmQUU4R0YrTkxBUm12VHM4ZTUwY0I0M012QU1zQS93QUpPUWNKUlFIUkFmZHhBTHNCWXdzMUNhYTN1UUZSN1MwQWh3QVpid0hiQW8wQTRRQTVBSVAxQVZjQVVRVmQvUVhYQWxOTkFSVTFIQzliWlFHL0F5TUJOd0VSQUgwR3o1R3B6UXNqQkhFSDF3SVFIeFhsQXU4eUI3a0ZBeUxqRTlGQ3lRSzk0bGtBTWhvS1BBcXJDcXBnWDJRM0NqVjJQVlFBRWgrc1Bzcy9VZ1ZWTzFjN1hEdFhPMXc3Vnp0Y08xYzdYRHRYTzF3RG04UG13K1lLY0Y5SlllOE1xZzNZUk13NlRSUGZZRlZnTmhQTUxic1V4UlhTSlZvWlFSckFKd2tsNkZVTkR3Z3QxMlkwQ0RBMGVSZkFBRU1wYklORlk0b2VOQXBQSE90VGxWVDhMUjhBdFV1bU03TU5zQnNaUkVRRlMzWHhZaTRXRWdvbUFtU0ZBbUpHWDFHekFWODNKQUtoK3dKb25BSm1EUUtmaURnZkR3Sm1Qd0ptS2dSeUJJTURmeGNEZnBZNUNqbDdHem1HT2ljbkFtd2hBakk2T0E0Q2Jjc0NiYkx6amdNM2Ewa3ZBV3NBNGdEbEFFNEpCNXdNa1FFQ0Q4WUFFYmtDZHpNQ2RxWkRBbmxQUndKNHZpRmczMFd5UnZjQ2ZFTUNlc3dDZlEwQ2ZQUklCRWlCWnlnQUx4bEpYRXBmR1J0SzBBTFJCUUxRMEVzckE0aFRBNGZxUk1tUk5nTHlwVjBIQXdPeVM5Sk1NU2tIMDAxUVRiTUNpME1DaXR6Rkh3c2hSMnNKdXdLT093S09ZRVNiaFFLTzNRS09ZSHhSdUZNNUFRNVMyRlNKQXBQL0FwTVFBTzBBSUZVaVZiTlYxQW9zSHltWmlqTGxlR3BGUHowQ2w2TUM3N1pZSmF3QVhTa0NscE1DbG9DZ0FLMVpzRm9OaFZFQVB3S1d1UUtXVWx4SVhOVUNtYzhDbVdoY3psMExIUUtjbnpuR09xRUNuQm9DbjU4Q25yeU9BQ0VUTlM0VEFwMzFBcDZXQUxsQllUaGg4d0tlMXdLZ2NnR3RBcDZqSXdLZVVxbGp6R1FyS1M4Q0o3TUNKb0lDb1A4Q29GRGJBcVl6QXFYU0FxZ0RBSUVDcC9ab2dHaTFBQWROYWlCcTFRS3M1d0tzc2dLdGF3S3RCZ0pYSVFKVjRBS3g1ZHNESDFKc213S3l3UkVDc3V3YmJPUnRaMjFNWXdNbDBRSzJZRDlEYnBRREtVa0N1R0lDdVVzWkFya3VlM0E2Y09VQ3ZSMERMYllETWhVQ3ZveHlCZ016ZFFLK0huTW1jMU1Ddzg4Q3d3aHpoblJQT1VsMDVBTThxd0VEUEo0RFBjTUN4WUFDeGtzQ3hoU05Bc2h0VlFMSVNBTEpVd0xKTWdKa29RTGQxbmg5WlhpeWVTbEwxQU1ZcDJjR0FtSDRHZmVWS0hzUFhwWmV2eFVDejI4Q3ozQXpUMWZXOXhlakFNcXhBczkzQVMzdUEwNFdmazhKQXR3ckF0dU9BdEpUQTFKZ0ExTmpBUVVEVlpDQWpVTUV6eHJ4WkVsNUE0TFNnNUVDMnNzQzJlS0VGSVJOcDBBRGhxa0FNd05rRW9aMVhmMEFXUUxmYVFMZXZIZDdBdUl6N1JnQjh6UXJBZlNmQWZMV2l3THI5d0xwZEgwREF1cjlBdXJvQVAxTEFiMEM3bzBDNjZDV3JwY0hBdTVEQTRYa21IMXc1SEdsQXZNSEFHMERqaHFabHdMM0Z3T1JjZ09TaXdMM25BTDUzUUw0YXBvZ21xKy9PNXNpQTUySEF2NytBUjhBUFo4Z0FaKzNBd1dSQTZadUE2YmRBTlhKQXdadW9ZeWlDUTBEREUwQkV3RWpCM0VHWmIxckNRQy9CRy9ERlk4ZXR4RUFHM2s5QUNjRE54SlJBNDJEQVdjckpRQ004d0FsQU9hbkM2T1ZDTHNHSTZmSkJnQ3ZCUm5EQnZFbFJVWUZGb0FGY0Q5R1NETkNLVUs4WDNrWlg4UUFsczBGT2dDUVZDR2J3VHN1WURvWnV0Y09OeGpPR0pISi9nVmZCV0FGWHdWZ0JXc0ZZQVZmQldBRlh3VmdCVjhGWUFWZkJXQk9IUWpmalc4S0Nnb0tiRjd4TXdUUkE3a0dOOFBEQU1NRXI4TUE3MGd4RnJvRlRqNXhQbmhDUjBLK1gzMC9YL0FBV0JrenN3Q05Cc3h6ekFTbTcwYUNSUzRyRERNZUx6NDlmblhmY3NINUdjb3NjUUZ6MTNZNEh3Vm5CWExKeWNuQUNOZFJZd2dJQ0FxRVhvV1R4Z0E3UDRrQUN4YlpCdTIxS3cwQWpNc1RBd2tWQU9WdEpVVXNKMUpDdVVMRVNVQXJYeTlnUGk5QUt3bkpSUVlLVEQ5TFBvQStpVDU0UG5rQ2tVTEVVVXBEWDlOV1YzSlZFalFBYzF3M0EzSUJFM1luWCtnN1FpTUpiNk1LYWlzelJDVXVRck5DeERQTUNjd0VYOUVXSnpZUkVCRUVCd0lIS242bDMzSkNOVklmeWJQSnRBbHR5ZFBVQ21oQlp3L3RFS3NaQUpPVkpVMUNMUnV4YlVIT1FBbzdQMHMrZUVKSEhBOFNKVlJQZEdNME5WcnB2Qm9LaGZVbE0wSkhIR1VRVWhFV08xeExTajhNTzB1Y05BcUpJelZDUnh2OUVGc3FLeUE0T1FnTmoybndaZ3A1Wk5GZ0UyQTFLM1lIUzJBaFFRb2pKbUM3RGdwekdHMVdZRlVaQ1FZSFpPOWdIV0NkWUlWZ3UyQlRZSmx3Rmg4R3ZSYmNYYkc4WWd0REhyTUJ3elBWeVFvbkhRZ2tDeVlCZ1FKMEFqYzRuVnFJQXdHU0NzQlBJZ0RzSzNTV0V0SVZCYTVOOGdHakFvK2tWd1ZJWndEL0FFVVNDRHdlWDRJVHJSUXNKOEszVHdCWEZEd0VBQjBUdnpWY0F0b1RTMjBSSXdEZ1ZnWjlCQkltWWdBNUFMNENvaThMRm5lek9rQ25JUUZqQVk0S0JBUGg5UmNHc2daU0JzRUFKY3Rkc1dJUnUya1RrUXN0Unc3REFjTUJLZ3BQQkdJR01EQXdLQ1luS1RRYUxnNEFLUlNWQUZ3Q2RsK1lVWjBKZGljRkQzbFBBZHQxRjlaWktDR3h1RTN5QnhrRlZHY0Evd0JGRWdpQ0J3QU9MSFFTanhPdFFEZzF6N2RlRlJNQVo4UVRBR3RLYjFBcElpUEhBRGtBdmdLaUx5MURGdFlDbUJpREFsRERXTkIwZW83ZnBhTU8vYUVWUlJ2MEFURVFaQklPRHlNRUFjOEpRaENiRFJnekZENFRBRU1BdTlZQkNnQ3NBT2tBbTVJM0FCd0FZeHZPTm5SK01oWEpBeGdLUXl4TDIra2tKaE1iaFFLREJNa1NzdkYwQUQ5Qk5RNnVRQzdXcVNRSHd4RUFFRUl1MWhraEFIMno0aVFQd3lKUEhOV3BkeVlCUlNwbkpBTHpvQkFFVlBQc0gyME14QTBDQ0VRS1JnQUZ5QXRGQWxNTnd3akVEVVFKUkFyRUx0YXBNZzdERFpnSkl3K1RHdWtFSXd2REZrTUFxQXRERU1NTUJoaW9lK1FBTzNNTVJBQUNyZ25FQlNQWTlRMEZEbmJTQm9NQUI4TVNZeGtTeEFFSkFQSUpBQUI4RldNT0Z0TWMvSGNYd3hoREFDN0RBdk9vd3dBZXd3SmRLREtIQUFIREFBTHJGVVFWd3dBYnd5dnpwV01Xdjh3QS9BQnBBeSsrYmNZRFVLUEQwS2hEQ3dLbUoxTUFBbU1BNStVWnd4QWFnd2lwQlJML2VBRGZ3NmZER09NQ0dzT2prM2w2QndPcG80c0FFc01PR3hNQUE1c0FiY01PQUF2RHAwTUpHa01Ed2dpcG5OSVBBd2ZJcVVNR0FPR0RBQVB6QUJYREFBY0RBQW5EQUdtVEFCckRBQTdEQ2hqRGpuRVdBd0FCWXdBT2N3QXVVeVlBQnNNQUY4TUlLUUFOVWdDNnd5NEFBOE1BRHFNcTh3Q3lZZ0FjSXdBQjh3cXBBQVhPQ3gwVjR3QUhvd0JDd3dFS0FHbkRBQXVEQUIzREFBakRDYWtBQmRJQWJxY1ozUUNaQ0NrQUJkSUFBQUZEQUFmakFCMmpDQ2tBQnFJQUNZTUFHek1BYlNNQTVzT0lBQWhqQUFoREFCVERCQWtwQUFiU0FPT1RBQWxEQzZrT3pQdG5BQWREQUc2a1FGQUFUd0FLd3d3QUEwTUFDYlVEUHdBSEl3QVpnd0FDRTZjREFBb2pBQXBEQUFvRHAvTUd3d0FKSXdBREV3QVFRd2dBRkVNQUVYTUFENU1BRGZNQURjTUFHUk1PRmlNQUZVTUFicU1XdXdIREFNSUFFME1MQUdrekVnRGhVd0FDUXdBRVdnQVhnd1VqQUFiWUFCakRCU1lCZ3pCYUFFRk5BTGNRQnhVTWVnQXdNbmdCckEwSVpnSjBLeFFIQlJFUGQxTjBaektSSndhSUhBWnFOVDREcVFxOEJ3bmdBQjREQXd0MkFYNTZUMW9jS1FOWEFoMUdBVFFHQzN0T3hZTmFna2dBTVFBNUNRQURBUUVBV3hMakFJT1lOQUV6QUg3dEZSazZUZ2xTQUY4TkFBbFlBUStTMUFDQVF3UW9yUUJpQU40ZEFKMXdQeWVUQU5WenVRRFgzQUllRU1wOWV5TWdYaVVBRWRrQmtKaXpLbHRiVlZBYVJNcVJBQUVBaHlRL1NERXo2Qm1mVndCNkFURXNPQ2xLSVJjRE9GMEUvODMyQUZOdDVBQnlBbmtDUnhHQ09zOTROalhkQXdJTkdCb25EQndQQUxXMkF3SUNBZ0FBQUFBQUFBWURCUU1EQVJyVUF3QXRBQUFBQWdFR0JnWUdCZ1lGQlFVRkJRVUVCUVlIQ0FrRUJRVUZCUVFBQUFJQ0FBQUFJZ0NOQUpBQWxUMEE2Z0M3QU53QXBFUUF3Z0N5QUswQXFBRHVBS1lBMmdDakFPY0JDQUVEQU1jQWdRQmlBTklBMUFFREFONEE4Z0NRQUtrQk1RRHFBTjhBM0FzQkNROHlPOXJhMnRxOHh1TFQxdFJKT0IwQlVnRmNOVTBCV2dGcEFXZ0JXd0ZNVVVsTGJoTUJVeHNORUFzNlBoTU9BQ2NVS3kwdk1qNUFRRU5EUTBSRkZFWUdKRmRYVjFkWldWaFpMMXBiWFZ4Y0kyTm5aMlpvWnlwc2JuWjFlSGg0ZUhoNGVucDZlbnA2ZW5wNmVucDhmSDE4ZTJJQVJQSUFTUUNhQUhnQU1nQm0rQUNPQUZjQVZ3QTNBbmJ2QUlzQUJmajRBR1FBay9JQW53QlBBR0lBWlAvL3NBQ0ZBSVVBYVFCV0FMRUFKQUMyQUlNQ1FBSkRBUHdBNXdEK0FQNEE2QUQvQU9rQTZRRG9BT1lBTHdKN0FWRUJRQUUrQVZRQlBnRStBVDRCT1FFNEFUZ0JPQUVjQVZnWEFERVFDQUVBVXg4U0hnc2RIaFlBamdDV0FLWUFVUUJxSUFJeEFIWUFid0NYQXhVREp6SURJVWxHVHpFQWtRSlBBTWNDVndLa0FNQUNsZ0tXQXBZQ2xnS1dBcFlDaXdLV0FwWUNsZ0tXQXBZQ2xnS1ZBcFVDbUFLZ0FwY0NsZ0tXQXBRQ2xBS1VBcFFDa2dLVkFuVUIxQUtYQXA4Q2xnS1dBcFVlQUlFVEJRRCtEUU9mQW1FQ09oOEJWQmc5QXVJWkVqTWJBVTQvRzFXWkFYdXNSQUZwWVFFRkEwRlBBUVlBbVRFZUlKZHlBREZvQUhFQU5nQ1JBNXpNay9DMmpHSU53ak1XeWdJWkNhWGRmRElMQkNzNWRBRTdZblFCdWdEbGhvaUhob2lHaVlxS2hvdU9qSWFOa0k2SWo0cVFpcEdHa29hVGhwU1NsWWFXaHBlS21JYVpocHFHbTRhY2k1MlFub3FmaHVJQzRYVHBBdDkwQUlwMExIU29BSXNBZEhRRVF3UkFCRUlFUlFSREJFa0VSZ1JCQkVjRVNRUklCRVFFUmdSSkFKNXVkQUNyQTQ5MEFMeHVBUTEwQU5GWmRIUUExM1FDRkhRQS9tSjBBUDRCSVFEK0FQd0EvQUQ5QVB3RGhHWjAzQVNNSzIzSEFQNEEvQUQ4QVAwQS9DUjBkQUNSWW5RQS9nQ1JBU0VBL2dDUkF2UUEvZ0NSQTRSbWROd0VqQ3R0eHlSMEFQOWlkQUVoQVA0QS9nRDhBUHdBL1FEOEFQOEEvQUQ4QVAwQS9BT0VablRjQkl3cmJjY2tkSFFBa1dKMEFTRUEvZ0NSQVA0QWtRTDBBUDRBa1FPRVpuVGNCSXdyYmNja2RBSkxBVDUwQWxJQlFYUUNVOGwwZEFKZmRIUURwZ0wwQTZZRHBnT25BNmNEcHdPbkE0Um1kTndFakN0dHh5UjBkQUNSWW5RQklRT21BSkVEcGdDUkF2UURwZ0NSQTRSbWROd0VqQ3R0eHlSMEJEaDBBSkVFT1FDUkRwVTVkU2dDQURSMDNnVjJDd0FyZEFFRkFNNWlDblIwQUYxaUFBWWNPZ3AwZEFDUkNuUUFYQUVJd1daMENuUm1kSFFBa1daMENuUm1kRVhnQUZGMDNncDBkRVkwdGxUMnUzU09BUVR3c2N3aGpaWktyaFljQlNmRnA5WE5iS2lWRE9EMmIrY3BlNC9aMTdtUW5idHp6aGFlUXRFMkdHajBJRE5UalJVU3lUeHh3L1JQSFcvK3ZTN2QxTmZSdDl6OVFQWmc0WDdRRmZoQ25rdmdOUElJdE9zQzJlVjZoUGFublpOSGxaOXhyd1pYSU1PbHUzalNvUVNxNzhXRWp3TGp3MUVMU2xGMWFCdmZ6d2s1Wlg3QVV2UXpqUFFLYkR1UStzbTR3Tk9wNEE2QWRWdVJTMHQxeS9EWnBnNFI2bTdGTmpNOUhndlc3Qmk4OHphTWpPbzZsTTh3dEJCZGo4TFA0eWx2M3pDWFBoZWJNS0pjMDY2bzlzRjcxb0ZXLzhKWHU4NkhKYndESUQ1bHp3NUdXTFIvTGhUMFFxbnAySlF4TlpOZmNiTEl6UHkrWXlwcVJtL2xCbUdtZXgrODIrUGlzeFV1bVNlSmtBTElUNnJKZXp4TUgrQ1RKbVF0dDV1d1RWYkwzcHRtakRVUXpsU0l2V2k4VGw3bmcxTnB1Um4xTmc0bjE0UWMrM0lpbDdPd2t2TldvZ0xTUGtuM3BpaElGeXR5SUdtTWhPZTNuMXRXc3VNeTlCZEt5cUY0WjN2MlNnZ2dUTDlLVnZNWFBuQ2JSZStvT3VGRlAzSGVqQkcvdzlndm1mTll2ZzZKdVdpYTJsY1NTTjF1SWpCa3R6b0lhek9IUEpaN2tLSFB6OG1SV1ZkVzNsQThXR0Y5ZFFGNkJtNjczYm9vdjNCVVdEVTJKTmNhaFIyM0d0ZkhLTE96L3ZpWityWW5aRmFJem5YTzY3Q1lFSjFmWHVUUnBaaFlaa0tlNTR4ZW9hZ2tOR0xzK05UWkhFMHJYNDUvWHZRMlJHQURYNnZjQXZkeElVQlYyN3d4R20yempabzRYM0lMZ0Fsck9GaGV1WjZ3dHN2YUlqNHlMWTdxcWF3bGxpYUljcnoyRytjM3ZzY0FuQ2tDdU16TW1adk1mdTlsTHdUdmZYKzNjVlN5UGROOVp3Z0RaaGZqUmdOSmNMaUo2N2I5eHg4Skhzd3ByYmlFM3Y5VXBob3RBUElnblhWSU41S21NYzBwaVhoYzZjQ2hQbk4rTVJoRzlhZHRkdHRRVFR3U0lwbDhJNC9qLy9kM3N6MTMyNnFUQlRwUFJNL0hnaDNrenFFWHM4WkFrNEVyUWhOTzhoenJRMERMa1dNQS9OKzkxdG4yTWRPSm5XQzJGQ1plaGtRcnd6d2JLT2podlpzYk05NVFvZUw5c2tZeU1mNHNyVlBWSlNnZzdwT0xVdHIvbjllVDk5b2U5bkx0RlJwakE5b2tWMktqOGg5azVIYUMwb2l2UkQ4VnlYa0o4MXRjZDRmSE5YUENmbG9JUWFzeHN1TzE4LzQ2ZFIyamd1bC9VSWV0Mkcwa1J2bnlPTk1LaEhzNkoyNkZFb3FTcWQrcmZZamVFR3dIV1ZEcFgxZmgxakJCY0tHTXFSZXBqdTlZMDBtRFZIQytYZGlqL2o0NHJLZnZmakdpbk5zMWpPLzBGM2pCODNYQ0RJTk4vSEI4NGF4bFArM0Uva2xrdFJvK3ZsM1UvYWl5TUpiSW9kRTFYU3NEbjZVQXpJb010VU9iWTIray80Z1kvbCtBa1pKNVNqMnZRcmt5TG0zRm94amhEWCszMVVYQkZmOVhyQUgzMWZGcW9CbURFWnZodnZwblo4N04rb1pFdTdVOU8vbm5rK1FXajN4OHV5b1JiRW5mK081VU1yOWkwbkhQMzhJRjVBdnpyQlc4WVdCVVIwbUlBekl2bmRRcTlOM3YvSnRvM2FQalBYVVBsOEFTZFBQeUFwN2pFTmY4Yms3Vk1NOW9sOVhHbWxCbWVETXVHcXQrV3p1TDZDWEF4WGpJaENQTTV2QUNjaGdNSi84WEJHTE8vRDFpc1Z2R2h3d0hIcjFETGFJNW1uMkpyL2IxcFVEOTB1Y2lEYVM4Y1hORHpDV3ZObVQvUGhRZTVlOG5Ubm5ua3Q4RHMvU0lqaWJjdW0vZnFEaEtvcHhBWThBa1NyUG4rSUdERUtPTytVM1hPUDZkakZzMkg1Tjkrb3JoT2FoaVFrNUtuRVVXYStDemtWemhwOGJNSFJiZzgxcWhqalh1SUtiSGpTTFNJQktXcW9ja0d0S2luWSt6NC9SZEJVRjZwY2MzSm1ubHhWY05nckk0U0V6S1VaU3djRDJRQ3l4ekt2ZStnQW1nNlp1U1JrcFBGYTZtZlRodTdMSk51M0g1SzQydUNwTnZQQXNvZWRvbEtWL0xIZS9lSitCYmFHNU1HME5hU0dWUFJVbU5GTUZGU1NwWEVjWHdiVmg3VUVUT1padG9WTlJHT0liYmtpZzNNY0V0UjY4Y0cwUlpBb0pldldZbzdEZy9sWjFDUXpibFdlVXZWSG1yOGZZNE5xZDlKSmlIL3pFWDI0bUp2aUg2MGZBeUZyMEEzYzRiQzFqM3laVTYwVmdKeFhuOEpnSlhMVUlzaUJubUttTVl6Kzd5QlFGQnZxYjJlWW51VzU5am9aQmY1Ni93WHZXSVI0Ujh3VG1WODBpMW1aeStTNCtCVUVTK2h6amswdVhwQy8vL3ovSWxxSFoxbW9uemxYcDhhQ2ZoR0tNdGk3M0ZJMUtiTDFxNklLTzRmdUJ1WjU5Z2Fnam41eFU3OW11TXBIWGc2UytlK2dETS9VOUJLTEhibDlsNm84Y3pRS2w0UlVrSkppcWZ0UUcyaTNCTWcvVFFsVVlGa0pEWUJPT3ZBdWdZdXpZU0RuWmJERGQvYVNkOXgwT2U2RitiSmNIZmw5K2dwNkw1L1RnQStCZEZGb3ZiZkNyUTQwczV2TVB3ODg2NnBOWDh6eUZHZUZXZHhJcFBWcDlSZzFVUE9WRmJGWnJ2YUZxL1lBekhRZ3FNV3BhaE1ZZnFIcG13WGZITDEva3BZbUd1SEZ3VDU1bVF1MGR5bGZOdXEyT3EwaFRNQ1B3cWZ4bnVCSVBMWGZjaTRZMUFOeSsxQ1VpcFF4bGQvaXpWaDE2V3lHMlEwQ1FROU5xdEFueDFIQ0h3RGo3c1l4T1NCMHdvcFpTbk96eFFPY0V4bXhyVlRGMkJrT3RoVnBHZnVoYUdFQ2ZDSnBKS3BqbmloWSt4T1QyUUp4TjYxKzlLNlFTcXR2MlNocjgySTNqZ0pycUJnMHdFTEZaUGp2SHB2elR0YUpuTEs2VmI5N1luOTMza29PL3NhTjdmc2p3Tkt6cDRsMmxKVngyb3JqQ0d6Qy80Wkw0ekN2ZXI2YVFZdEM1c2RveWNodUZFNnVmT2lvZytWV2k1VURrYm12bXRhaC8zYUFyRUJJaTM5czVJTFVubEZMZ2lsY0d1ejlDUXNoRVk3Zncyb3VvSUxBWVBWVC9neUFJcTNURkFJd1ZzbCtrdGtSei9xR2ZuQ0RHcm01Z3NsL2w5UWR2Q1dHc2pQejNkVTdYdXFLZmRVcnIvNlhJZ2pwNHJleTZBSkJtQ21VSk1qSVRIVmRGYjVtMXArZExNQ0w4dDU1ekQ0MmNtZnRtTEVKQzBEYTA0WWlSQ1ZVQkxMYThEMDcxL041VUJOQlhEaDBMRnNtaFYvNUI1RXhPQjRqM1dWRy9TM2xmSzVvK1Y2RUxIdnk2UlI5bjRhYytWc0s0VkU0eXBoUHZWK2tHOUZlZ1RCSDRaUlhMMkh5dFVIQ2R1SmF6Qi9LeWtqZmV0WXhPWFRMd3MyNjdhR09kK0krSmhLUC8vK1ZuWG1TOTBPRC9qdkxjVnUwYXN5cWN1WU4xbVNiNlhUbENrcXYxdmlnWlBJWXdORi96cFdjVDFHUi82YUVJUmpraDB5aGc0TFhKZmFHb2JZSlRZNEpJNThLaUFLZ21tZ0FLV2RsNW5ZQ2VMcWF2UkpHUU51WXVadFpGR3grSWtJNHc0TlMyeHdiZXROTXVuT2pCdS9obUtDSS93N3RmaWl5VWQvLzRyYlRlV3Q0aXpCWThZdkdJTjZ2eUtZbVAvOFg4d0hLQ2VOK1dSY0tNNzArdFhLTkd5ZXZVOUgyRGc1QnNsam5UZjhZYnNKMVRtTXM3NENlMlhsSGlzbGVndWh5ZWc0NHJRT0hadXcvNkhUa2hubnVySzJkNjJxNnlTNzIxMFNzQUlhUitqWE1RQStzdmtyTHBzVVkrRjMwVXc4OXVPZEdBUjZ2bzRGSU1FMEVmVlZlSFR1NmVLaWNmaFNxT2VYSmhiZnRjZDA4c1dFbk5VTDFDOWZucHJUZ2Q4M0lNdXQ4b25WVUYwaHZxelpmSGR1UGpiandFWEljb1lteStQNnRjSlpIbWVPdjZWcnZFZGtIREplY2pIdUhlV0FOZTc5Vkc2NjJxVGpBL0hDdnVtVnYzcUwrTHJPY3BxR3BzMlpHd1FkRko3UFU0aXV5UmxCcndmTyt4blB5cjQ3czJjWFZiV3pBeXpuRGlCR2pDTTNrc3hqanFNNjJHRTlDOGY1VTM4a0IzVmp0YWJLcC9uUmR2TUVTUEdERzkwYldSTEF0MVFrNUR5THVhelJSMVl6ZEMxYytoWlh2QVdWOHhBNzJTNEE4QjY3dmpWaGJiYTNNTW9wMjkzRmVFWHBlN3pJdE1XckpHL0xPSDlCeU9YbVluTkpmam1mdVg5S2JycGdMT2JhNG5aK2ZsOEdiZHYvaWh2KzZ3RkdLSENZclZ3bWhGQzBKM1YyYm4ydElCMXdDYzFDU1QzZDNYMk95eGhndVhjczRzbTY3OVVuZ3pvZnVTZUJld01GSmJvSVFIYlVoL20ySmhXMmhHOURJdkcydDd5Wkl6S0JUejl3QnRuTkMrMnBDUlloU0l1UTFqOHhzejVWdnFueVVJdGh2dW95eXU3Zk5JcmcvS1FVVm1HUWFxa3Faay9WeDViMzMvZ3NFczh5WDdTQzFKK05WNGljejZidklFN0M1RzZNY0JhSThyVmc1NnE1UUJKV3huLzg3UTFzUEs0K3NRYThmTFU1Z1hvNHBhYXE0Y09jUTR3UjBWQkhQR2pLaCtVbFBDYkExbkxYeUVVWDQ1cVo4SjcvTG40RlBKRTJUZHpEMFo4TUxTTlFpeWtNTW1TeU9DaUZmeTg0UnE2MGVtWUIydkQwOUtqWXdzb0lwZURjQkRURWxCYlh4TkQ3MnloZDlwQy8xQ01pZC81SFVNdkFMMjdPdGNJSkR6TktwUlBOcVBPcHl0MmFQR3o5UVdJczloUTlMaVg1czhtOWhqVFV1L2Y3TXlJYXRqamQrdFNmUTN1Zlp4UHBtSmhUYUJ0WnRLTFVjZk9DVXFBRHVPK1FvSDhCOXY2VStQMEhWMUdMUW10b05GVGIzczc0aXZaZ2pFUzBxZksrOFJkR2dCYmNDTVN5OGVCdmg5OCtldDFLSUZxU2UxS1FQeVhVTEJNVHNJWW55c0l3aVpCSllkSTIwdnNlVit3dUprY3FHZW1laEtqYUFiOUw1N3habTNnMnpYMGJaMnhrL2ZVK2JDbzdUbG5iVzdKdUYxWWRVUm8vMkd3N1ZjbERHMVc3TE90YXMyTFg0dXBpZlovMjNyenBzblkvQUxmUmdyY1dQNWhZbVY5VnhWT1FBMWZadnA5RjJVTlUrN2Q3eFJ5Vm01d2lMcDMvMGRsVjd2ZHcxUE1pWnJiREFZeklWcUVqUlkyWVUwM3NKaFBubHdJUGNaVUc1bHRMNlM4WEN4VTFlWVM1Y2pyMzR2ZUJtWEF2eTd5TjRaakFySUcwZGZELzVVcEJObFgxWlBveEpPd3lxUmkzd1FXdE96ZDRvTktoMExrb1RtOGN3cWdJZktocXFHT2h3bzcxSSt6WG5NZW1UdjJCMkFVekFCV3lGenRHZ0dVTGpERHpXWXdKVVZCVGpLQ241SzJRR01LMUNRVDdTenppT2pvK0JoQW1xQmp6dWMzeFl5bTJlZWRHZU9JUkpWeVR3RHczN2lDTWU0ZzVWYm5zYjVaQmR4T0FuTVQ3SFU0REhweFdHdVE3R2VpWTMwQ3BidnpzczU1KzVLbTFZc2JENWVhM05JOVFOWUlYb2w1YXBnU3U5ZFo4Zjh4UzVkdEhwaWRvNUJjbER1TFdZNGxoaWswdGJKYTA3eUpoSDBCT3lFdXQvR1JiWVRTNlJmaVRZV0dNQ2tOcGZTSGk3SHZkaVRnbEVWSEtaWGFWaGV6SDRra1hpSXZLb3BZQWxQdXNmdHBFNGE1SVp3dncxeC9lTHZvREloL3pwbzlGaVFJbnNUYjJTQWtLSFY0MlhZQmpwSkRnNDM3NFhpVmIzd3M0cU0wczllU1E1SHpzTVU0T1pKS3VvcEZqQk0rZEFaRWw4UlVNeDV1VTJONDg2S3IxNDF0VnNHUWZHak9SWU1DSkFNc3hFTGVOVDRSbVdqUmNwZFRHQndjeDZYTjlkcldxUG1KemNyR3JINCtEUmM3K24xdzNrUFp3dTBCa05yNmhRcnFnbzdKVEI5QTVrZEovSDdQNGNXQk13c211aXhBekpCM3lyUXBuR0lxOTBseEFYTHpEQ2RuMUxQaWJzUnQ3ckhOamdRQmtsUmdQWjh2VGJqWGRnWHJUV1FzSzVNZHJYWFFWUHAwUmlucTNmcnpaS0owcUQ2UWhjNDBWekFyYVVYbG9iMWd2a2hLM3ZwbUhnSTZGUmxRWk54NmVScWtwMHp5NEFRbFg4MTNmQVB0TDNqTVJhaXRHRkZqbzB6bUVybG9DK2grWVlkVlE2azRGL2VweEFvRjBCbXFFb0tOVHQ2ajR2UVpOUTJCb3FGOVZqNTNUT0lvTm1EaXU5WHAxNVJrSWdRSUdjb0xwZm9JYmVuenBHVUF0cUZKcDVXK0xMbngzOGpIZUVDVEovbmF2S1kxTldmTjBzWTFUOC9wQjhrSUgzRFUzRFgrdTZXM1l3cHlwQk1ZT2hiU3hHanE4NFJaODRmV0pvdzhweUhxbjRTLzlKMTVFY0NNc1hxcmZ3eWQ5bWhpdTMrckVvOXBQcG9Ka2RacUhqcmE0TnZ6Rnd1VGhOS3k2aGFvL1NsTHczWkFEVWNVcDN3M1NSVmZXMnJobDgwek9nVFluS0UwSHMycXAxSjZIM3hxUHFJa3ZVRFJNRkRZeVJic0ZJM005TUV5b3ZQazhybHc3LzBhODFjRFZMbUJzUjJ6ZTJwQnVLYjIzZmJlWkMwdVhvSXZEcHBmVHdJRHhrMU9xMmRHZXNHYytvSlhXSkxHa09oYTNDWCtEVW56Z0FwOUhHSDlSc1BaTjYzSG40Uk1BNWVTVmhQSE8rOVJjUmIvSU9ndFczMVYxUTVJUEd0b3hQakMrTUVKYlZsSU1ZQURkOWFIWVdVSVFLb3B1UE9IbW9xU2t1Ym5BS256Z0tIcWdJT2ZXNVJkQWdvdE42Qk4rTzJaWUhrdWVtTG52UThVOVRIVnJTMVJ0TG1LYmNDN1BlZURzWXpudnF6ZWc2VkNOd21yMFl5eDF3bkxqeVQ4NEJaejNFSnlDcHREM3lldWVBeURXSXMwTDJxcy9WUTNIVXlxZnJqYTBWMUxkRHpxQWlrZVd1VjRzYzdSTElCNjlqRUlCakNreVplZG9VSHFDck92U2hWenlkNzNPZHJKVzBoUE91UXYycU9vSERjOXhWYjZZdTZ1cTNYcXAyWmFINDZBN2x6ZXZieFFFbWZyenZBWVNKdVo0V0RrMUh6M1FYMUxWZGlVSzBFdmxBR0FZbEczTWQzMHI3ZGNQTjYzeXFCQ0lqMjVwcnB2WlAwbkk0K0VnV29GRzk1VjU5NkN1clhwS1JCR1JqUWxIQ3Z5NUliL2lXOG5aSld3ckVUM21nZDZtRWhmUDRLQ3VhTGpvcFdzN2grTWRYRmRJdjhkSFFKZ2cxeGkxZVlxQjB1RFlqeHdWbXJpMFN2NVhLdXQvb25xYXBDK0ZRaUMyQzFsdllKOU1WY282eURZc1MzQUFOVWZNdHZ0YllJMmhmd1phdGlTc25vVWVNWmQzNEdWamtNTUtBK1huakpwWGdSVzJTSFRacGxWb3dQbUpzdlh5NnczY2ZPMUFLMmR2dFpFS1RrQy9UWTlMRmlLSENHMERuck1RZEdtMmx6bEJITTlpRVl5bkgyVWNWTWhVRWpzYzBvREJUZ28yWlNRMWd6a0FIZVdlQlhZRmpZTHV1Zjh5elRDeTcvUkZSODFXRGpYTWJxMkJPSDVkVVJueG82b2l2bXhMM2NLektJbmxaa0QzMW52cEhCOUtrN0dmY2ZFMXQrMVY2NGI5THRnZUpHbHBSRnhRQ0FxV0o1RG9ZNzdza2k4Z3NPRU9yMnV5d1phb08vTkdhMFgweTFwTlFIQmkzYjJTVUdOcGNaeERUN3JMYkJmMUZTblE4Z3V4R1czVyszNkJXMGdCamU0RE96NkJhNlNWazB4aUtndCtxMkpPRnlyNFNZZm51K0ljMVFaWUl1d0hCcmd6cjZVdk9jU0N6UFRPbzdENklDNElTZVM3emtsNGgrMlZvZUhwbkcvdVdSMyt5c05nUGNPSVhRYnYwbjRtcjNCd1FjZEtKeGdQU2V5dVAvejFKamc0ZTluVXZvWGVncVFWSUUzMEVIeDVHSHYrRkFWVU5Ub3dZREpneUZoZjVJdmxZbUVxUmlmNitXTjFNa0VKbURjUUlUeDlGWDIzYTRteHkxQVFSc09ITy8rZUltWDlsOEVNSkkzb1BXelZYeFNPZUhVMWRVV1lyMnVBQTdBTWIrdkFFWlNiVTNxb2I5aWJDeVhleXBFTXBaNjg2M282UVBxbHFHSFprdVdBQlNUVk5kNGNPaDlodjNxRXBTeDJaeS9ESk1QNmNJdEVtaUJKNVBGcVFuREVJdDNOckEzQ09sT1NnejQzRDdncE5GTko1TUJoNG9GemhEUGlnbEMyeXBzTlU0SVN5d1kyZXJreWIxTkMzUWgvSWZXajBlRGdaSTQvbG44V1BmQnNUM21lVGpxMVVxdDFFN1psL3FmdHFreDZhTTlLdWVNQ2VrU25NcmNIajFDcVRXV3pFelBzWkdjRGUzVWU0V3MrWEZZVnhOYk9GRjhlemt2UUdSNlpPdE9MVTJsUUVuTUJTdHg0N3ZFNlBiN0FZTUJSajJPT2ZaWGZpc2pKbnBUZlNOam82c1o2cVN2TnhaTm1EZVM3R2szeVl5Q2sxSHRLTjJVbmhNSWpPWFV6QXFEdjkwbHg5Ty9xL0FUMVpNbml0NVhRZTl3bVF4bkUvV1NIMENxWjkvMkh5K1NmbXBlZzhSd3NISTVaOGtDOEgyOTNtL0xIVlZNL0JBN0hhVEpZZzVFbms3TS94V3BxMDE5MkFDZkJhaTJMQS9xckNqQ3I2RGgxQklNek1YSU5CbVg5Nk1KNUhuMm54bG4vUlhQRmh3SHhVbVNWMEVWMlYwam04Ni9keHh1WVNVMVc3c1ZrRWJOOUV6a0cwUUZ3UGh5SEt5YjN0K0ZqNVdvVVVURXJjYXpFL042RVc2THZwMGQvL1NEUGo3RVY5VWRKTitBbW5mM1d3azNBMFNsSjlaMDB5dlhaN24zejcwRzQ3SGZzb3c4V3ExSlhjZnduQStZeGE1bUZzZ1Y0NjRLS1A0VDMxd3FJZ3pGUGQzZUNlM2o1b3J5NWZCRjJoZ0NGeVZGckx6STllZXROWHZNN29RcXlGZ0RvNENUcC9oRFY5Tk1YOUpESFEvbnlIVEx2WkxOTEY2ZnRuMk94akdtOCtQcU93aHhuUEhXaXBrRS84d2J0eXJpODBTcjdwTU5rUUdNZm80WllLOU9jQ0M0RVNWRkZiTE1Jdmx4U29ScVdpZTB3eHFuTGZjTFNYTVNwTU1RRUpZRFZPYllzWElRTnY0VEdOd2pxMWt2VDFVT2tpY1RyRzNJYUJaM1hkU2NTM3U4c2dlWlBWcE9Ma2JpRjk0MEZqYkNlTlJJTk52RGJkMDFFUEJyVENQcG0xMm00M3plMWJCQjU5SWE2T3ZobnVyL052eDNJeHdTV29sKzNIMnFmQ0pSOGRmNmFRZjR2NldpT054a0srSXFUNHBLUXJaSy9McGxnREkvUEpaYk9lcDhkdGJWN29DcjZDZ2ZwV2E4TmN6T2tQeDgxaVNIYnNOaFZTSkJPdHJMSU1yTDMxTEs5VHFIcUFiQUhlMFJMbW1WODA2a1JMRExORWhVRUpmbTl1MHN4cGtMOTNaZ2Q2cncrdHFCZlRNaTU5eHFYSExYU0h3U2JTQmwwRUswK2xvRUNPUHRybCsvbnNhRmUxOTdkaTR5VWdvZTRqS29BSkRYYzZER0RqclFPb0ZEV1pKOUhYd3Q4eERyUVArN2FSd1dLV0kxR0Y4czhPNEt6eFdCQmN3bmwzdm5sMU9lejNvaDZFYTF2alI3L3o3RERUckZ0cVUyVy9LQUV6QXVYRE5aN01ZNzNNRjIxNmR6ZFNiV21VcDRsY203a2VKZldhTUhndXQ5eDVDOW1qNjZaMGxKK3loc2pWdnlpV3JmazFselBPVGRoRzE1WTdnUWxYdGFjdkk3cXYvWE5Tc2NEd3FrZ3dIVC9nVXNENXlCN0xkUlJ2SnhRR1lJTm45aFRwb2RLRlZTVFBydEd2eVF3K0hsUkZYSWtvZEVyQUd1OUl5MVlwZlNQYzNqa0ZoNUNYM2xQeHY3YXFqRS9KQWZUSXBFakdiL0g3TU8wZTJ2c1ZpU1cxcWEvTG1pNC9uNERFSTNnN2xZcmNhbnNwRGZFcEtrZFYxT2pTTE95MEJDVXFWb0VDYUI1NXZzMDZyWGw0anFtTHNQc0ZNLzd2WUowdnJCaERDbS8wMEEvSDgxbDF1ZWtKLzZMbWwzSGI5K05LaUxxQVRKbURweXpmWVpGSHVtRWpDNjYyTDBCd2t4aTdFOVU0Y1FBMFhNVkR1TVlBSWVMTVBnUWFNVk9kOGZtdDVTZmxGSWZ1Qm9zemVBdzdvdzVnWFBFMlkveUJjLzdqRXhBUlVmL0J4SUhRQkY1U24zaTYxdzR6NXhKZEN5TzFGMVgzKzNheCtKU3ZNZVo3UzZRU0twMUZwL3NqWXo2WitWZ0NaemliR2VFb3VqcnlmTXVsSDdSYWk1a0FmdDllYmNXNTBEeUpyMnVvMno5N21UV0l1NDVZc1NuTlNNcnJOVXVHMVhzWUJ0RDlURFl6UWZmS0I4N3ZXYmtNNEViUEFGZ29CVjRHUVMrdnRGRFVxT0ZBb2kxblR0bUlPdmczOE40aFQyU244cjhjbG1CQ1hzcEJsTUJZVG5ycUZKR0JUM3daT3pBeUpEcmU5ZEhINyt4N3FhYUtET0I0VVFBTEQ1ZWNTMERFNG9idWJRRWl1SlowRXBCVnBMdVljY2U4QWE0UFlkL1Y0RExEQUpCWUtRUENXVGNyRWFaNUhZYkppMTFHZDZoakdvbTFpaTE4VkhZbkcyOE5LcGt6MlVLVlB4bGhZU3A4dVpyMzY3aU9tb3k3enN4ZWhXOXd6Y3kyekcwYTgwUEJNQ1JRTWIzMmhuYUhlT1I4Zm5ORHpaaGFOWWhrT2REc0JVWjNsb0RNYTFZUDB1UzBjalVQM2IvNkRCbHFtWk9lTkFCRHNMbDVCSTVRSnVwczh1eEF1V0pka1VCL3BPNlpheDZ0c2c3Zk41bWpqRGdNR25nTytEUGNLcWlISURiRklHdWR4dFBUSXlEaTlTRk1LQkRjZmRHUVJ2NDFxMUFxbXhna1ZmSk1uUDh3L0JjN045L1RSNkM3bUdPYkZxRmtJRW9tOHNLaTJ4WXFKTFRDSEs3Y3h6YVp2cU9EbzIyYzN3aXNCQ1A0SGVBZ2NSYk5QQXNCa05SaFNtRDQ4ZEh1cGRCUnc0bUl2dFM1b2VGNnplVDFLTUN5aE1ubWhwa0ZBR1duR3Njb05rd3ZROFpNNWxFL3ZnVEhGWUw5OU91TnhkRkJ4VEVEZDV2MnFMUjh5OVdrWHNXZ0c2a1pObmRGRytwTy9VQWtPQ2lwcUloTDNocTdjUlNkckNxN1loVXNUb2NFY25hRmE2blZraG5TZVJZVUExWU8wejVpdEY5U2x5M1ZseFlEdzIzOVRKSkg2ZjNFVWZZTzVsYjdiY0ZjejhCcDdPbzhRbW5zVUhPei9mYWdWVUJ0S0V3MWlUODhqK2FLa3Y4Y3NjS05rTXhqWXI4MzQ0RDFrRm9aNy90ZDFXNkxDTllONTk0MzAxdFVHUm1GakF6ZVJnNXZ5b00xRjYrYkpaL1E1NGpOL2s4U0ZkM0R4UFRZYUFVc2l2c0JmZ1RuN014OEgyU3BQdDRHT2RZUm5FSk9INmpITTJwNlNnQjBneklScTZmSHhHTW1TbXFhUENtbGZ3eGl1bG9hVklpdExHTjh3aWUyQ0RXaGt6TG9DSmNPRGg3S0lPQXFiSEV2WGRVeGFTNFRUVHMwN0NsemovNkdtVnM5a2laRGVyTXhFbmhVQjZRUVBsY2Zxa0c5ODgyUnFIb0xpSEdCb0hmUXVYSXNBRzhHVEF0YW8yS1Z3Um52dmFtOGpvMWUzMTJHUUFLV0VhNHNVVkVBTUc0RzZja2NPTkR3UmNnMWUyRDMrb2hYZ1k0VUFXRjh3SEtRTXJTbnpDZ2ZGcHN4aCthSFhNR3RQUXJvUWFzUlk0VTZVZEcwcnoxVmpia2EwTWVrT0dSWlFFdnFRRmx4c2VGb3I4eldGZ0hlazN2MjkrV3FONmdhSzVnWk9UT01aenBRSUMxMjAxTGtNQ1hpbGQzdldYU2M1VVg5eGNGWWZiUlB6R0ZhMUZEY1BmUEIvalVFcS9GZUd0NDE5Q0kzWW1CbFZvSHNhNEtkY3dRUDVaU3dISGhGSjcvUGgvUmFwLzR2bUc5MWVEd1BQMGxEZkNEUkNMc3pUcWZ6TTcxeHBtaUtpMkh3UzRXbHF2R053dHZ3RjVEcXBuNktUcThheDAwVU1Qa3hEY1pyRUVFc0l2SGlVWFhFcGhkYjRHQjRGeW1sUHdCejRHcGVycXE1cFc3VFE2L3lOUmhXOFZUNU5odVAwdWRseG80Z0lMcTVaeEFaazhaR2gzZzRDcXhKbFBLWTdBUXh1cGZVY1ZwV1Q1Vkl0cDErMzBVcW95UDR3V3NSbzNvbFJSZ2tXWloyWk42VkMzT1pGZVhCOE5iblVyU2Rpa05wdEQxUWlHdUtrcjhFbVNSL0FLOVJ3K0ZGM3M1dXd1UGJ2SEdpUGVGT1ZpbHRNSzdBVWFPc3E5K3g5Y25kazNpSkVFNUxLWlJsV0piS09ad2VST3ptUE5WUGtqRTNLL1R5QTU3UnM2OFRrWjNNUjhha0twbTdjRmpualBkL0Rka1dqZ1lvS0hTcjVXdTVzc29CWVU0YWNSczVnMkRIeFVtZHE4VlhPWFJidW5EOFFOMExoZ2tzc2dhaGNkb1lzTnZ1WEdVSy9LWEQvN29GYitWR2RocUluMDJ2ZXVNNWJMdWRKT2MyS3kwR01hRzRXL3hXQnhJSmNMN3lsaUpPWE9weDBBa0JxVWd6bERjem1MVDRpSUxYRHh4dFJSMW9aYTJKV0ZnaUFiNDNvYnJKbkcvVFpDMktTSzJ3cU96UlpUWGF2WlpGTWIxZjNiWHZWYU5hSzgyOHc5VE82MTBnazhKTmYzZ01mRVR6WFhzYmN2UkdDRzlKV1FaNitjRFBxYzQ0NjZZbzJSY0tIK1BJTGVLT3F0bmxiSW5SM01tQmVHRzNGSDEweXpreWJ1cUVDMkhTUXdwQTBBbjdkOSs3M0JrRFVUbTMwYlptb1AvUkdiZ0ZOK0dyQ09mQURncXIwV2JJMWExb2twRm1zOGlIWXc5aG0welV2bEVNaXZCUnhNb2RyYkpKKzkvcDNqVWRRUTlCQ3RRZHhuT0dyVDVkelJVbXcwNTkzL21iUlNkQmcwblJ2UlpNNS9FMTZtN1pIbURFdFdod3ZmZFpDWjhKOE0xMlcweVJNc3pYYW1XZlFUd0laNGF5WWt0cm5zY1F1V3I4aWRwM1BqVDJlRi9qbXRkaElmY3BNbmIrSWZaWTJGZWJXNlVZL0FLM2pQNHUzVHU0ekU0cWxuUWdMRmJNMTlFQklzTmY3S2hqZGJxUS9ENnlpRGIrTmxFaTJTS0QraXZYVlVLOGliMG9CbzM2NmdYa1I4WnhHanBKSURjRWdaUGE5VGNZZTBUSWJpUGwvclBVUUR1M1hCSjlYL0dOcTNGQVVzS3NsbDU3RHphR01yamNUK2djdHArOU1MWVhDcStzcVA4MWVWUTByOWx0K2djUWZaYkFDUmJFanZsTXNrenRaRzhnYkM4UW45dHQyNlE3eTduRHJiWnEvTEV6N2tSNkpjNnBnM045clZYOFk1TUpyR2xNTDlwOWxVNGpiVGtLcUN2ZWVaVUpqSEIwM20yS1JLUjJUeXRvRmtUWE9MZzdrZVUxczFsclBNUUpwb09LTHVBQUMreTFIbEp1Y1U2eXNCNWhzWGh2U1BQTHE1SjdKdG5xSEtaNHZZakM0Vnk4MTUzUVkrNjc4MHhEdUdBUnNHYk9zMVdxekgwUVM3NjVyblNLRWJiS2xrTzhvSS9WRHdVZDBpczEzdEtwcUlMdTFtREpGTnkvaUpBV2N2RGdqeHZ1c0lUK1BHejNTVC9KOXI5TXRmZDBqcGFHZWlMWUlxWGM3RGlIU1M4VGNqRlZrc2k2NlBFa3hXMXo2dWpiTExVR05OWW56T1dwSDhCWkdLNGJDSzdpUitNYkl2OG5jREF6MXU0U3ROM3ZUVHpld3I5SVFqazl3eEZ4bis2TjFkZEtzMHZmZkppUzA4TjNhNEcxU1ZybFo5N1EvTSs4RzlmZTVBUDZkOS9RcTRXUm5PUlZob2ZQSUtFZENyM2xsc3BVZkUwb0tJSVlvQnlCUlBoK2JYMUhMUzNKV0dKUmhJdkUxYVc0TlRkOGVQaTRaK2tYYitaOHNuWWZTTmNxaWpoQWdWc3g0UkNNNTRjWFVpWWtqZUJtbUM0YWpPSHJDaG9FTHNjSkpDNys5ampNanc1QmFnWktsZ1JNaVNOWXo3aDd2dlpJb1FxYnRRbXNwYzBjVWsxRy83M2lYdFNwUk9sNXd0TGdRaTBtVzJFeDhpM1dVTGhjZ2d4NkUxTE1WSFVzZGM5R0hJMVBIM1UyS28wUHlHZG45S2RWT0xtN0ZQQnVpMGk5YTBIcEE2ME1zZXdWRTR6OENBdDVkNDAxR3Y2elhsSVQ1WWJpdDFWSUEwRkNzN3d0dllyZXJ1MWZVeVczb0xBWi8rYVRuWnJPY1lSTlZBOHNwb1J0bFJvV2Zsc1JDbEZjZ3prcWlIT3JmMC9TVncrRXBWYUZsSjBnNEt4cTFNTU9taVFkcE1OcHRlOGxNTVFxbTZjSUZYbG5HYmZKbGx5c0tEaSswSkpNb3RrcWdJeE9TUWdVOWRuL2xXa2VWZjhuVW0zaXdYMk5sM1dEdzlpNkFVSzN2QkFiWlpyY0pwRFEvTjY0QVZ3alQwN0plZjMwR1NTbXROdTJXbFc3WW95VzJGbFdmWkZRVXdrODY3RWRMWUtrOVZHNkpnRW5CaUJ4a1k3TE1vNFlMUUpKbEFvOWwvb1R2SmtTQVJERi9YdHlBek04TzJ0M2VUL2lYYTZ3RE4zV2V3Tm1RSGRQZnN4Q2hVL0t0TEcyTW44aTRacUtkU2xJYUJaYWR4Sm1SelZTL280eUE2NVJUU1ZpcTYwb2EzOTVMcXcwcHpZNFNpcHdFMFNYWHNLVitHWnJhR1Nrci9SVzA4d1BSdnF2U1VrWUJNQTlsUHg0bTI0YXorSUhtQ2JYQSswZmF4VFJFOXd1R2VPMDZESVhhNlFsS0ozcHVJeWl1QVZmUHI3MzZ2em8ycEJpclMrVnhlbDNUTW0zSktoejlvMlpvUnZhRlZwSWt5a2IwSGNtNG9IRkJNY05TTmo3LzRHSnQ0M29nb25ZMlZnNG5zRFFJV3hBY29ycFhBQ3pnQnFRUGpZc0UvVlVwWHB3Tk1hbkVydTROd01DRlBrWHZNb3F2b2VMTjNxeXUvTjFlV0VIdHRNRDY1djE5bC8wa0gybVIzNWl2L0ZJK3lqb0hKOWdQTXo2N2FmM01xL0JvV1hxdTNycGhpV01YVmttblBTRWtwR3BVSTJoMU1UaGlkZUdGRU9LNllaSFB3WXpNQnZwTkM3K1pIeFBiN2VwZmVmR3lJQjRKek85RFRORVluRExWVkhkUXl2T0VWZWZyazZVdjVrVFFZVllXV2RxcmRjSWw3eWxqd3dJV2RmUS95KzJRQjNlUi9xeFlPYnVZeUI0Z1RibzJpbjRQemFyVTFzTzluRVRrbWo5L0FveERBK0pNM0dNcVF0SlI0anRkdUh0bm9DTHhkMWdRVXNjSFJCL01vUllJRXNQMnBEWjlLdkhndGxrMWlUYldXYkhob2h3RkVZWDd5NTFmVVYybnVVbW5vVWNxbldJUUFBZ2w5TFRWWCtCYzBRR05FaENoeEhSNFlqZkU1MVBVZEdmc1NGRTZjazdCTDMvaFRmOWpMcTRHMUlhZklOeE9MS2VBdE83cXV1bFl2SDVZT0JjK3pYN0NyTWdXblc0Ny9qZlJzV25KallZb0U3eE1mV1YySE4yaXlJcUxJJztcbmNvbnN0IEZFTkNFRCA9IG5ldyBNYXAoW1s4MjE3LFwiYXBvc3Ryb3BoZVwiXSxbODI2MCxcImZyYWN0aW9uIHNsYXNoXCJdLFsxMjUzOSxcIm1pZGRsZSBkb3RcIl1dKTtcbmNvbnN0IE5TTV9NQVggPSA0O1xuXG5mdW5jdGlvbiBkZWNvZGVfYXJpdGhtZXRpYyhieXRlcykge1xyXG5cdGxldCBwb3MgPSAwO1xyXG5cdGZ1bmN0aW9uIHUxNigpIHsgcmV0dXJuIChieXRlc1twb3MrK10gPDwgOCkgfCBieXRlc1twb3MrK107IH1cclxuXHRcclxuXHQvLyBkZWNvZGUgdGhlIGZyZXF1ZW5jeSB0YWJsZVxyXG5cdGxldCBzeW1ib2xfY291bnQgPSB1MTYoKTtcclxuXHRsZXQgdG90YWwgPSAxO1xyXG5cdGxldCBhY2MgPSBbMCwgMV07IC8vIGZpcnN0IHN5bWJvbCBoYXMgZnJlcXVlbmN5IDFcclxuXHRmb3IgKGxldCBpID0gMTsgaSA8IHN5bWJvbF9jb3VudDsgaSsrKSB7XHJcblx0XHRhY2MucHVzaCh0b3RhbCArPSB1MTYoKSk7XHJcblx0fVxyXG5cclxuXHQvLyBza2lwIHRoZSBzaXplZC1wYXlsb2FkIHRoYXQgdGhlIGxhc3QgMyBzeW1ib2xzIGluZGV4IGludG9cclxuXHRsZXQgc2tpcCA9IHUxNigpO1xyXG5cdGxldCBwb3NfcGF5bG9hZCA9IHBvcztcclxuXHRwb3MgKz0gc2tpcDtcclxuXHJcblx0bGV0IHJlYWRfd2lkdGggPSAwO1xyXG5cdGxldCByZWFkX2J1ZmZlciA9IDA7IFxyXG5cdGZ1bmN0aW9uIHJlYWRfYml0KCkge1xyXG5cdFx0aWYgKHJlYWRfd2lkdGggPT0gMCkge1xyXG5cdFx0XHQvLyB0aGlzIHdpbGwgcmVhZCBiZXlvbmQgZW5kIG9mIGJ1ZmZlclxyXG5cdFx0XHQvLyBidXQgKHVuZGVmaW5lZHwwKSA9PiB6ZXJvIHBhZFxyXG5cdFx0XHRyZWFkX2J1ZmZlciA9IChyZWFkX2J1ZmZlciA8PCA4KSB8IGJ5dGVzW3BvcysrXTtcclxuXHRcdFx0cmVhZF93aWR0aCA9IDg7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHJlYWRfYnVmZmVyID4+IC0tcmVhZF93aWR0aCkgJiAxO1xyXG5cdH1cclxuXHJcblx0Y29uc3QgTiA9IDMxO1xyXG5cdGNvbnN0IEZVTEwgPSAyKipOO1xyXG5cdGNvbnN0IEhBTEYgPSBGVUxMID4+PiAxO1xyXG5cdGNvbnN0IFFSVFIgPSBIQUxGID4+IDE7XHJcblx0Y29uc3QgTUFTSyA9IEZVTEwgLSAxO1xyXG5cclxuXHQvLyBmaWxsIHJlZ2lzdGVyXHJcblx0bGV0IHJlZ2lzdGVyID0gMDtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykgcmVnaXN0ZXIgPSAocmVnaXN0ZXIgPDwgMSkgfCByZWFkX2JpdCgpO1xyXG5cclxuXHRsZXQgc3ltYm9scyA9IFtdO1xyXG5cdGxldCBsb3cgPSAwO1xyXG5cdGxldCByYW5nZSA9IEZVTEw7IC8vIHRyZWF0IGxpa2UgYSBmbG9hdFxyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdmFsdWUgPSBNYXRoLmZsb29yKCgoKHJlZ2lzdGVyIC0gbG93ICsgMSkgKiB0b3RhbCkgLSAxKSAvIHJhbmdlKTtcclxuXHRcdGxldCBzdGFydCA9IDA7XHJcblx0XHRsZXQgZW5kID0gc3ltYm9sX2NvdW50O1xyXG5cdFx0d2hpbGUgKGVuZCAtIHN0YXJ0ID4gMSkgeyAvLyBiaW5hcnkgc2VhcmNoXHJcblx0XHRcdGxldCBtaWQgPSAoc3RhcnQgKyBlbmQpID4+PiAxO1xyXG5cdFx0XHRpZiAodmFsdWUgPCBhY2NbbWlkXSkge1xyXG5cdFx0XHRcdGVuZCA9IG1pZDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFydCA9IG1pZDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHN0YXJ0ID09IDApIGJyZWFrOyAvLyBmaXJzdCBzeW1ib2wgaXMgZW5kIG1hcmtcclxuXHRcdHN5bWJvbHMucHVzaChzdGFydCk7XHJcblx0XHRsZXQgYSA9IGxvdyArIE1hdGguZmxvb3IocmFuZ2UgKiBhY2Nbc3RhcnRdICAgLyB0b3RhbCk7XHJcblx0XHRsZXQgYiA9IGxvdyArIE1hdGguZmxvb3IocmFuZ2UgKiBhY2Nbc3RhcnQrMV0gLyB0b3RhbCkgLSAxO1xyXG5cdFx0d2hpbGUgKCgoYSBeIGIpICYgSEFMRikgPT0gMCkge1xyXG5cdFx0XHRyZWdpc3RlciA9IChyZWdpc3RlciA8PCAxKSAmIE1BU0sgfCByZWFkX2JpdCgpO1xyXG5cdFx0XHRhID0gKGEgPDwgMSkgJiBNQVNLO1xyXG5cdFx0XHRiID0gKGIgPDwgMSkgJiBNQVNLIHwgMTtcclxuXHRcdH1cclxuXHRcdHdoaWxlIChhICYgfmIgJiBRUlRSKSB7XHJcblx0XHRcdHJlZ2lzdGVyID0gKHJlZ2lzdGVyICYgSEFMRikgfCAoKHJlZ2lzdGVyIDw8IDEpICYgKE1BU0sgPj4+IDEpKSB8IHJlYWRfYml0KCk7XHJcblx0XHRcdGEgPSAoYSA8PCAxKSBeIEhBTEY7XHJcblx0XHRcdGIgPSAoKGIgXiBIQUxGKSA8PCAxKSB8IEhBTEYgfCAxO1xyXG5cdFx0fVxyXG5cdFx0bG93ID0gYTtcclxuXHRcdHJhbmdlID0gMSArIGIgLSBhO1xyXG5cdH1cclxuXHRsZXQgb2Zmc2V0ID0gc3ltYm9sX2NvdW50IC0gNDtcclxuXHRyZXR1cm4gc3ltYm9scy5tYXAoeCA9PiB7IC8vIGluZGV4IGludG8gcGF5bG9hZFxyXG5cdFx0c3dpdGNoICh4IC0gb2Zmc2V0KSB7XHJcblx0XHRcdGNhc2UgMzogcmV0dXJuIG9mZnNldCArIDB4MTAxMDAgKyAoKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDE2KSB8IChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCA4KSB8IGJ5dGVzW3Bvc19wYXlsb2FkKytdKTtcclxuXHRcdFx0Y2FzZSAyOiByZXR1cm4gb2Zmc2V0ICsgMHgxMDAgKyAoKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDgpIHwgYnl0ZXNbcG9zX3BheWxvYWQrK10pO1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiBvZmZzZXQgKyBieXRlc1twb3NfcGF5bG9hZCsrXTtcclxuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIHggLSAxO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHRcclxuXHJcbi8vIHJldHVybnMgYW4gaXRlcmF0b3Igd2hpY2ggcmV0dXJucyB0aGUgbmV4dCBzeW1ib2xcclxuZnVuY3Rpb24gcmVhZF9wYXlsb2FkKHYpIHtcclxuXHRsZXQgcG9zID0gMDtcclxuXHRyZXR1cm4gKCkgPT4gdltwb3MrK107XHJcbn1cclxuZnVuY3Rpb24gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQocykge1xyXG5cdHJldHVybiByZWFkX3BheWxvYWQoZGVjb2RlX2FyaXRobWV0aWModW5zYWZlX2F0b2IocykpKTtcclxufVxyXG5cclxuLy8gdW5zYWZlIGluIHRoZSBzZW5zZTpcclxuLy8gZXhwZWN0ZWQgd2VsbC1mb3JtZWQgQmFzZTY0IHcvbyBwYWRkaW5nIFxyXG4vLyAyMDIyMDkyMjogYWRkZWQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvaXNzdWVzLzRcclxuZnVuY3Rpb24gdW5zYWZlX2F0b2Iocykge1xyXG5cdGxldCBsb29rdXAgPSBbXTtcclxuXHRbLi4uJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXS5mb3JFYWNoKChjLCBpKSA9PiBsb29rdXBbYy5jaGFyQ29kZUF0KDApXSA9IGkpO1xyXG5cdGxldCBuID0gcy5sZW5ndGg7XHJcblx0bGV0IHJldCA9IG5ldyBVaW50OEFycmF5KCg2ICogbikgPj4gMyk7XHJcblx0Zm9yIChsZXQgaSA9IDAsIHBvcyA9IDAsIHdpZHRoID0gMCwgY2FycnkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRjYXJyeSA9IChjYXJyeSA8PCA2KSB8IGxvb2t1cFtzLmNoYXJDb2RlQXQoaSldO1xyXG5cdFx0d2lkdGggKz0gNjtcclxuXHRcdGlmICh3aWR0aCA+PSA4KSB7XHJcblx0XHRcdHJldFtwb3MrK10gPSAoY2FycnkgPj4gKHdpZHRoIC09IDgpKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuLy8gZWcuIFswLDEsMiwzLi4uXSA9PiBbMCwtMSwxLC0yLC4uLl1cclxuZnVuY3Rpb24gc2lnbmVkKGkpIHsgXHJcblx0cmV0dXJuIChpICYgMSkgPyAofmkgPj4gMSkgOiAoaSA+PiAxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZF9kZWx0YXMobiwgbmV4dCkge1xyXG5cdGxldCB2ID0gQXJyYXkobik7XHJcblx0Zm9yIChsZXQgaSA9IDAsIHggPSAwOyBpIDwgbjsgaSsrKSB2W2ldID0geCArPSBzaWduZWQobmV4dCgpKTtcclxuXHRyZXR1cm4gdjtcclxufVxyXG5cclxuLy8gWzEyM11bNV0gPT4gWzAgM10gWzEgMV0gWzAgMF1cclxuZnVuY3Rpb24gcmVhZF9zb3J0ZWQobmV4dCwgcHJldiA9IDApIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB4ID0gbmV4dCgpO1xyXG5cdFx0bGV0IG4gPSBuZXh0KCk7XHJcblx0XHRpZiAoIW4pIGJyZWFrO1xyXG5cdFx0cHJldiArPSB4O1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0cmV0LnB1c2gocHJldiArIGkpO1xyXG5cdFx0fVxyXG5cdFx0cHJldiArPSBuICsgMTtcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZF9zb3J0ZWRfYXJyYXlzKG5leHQpIHtcclxuXHRyZXR1cm4gcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7IFxyXG5cdFx0bGV0IHYgPSByZWFkX3NvcnRlZChuZXh0KTtcclxuXHRcdGlmICh2Lmxlbmd0aCkgcmV0dXJuIHY7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8vIHJldHVybnMgbWFwIG9mIHggPT4geXNcclxuZnVuY3Rpb24gcmVhZF9tYXBwZWQobmV4dCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHcgPSBuZXh0KCk7XHJcblx0XHRpZiAodyA9PSAwKSBicmVhaztcclxuXHRcdHJldC5wdXNoKHJlYWRfbGluZWFyX3RhYmxlKHcsIG5leHQpKTtcclxuXHR9XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB3ID0gbmV4dCgpIC0gMTtcclxuXHRcdGlmICh3IDwgMCkgYnJlYWs7XHJcblx0XHRyZXQucHVzaChyZWFkX3JlcGxhY2VtZW50X3RhYmxlKHcsIG5leHQpKTtcclxuXHR9XHJcblx0cmV0dXJuIHJldC5mbGF0KCk7XHJcbn1cclxuXHJcbi8vIHJlYWQgdW50aWwgbmV4dCBpcyBmYWxzeVxyXG4vLyByZXR1cm4gYXJyYXkgb2YgcmVhZCB2YWx1ZXNcclxuZnVuY3Rpb24gcmVhZF9hcnJheV93aGlsZShuZXh0KSB7XHJcblx0bGV0IHYgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHggPSBuZXh0KHYubGVuZ3RoKTtcclxuXHRcdGlmICgheCkgYnJlYWs7XHJcblx0XHR2LnB1c2goeCk7XHJcblx0fVxyXG5cdHJldHVybiB2O1xyXG59XHJcblxyXG4vLyByZWFkIHcgY29sdW1ucyBvZiBsZW5ndGggblxyXG4vLyByZXR1cm4gYXMgbiByb3dzIG9mIGxlbmd0aCB3XHJcbmZ1bmN0aW9uIHJlYWRfdHJhbnNwb3NlZChuLCB3LCBuZXh0KSB7XHJcblx0bGV0IG0gPSBBcnJheShuKS5maWxsKCkubWFwKCgpID0+IFtdKTtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHc7IGkrKykge1xyXG5cdFx0cmVhZF9kZWx0YXMobiwgbmV4dCkuZm9yRWFjaCgoeCwgaikgPT4gbVtqXS5wdXNoKHgpKTtcclxuXHR9XHJcblx0cmV0dXJuIG07XHJcbn1cclxuIFxyXG4vLyByZXR1cm5zIFtbeCwgeXNdLCBbeCtkeCwgeXMrZHldLCBbeCsyKmR4LCB5cysyKmR5XSwgLi4uXVxyXG4vLyB3aGVyZSBkeC9keSA9IHN0ZXBzLCBuID0gcnVuIHNpemUsIHcgPSBsZW5ndGggb2YgeVxyXG5mdW5jdGlvbiByZWFkX2xpbmVhcl90YWJsZSh3LCBuZXh0KSB7XHJcblx0bGV0IGR4ID0gMSArIG5leHQoKTtcclxuXHRsZXQgZHkgPSBuZXh0KCk7XHJcblx0bGV0IHZOID0gcmVhZF9hcnJheV93aGlsZShuZXh0KTtcclxuXHRsZXQgbSA9IHJlYWRfdHJhbnNwb3NlZCh2Ti5sZW5ndGgsIDErdywgbmV4dCk7XHJcblx0cmV0dXJuIG0uZmxhdE1hcCgodiwgaSkgPT4ge1xyXG5cdFx0bGV0IFt4LCAuLi55c10gPSB2O1xyXG5cdFx0cmV0dXJuIEFycmF5KHZOW2ldKS5maWxsKCkubWFwKChfLCBqKSA9PiB7XHJcblx0XHRcdGxldCBqX2R5ID0gaiAqIGR5O1xyXG5cdFx0XHRyZXR1cm4gW3ggKyBqICogZHgsIHlzLm1hcCh5ID0+IHkgKyBqX2R5KV07XHJcblx0XHR9KTtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gcmV0dXJuIFtbeCwgeXMuLi5dLCAuLi5dXHJcbi8vIHdoZXJlIHcgPSBsZW5ndGggb2YgeVxyXG5mdW5jdGlvbiByZWFkX3JlcGxhY2VtZW50X3RhYmxlKHcsIG5leHQpIHsgXHJcblx0bGV0IG4gPSAxICsgbmV4dCgpO1xyXG5cdGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKG4sIDErdywgbmV4dCk7XHJcblx0cmV0dXJuIG0ubWFwKHYgPT4gW3ZbMF0sIHYuc2xpY2UoMSldKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHJlYWRfdHJpZShuZXh0KSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBzb3J0ZWQgPSByZWFkX3NvcnRlZChuZXh0KTsgXHJcblx0ZXhwYW5kKGRlY29kZShbXSksIFtdKTtcclxuXHRyZXR1cm4gcmV0OyAvLyBub3Qgc29ydGVkXHJcblx0ZnVuY3Rpb24gZGVjb2RlKFEpIHsgLy8gY2hhcmFjdGVycyB0aGF0IGxlYWQgaW50byB0aGlzIG5vZGVcclxuXHRcdGxldCBTID0gbmV4dCgpOyAvLyBzdGF0ZTogdmFsaWQsIHNhdmUsIGNoZWNrXHJcblx0XHRsZXQgQiA9IHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4geyAvLyBidWNrZXRzIGxlYWRpbmcgdG8gbmV3IG5vZGVzXHJcblx0XHRcdGxldCBjcHMgPSByZWFkX3NvcnRlZChuZXh0KS5tYXAoaSA9PiBzb3J0ZWRbaV0pO1xyXG5cdFx0XHRpZiAoY3BzLmxlbmd0aCkgcmV0dXJuIGRlY29kZShjcHMpO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4ge1MsIEIsIFF9O1xyXG5cdH1cclxuXHRmdW5jdGlvbiBleHBhbmQoe1MsIEJ9LCBjcHMsIHNhdmVkKSB7XHJcblx0XHRpZiAoUyAmIDQgJiYgc2F2ZWQgPT09IGNwc1tjcHMubGVuZ3RoLTFdKSByZXR1cm47XHJcblx0XHRpZiAoUyAmIDIpIHNhdmVkID0gY3BzW2Nwcy5sZW5ndGgtMV07XHJcblx0XHRpZiAoUyAmIDEpIHJldC5wdXNoKGNwcyk7IFxyXG5cdFx0Zm9yIChsZXQgYnIgb2YgQikge1xyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBici5RKSB7XHJcblx0XHRcdFx0ZXhwYW5kKGJyLCBbLi4uY3BzLCBjcF0sIHNhdmVkKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxuXG5mdW5jdGlvbiBoZXhfY3AoY3ApIHtcclxuXHRyZXR1cm4gY3AudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkucGFkU3RhcnQoMiwgJzAnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcXVvdGVfY3AoY3ApIHtcclxuXHRyZXR1cm4gYHske2hleF9jcChjcCl9fWA7IC8vIHJhZmZ5IGNvbnZlbnRpb246IGxpa2UgXCJcXHV7WH1cIiB3L28gdGhlIFwiXFx1XCJcclxufVxyXG5cclxuLypcclxuZXhwb3J0IGZ1bmN0aW9uIGV4cGxvZGVfY3Aocykge1xyXG5cdHJldHVybiBbLi4uc10ubWFwKGMgPT4gYy5jb2RlUG9pbnRBdCgwKSk7XHJcbn1cclxuKi9cclxuZnVuY3Rpb24gZXhwbG9kZV9jcChzKSB7IC8vIHRoaXMgaXMgYWJvdXQgMnggZmFzdGVyXHJcblx0bGV0IGNwcyA9IFtdO1xyXG5cdGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IHMubGVuZ3RoOyBwb3MgPCBsZW47ICkge1xyXG5cdFx0bGV0IGNwID0gcy5jb2RlUG9pbnRBdChwb3MpO1xyXG5cdFx0cG9zICs9IGNwIDwgMHgxMDAwMCA/IDEgOiAyO1xyXG5cdFx0Y3BzLnB1c2goY3ApO1xyXG5cdH1cclxuXHRyZXR1cm4gY3BzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHJfZnJvbV9jcHMoY3BzKSB7XHJcblx0Y29uc3QgY2h1bmsgPSA0MDk2O1xyXG5cdGxldCBsZW4gPSBjcHMubGVuZ3RoO1xyXG5cdGlmIChsZW4gPCBjaHVuaykgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNwcyk7XHJcblx0bGV0IGJ1ZiA9IFtdO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyApIHtcclxuXHRcdGJ1Zi5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNwcy5zbGljZShpLCBpICs9IGNodW5rKSkpO1xyXG5cdH1cclxuXHRyZXR1cm4gYnVmLmpvaW4oJycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wYXJlX2FycmF5cyhhLCBiKSB7XHJcblx0bGV0IG4gPSBhLmxlbmd0aDtcclxuXHRsZXQgYyA9IG4gLSBiLmxlbmd0aDtcclxuXHRmb3IgKGxldCBpID0gMDsgYyA9PSAwICYmIGkgPCBuOyBpKyspIGMgPSBhW2ldIC0gYltpXTtcclxuXHRyZXR1cm4gYztcclxufVxuXG4vLyBjcmVhdGVkIDIwMjMtMDktMTJUMjI6MDU6MTQuMjExWlxuLy8gY29tcHJlc3NlZCBiYXNlNjQtZW5jb2RlZCBibG9iIGZvciBpbmNsdWRlLW5mIGRhdGFcbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9ibG9iL21haW4vc3JjL21ha2UuanNcbi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcyNzZWN1cml0eVxuLy8gU0hBLTI1NjogYTk3NGI2Zjg1NDFmYzI5ZDkxOWJjODUxMThhZjBhNDQwMTU4NTFmYWI1MzQzZjg2NzljYjMxYmUyYmRiMjA5ZVxudmFyIENPTVBSRVNTRUQgPSAnQUVVRFRBSEJDRlFBVFFEUkFEQUFjZ0FnQURRQUZBQXNBQlFBSHdBT0FDUUFEUUFSQUFvQUZ3QUhBQklBQ0FBUEFBVUFDd0FGQUF3QUJBQVFBQU1BQndBRUFBb0FCUUFJQUFJQUNnQUJBQVFBRkFBTEFBSUFDd0FCQUFJQUFRQUhBQU1BQXdBRUFBc0FEQUFNQUF3QUNnQU5BQTBBQXdBS0FBa0FCQUFkQUFZQVp3RFNBZHNESmdDMENrTUI4eGhaQXFmb0MxOTBVR2NUaGdCdXJ3ZjdQVDA5UGIwOUFqZ0p1bThPakRsbHhIWVVLWEFQeHpxNnRBQkF4Z0s4eXNVdldBZ01QVDA5UFQwOVBTczZMVDJIY2dXWFd3RkxvU01FRUVsNVJGVk1Ldk8wWFE4RXhEZEpNbklnc2oyNlBUUXl5OEZmRVE4QVk4SVBBR2NFYndSd0JIRUVjZ1J6QkhRRWRRUjJCSGNFZUFSNkJIc0VmQVIrQklBRWdmbmRCUW9CWWdVTEFXSUZEQUZpQk5jRTJBVFpCUkFGRVFVdkJkQUxGQXNWRFBjTkJ3MTNEWWNPTUE0eERqTUI0QmxsSEkwQjJncmJBTURwSExrUTdRSFZBUFJOUVFGbkdSVUVnMHlFQjJ1YUpGOEFKcElCcG9iNUFFUlNNQUtOb0FYcWFRTFVCTUN6RWlBQ253UlpFa2tWc1M3dEFOQXNCRzBSdUFRTEVQQUJ2OUhJQ1RVQlhpZ1Bad1JCQXBNRE93QWFtaHRhQUJxRUFZOEt2S3gzTFE0QXJBQjhVaHdFQkFWU2FnRDhBRUZaQURrQklhZFZqMlVNVWd4NUlsNEFOUUM5QXhJQjFCbGJFUE1BczMwQ0d4bFhBaHdaS1FJRUNCYzZFYnNDb3huZ3p2N1V6UlFBOE0wQmF3TDZad2tON3dBQkFEMzNPUVJjc2dMSkNqTUNqcVVDaHR3L2ttK05Bc1hQQW9QMkJUODRQd1VSQUswUkF2cHRiNmNBcFFTL09NTWV5NUhKUzg0VWR4cHhUUGtDb2dWRklUYVRPd0VSQUs1cEF2a05CT1Z5QTdxM0JLbE9KU0FMQWdVSUJSY0VkQVNwQlhxekFCWEZTV1pPYXdMQ09xdy8vQW9sQ1pkdnYzZFNCa0VRR3llbEVQY01Nd0cxQVRzTjdVdllCUEVHT3dUSkgzMFpHUS9ObFp3SXBTM2RETzBtNHk2aGdGb2o5U3FEQmUxTDlEemRDMDFSYUE5WkMyVUo0enBqZ1U0RElRRU5Jb3NLM1EwNUNHMFE4d3JKYXczbEVVVUhPUVBWU1pvQXBRY0JDeEVkTlJXMUpoQmlyQXNKT1hjRyt4cjJDNDhtcnhNcGV2d0YweG9oQmswQktSci9BTTh1NTRXd1dqRmNIRTlmQmdNTEpTUEhGS2hRSUEwbFFMZDRTQm9iQnhVbHFRS1JRM0JLaDFFMkhwTWg5anc5RFdZdUUxRjhCL1U4QlJsUEM0RThua2FyUlE0UjBqNk5QVWdpU1V3c0JEVi9MQzhuaXduUEQ0VU11WHh5QVZrSklRbXhESEVUTVJFWE44VUlPUWNaTFpja0p4VUlJVWFWWUpvRTk1OEQ4eFBSQXdzRlB3bEJCeE1EdFJ3dEV5NFZLUVVOZ1NUWEF2TTIxUzZ6QW85V2dBRVhCY3NQSlIvZkVGQkg0QTdwQ0pzQ1pRT0RKZXNBTFJVaEFCY2ltd2hEWXdCZmo5aFRCUzdMQ01kcWJDTjBBMmNVNTJFUmN3ZVJEbGNIcHh3ekZiOGM0WERJWGd1R0NDaWpyd2xiQVhVSm1RRmZCT01JQ1RWYmpLQWdRV2RUaTFnWW15QmhRVDlkL0FJeERHVVZuMFM5aDNnQ2l3OXJFaHNCTlFGekJ6a05BUUozRWUwUmF4Q1ZDT3VHQkRXMU0vZzZKUVJQSVlNZ0VRb25BMDlzemdzbkp2a00rR2tCb3hKaUF3dzBQWGZ1WjZ0Z3RpUVgvUWNaTXNWQllDSHhDNUpQelF5Y0dzRVlRbFF1R2VRSHZ3UHpHdk1uNmtGWEJmOERvd01UT2swejdnUzlDMmtJaXdrL0FFa09veGNIMXhocUNuR00wQUV4aXdHM21RTlhrWU1DYjQ4R053Y0xBR2NMaHdWNTVRQWRBcWNJb3dBRkFNOERWd0E1QXEwSG5RQVpBSVZCQVQwREp5OEJJZVVDandPVENESExBWlV2QWZNcEJCdkREQlVBOXpkdVNnTERzUUtBYW1haUJkMVlBbzRDU1RVQlRTVUVCVTVIVVFPdmNlRUEyd0JMQmhQZlJ3RVZxMHJMR3VOREFkOXZLd0RIQVBzQUJUVUhCVUVCelFIemJRQzNBVjhMTVFtaXM3VUJUZWtwQUlNQUZXc0Ixd0tKQU4wQU5RQi84UUZUQUUwRldma0Ywd0pQU1FFUk1SZ3JWMkVCdXdNZkFUTUJEUUI1QnN1TnBja0hId1J0QjlNQ0VCc1Y0UUx2TGdlMUFRTWkzeFBOUXNVQ3ZkNVZvV0FDWklFQ1lrSmJUYTliTnlBQ29mY0NhSmdDWmdrQ240UTRHd3NDWmpzQ1ppWUViZ1IvQTM4VEEzNlNPUVk1ZHhjNWdqb2pJd0pzSFFJeU5qZ0tBbTNIQW0ydTc0b3paMFVyQVdjQTNnRGhBRW9GQjVnTWpRRCtDOElBRGJVQ2R5OENkcUkvQW5sTFF3SjR1aDFjMjBXdVJ0Y0NmRDhDZXNnQ2ZRa0NmUEFGV1FVZ1NBQklmV01rQW9GdEFvQUFBb0FGQW4rdVNWaEtXeFVYU3N3QzBRRUMwTXhMSndPSVR3T0g1a1RGa1RJQzhxRmRBd01Ecmt2T1RDMGxBODlOVEUydkFvcy9Bb3JZd1JzSEhVTm5CYmNDampjQ2pseEFsNEVDanRrQ2pseDRVYlJUTlFwUzFGU0ZBcFA3QXBNTUFPa0FIRlVlVmE5VjBBWXNHeW1WaGpMaGVHWkZPemtDbDU4Qzc3SllJYWdBV1NVQ2xvOENsbnljQUtsWnJGb0pnVTBBT3dLV3RRS1dUbHhFWE5FQ21jc0NtV1JjeWwwSEdRS2Ntem5DT3AwQ25CWUNuNXNDbnJpS0FCMFBNU29QQXAzeEFwNlNBTFU5WVRSaDd3S2Uwd0tnYmdHcEFwNmZId0tlVHFWanlHUW5KU3NDSjY4Q0puNENvUHNDb0V3Q290MENvY1FDcGk4Q3BjNENwLzhBZlFLbjhtaDhhTEVBQTBscUhHclJBcXpqQXF5dUFxMW5BcTBDQWxjZEFsWGNBckhoMXdNZlRteVhBcks5RFFLeTZCZHM0RzFqYlVoZkF5WE5BclpjT3o5dWtBTXBSUUs0WGdLNVJ4VUN1U3AzY0RadzRRSzlHUUs3Mm5DV0F6SVJBcjZJY2dJRE0zRUN2aHB6SW5OUEFzUExBc01FYzRKMFN6VkZkT0FEUEtjRFBKb0RQYjhDeFh3Q3hrY0N4aENKQXNocFVRTElSQUxKVHdMSkxnSmtuUUxkMG5oNVlYaXVlU1ZMMEFNWW8yY0NBbUgwR2ZPVkpIc0xYcEpldXhFQ3oyc0N6Mnd2UzFQUzh4T2ZBTWF0QXM5ekFTbnFBMDRTZmtzRkF0d25BdHVLQXRKUEExSmNBMU5mQVFFRFZZeUFpVDhBeXhidFlFV0NISUxUZ3M2RGpRTGF4d0xaM29RUWhFbW5QQU9HcFFBdkEyUU9obkZaK1FCVkF0OWxBdDY0YzNjQzRpL3RGQUh6TUNjQjlKc0I4dEtIQXV2ekF1bHdlUUxxK1FMcTVBRDVSd0c1QXU2SkF1dWNscXFYQXdMdVB3T0Y0Smg1Y09CeG9RTHpBd0JwQTQ0V21aTUM5eE1Ea1c0RGtvY0M5NWdDK2RrQytHYWFISnFydXplYkhnT2Rnd0wrK2dFYkFEbWZISit6QXdXTkE2WnFBNmJaQU5IRkF3WnFvWWlpQlFrRERFa0N3QUEvQXdEaFFSZFRBUkh6QTJzSGwyY0ZBSk10SzdldnZkc0JpWmtVZnhFRU9RSDdLUVVoRHAwSm53Q1MvU2xYeFFMM0FaMEF0d1c1QUc4TGJVRXVGQ2FOTGdGREFZRDhBYlVtQUhVRERnUnRBQ3dDRmd5aEFBQUtBajBDYWdQZEEzNEVrUUVnUlFVaGZBb0FCUUJFQUJNQU5oSUNkd0VBQmRVRGErOEt4UUlBOXdxZko3K3h0K1VCa1NGQlFnSHBGSDhSTk1DSkFBUUFHd0JhQWtVQ2hJc0FCanBUT3BTTmJRQzRPbzg2MEFDTk9NRTYzQUNsQU9nQXl3RTZnVG83T2Z3NStUdDJpVHBiTzU2Sk9tODVHQUZXQVRNQmJBVXZOVjAxbmpXdE5XWTFkVFcyTmNVMWdqV1JOZEkxNFRXZU5hMDE3alg5TmJJMXdUWUNOaEUxeGpYVk5oWTJKelhlTmUwMkxqWTlOaTQxTFNFMk9qWTlOancyeVRjSUJKQThWelk0TnQwM0lEY1BOc29nTjRrM01Bb0VzRHhuTmlRM0dUZHNPbzAzSVVMVVF3ZEM0RU1MSEE4UENac29iU2hSVlFZQTZYOEE2YkFCRkNuWEF1a0Jvd0M5QmJjQWJ3TnpCTDhNREFNTUFRZ0RBQWtLQ3dzTENRb0dCQVZWQkkvRHZ3RHo5YjI5a2FVQ2IwUXRzUlROTHQ0ZUdCY1NIQU1aRmhZWkVoWUVBUkFFQlVFY1FSeEJIRUVjUVJ4QkhFRWFRUnhCSEVGQ1NUeEJQRWxJU1VoQk5rTTJRVFliTmtsSVNWbUJWSWdCRkxXWkF1MEJoUUNqQmNFQWJ5a0J2d0dKQWFRY0VaMGVQQ2tsTUFBaE12QUlNQUw1NGdDN0JtOEVlc2NqelFNcEFSUXBLZ0RVQUJhdkFqNjI2eFFBSlAwQTNldHp1ZjROTlJBN2VmeTJaOU5RckNuQzBPU3lBTno1QkJJYko1SUZEUjZtaUlhdllTNnRwcmpqbXVLZWJ4bTVDNzRRMjI1WDFwa2FZWVBiNmYxREs0azN4TUVCYjlTMldNakVpYlROV2hzUkpJQSt2d05WRWlYVEU1aVhzL3dlelY2Nm9GTGZwOU5aR1lXK0drMTlKMitiQ1Q2WWUydzZMRFlkZ3pLTVVhYms1OTVlTEJDWEFOejlIVXBXYkFUcTl2cVhWeDlYRGcrUGM5WHA0K2JzUzAwNVNWTS9CSkJNNDY4N1dVdWYrVWo5ZEVpOGFETmFQeHRwYkR4Y0cxVEhUSW1VTVpxNFVDYWFOWXBzVnFyYU55S0xKWERZc0ZaLzVqbDdiTFJ0Tzg4dDdQM3haYUF4aGI1T2RQTVhxc1NrcDFXQ2llRzhqWG0xVTk5K2JsdkxsWHpQQ1MrTTkzVm5KQ2lLKzA5TGZhU2FCQVZCb215RGdKdWE4ZGZVelI3Z2EzNEl2UjJOdmorQTloZUo2bHNsMUtHNE5rSTEwMzJDbmZmMW0xd29mMkI5b0hKSzRiaTZKa0VkU3FlTmVpdW82UW9aWmluY29jNzMvVEg5U1hGOHNDRTdYeXVZeVc4V1NnYkdGQ2pQVjBpaExLaGRQczA4VHg4MmZZQWtMTGM0STJ3ZGw0YXBZN0dVNWxIUkZ6UldKZXA3V3czd2JlQTNxbWQ1OS84NlA0eHVOYXFEcHlnWHQ2TTg1Z2xTQkhPQ0dnSkRudCtwTjliSzdIQXBNZ3VYNiswNlJaTmp6Vm1jWkord2NVcko5Ly9icFJOeE51S3BObDl1RmRzK1M5dGR4N0xhTTVaa0lyUGo2bklVOW1uYkZ0VmJzOXMvdUxnbDhNVmN6QXdldCtpT0V6ekJsWVc3UkNNZ0U2Z3lOTGVxNisxdEl4NGRwZ1puZDBEa3NKUzVmK0pORHB3d2NQTlhhYVZzcHExZmJRYWpPckpnSzBvZkt0SjFOZTkwTDZWTzRNT2w1Uzg4NnA3dTZ4bzdPTGpHOFRHTCtIVTFKWEdKZ3BwZzRuTmJOSjVubHpTcHVQWXkyMUpVRWNVQTk0UG9GaVpmalp1ZStRbnlRODBla091WlZreHg0ZytjdmhKZkhnTmw0aHkxL2E2K1JLY0tsYXIvSjI5eS8vRXp0bGJWUEhWVWVRMXpYODZlUVZBalIvTTNkQTl3NFc4TGZhWHA0RWdNODV3T1dhc2xpODM3UHpWTU9uc0x6UitrM283NS9sUlBBSlNFMXhBS1F6RWk1djEwa2UrVkJ2UnQxY3dRUk1kK1U1bUxDVEdWZDZYaVp0Z0JHNWNEaTB3MjJHS2NWTnZIaXU1TFFiWkVEVnR6MG9ubjdrNStoZXVLWFZzWnRTemlsa0xSQVVtak1YRU1CM0o5WUM1MFhCeFBpejUzU0MrRWhuUGw5V3NLQ3Y5MlNNL09GRklNSlpZZmwwV1c4dElPM1V4WWN3ZE1BajdGU21ncnNaMmFBWk8wM0JPaFAxYk5OWkl0eVhZUUZUcEMzU0cxVnVQRHFIOUdraUNEbUUrSnd4eUlWU081c2lERXJBT3BFWEZnank2UFF0T1ZEaitzNmUxcjhoZVdWdm1ablRjaXVmNEVpTlp6Q0FkN1NPTWhYRVJJT2xzSElNRzM5OWk5YUxUeTNtMmhSTFpqSlZETkxTNTNpR0lLMTFkUHFRdDB6QkR5ZzZxYzdZcWtEbTJNNVZlNmRDV0NhQ2JUWFgyclRvYUlnejYremg0bFlVaS8rNm5xY0ZNQWtRSktIWUxLMHdZazVOOXN6VjZ4aWhEYkRERnI0NWxOMUs0YUNYQnEvRml0UFN1ZDlnTHQ1WlZuK1pxR1g3Y3dtMno1RUdNZ2ZGcElGeWhHR3VEUG1zbzZUSXRUTXdueSs3dVBuTENmNFc2Z29GUUZWMG9RU3NjOVZmTW1WTGNMcjZaZXREWmJhU0ZUTHFuU08vYklQakEzL3pBVW9xZ0dGQUVRUzRJaHVNekVwMkkzakp6Ynpray9JRW15YXgrcmhaVHdkNmYrQ0d0d1BpeHU4SXZ6QUNxdVBXUFJFdTladkdrVXpwUnd2UlJ1YU5ONmNyMFcxd1dpdHM5SUNkWUo3bHRiZ01pU0wzc1RQZXVmZ05jVnFNVldGa0NQREg0akcyakEwWGNWZ1FqNjJDYjI5djlmL3ovKzJLYll2SXYvenpqcFFBUGtsaWFWRHpOclc1N1RaL1pPeVpEMG5sZk1tQUlCSUFHQUkwRDNrL21kTjR4cjl2ODVaYlpiYnFmSDJqR2Q1aFVxTlpXd2w1U1Bmb0dtZkVsbWF6VUllTkwxai9ta0Y3Vk5BelRxNGpOdDhKb1ExMU5RT2NtaHByWG94U3hmUkdKOUxERU9BUStkbXhBUUg5MGl0aTllMnUvTW9ldWFHY0RUSG9DK3hzbUVlV214RUtlZlF1SXpIYnB3NVRjNWNFb2Nib0FEMDlvaXBXUWh0VE8xd2l2Zi9PK0RSZTJycGwvRTl3bHJ6Qm9yakpzT2VHMUIvWFBXNEVhSkVGZE5sRUNFWmdhNVpvR1JIWGdZb3VHUnVWa204dERFU2lFeUZObyszczVNNXB1U2RUeVVMMmxsbklOVkhFdDkxWFVOVzRld2RNZ0o0Ym9KZkV5dC9pWTVXWHFiQStBMkZrdDVaMGx1dGlXaGU5blpJeUlVanlYREMzVXNhRzF0K2VOeDZ6NFcvT1lvVEI3QTZ4K2ROU1RPaTlBSW5jdGJFU3FtNWd2T0x3dzdPV1hQcm1Id1ZaYXNybDRlRDExM3BtK0p0VDdKVk92bkNYcWR6emRUUkhnSjBQaUdURllXNUd2dDlSOUxENkx6ZnMwdi9UWlpIU215Vk5xN3ZpSUhFNkRCSzdRcDA3SXo1NUVNOFNZdFF2WmYvb2JCbmlUV2k1QzIvb3ZIZnc0Vm5ka0U1WFlkak9oQ01SakRlT0VmWGVOL0N3ZkdkdWlVSWZzb0ZlVXhYZVFYYmE3Yzc5NzJYTnY4dytkVGpqVU0wUWVOQVJlVytKMDE0ZEtBRC9NY1FZWFQ3YzBHUVBJa24zTGw2UjdnR2p1aVFvWkQwVEVlRXFRcEtvWjE1Zy8wT1BRSTE3UWlTdjlBVVJPYS9WL1RRTjNkdkxBcmVjM1Jyc1lsdkJtMWI4TFd6bHRkdWdzQzUwbE5LWUxFcDJhK1paWXFQZWpVTFJsT0poNXpqL0xWTXlURHZ3S2hNeHh3dURreEoxUXBvTkkwT1RXTG9tNFo3MVNOekk5VFYxaVhKckl1OVdjbmQrTUNhQXc4bzFqU1hkOTRZVS8xZ25rckM5QlVFT3RRdkVJUTdnMGk2aCtLTDJKS2s4WWRsN0hydXZnV01TQW1OZStMc2hHaFY0cW5XSGhPOS9SSVBRelkxdEhSajJWcU95TnNEcEswY3d3KzU2QWREQzRnc1d3WTBYeG91Y0lXSXFzL0djd25XcWxhVDBLUHI4bWJLNVU5NC8zMDFpMVdMdDRZSU5UVnZDRkJyRlpiSWJZOGV5Y09kZUoydGVENUlmUExDUmc3ampjRlR3bE1GTmw5emRoL28zRS9oSFB3ajdCV2cwTVUwOXBQckJMYnJDZ201NEE2SCtJNnYyNytqTDVna2pXZy9pWWRrczlqYmZWUDV5L24wZGxnV0VNbEthc2w3SnZGWmQ1NkxmeWJXMWVlYVZPMGd4VGZYWndEOEc0U0kxMTZ5eDdVS1ZSZ3VpNllhMVlwaXhxWGVOTGM4SXh0QXdDVTVJaHdRZ24rTnFIblJhRHY2MUN4S2hPcTRwT1g3TTZwa0ErUG1wZDRqMXZuNkFDVUFMb0xMYzR2cFhjaThWaWRMeHptN3FGQmU3cytxdXVKczZFVFltbnBnUzNMd1NaeFBJbHRnQkRYejhNMWsvVzJ5U052MmY5L05QaHhMR0syRDIxZGtIZVNHbWVuUlQzWXFjZGwwbS9oM09ZcjhWK2xYTllHZjhhQ0NwZDRiV2pFNFFJUGo3dlVLTjROcmZzN01MNlkyT3lTODMwSkNub2ZnL2s3bHBGcHQ0U3FaYzVIR2cxSENPckh2T2RDOGJQNkZHRGJFL1ZWMG1YNElha3piZFMvb3ArS3QzRzI0LzhRYkJWN3k4NnNHU1Evdlp6VThGWHM3dTZqSXZ3Y2hzRVAyQnBJaFczRzh1V053YTNIbWpmSC9aamhoQ1d2bHVBY0Yrbk1mMTRDbEtnNWhHZ3RQTEo5OHVlTkFrYzVIczJXWmxrMlFIdmZyZUNLMUNDR082bk1aVlNiOTlWTS9hanI4V0hUdGU5SlNta1hxL2kvVTk0M0hFYmR6VzZSZS9TODhkS2dnOHBHT0xsQWVOaXFyY0xrVVIzL2FDbEZwTVhjT1VQM3JtRVRjV1NmTVhaRTNUVU9pOGkrZnFSblRZTGZsVngvVmIvNkdKN2VJUlpVQTZrM1JZUjNpRlNLOWM0aURkTndKdVpMMkZLei9JSzVWaW1jTldFcWRYalNveFNnbUYwVVBsRG9VbE5yUGNNN2Z0bUE4WTlnS2lxS0VIdVdOK0FaUkl3dFZTeHllMktmOHJNM2xoSjVYY0JYVTluNHYwT3kxUlUyTSs0cU04QVFQVndzZThFck5Tb2I1b0ZQV3h1cVpuVnpvMXFCL0lCeGtNM0VWVUtGVVVsTzNlNTEyNTlHZ05jSmJDbWx2cmRqdG9UVzdyQ2htMXd5Q0t6cENUd296VVVFT0ljV0xuZVJMZ01YaCtTakdTRmtBbGx6YkdTNUhLN0xsZkNNUk5SRFN2YlFQamNYYWVuTll4Q3Z1MlF5em56NlN0dXhWajY2U2dJMFQ4QjYvc2ZIQUpZWmFaNzh0aGpPU0lGdW1OV0xRYmVaaXhEQ0NDK3YwWUJ0a3hpQkIzamVmSHFaL2RGSFUrY3JiajZPdlMxeC9KREQ3dmxtN3pPVlB3cFVDMDFuaHhadVkvNjNFN2cnO1xuXG4vLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIxNS9cclxuLy8gZm9yIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvblxyXG4vLyBzZWU6IC9kZXJpdmUvbmYuanNcclxuXHJcblxyXG4vLyBhbGdvcml0aG1pYyBoYW5ndWxcclxuLy8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvdmVyc2lvbnMvVW5pY29kZTE1LjAuMC9jaDAzLnBkZiAocGFnZSAxNDQpXHJcbmNvbnN0IFMwID0gMHhBQzAwO1xyXG5jb25zdCBMMCA9IDB4MTEwMDtcclxuY29uc3QgVjAgPSAweDExNjE7XHJcbmNvbnN0IFQwID0gMHgxMUE3O1xyXG5jb25zdCBMX0NPVU5UID0gMTk7XHJcbmNvbnN0IFZfQ09VTlQgPSAyMTtcclxuY29uc3QgVF9DT1VOVCA9IDI4O1xyXG5jb25zdCBOX0NPVU5UID0gVl9DT1VOVCAqIFRfQ09VTlQ7XHJcbmNvbnN0IFNfQ09VTlQgPSBMX0NPVU5UICogTl9DT1VOVDtcclxuY29uc3QgUzEgPSBTMCArIFNfQ09VTlQ7XHJcbmNvbnN0IEwxID0gTDAgKyBMX0NPVU5UO1xyXG5jb25zdCBWMSA9IFYwICsgVl9DT1VOVDtcclxuY29uc3QgVDEgPSBUMCArIFRfQ09VTlQ7XHJcblxyXG5mdW5jdGlvbiB1bnBhY2tfY2MocGFja2VkKSB7XHJcblx0cmV0dXJuIChwYWNrZWQgPj4gMjQpICYgMHhGRjtcclxufVxyXG5mdW5jdGlvbiB1bnBhY2tfY3AocGFja2VkKSB7XHJcblx0cmV0dXJuIHBhY2tlZCAmIDB4RkZGRkZGO1xyXG59XHJcblxyXG5sZXQgU0hJRlRFRF9SQU5LLCBFWENMVVNJT05TLCBERUNPTVAsIFJFQ09NUDtcclxuXHJcbmZ1bmN0aW9uIGluaXQkMSgpIHtcclxuXHQvL2NvbnNvbGUudGltZSgnbmYnKTtcclxuXHRsZXQgciA9IHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkKENPTVBSRVNTRUQpO1xyXG5cdFNISUZURURfUkFOSyA9IG5ldyBNYXAocmVhZF9zb3J0ZWRfYXJyYXlzKHIpLmZsYXRNYXAoKHYsIGkpID0+IHYubWFwKHggPT4gW3gsIChpKzEpIDw8IDI0XSkpKTsgLy8gcHJlLXNoaWZ0ZWRcclxuXHRFWENMVVNJT05TID0gbmV3IFNldChyZWFkX3NvcnRlZChyKSk7XHJcblx0REVDT01QID0gbmV3IE1hcCgpO1xyXG5cdFJFQ09NUCA9IG5ldyBNYXAoKTtcclxuXHRmb3IgKGxldCBbY3AsIGNwc10gb2YgcmVhZF9tYXBwZWQocikpIHtcclxuXHRcdGlmICghRVhDTFVTSU9OUy5oYXMoY3ApICYmIGNwcy5sZW5ndGggPT0gMikge1xyXG5cdFx0XHRsZXQgW2EsIGJdID0gY3BzO1xyXG5cdFx0XHRsZXQgYnVja2V0ID0gUkVDT01QLmdldChhKTtcclxuXHRcdFx0aWYgKCFidWNrZXQpIHtcclxuXHRcdFx0XHRidWNrZXQgPSBuZXcgTWFwKCk7XHJcblx0XHRcdFx0UkVDT01QLnNldChhLCBidWNrZXQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJ1Y2tldC5zZXQoYiwgY3ApO1xyXG5cdFx0fVxyXG5cdFx0REVDT01QLnNldChjcCwgY3BzLnJldmVyc2UoKSk7IC8vIHN0b3JlZCByZXZlcnNlZFxyXG5cdH1cclxuXHQvL2NvbnNvbGUudGltZUVuZCgnbmYnKTtcclxuXHQvLyAyMDIzMDkwNTogMTFtc1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc19oYW5ndWwoY3ApIHtcclxuXHRyZXR1cm4gY3AgPj0gUzAgJiYgY3AgPCBTMTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcG9zZV9wYWlyKGEsIGIpIHtcclxuXHRpZiAoYSA+PSBMMCAmJiBhIDwgTDEgJiYgYiA+PSBWMCAmJiBiIDwgVjEpIHtcclxuXHRcdHJldHVybiBTMCArIChhIC0gTDApICogTl9DT1VOVCArIChiIC0gVjApICogVF9DT1VOVDtcclxuXHR9IGVsc2UgaWYgKGlzX2hhbmd1bChhKSAmJiBiID4gVDAgJiYgYiA8IFQxICYmIChhIC0gUzApICUgVF9DT1VOVCA9PSAwKSB7XHJcblx0XHRyZXR1cm4gYSArIChiIC0gVDApO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRsZXQgcmVjb21wID0gUkVDT01QLmdldChhKTtcclxuXHRcdGlmIChyZWNvbXApIHtcclxuXHRcdFx0cmVjb21wID0gcmVjb21wLmdldChiKTtcclxuXHRcdFx0aWYgKHJlY29tcCkge1xyXG5cdFx0XHRcdHJldHVybiByZWNvbXA7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiAtMTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlY29tcG9zZWQoY3BzKSB7XHJcblx0aWYgKCFTSElGVEVEX1JBTkspIGluaXQkMSgpO1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgYnVmID0gW107XHJcblx0bGV0IGNoZWNrX29yZGVyID0gZmFsc2U7XHJcblx0ZnVuY3Rpb24gYWRkKGNwKSB7XHJcblx0XHRsZXQgY2MgPSBTSElGVEVEX1JBTksuZ2V0KGNwKTtcclxuXHRcdGlmIChjYykge1xyXG5cdFx0XHRjaGVja19vcmRlciA9IHRydWU7XHJcblx0XHRcdGNwIHw9IGNjO1xyXG5cdFx0fVxyXG5cdFx0cmV0LnB1c2goY3ApO1xyXG5cdH1cclxuXHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdGlmIChjcCA8IDB4ODApIHtcclxuXHRcdFx0XHRyZXQucHVzaChjcCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoaXNfaGFuZ3VsKGNwKSkge1xyXG5cdFx0XHRcdGxldCBzX2luZGV4ID0gY3AgLSBTMDtcclxuXHRcdFx0XHRsZXQgbF9pbmRleCA9IHNfaW5kZXggLyBOX0NPVU5UIHwgMDtcclxuXHRcdFx0XHRsZXQgdl9pbmRleCA9IChzX2luZGV4ICUgTl9DT1VOVCkgLyBUX0NPVU5UIHwgMDtcclxuXHRcdFx0XHRsZXQgdF9pbmRleCA9IHNfaW5kZXggJSBUX0NPVU5UO1xyXG5cdFx0XHRcdGFkZChMMCArIGxfaW5kZXgpO1xyXG5cdFx0XHRcdGFkZChWMCArIHZfaW5kZXgpO1xyXG5cdFx0XHRcdGlmICh0X2luZGV4ID4gMCkgYWRkKFQwICsgdF9pbmRleCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IG1hcHBlZCA9IERFQ09NUC5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmIChtYXBwZWQpIHtcclxuXHRcdFx0XHRcdGJ1Zi5wdXNoKC4uLm1hcHBlZCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGFkZChjcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghYnVmLmxlbmd0aCkgYnJlYWs7XHJcblx0XHRcdGNwID0gYnVmLnBvcCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoY2hlY2tfb3JkZXIgJiYgcmV0Lmxlbmd0aCA+IDEpIHtcclxuXHRcdGxldCBwcmV2X2NjID0gdW5wYWNrX2NjKHJldFswXSk7XHJcblx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgY2MgPSB1bnBhY2tfY2MocmV0W2ldKTtcclxuXHRcdFx0aWYgKGNjID09IDAgfHwgcHJldl9jYyA8PSBjYykge1xyXG5cdFx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsZXQgaiA9IGktMTtcclxuXHRcdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0XHRsZXQgdG1wID0gcmV0W2orMV07XHJcblx0XHRcdFx0cmV0W2orMV0gPSByZXRbal07XHJcblx0XHRcdFx0cmV0W2pdID0gdG1wO1xyXG5cdFx0XHRcdGlmICghaikgYnJlYWs7XHJcblx0XHRcdFx0cHJldl9jYyA9IHVucGFja19jYyhyZXRbLS1qXSk7XHJcblx0XHRcdFx0aWYgKHByZXZfY2MgPD0gY2MpIGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdHByZXZfY2MgPSB1bnBhY2tfY2MocmV0W2ldKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcG9zZWRfZnJvbV9kZWNvbXBvc2VkKHYpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IHN0YWNrID0gW107XHJcblx0bGV0IHByZXZfY3AgPSAtMTtcclxuXHRsZXQgcHJldl9jYyA9IDA7XHJcblx0Zm9yIChsZXQgcGFja2VkIG9mIHYpIHtcclxuXHRcdGxldCBjYyA9IHVucGFja19jYyhwYWNrZWQpO1xyXG5cdFx0bGV0IGNwID0gdW5wYWNrX2NwKHBhY2tlZCk7XHJcblx0XHRpZiAocHJldl9jcCA9PSAtMSkge1xyXG5cdFx0XHRpZiAoY2MgPT0gMCkge1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXQucHVzaChjcCk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAocHJldl9jYyA+IDAgJiYgcHJldl9jYyA+PSBjYykge1xyXG5cdFx0XHRpZiAoY2MgPT0gMCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKHByZXZfY3AsIC4uLnN0YWNrKTtcclxuXHRcdFx0XHRzdGFjay5sZW5ndGggPSAwO1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFjay5wdXNoKGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRwcmV2X2NjID0gY2M7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY29tcG9zZWQgPSBjb21wb3NlX3BhaXIocHJldl9jcCwgY3ApO1xyXG5cdFx0XHRpZiAoY29tcG9zZWQgPj0gMCkge1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjb21wb3NlZDtcclxuXHRcdFx0fSBlbHNlIGlmIChwcmV2X2NjID09IDAgJiYgY2MgPT0gMCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKHByZXZfY3ApO1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFjay5wdXNoKGNwKTtcclxuXHRcdFx0XHRwcmV2X2NjID0gY2M7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKHByZXZfY3AgPj0gMCkge1xyXG5cdFx0cmV0LnB1c2gocHJldl9jcCwgLi4uc3RhY2spO1x0XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8vIG5vdGU6IGNwcyBjYW4gYmUgaXRlcmFibGVcclxuZnVuY3Rpb24gbmZkKGNwcykge1xyXG5cdHJldHVybiBkZWNvbXBvc2VkKGNwcykubWFwKHVucGFja19jcCk7XHJcbn1cclxuZnVuY3Rpb24gbmZjKGNwcykge1xyXG5cdHJldHVybiBjb21wb3NlZF9mcm9tX2RlY29tcG9zZWQoZGVjb21wb3NlZChjcHMpKTtcclxufVxuXG5jb25zdCBIWVBIRU4gPSAweDJEO1xyXG5jb25zdCBTVE9QID0gMHgyRTtcclxuY29uc3QgU1RPUF9DSCA9ICcuJztcclxuY29uc3QgRkUwRiA9IDB4RkUwRjtcclxuY29uc3QgVU5JUVVFX1BIID0gMTtcclxuXHJcbi8vIDIwMjMwOTEzOiByZXBsYWNlIFsuLi52XSB3aXRoIEFycmF5X2Zyb20odikgdG8gYXZvaWQgbGFyZ2Ugc3ByZWFkc1xyXG5jb25zdCBBcnJheV9mcm9tID0geCA9PiBBcnJheS5mcm9tKHgpOyAvLyBBcnJheS5mcm9tLmJpbmQoQXJyYXkpO1xyXG5cclxuZnVuY3Rpb24gZ3JvdXBfaGFzX2NwKGcsIGNwKSB7XHJcblx0Ly8gMjAyMzA5MTM6IGtlZXAgcHJpbWFyeSBhbmQgc2Vjb25kYXJ5IGRpc3RpbmN0IGluc3RlYWQgb2YgY3JlYXRpbmcgdmFsaWQgdW5pb25cclxuXHRyZXR1cm4gZy5QLmhhcyhjcCkgfHwgZy5RLmhhcyhjcCk7XHJcbn1cclxuXHJcbmNsYXNzIEVtb2ppIGV4dGVuZHMgQXJyYXkge1xyXG5cdGdldCBpc19lbW9qaSgpIHsgcmV0dXJuIHRydWU7IH0gLy8gZnJlZSB0YWdnaW5nIHN5c3RlbVxyXG59XHJcblxyXG5sZXQgTUFQUEVELCBJR05PUkVELCBDTSwgTlNNLCBFU0NBUEUsIE5GQ19DSEVDSywgR1JPVVBTLCBXSE9MRV9WQUxJRCwgV0hPTEVfTUFQLCBWQUxJRCwgRU1PSklfTElTVCwgRU1PSklfUk9PVDtcclxuXHJcbmZ1bmN0aW9uIGluaXQoKSB7XHJcblx0aWYgKE1BUFBFRCkgcmV0dXJuO1xyXG5cdFxyXG5cdGxldCByID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoQ09NUFJFU1NFRCQxKTtcclxuXHRjb25zdCByZWFkX3NvcnRlZF9hcnJheSA9ICgpID0+IHJlYWRfc29ydGVkKHIpO1xyXG5cdGNvbnN0IHJlYWRfc29ydGVkX3NldCA9ICgpID0+IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKSk7XHJcblxyXG5cdE1BUFBFRCA9IG5ldyBNYXAocmVhZF9tYXBwZWQocikpOyBcclxuXHRJR05PUkVEID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIGlnbm9yZWQgY2hhcmFjdGVycyBhcmUgbm90IHZhbGlkLCBzbyBqdXN0IHJlYWQgcmF3IGNvZGVwb2ludHNcclxuXHJcblx0LypcclxuXHQvLyBkaXJlY3QgaW5jbHVkZSBmcm9tIHBheWxvYWQgaXMgc21hbGxlciB0aGFuIHRoZSBkZWNvbXByZXNzaW9uIGNvZGVcclxuXHRjb25zdCBGRU5DRUQgPSBuZXcgTWFwKHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0bGV0IGNwID0gcigpO1xyXG5cdFx0aWYgKGNwKSByZXR1cm4gW2NwLCByZWFkX3N0cihyKCkpXTtcclxuXHR9KSk7XHJcblx0Ki9cclxuXHQvLyAyMDIzMDIxNzogd2Ugc3RpbGwgbmVlZCBhbGwgQ00gZm9yIHByb3BlciBlcnJvciBmb3JtYXR0aW5nXHJcblx0Ly8gYnV0IG5vcm0gb25seSBuZWVkcyBOU00gc3Vic2V0IHRoYXQgYXJlIHBvdGVudGlhbGx5LXZhbGlkXHJcblx0Q00gPSByZWFkX3NvcnRlZF9hcnJheSgpO1xyXG5cdE5TTSA9IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKS5tYXAoaSA9PiBDTVtpXSkpO1xyXG5cdENNID0gbmV3IFNldChDTSk7XHJcblx0XHJcblx0RVNDQVBFID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgbm90IGJlIHByaW50ZWRcclxuXHRORkNfQ0hFQ0sgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gb25seSBuZWVkZWQgdG8gaWxsdXN0cmF0ZSBlbnNfdG9rZW5pemUoKSB0cmFuc2Zvcm1hdGlvbnNcclxuXHJcblx0bGV0IGNodW5rcyA9IHJlYWRfc29ydGVkX2FycmF5cyhyKTtcclxuXHRsZXQgdW5yZXN0cmljdGVkID0gcigpO1xyXG5cdGNvbnN0IHJlYWRfY2h1bmtlZCA9ICgpID0+IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKS5mbGF0TWFwKGkgPT4gY2h1bmtzW2ldKS5jb25jYXQocmVhZF9zb3J0ZWRfYXJyYXkoKSkpO1xyXG5cdEdST1VQUyA9IHJlYWRfYXJyYXlfd2hpbGUoaSA9PiB7XHJcblx0XHQvLyBtaW5pZmllciBwcm9wZXJ0eSBtYW5nbGluZyBzZWVtcyB1bnNhZmVcclxuXHRcdC8vIHNvIHRoZXNlIGFyZSBtYW51YWxseSByZW5hbWVkIHRvIHNpbmdsZSBjaGFyc1xyXG5cdFx0bGV0IE4gPSByZWFkX2FycmF5X3doaWxlKHIpLm1hcCh4ID0+IHgrMHg2MCk7XHJcblx0XHRpZiAoTi5sZW5ndGgpIHtcclxuXHRcdFx0bGV0IFIgPSBpID49IHVucmVzdHJpY3RlZDsgLy8gZmlyc3QgYXJlbnQgcmVzdHJpY3RlZFxyXG5cdFx0XHROWzBdIC09IDMyOyAvLyBjYXBpdGFsaXplXHJcblx0XHRcdE4gPSBzdHJfZnJvbV9jcHMoTik7XHJcblx0XHRcdGlmIChSKSBOPWBSZXN0cmljdGVkWyR7Tn1dYDtcclxuXHRcdFx0bGV0IFAgPSByZWFkX2NodW5rZWQoKTsgLy8gcHJpbWFyeVxyXG5cdFx0XHRsZXQgUSA9IHJlYWRfY2h1bmtlZCgpOyAvLyBzZWNvbmRhcnlcclxuXHRcdFx0bGV0IE0gPSAhcigpOyAvLyBub3Qtd2hpdGVsaXN0ZWQsIGNoZWNrIGZvciBOU01cclxuXHRcdFx0Ly8gKioqIHRoaXMgY29kZSBjdXJyZW50bHkgaXNuJ3QgbmVlZGVkICoqKlxyXG5cdFx0XHQvKlxyXG5cdFx0XHRsZXQgViA9IFsuLi5QLCAuLi5RXS5zb3J0KChhLCBiKSA9PiBhLWIpOyAvLyBkZXJpdmU6IHNvcnRlZCB2YWxpZFxyXG5cdFx0XHRsZXQgTSA9IHIoKS0xOyAvLyBudW1iZXIgb2YgY29tYmluaW5nIG1hcmtcclxuXHRcdFx0aWYgKE0gPCAwKSB7IC8vIHdoaXRlbGlzdGVkXHJcblx0XHRcdFx0TSA9IG5ldyBNYXAocmVhZF9hcnJheV93aGlsZSgoKSA9PiB7XHJcblx0XHRcdFx0XHRsZXQgaSA9IHIoKTtcclxuXHRcdFx0XHRcdGlmIChpKSByZXR1cm4gW1ZbaS0xXSwgcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7XHJcblx0XHRcdFx0XHRcdGxldCB2ID0gcmVhZF9hcnJheV93aGlsZShyKTtcclxuXHRcdFx0XHRcdFx0aWYgKHYubGVuZ3RoKSByZXR1cm4gdi5tYXAoeCA9PiB4LTEpO1xyXG5cdFx0XHRcdFx0fSldO1xyXG5cdFx0XHRcdH0pKTtcclxuXHRcdFx0fSovXHJcblx0XHRcdHJldHVybiB7TiwgUCwgUSwgTSwgUn07XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdC8vIGRlY29kZSBjb21wcmVzc2VkIHdob2xlc1xyXG5cdFdIT0xFX1ZBTElEID0gcmVhZF9zb3J0ZWRfc2V0KCk7XHJcblx0V0hPTEVfTUFQID0gbmV3IE1hcCgpO1xyXG5cdGxldCB3aG9sZXMgPSByZWFkX3NvcnRlZF9hcnJheSgpLmNvbmNhdChBcnJheV9mcm9tKFdIT0xFX1ZBTElEKSkuc29ydCgoYSwgYikgPT4gYS1iKTsgLy8gbXVzdCBiZSBzb3J0ZWRcclxuXHR3aG9sZXMuZm9yRWFjaCgoY3AsIGkpID0+IHtcclxuXHRcdGxldCBkID0gcigpOyBcclxuXHRcdGxldCB3ID0gd2hvbGVzW2ldID0gZCA/IHdob2xlc1tpLWRdIDoge1Y6IFtdLCBNOiBuZXcgTWFwKCl9O1xyXG5cdFx0dy5WLnB1c2goY3ApOyAvLyBhZGQgdG8gbWVtYmVyIHNldFxyXG5cdFx0aWYgKCFXSE9MRV9WQUxJRC5oYXMoY3ApKSB7XHJcblx0XHRcdFdIT0xFX01BUC5zZXQoY3AsIHcpOyAgLy8gcmVnaXN0ZXIgd2l0aCB3aG9sZSBtYXBcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Ly8gY29tcHV0ZSBjb25mdXNhYmxlLWV4dGVudCBjb21wbGVtZW50c1xyXG5cdGZvciAobGV0IHtWLCBNfSBvZiBuZXcgU2V0KFdIT0xFX01BUC52YWx1ZXMoKSkpIHtcclxuXHRcdC8vIGNvbm5lY3QgYWxsIGdyb3VwcyB0aGF0IGhhdmUgZWFjaCB3aG9sZSBjaGFyYWN0ZXJcclxuXHRcdGxldCByZWNzID0gW107XHJcblx0XHRmb3IgKGxldCBjcCBvZiBWKSB7XHJcblx0XHRcdGxldCBncyA9IEdST1VQUy5maWx0ZXIoZyA9PiBncm91cF9oYXNfY3AoZywgY3ApKTtcclxuXHRcdFx0bGV0IHJlYyA9IHJlY3MuZmluZCgoe0d9KSA9PiBncy5zb21lKGcgPT4gRy5oYXMoZykpKTtcclxuXHRcdFx0aWYgKCFyZWMpIHtcclxuXHRcdFx0XHRyZWMgPSB7RzogbmV3IFNldCgpLCBWOiBbXX07XHJcblx0XHRcdFx0cmVjcy5wdXNoKHJlYyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmVjLlYucHVzaChjcCk7XHJcblx0XHRcdGdzLmZvckVhY2goZyA9PiByZWMuRy5hZGQoZykpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gcGVyIGNoYXJhY3RlciBjYWNoZSBncm91cHMgd2hpY2ggYXJlIG5vdCBhIG1lbWJlciBvZiB0aGUgZXh0ZW50XHJcblx0XHRsZXQgdW5pb24gPSByZWNzLmZsYXRNYXAoeCA9PiBBcnJheV9mcm9tKHguRykpO1xyXG5cdFx0Zm9yIChsZXQge0csIFZ9IG9mIHJlY3MpIHtcclxuXHRcdFx0bGV0IGNvbXBsZW1lbnQgPSBuZXcgU2V0KHVuaW9uLmZpbHRlcihnID0+ICFHLmhhcyhnKSkpO1xyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBWKSB7XHJcblx0XHRcdFx0TS5zZXQoY3AsIGNvbXBsZW1lbnQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBjb21wdXRlIHZhbGlkIHNldFxyXG5cdGxldCB1bmlvbiA9IG5ldyBTZXQoKTsgLy8gZXhpc3RzIGluIDErIGdyb3Vwc1xyXG5cdGxldCBtdWx0aSA9IG5ldyBTZXQoKTsgLy8gZXhpc3RzIGluIDIrIGdyb3Vwc1xyXG5cdGNvbnN0IGFkZF90b191bmlvbiA9IGNwID0+IHVuaW9uLmhhcyhjcCkgPyBtdWx0aS5hZGQoY3ApIDogdW5pb24uYWRkKGNwKTtcclxuXHRmb3IgKGxldCBnIG9mIEdST1VQUykge1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgZy5QKSBhZGRfdG9fdW5pb24oY3ApO1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgZy5RKSBhZGRfdG9fdW5pb24oY3ApO1xyXG5cdH1cclxuXHQvLyBkdWFsIHB1cnBvc2UgV0hPTEVfTUFQOiByZXR1cm4gcGxhY2Vob2xkZXIgaWYgdW5pcXVlIG5vbi1jb25mdXNhYmxlXHJcblx0Zm9yIChsZXQgY3Agb2YgdW5pb24pIHtcclxuXHRcdGlmICghV0hPTEVfTUFQLmhhcyhjcCkgJiYgIW11bHRpLmhhcyhjcCkpIHtcclxuXHRcdFx0V0hPTEVfTUFQLnNldChjcCwgVU5JUVVFX1BIKTtcclxuXHRcdH1cclxuXHR9XHJcblx0VkFMSUQgPSBuZXcgU2V0KEFycmF5X2Zyb20odW5pb24pLmNvbmNhdChBcnJheV9mcm9tKG5mZCh1bmlvbikpKSk7IC8vIHBvc3NpYmx5IHZhbGlkXHJcblxyXG5cdC8vIGRlY29kZSBlbW9qaVxyXG5cdC8vIDIwMjMwNzE5OiBlbW9qaSBhcmUgbm93IGZ1bGx5LWV4cGFuZGVkIHRvIGF2b2lkIHF1aXJrIGxvZ2ljIFxyXG5cdEVNT0pJX0xJU1QgPSByZWFkX3RyaWUocikubWFwKHYgPT4gRW1vamkuZnJvbSh2KSkuc29ydChjb21wYXJlX2FycmF5cyk7XHJcblx0RU1PSklfUk9PVCA9IG5ldyBNYXAoKTsgLy8gdGhpcyBoYXMgYXBwcm94IDdLIG5vZGVzICgyKyBwZXIgZW1vamkpXHJcblx0Zm9yIChsZXQgY3BzIG9mIEVNT0pJX0xJU1QpIHtcclxuXHRcdC8vIDIwMjMwNzE5OiBjaGFuZ2UgdG8gKnNsaWdodGx5KiBzdHJpY3RlciBhbGdvcml0aG0gd2hpY2ggZGlzYWxsb3dzIFxyXG5cdFx0Ly8gaW5zZXJ0aW9uIG9mIG1pc3BsYWNlZCBGRTBGIGluIGVtb2ppIHNlcXVlbmNlcyAobWF0Y2hpbmcgRU5TSVAtMTUpXHJcblx0XHQvLyBleGFtcGxlOiBiZWF1dGlmaWVkIFtBIEJdIChlZy4gZmxhZyBlbW9qaSkgXHJcblx0XHQvLyAgYmVmb3JlOiBhbGxvdzogW0EgRkUwRiBCXSwgZXJyb3I6IFtBIEZFMEYgRkUwRiBCXSBcclxuXHRcdC8vICAgYWZ0ZXI6IGVycm9yOiBib3RoXHJcblx0XHQvLyBub3RlOiB0aGlzIGNvZGUgbm93IG1hdGNoZXMgRU5TTm9ybWFsaXplLntjcyxqYXZhfSBsb2dpY1xyXG5cdFx0bGV0IHByZXYgPSBbRU1PSklfUk9PVF07XHJcblx0XHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdFx0bGV0IG5leHQgPSBwcmV2Lm1hcChub2RlID0+IHtcclxuXHRcdFx0XHRsZXQgY2hpbGQgPSBub2RlLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKCFjaGlsZCkge1xyXG5cdFx0XHRcdFx0Ly8gc2hvdWxkIHRoaXMgYmUgb2JqZWN0PyBcclxuXHRcdFx0XHRcdC8vIChtb3N0IGhhdmUgMS0yIGl0ZW1zLCBmZXcgaGF2ZSBtYW55KVxyXG5cdFx0XHRcdFx0Ly8gMjAyMzA3MTk6IG5vLCB2OCBkZWZhdWx0IG1hcCBpcyA0P1xyXG5cdFx0XHRcdFx0Y2hpbGQgPSBuZXcgTWFwKCk7XHJcblx0XHRcdFx0XHRub2RlLnNldChjcCwgY2hpbGQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gY2hpbGQ7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpZiAoY3AgPT09IEZFMEYpIHtcclxuXHRcdFx0XHRwcmV2LnB1c2goLi4ubmV4dCk7IC8vIGxlc3MgdGhhbiAyMCBlbGVtZW50c1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHByZXYgPSBuZXh0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKGxldCB4IG9mIHByZXYpIHtcclxuXHRcdFx0eC5WID0gY3BzO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gaWYgZXNjYXBlZDoge0hFWH1cclxuLy8gICAgICAgZWxzZTogXCJ4XCIge0hFWH1cclxuZnVuY3Rpb24gcXVvdGVkX2NwKGNwKSB7XHJcblx0cmV0dXJuIChzaG91bGRfZXNjYXBlKGNwKSA/ICcnIDogYCR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhbY3BdKSl9IGApICsgcXVvdGVfY3AoY3ApO1xyXG59XHJcblxyXG4vLyAyMDIzMDIxMTogc29tZSBtZXNzYWdlcyBjYW4gYmUgbWl4ZWQtZGlyZWN0aW9uYWwgYW5kIHJlc3VsdCBpbiBzcGlsbG92ZXJcclxuLy8gdXNlIDIwMEUgYWZ0ZXIgYSBxdW90ZWQgc3RyaW5nIHRvIGZvcmNlIHRoZSByZW1haW5kZXIgb2YgYSBzdHJpbmcgZnJvbSBcclxuLy8gYWNxdXJpbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcXVvdGVcclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL0ludGVybmF0aW9uYWwvcXVlc3Rpb25zL3FhLWJpZGktdW5pY29kZS1jb250cm9scyNleGNlcHRpb25zXHJcbmZ1bmN0aW9uIGJpZGlfcXEocykge1xyXG5cdHJldHVybiBgXCIke3N9XCJcXHUyMDBFYDsgLy8gc3Ryb25nIExUUlxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja19sYWJlbF9leHRlbnNpb24oY3BzKSB7XHJcblx0aWYgKGNwcy5sZW5ndGggPj0gNCAmJiBjcHNbMl0gPT0gSFlQSEVOICYmIGNwc1szXSA9PSBIWVBIRU4pIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBsYWJlbCBleHRlbnNpb246IFwiJHtzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKDAsIDQpKX1cImApO1xyXG5cdH1cclxufVxyXG5mdW5jdGlvbiBjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUoY3BzKSB7XHJcblx0Y29uc3QgVU5ERVJTQ09SRSA9IDB4NUY7XHJcblx0Zm9yIChsZXQgaSA9IGNwcy5sYXN0SW5kZXhPZihVTkRFUlNDT1JFKTsgaSA+IDA7ICkge1xyXG5cdFx0aWYgKGNwc1stLWldICE9PSBVTkRFUlNDT1JFKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcigndW5kZXJzY29yZSBhbGxvd2VkIG9ubHkgYXQgc3RhcnQnKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuLy8gY2hlY2sgdGhhdCBhIGZlbmNlZCBjcCBpcyBub3QgbGVhZGluZywgdHJhaWxpbmcsIG9yIHRvdWNoaW5nIGFub3RoZXIgZmVuY2VkIGNwXHJcbmZ1bmN0aW9uIGNoZWNrX2ZlbmNlZChjcHMpIHtcclxuXHRsZXQgY3AgPSBjcHNbMF07XHJcblx0bGV0IHByZXYgPSBGRU5DRUQuZ2V0KGNwKTtcclxuXHRpZiAocHJldikgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGBsZWFkaW5nICR7cHJldn1gKTtcclxuXHRsZXQgbiA9IGNwcy5sZW5ndGg7XHJcblx0bGV0IGxhc3QgPSAtMTsgLy8gcHJldmVudHMgdHJhaWxpbmcgZnJvbSB0aHJvd2luZ1xyXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRjcCA9IGNwc1tpXTtcclxuXHRcdGxldCBtYXRjaCA9IEZFTkNFRC5nZXQoY3ApO1xyXG5cdFx0aWYgKG1hdGNoKSB7XHJcblx0XHRcdC8vIHNpbmNlIGNwc1swXSBpc24ndCBmZW5jZWQsIGNwc1sxXSBjYW5ub3QgdGhyb3dcclxuXHRcdFx0aWYgKGxhc3QgPT0gaSkgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGAke3ByZXZ9ICsgJHttYXRjaH1gKTtcclxuXHRcdFx0bGFzdCA9IGkgKyAxO1xyXG5cdFx0XHRwcmV2ID0gbWF0Y2g7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChsYXN0ID09IG4pIHRocm93IGVycm9yX3BsYWNlbWVudChgdHJhaWxpbmcgJHtwcmV2fWApO1xyXG59XHJcblxyXG4vLyBjcmVhdGUgYSBzYWZlIHRvIHByaW50IHN0cmluZyBcclxuLy8gaW52aXNpYmxlcyBhcmUgZXNjYXBlZFxyXG4vLyBsZWFkaW5nIGNtIHVzZXMgcGxhY2Vob2xkZXJcclxuLy8gcXVvdGVyKGNwKSA9PiBzdHJpbmcsIGVnLiAzMDAwID0+IFwiezMwMDB9XCJcclxuLy8gbm90ZTogaW4gaHRtbCwgeW91J2QgY2FsbCB0aGlzIGZ1bmN0aW9uIHRoZW4gcmVwbGFjZSBbPD4mXSB3aXRoIGVudGl0aWVzXHJcbmZ1bmN0aW9uIHNhZmVfc3RyX2Zyb21fY3BzKGNwcywgcXVvdGVyID0gcXVvdGVfY3ApIHtcclxuXHQvL2lmIChOdW1iZXIuaXNJbnRlZ2VyKGNwcykpIGNwcyA9IFtjcHNdO1xyXG5cdC8vaWYgKCFBcnJheS5pc0FycmF5KGNwcykpIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIGNvZGVwb2ludHNgKTtcclxuXHRsZXQgYnVmID0gW107XHJcblx0aWYgKGlzX2NvbWJpbmluZ19tYXJrKGNwc1swXSkpIGJ1Zi5wdXNoKCfil4wnKTtcclxuXHRsZXQgcHJldiA9IDA7XHJcblx0bGV0IG4gPSBjcHMubGVuZ3RoO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRsZXQgY3AgPSBjcHNbaV07XHJcblx0XHRpZiAoc2hvdWxkX2VzY2FwZShjcCkpIHtcclxuXHRcdFx0YnVmLnB1c2goc3RyX2Zyb21fY3BzKGNwcy5zbGljZShwcmV2LCBpKSkpO1xyXG5cdFx0XHRidWYucHVzaChxdW90ZXIoY3ApKTtcclxuXHRcdFx0cHJldiA9IGkgKyAxO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRidWYucHVzaChzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKHByZXYsIG4pKSk7XHJcblx0cmV0dXJuIGJ1Zi5qb2luKCcnKTtcclxufVxyXG5cclxuLy8gbm90ZTogc2V0KHMpIGNhbm5vdCBiZSBleHBvc2VkIGJlY2F1c2UgdGhleSBjYW4gYmUgbW9kaWZpZWRcclxuLy8gbm90ZTogT2JqZWN0LmZyZWV6ZSgpIGRvZXNuJ3Qgd29ya1xyXG5mdW5jdGlvbiBpc19jb21iaW5pbmdfbWFyayhjcCkge1xyXG5cdGluaXQoKTtcclxuXHRyZXR1cm4gQ00uaGFzKGNwKTtcclxufVxyXG5mdW5jdGlvbiBzaG91bGRfZXNjYXBlKGNwKSB7XHJcblx0aW5pdCgpO1xyXG5cdHJldHVybiBFU0NBUEUuaGFzKGNwKTtcclxufVxyXG5cclxuLy8gcmV0dXJuIGFsbCBzdXBwb3J0ZWQgZW1vamkgYXMgZnVsbHktcXVhbGlmaWVkIGVtb2ppIFxyXG4vLyBvcmRlcmVkIGJ5IGxlbmd0aCB0aGVuIGxleGljb2dyYXBoaWMgXHJcbmZ1bmN0aW9uIGVuc19lbW9qaSgpIHtcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIEVNT0pJX0xJU1QubWFwKHggPT4geC5zbGljZSgpKTsgLy8gZW1vamkgYXJlIGV4cG9zZWQgc28gY29weVxyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfbm9ybWFsaXplX2ZyYWdtZW50KGZyYWcsIGRlY29tcG9zZSkge1xyXG5cdGluaXQoKTtcclxuXHRsZXQgbmYgPSBkZWNvbXBvc2UgPyBuZmQgOiBuZmM7XHJcblx0cmV0dXJuIGZyYWcuc3BsaXQoU1RPUF9DSCkubWFwKGxhYmVsID0+IHN0cl9mcm9tX2Nwcyh0b2tlbnNfZnJvbV9zdHIoZXhwbG9kZV9jcChsYWJlbCksIG5mLCBmaWx0ZXJfZmUwZikuZmxhdCgpKSkuam9pbihTVE9QX0NIKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX25vcm1hbGl6ZShuYW1lKSB7XHJcblx0cmV0dXJuIGZsYXR0ZW4oc3BsaXQobmFtZSwgbmZjLCBmaWx0ZXJfZmUwZikpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfYmVhdXRpZnkobmFtZSkge1xyXG5cdGxldCBsYWJlbHMgPSBzcGxpdChuYW1lLCBuZmMsIHggPT4geCk7IC8vIGVtb2ppIG5vdCBleHBvc2VkXHJcblx0Zm9yIChsZXQge3R5cGUsIG91dHB1dCwgZXJyb3J9IG9mIGxhYmVscykge1xyXG5cdFx0aWYgKGVycm9yKSBicmVhazsgLy8gZmxhdHRlbiB3aWxsIHRocm93XHJcblxyXG5cdFx0Ly8gcmVwbGFjZSBsZWFkaW5nL3RyYWlsaW5nIGh5cGhlblxyXG5cdFx0Ly8gMjAyMzAxMjE6IGNvbnNpZGVyIGJlYXV0aWZpbmcgYWxsIG9yIGxlYWRpbmcvdHJhaWxpbmcgaHlwaGVuIHRvIHVuaWNvZGUgdmFyaWFudFxyXG5cdFx0Ly8gbm90IGV4YWN0bHkgdGhlIHNhbWUgaW4gZXZlcnkgZm9udCwgYnV0IHZlcnkgc2ltaWxhcjogXCItXCIgdnMgXCLigJBcIlxyXG5cdFx0LypcclxuXHRcdGNvbnN0IFVOSUNPREVfSFlQSEVOID0gMHgyMDEwO1xyXG5cdFx0Ly8gbWF5YmUgdGhpcyBzaG91bGQgcmVwbGFjZSBhbGwgZm9yIHZpc3VhbCBjb25zaXN0YW5jeT9cclxuXHRcdC8vIGBub2RlIHRvb2xzL3JlZy1jb3VudC5qcyByZWdleCBeLVxcezIsXFx9YCA9PiA1OTJcclxuXHRcdC8vZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspIGlmIChvdXRwdXRbaV0gPT0gMHgyRCkgb3V0cHV0W2ldID0gMHgyMDEwO1xyXG5cdFx0aWYgKG91dHB1dFswXSA9PSBIWVBIRU4pIG91dHB1dFswXSA9IFVOSUNPREVfSFlQSEVOO1xyXG5cdFx0bGV0IGVuZCA9IG91dHB1dC5sZW5ndGgtMTtcclxuXHRcdGlmIChvdXRwdXRbZW5kXSA9PSBIWVBIRU4pIG91dHB1dFtlbmRdID0gVU5JQ09ERV9IWVBIRU47XHJcblx0XHQqL1xyXG5cdFx0Ly8gMjAyMzAxMjM6IFdIQVRXRyBVUkwgdXNlcyBcIkNoZWNrSHlwaGVuc1wiIGZhbHNlXHJcblx0XHQvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2lkbmFcclxuXHJcblx0XHQvLyB1cGRhdGUgZXRoZXJldW0gc3ltYm9sXHJcblx0XHQvLyDOviA9PiDOniBpZiBub3QgZ3JlZWtcclxuXHRcdGlmICh0eXBlICE9PSAnR3JlZWsnKSB7IFxyXG5cdFx0XHRsZXQgcHJldiA9IDA7XHJcblx0XHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdFx0bGV0IG5leHQgPSBvdXRwdXQuaW5kZXhPZigweDNCRSwgcHJldik7XHJcblx0XHRcdFx0aWYgKG5leHQgPCAwKSBicmVhaztcclxuXHRcdFx0XHRvdXRwdXRbbmV4dF0gPSAweDM5RTsgXHJcblx0XHRcdFx0cHJldiA9IG5leHQgKyAxO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gMjAyMjEyMTM6IGZpeGVzIGJpZGkgc3ViZG9tYWluIGlzc3VlLCBidXQgYnJlYWtzIGludmFyaWFudCAoMjAwRSBpcyBkaXNhbGxvd2VkKVxyXG5cdFx0Ly8gY291bGQgYmUgZml4ZWQgd2l0aCBzcGVjaWFsIGNhc2UgZm9yOiAyRCAoLikgKyAyMDBFIChMVFIpXHJcblx0XHQvLyBodHRwczovL2Rpc2N1c3MuZW5zLmRvbWFpbnMvdC9iaWRpLWxhYmVsLW9yZGVyaW5nLXNwb29mLzE1ODI0XHJcblx0XHQvL291dHB1dC5zcGxpY2UoMCwgMCwgMHgyMDBFKTtcclxuXHR9XHJcblx0cmV0dXJuIGZsYXR0ZW4obGFiZWxzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX3NwbGl0KG5hbWUsIHByZXNlcnZlX2Vtb2ppKSB7XHJcblx0cmV0dXJuIHNwbGl0KG5hbWUsIG5mYywgcHJlc2VydmVfZW1vamkgPyB4ID0+IHguc2xpY2UoKSA6IGZpbHRlcl9mZTBmKTsgLy8gZW1vamkgYXJlIGV4cG9zZWQgc28gY29weVxyXG59XHJcblxyXG5mdW5jdGlvbiBzcGxpdChuYW1lLCBuZiwgZWYpIHtcclxuXHRpZiAoIW5hbWUpIHJldHVybiBbXTsgLy8gMjAyMzA3MTk6IGVtcHR5IG5hbWUgYWxsb3dhbmNlXHJcblx0aW5pdCgpO1xyXG5cdGxldCBvZmZzZXQgPSAwO1xyXG5cdC8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjQ2LyNWYWxpZGl0eV9Dcml0ZXJpYVxyXG5cdC8vIDQuKSBcIlRoZSBsYWJlbCBtdXN0IG5vdCBjb250YWluIGEgVSswMDJFICggLiApIEZVTEwgU1RPUC5cIlxyXG5cdHJldHVybiBuYW1lLnNwbGl0KFNUT1BfQ0gpLm1hcChsYWJlbCA9PiB7XHJcblx0XHRsZXQgaW5wdXQgPSBleHBsb2RlX2NwKGxhYmVsKTtcclxuXHRcdGxldCBpbmZvID0ge1xyXG5cdFx0XHRpbnB1dCxcclxuXHRcdFx0b2Zmc2V0LCAvLyBjb2RlcG9pbnQsIG5vdCBzdWJzdHJpbmchXHJcblx0XHR9O1xyXG5cdFx0b2Zmc2V0ICs9IGlucHV0Lmxlbmd0aCArIDE7IC8vICsgc3RvcFxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gMS4pIFwiVGhlIGxhYmVsIG11c3QgYmUgaW4gVW5pY29kZSBOb3JtYWxpemF0aW9uIEZvcm0gTkZDXCJcclxuXHRcdFx0bGV0IHRva2VucyA9IGluZm8udG9rZW5zID0gdG9rZW5zX2Zyb21fc3RyKGlucHV0LCBuZiwgZWYpO1xyXG5cdFx0XHRsZXQgdG9rZW5fY291bnQgPSB0b2tlbnMubGVuZ3RoO1xyXG5cdFx0XHRsZXQgdHlwZTtcclxuXHRcdFx0aWYgKCF0b2tlbl9jb3VudCkgeyAvLyB0aGUgbGFiZWwgd2FzIGVmZmVjdGl2ZWx5IGVtcHR5IChjb3VsZCBvZiBoYWQgaWdub3JlZCBjaGFyYWN0ZXJzKVxyXG5cdFx0XHRcdC8vbm9ybSA9IFtdO1xyXG5cdFx0XHRcdC8vdHlwZSA9ICdOb25lJzsgLy8gdXNlIHRoaXMgaW5zdGVhZCBvZiBuZXh0IG1hdGNoLCBcIkFTQ0lJXCJcclxuXHRcdFx0XHQvLyAyMDIzMDEyMDogY2hhbmdlIHRvIHN0cmljdFxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vZGlzY3Vzcy5lbnMuZG9tYWlucy90L2Vucy1uYW1lLW5vcm1hbGl6YXRpb24tMm5kLzE0NTY0LzU5XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBlbXB0eSBsYWJlbGApO1xyXG5cdFx0XHR9IFxyXG5cdFx0XHRsZXQgbm9ybSA9IGluZm8ub3V0cHV0ID0gdG9rZW5zLmZsYXQoKTtcclxuXHRcdFx0Y2hlY2tfbGVhZGluZ191bmRlcnNjb3JlKG5vcm0pO1xyXG5cdFx0XHRsZXQgZW1vamkgPSBpbmZvLmVtb2ppID0gdG9rZW5fY291bnQgPiAxIHx8IHRva2Vuc1swXS5pc19lbW9qaTsgLy8gc2FtZSBhczogdG9rZW5zLnNvbWUoeCA9PiB4LmlzX2Vtb2ppKTtcclxuXHRcdFx0aWYgKCFlbW9qaSAmJiBub3JtLmV2ZXJ5KGNwID0+IGNwIDwgMHg4MCkpIHsgLy8gc3BlY2lhbCBjYXNlIGZvciBhc2NpaVxyXG5cdFx0XHRcdC8vIDIwMjMwMTIzOiBtYXRjaGVzIG1hdGNoZXMgV0hBVFdHLCBzZWUgbm90ZSAzLjNcclxuXHRcdFx0XHRjaGVja19sYWJlbF9leHRlbnNpb24obm9ybSk7IC8vIG9ubHkgbmVlZGVkIGZvciBhc2NpaVxyXG5cdFx0XHRcdC8vIGNhbnQgaGF2ZSBmZW5jZWRcclxuXHRcdFx0XHQvLyBjYW50IGhhdmUgY21cclxuXHRcdFx0XHQvLyBjYW50IGhhdmUgd2hvbGVzXHJcblx0XHRcdFx0Ly8gc2VlIGRlcml2ZTogXCJGYXN0cGF0aCBBU0NJSVwiXHJcblx0XHRcdFx0dHlwZSA9ICdBU0NJSSc7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IGNoYXJzID0gdG9rZW5zLmZsYXRNYXAoeCA9PiB4LmlzX2Vtb2ppID8gW10gOiB4KTsgLy8gYWxsIG9mIHRoZSBuZmMgdG9rZW5zIGNvbmNhdCB0b2dldGhlclxyXG5cdFx0XHRcdGlmICghY2hhcnMubGVuZ3RoKSB7IC8vIHRoZXJlcyBubyB0ZXh0LCBqdXN0IGVtb2ppXHJcblx0XHRcdFx0XHR0eXBlID0gJ0Vtb2ppJztcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gNS4pIFwiVGhlIGxhYmVsIG11c3Qgbm90IGJlZ2luIHdpdGggYSBjb21iaW5pbmcgbWFyaywgdGhhdCBpczogR2VuZXJhbF9DYXRlZ29yeT1NYXJrLlwiXHJcblx0XHRcdFx0XHRpZiAoQ00uaGFzKG5vcm1bMF0pKSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoJ2xlYWRpbmcgY29tYmluaW5nIG1hcmsnKTtcclxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgdG9rZW5fY291bnQ7IGkrKykgeyAvLyB3ZSd2ZSBhbHJlYWR5IGNoZWNrZWQgdGhlIGZpcnN0IHRva2VuXHJcblx0XHRcdFx0XHRcdGxldCBjcHMgPSB0b2tlbnNbaV07XHJcblx0XHRcdFx0XHRcdGlmICghY3BzLmlzX2Vtb2ppICYmIENNLmhhcyhjcHNbMF0pKSB7IC8vIGV2ZXJ5IHRleHQgdG9rZW4gaGFzIGVtb2ppIG5laWdoYm9ycywgZWcuIEV0RUVFdEV0Li4uXHJcblx0XHRcdFx0XHRcdFx0Ly8gYmlkaV9xcSgpIG5vdCBuZWVkZWQgc2luY2UgZW1vamkgaXMgTFRSIGFuZCBjcHMgaXMgYSBDTVxyXG5cdFx0XHRcdFx0XHRcdHRocm93IGVycm9yX3BsYWNlbWVudChgZW1vamkgKyBjb21iaW5pbmcgbWFyazogXCIke3N0cl9mcm9tX2Nwcyh0b2tlbnNbaS0xXSl9ICsgJHtzYWZlX3N0cl9mcm9tX2NwcyhbY3BzWzBdXSl9XCJgKTsgXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGNoZWNrX2ZlbmNlZChub3JtKTtcclxuXHRcdFx0XHRcdGxldCB1bmlxdWUgPSBBcnJheV9mcm9tKG5ldyBTZXQoY2hhcnMpKTtcclxuXHRcdFx0XHRcdGxldCBbZ10gPSBkZXRlcm1pbmVfZ3JvdXAodW5pcXVlKTsgLy8gdGFrZSB0aGUgZmlyc3QgbWF0Y2hcclxuXHRcdFx0XHRcdC8vIHNlZSBkZXJpdmU6IFwiTWF0Y2hpbmcgR3JvdXBzIGhhdmUgU2FtZSBDTSBTdHlsZVwiXHJcblx0XHRcdFx0XHQvLyBhbHRlcm5hdGl2ZTogY291bGQgZm9ybSBhIGh5YnJpZCB0eXBlOiBMYXRpbi9KYXBhbmVzZS8uLi5cdFxyXG5cdFx0XHRcdFx0Y2hlY2tfZ3JvdXAoZywgY2hhcnMpOyAvLyBuZWVkIHRleHQgaW4gb3JkZXJcclxuXHRcdFx0XHRcdGNoZWNrX3dob2xlKGcsIHVuaXF1ZSk7IC8vIG9ubHkgbmVlZCB1bmlxdWUgdGV4dCAob3JkZXIgd291bGQgYmUgcmVxdWlyZWQgZm9yIG11bHRpcGxlLWNoYXIgY29uZnVzYWJsZXMpXHJcblx0XHRcdFx0XHR0eXBlID0gZy5OO1xyXG5cdFx0XHRcdFx0Ly8gMjAyMzAxMjE6IGNvbnNpZGVyIGV4cG9zaW5nIHJlc3RyaWN0ZWQgZmxhZ1xyXG5cdFx0XHRcdFx0Ly8gaXQncyBzaW1wbGVyIHRvIGp1c3QgY2hlY2sgZm9yICdSZXN0cmljdGVkJ1xyXG5cdFx0XHRcdFx0Ly8gb3IgZXZlbiBiZXR0ZXI6IHR5cGUuZW5kc1dpdGgoJ10nKVxyXG5cdFx0XHRcdFx0Ly9pZiAoZy5SKSBpbmZvLnJlc3RyaWN0ZWQgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpbmZvLnR5cGUgPSB0eXBlO1xyXG5cdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdGluZm8uZXJyb3IgPSBlcnI7IC8vIHVzZSBmdWxsIGVycm9yIG9iamVjdFxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGluZm87XHJcblx0fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrX3dob2xlKGdyb3VwLCB1bmlxdWUpIHtcclxuXHRsZXQgbWFrZXI7XHJcblx0bGV0IHNoYXJlZCA9IFtdO1xyXG5cdGZvciAobGV0IGNwIG9mIHVuaXF1ZSkge1xyXG5cdFx0bGV0IHdob2xlID0gV0hPTEVfTUFQLmdldChjcCk7XHJcblx0XHRpZiAod2hvbGUgPT09IFVOSVFVRV9QSCkgcmV0dXJuOyAvLyB1bmlxdWUsIG5vbi1jb25mdXNhYmxlXHJcblx0XHRpZiAod2hvbGUpIHtcclxuXHRcdFx0bGV0IHNldCA9IHdob2xlLk0uZ2V0KGNwKTsgLy8gZ3JvdXBzIHdoaWNoIGhhdmUgYSBjaGFyYWN0ZXIgdGhhdCBsb29rLWxpa2UgdGhpcyBjaGFyYWN0ZXJcclxuXHRcdFx0bWFrZXIgPSBtYWtlciA/IG1ha2VyLmZpbHRlcihnID0+IHNldC5oYXMoZykpIDogQXJyYXlfZnJvbShzZXQpO1xyXG5cdFx0XHRpZiAoIW1ha2VyLmxlbmd0aCkgcmV0dXJuOyAvLyBjb25mdXNhYmxlIGludGVyc2VjdGlvbiBpcyBlbXB0eVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c2hhcmVkLnB1c2goY3ApOyBcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKG1ha2VyKSB7XHJcblx0XHQvLyB3ZSBoYXZlIDErIGNvbmZ1c2FibGVcclxuXHRcdC8vIGNoZWNrIGlmIGFueSBvZiB0aGUgcmVtYWluaW5nIGdyb3Vwc1xyXG5cdFx0Ly8gY29udGFpbiB0aGUgc2hhcmVkIGNoYXJhY3RlcnMgdG9vXHJcblx0XHRmb3IgKGxldCBnIG9mIG1ha2VyKSB7XHJcblx0XHRcdGlmIChzaGFyZWQuZXZlcnkoY3AgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSkpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHdob2xlLXNjcmlwdCBjb25mdXNhYmxlOiAke2dyb3VwLk59LyR7Zy5OfWApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBhc3N1bXB0aW9uOiB1bmlxdWUuc2l6ZSA+IDBcclxuLy8gcmV0dXJucyBsaXN0IG9mIG1hdGNoaW5nIGdyb3Vwc1xyXG5mdW5jdGlvbiBkZXRlcm1pbmVfZ3JvdXAodW5pcXVlKSB7XHJcblx0bGV0IGdyb3VwcyA9IEdST1VQUztcclxuXHRmb3IgKGxldCBjcCBvZiB1bmlxdWUpIHtcclxuXHRcdC8vIG5vdGU6IHdlIG5lZWQgdG8gZG9kZ2UgQ00gdGhhdCBhcmUgd2hpdGVsaXN0ZWRcclxuXHRcdC8vIGJ1dCB0aGF0IGNvZGUgaXNuJ3QgY3VycmVudGx5IG5lY2Vzc2FyeVxyXG5cdFx0bGV0IGdzID0gZ3JvdXBzLmZpbHRlcihnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpO1xyXG5cdFx0aWYgKCFncy5sZW5ndGgpIHtcclxuXHRcdFx0aWYgKCFHUk9VUFMuc29tZShnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpKSB7IFxyXG5cdFx0XHRcdC8vIHRoZSBjaGFyYWN0ZXIgd2FzIGNvbXBvc2VkIG9mIHZhbGlkIHBhcnRzXHJcblx0XHRcdFx0Ly8gYnV0IGl0J3MgTkZDIGZvcm0gaXMgaW52YWxpZFxyXG5cdFx0XHRcdC8vIDIwMjMwNzE2OiBjaGFuZ2UgdG8gbW9yZSBleGFjdCBzdGF0ZW1lbnQsIHNlZTogRU5TTm9ybWFsaXplLntjcyxqYXZhfVxyXG5cdFx0XHRcdC8vIG5vdGU6IHRoaXMgZG9lc24ndCBoYXZlIHRvIGJlIGEgY29tcG9zaXRpb25cclxuXHRcdFx0XHQvLyAyMDIzMDcyMDogY2hhbmdlIHRvIGZ1bGwgY2hlY2tcclxuXHRcdFx0XHR0aHJvdyBlcnJvcl9kaXNhbGxvd2VkKGNwKTsgLy8gdGhpcyBzaG91bGQgYmUgcmFyZVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIHRoZXJlIGlzIG5vIGdyb3VwIHRoYXQgY29udGFpbnMgYWxsIHRoZXNlIGNoYXJhY3RlcnNcclxuXHRcdFx0XHQvLyB0aHJvdyB1c2luZyB0aGUgaGlnaGVzdCBwcmlvcml0eSBncm91cCB0aGF0IG1hdGNoZWRcclxuXHRcdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI21peGVkX3NjcmlwdF9jb25mdXNhYmxlc1xyXG5cdFx0XHRcdHRocm93IGVycm9yX2dyb3VwX21lbWJlcihncm91cHNbMF0sIGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Z3JvdXBzID0gZ3M7XHJcblx0XHRpZiAoZ3MubGVuZ3RoID09IDEpIGJyZWFrOyAvLyB0aGVyZSBpcyBvbmx5IG9uZSBncm91cCBsZWZ0XHJcblx0fVxyXG5cdC8vIHRoZXJlIGFyZSBhdCBsZWFzdCAxIGdyb3VwKHMpIHdpdGggYWxsIG9mIHRoZXNlIGNoYXJhY3RlcnNcclxuXHRyZXR1cm4gZ3JvdXBzO1xyXG59XHJcblxyXG4vLyB0aHJvdyBvbiBmaXJzdCBlcnJvclxyXG5mdW5jdGlvbiBmbGF0dGVuKHNwbGl0KSB7XHJcblx0cmV0dXJuIHNwbGl0Lm1hcCgoe2lucHV0LCBlcnJvciwgb3V0cHV0fSkgPT4ge1xyXG5cdFx0aWYgKGVycm9yKSB7XHJcblx0XHRcdC8vIGRvbid0IHByaW50IGxhYmVsIGFnYWluIGlmIGp1c3QgYSBzaW5nbGUgbGFiZWxcclxuXHRcdFx0bGV0IG1zZyA9IGVycm9yLm1lc3NhZ2U7XHJcblx0XHRcdC8vIGJpZGlfcXEoKSBvbmx5IG5lY2Vzc2FyeSBpZiBtc2cgaXMgZGlnaXRzXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihzcGxpdC5sZW5ndGggPT0gMSA/IG1zZyA6IGBJbnZhbGlkIGxhYmVsICR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhpbnB1dCkpfTogJHttc2d9YCk7IFxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0cl9mcm9tX2NwcyhvdXRwdXQpO1xyXG5cdH0pLmpvaW4oU1RPUF9DSCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVycm9yX2Rpc2FsbG93ZWQoY3ApIHtcclxuXHQvLyBUT0RPOiBhZGQgY3AgdG8gZXJyb3I/XHJcblx0cmV0dXJuIG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjaGFyYWN0ZXI6ICR7cXVvdGVkX2NwKGNwKX1gKTsgXHJcbn1cclxuZnVuY3Rpb24gZXJyb3JfZ3JvdXBfbWVtYmVyKGcsIGNwKSB7XHJcblx0bGV0IHF1b3RlZCA9IHF1b3RlZF9jcChjcCk7XHJcblx0bGV0IGdnID0gR1JPVVBTLmZpbmQoZyA9PiBnLlAuaGFzKGNwKSk7IC8vIG9ubHkgY2hlY2sgcHJpbWFyeVxyXG5cdGlmIChnZykge1xyXG5cdFx0cXVvdGVkID0gYCR7Z2cuTn0gJHtxdW90ZWR9YDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBFcnJvcihgaWxsZWdhbCBtaXh0dXJlOiAke2cuTn0gKyAke3F1b3RlZH1gKTtcclxufVxyXG5mdW5jdGlvbiBlcnJvcl9wbGFjZW1lbnQod2hlcmUpIHtcclxuXHRyZXR1cm4gbmV3IEVycm9yKGBpbGxlZ2FsIHBsYWNlbWVudDogJHt3aGVyZX1gKTtcclxufVxyXG5cclxuLy8gYXNzdW1wdGlvbjogY3BzLmxlbmd0aCA+IDBcclxuLy8gYXNzdW1wdGlvbjogY3BzWzBdIGlzbid0IGEgQ01cclxuLy8gYXNzdW1wdGlvbjogdGhlIHByZXZpb3VzIGNoYXJhY3RlciBpc24ndCBhbiBlbW9qaVxyXG5mdW5jdGlvbiBjaGVja19ncm91cChnLCBjcHMpIHtcclxuXHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdGlmICghZ3JvdXBfaGFzX2NwKGcsIGNwKSkge1xyXG5cdFx0XHQvLyBmb3Igd2hpdGVsaXN0ZWQgc2NyaXB0cywgdGhpcyB3aWxsIHRocm93IGlsbGVnYWwgbWl4dHVyZSBvbiBpbnZhbGlkIGNtLCBlZy4gXCJlezMwMH17MzAwfVwiXHJcblx0XHRcdC8vIGF0IHRoZSBtb21lbnQsIGl0J3MgdW5uZWNlc3NhcnkgdG8gaW50cm9kdWNlIGFuIGV4dHJhIGVycm9yIHR5cGVcclxuXHRcdFx0Ly8gdW50aWwgdGhlcmUgZXhpc3RzIGEgd2hpdGVsaXN0ZWQgbXVsdGktY2hhcmFjdGVyXHJcblx0XHRcdC8vICAgZWcuIGlmIChNIDwgMCAmJiBpc19jb21iaW5pbmdfbWFyayhjcCkpIHsgLi4uIH1cclxuXHRcdFx0Ly8gdGhlcmUgYXJlIDMgY2FzZXM6XHJcblx0XHRcdC8vICAgMS4gaWxsZWdhbCBjbSBmb3Igd3JvbmcgZ3JvdXAgPT4gbWl4dHVyZSBlcnJvclxyXG5cdFx0XHQvLyAgIDIuIGlsbGVnYWwgY20gZm9yIHNhbWUgZ3JvdXAgPT4gY20gZXJyb3JcclxuXHRcdFx0Ly8gICAgICAgcmVxdWlyZXMgc2V0IG9mIHdoaXRlbGlzdCBjbSBwZXIgZ3JvdXA6IFxyXG5cdFx0XHQvLyAgICAgICAgZWcuIG5ldyBTZXQoWy4uLmcuUCwgLi4uZy5RXS5mbGF0TWFwKG5mYykuZmlsdGVyKGNwID0+IENNLmhhcyhjcCkpKVxyXG5cdFx0XHQvLyAgIDMuIHdyb25nIGdyb3VwID0+IG1peHR1cmUgZXJyb3JcclxuXHRcdFx0dGhyb3cgZXJyb3JfZ3JvdXBfbWVtYmVyKGcsIGNwKTtcclxuXHRcdH1cclxuXHR9XHJcblx0Ly9pZiAoTSA+PSAwKSB7IC8vIHdlIGhhdmUgYSBrbm93biBmaXhlZCBjbSBjb3VudFxyXG5cdGlmIChnLk0pIHsgLy8gd2UgbmVlZCB0byBjaGVjayBmb3IgTlNNXHJcblx0XHRsZXQgZGVjb21wb3NlZCA9IG5mZChjcHMpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDEsIGUgPSBkZWNvbXBvc2VkLmxlbmd0aDsgaSA8IGU7IGkrKykgeyAvLyBzZWU6IGFzc3VtcHRpb25cclxuXHRcdFx0Ly8gMjAyMzAyMTA6IGJ1Z2ZpeDogdXNpbmcgY3BzIGluc3RlYWQgb2YgZGVjb21wb3NlZCBoL3QgQ2FyYm9uMjI1XHJcblx0XHRcdC8qXHJcblx0XHRcdGlmIChDTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdHdoaWxlIChqIDwgZSAmJiBDTS5oYXMoZGVjb21wb3NlZFtqXSkpIGorKztcclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBNKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHRvbyBtYW55IGNvbWJpbmluZyBtYXJrczogJHtnLk59ICR7YmlkaV9xcShzdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKSl9ICgke2otaX0vJHtNfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdFx0Ki9cclxuXHRcdFx0Ly8gMjAyMzAyMTc6IHN3aXRjaCB0byBOU00gY291bnRpbmdcclxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNPcHRpb25hbF9EZXRlY3Rpb25cclxuXHRcdFx0aWYgKE5TTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdGZvciAobGV0IGNwOyBqIDwgZSAmJiBOU00uaGFzKGNwID0gZGVjb21wb3NlZFtqXSk7IGorKykge1xyXG5cdFx0XHRcdFx0Ly8gYS4gRm9yYmlkIHNlcXVlbmNlcyBvZiB0aGUgc2FtZSBub25zcGFjaW5nIG1hcmsuXHJcblx0XHRcdFx0XHRmb3IgKGxldCBrID0gaTsgayA8IGo7IGsrKykgeyAvLyBPKG5eMikgYnV0IG4gPCAxMDBcclxuXHRcdFx0XHRcdFx0aWYgKGRlY29tcG9zZWRba10gPT0gY3ApIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZSBub24tc3BhY2luZyBtYXJrczogJHtxdW90ZWRfY3AoY3ApfWApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIHBhcnNlIHRvIGVuZCBzbyB3ZSBoYXZlIGZ1bGwgbnNtIGNvdW50XHJcblx0XHRcdFx0Ly8gYi4gRm9yYmlkIHNlcXVlbmNlcyBvZiBtb3JlIHRoYW4gNCBub25zcGFjaW5nIG1hcmtzIChnYz1NbiBvciBnYz1NZSkuXHJcblx0XHRcdFx0aWYgKGogLSBpID4gTlNNX01BWCkge1xyXG5cdFx0XHRcdFx0Ly8gbm90ZTogdGhpcyBzbGljZSBzdGFydHMgd2l0aCBhIGJhc2UgY2hhciBvciBzcGFjaW5nLW1hcmsgY21cclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZXhjZXNzaXZlIG5vbi1zcGFjaW5nIG1hcmtzOiAke2JpZGlfcXEoc2FmZV9zdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKSl9ICgke2otaX0vJHtOU01fTUFYfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0Ly8gKioqIHRoaXMgY29kZSBjdXJyZW50bHkgaXNuJ3QgbmVlZGVkICoqKlxyXG5cdC8qXHJcblx0bGV0IGNtX3doaXRlbGlzdCA9IE0gaW5zdGFuY2VvZiBNYXA7XHJcblx0Zm9yIChsZXQgaSA9IDAsIGUgPSBjcHMubGVuZ3RoOyBpIDwgZTsgKSB7XHJcblx0XHRsZXQgY3AgPSBjcHNbaSsrXTtcclxuXHRcdGxldCBzZXFzID0gY21fd2hpdGVsaXN0ICYmIE0uZ2V0KGNwKTtcclxuXHRcdGlmIChzZXFzKSB7IFxyXG5cdFx0XHQvLyBsaXN0IG9mIGNvZGVwb2ludHMgdGhhdCBjYW4gZm9sbG93XHJcblx0XHRcdC8vIGlmIHRoaXMgZXhpc3RzLCB0aGlzIHdpbGwgYWx3YXlzIGJlIDErXHJcblx0XHRcdGxldCBqID0gaTtcclxuXHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhjcHNbal0pKSBqKys7XHJcblx0XHRcdGxldCBjbXMgPSBjcHMuc2xpY2UoaSwgaik7XHJcblx0XHRcdGxldCBtYXRjaCA9IHNlcXMuZmluZChzZXEgPT4gIWNvbXBhcmVfYXJyYXlzKHNlcSwgY21zKSk7XHJcblx0XHRcdGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjb21iaW5pbmcgbWFyayBzZXF1ZW5jZTogXCIke3NhZmVfc3RyX2Zyb21fY3BzKFtjcCwgLi4uY21zXSl9XCJgKTtcclxuXHRcdFx0aSA9IGo7XHJcblx0XHR9IGVsc2UgaWYgKCFWLmhhcyhjcCkpIHtcclxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNtaXhlZF9zY3JpcHRfY29uZnVzYWJsZXNcclxuXHRcdFx0bGV0IHF1b3RlZCA9IHF1b3RlZF9jcChjcCk7XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0XHRcdGxldCB1ID0gVU5JUVVFLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKHUgJiYgdSAhPT0gZykge1xyXG5cdFx0XHRcdFx0Ly8gaWYgYm90aCBzY3JpcHRzIGFyZSByZXN0cmljdGVkIHRoaXMgZXJyb3IgaXMgY29uZnVzaW5nXHJcblx0XHRcdFx0XHQvLyBiZWNhdXNlIHdlIGRvbid0IGRpZmZlcmVudGlhdGUgUmVzdHJpY3RlZEEgZnJvbSBSZXN0cmljdGVkQiBcclxuXHRcdFx0XHRcdGlmICghdS5SKSBxdW90ZWQgPSBgJHtxdW90ZWR9IGlzICR7dS5OfWA7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkICR7Zy5OfSBjaGFyYWN0ZXI6ICR7cXVvdGVkfWApO1xyXG5cdFx0XHQvL3Rocm93IG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjaGFyYWN0ZXI6ICR7cXVvdGVkfSAoZXhwZWN0ZWQgJHtnLk59KWApO1xyXG5cdFx0XHQvL3Rocm93IG5ldyBFcnJvcihgJHtnLk59IGRvZXMgbm90IGFsbG93OiAke3F1b3RlZH1gKTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKCFjbV93aGl0ZWxpc3QpIHtcclxuXHRcdGxldCBkZWNvbXBvc2VkID0gbmZkKGNwcyk7XHJcblx0XHRmb3IgKGxldCBpID0gMSwgZSA9IGRlY29tcG9zZWQubGVuZ3RoOyBpIDwgZTsgaSsrKSB7IC8vIHdlIGtub3cgaXQgY2FuJ3QgYmUgY20gbGVhZGluZ1xyXG5cdFx0XHRpZiAoQ00uaGFzKGRlY29tcG9zZWRbaV0pKSB7XHJcblx0XHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGRlY29tcG9zZWRbal0pKSBqKys7XHJcblx0XHRcdFx0aWYgKGogLSBpID4gTSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB0b28gbWFueSBjb21iaW5pbmcgbWFya3M6IFwiJHtzdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKX1cIiAoJHtqLWl9LyR7TX0pYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGkgPSBqO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdCovXHJcbn1cclxuXHJcbi8vIGdpdmVuIGEgbGlzdCBvZiBjb2RlcG9pbnRzXHJcbi8vIHJldHVybnMgYSBsaXN0IG9mIGxpc3RzLCB3aGVyZSBlbW9qaSBhcmUgYSBmdWxseS1xdWFsaWZpZWQgKGFzIEFycmF5IHN1YmNsYXNzKVxyXG4vLyBlZy4gZXhwbG9kZV9jcChcImFiY/CfkqlkXCIpID0+IFtbNjEsIDYyLCA2M10sIEVtb2ppWzFGNEE5LCBGRTBGXSwgWzY0XV1cclxuLy8gMjAyMzA4MTg6IHJlbmFtZSBmb3IgJ3Byb2Nlc3MnIG5hbWUgY29sbGlzaW9uIGgvdCBKYXZhcm9tZVxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2lzc3Vlcy8yM1xyXG5mdW5jdGlvbiB0b2tlbnNfZnJvbV9zdHIoaW5wdXQsIG5mLCBlZikge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgY2hhcnMgPSBbXTtcclxuXHRpbnB1dCA9IGlucHV0LnNsaWNlKCkucmV2ZXJzZSgpOyAvLyBmbGlwIHNvIHdlIGNhbiBwb3BcclxuXHR3aGlsZSAoaW5wdXQubGVuZ3RoKSB7XHJcblx0XHRsZXQgZW1vamkgPSBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGlucHV0KTtcclxuXHRcdGlmIChlbW9qaSkge1xyXG5cdFx0XHRpZiAoY2hhcnMubGVuZ3RoKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gobmYoY2hhcnMpKTtcclxuXHRcdFx0XHRjaGFycyA9IFtdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldC5wdXNoKGVmKGVtb2ppKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY3AgPSBpbnB1dC5wb3AoKTtcclxuXHRcdFx0aWYgKFZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0XHRjaGFycy5wdXNoKGNwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY3BzID0gTUFQUEVELmdldChjcCk7XHJcblx0XHRcdFx0aWYgKGNwcykge1xyXG5cdFx0XHRcdFx0Y2hhcnMucHVzaCguLi5jcHMpOyAvLyBsZXNzIHRoYW4gMTAgZWxlbWVudHNcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCFJR05PUkVELmhhcyhjcCkpIHtcclxuXHRcdFx0XHRcdC8vIDIwMjMwOTEyOiB1bmljb2RlIDE1LjEgY2hhbmdlZCB0aGUgb3JkZXIgb2YgcHJvY2Vzc2luZyBzdWNoIHRoYXRcclxuXHRcdFx0XHRcdC8vIGRpc2FsbG93ZWQgcGFydHMgYXJlIG9ubHkgcmVqZWN0ZWQgYWZ0ZXIgTkZDXHJcblx0XHRcdFx0XHQvLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI0Ni8jVmFsaWRpdHlfQ3JpdGVyaWFcclxuXHRcdFx0XHRcdC8vIHRoaXMgZG9lc24ndCBpbXBhY3Qgbm9ybWFsaXphdGlvbiBhcyBvZiB0b2RheVxyXG5cdFx0XHRcdFx0Ly8gdGVjaG5pY2FsbHksIHRoaXMgZXJyb3IgY2FuIGJlIHJlbW92ZWQgYXMgdGhlIGdyb3VwIGxvZ2ljIHdpbGwgYXBwbHkgc2ltaWxhciBsb2dpY1xyXG5cdFx0XHRcdFx0Ly8gaG93ZXZlciB0aGUgZXJyb3IgdHlwZSBtaWdodCBiZSBsZXNzIGNsZWFyXHJcblx0XHRcdFx0XHR0aHJvdyBlcnJvcl9kaXNhbGxvd2VkKGNwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGNoYXJzLmxlbmd0aCkge1xyXG5cdFx0cmV0LnB1c2gobmYoY2hhcnMpKTtcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gZmlsdGVyX2ZlMGYoY3BzKSB7XHJcblx0cmV0dXJuIGNwcy5maWx0ZXIoY3AgPT4gY3AgIT0gRkUwRik7XHJcbn1cclxuXHJcbi8vIGdpdmVuIGFycmF5IG9mIGNvZGVwb2ludHNcclxuLy8gcmV0dXJucyB0aGUgbG9uZ2VzdCB2YWxpZCBlbW9qaSBzZXF1ZW5jZSAob3IgdW5kZWZpbmVkIGlmIG5vIG1hdGNoKVxyXG4vLyAqTVVUQVRFUyogdGhlIHN1cHBsaWVkIGFycmF5XHJcbi8vIGRpc2FsbG93cyBpbnRlcmxlYXZlZCBpZ25vcmVkIGNoYXJhY3RlcnNcclxuLy8gZmlsbHMgKG9wdGlvbmFsKSBlYXRlbiBhcnJheSB3aXRoIG1hdGNoZWQgY29kZXBvaW50c1xyXG5mdW5jdGlvbiBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGNwcywgZWF0ZW4pIHtcclxuXHRsZXQgbm9kZSA9IEVNT0pJX1JPT1Q7XHJcblx0bGV0IGVtb2ppO1xyXG5cdGxldCBwb3MgPSBjcHMubGVuZ3RoO1xyXG5cdHdoaWxlIChwb3MpIHtcclxuXHRcdG5vZGUgPSBub2RlLmdldChjcHNbLS1wb3NdKTtcclxuXHRcdGlmICghbm9kZSkgYnJlYWs7XHJcblx0XHRsZXQge1Z9ID0gbm9kZTtcclxuXHRcdGlmIChWKSB7IC8vIHRoaXMgaXMgYSB2YWxpZCBlbW9qaSAoc28gZmFyKVxyXG5cdFx0XHRlbW9qaSA9IFY7XHJcblx0XHRcdGlmIChlYXRlbikgZWF0ZW4ucHVzaCguLi5jcHMuc2xpY2UocG9zKS5yZXZlcnNlKCkpOyAvLyAob3B0aW9uYWwpIGNvcHkgaW5wdXQsIHVzZWQgZm9yIGVuc190b2tlbml6ZSgpXHJcblx0XHRcdGNwcy5sZW5ndGggPSBwb3M7IC8vIHRydW5jYXRlXHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBlbW9qaTtcclxufVxyXG5cclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vIHRva2VuaXplciBcclxuXHJcbmNvbnN0IFRZX1ZBTElEID0gJ3ZhbGlkJztcclxuY29uc3QgVFlfTUFQUEVEID0gJ21hcHBlZCc7XHJcbmNvbnN0IFRZX0lHTk9SRUQgPSAnaWdub3JlZCc7XHJcbmNvbnN0IFRZX0RJU0FMTE9XRUQgPSAnZGlzYWxsb3dlZCc7XHJcbmNvbnN0IFRZX0VNT0pJID0gJ2Vtb2ppJztcclxuY29uc3QgVFlfTkZDID0gJ25mYyc7XHJcbmNvbnN0IFRZX1NUT1AgPSAnc3RvcCc7XHJcblxyXG5mdW5jdGlvbiBlbnNfdG9rZW5pemUobmFtZSwge1xyXG5cdG5mID0gdHJ1ZSwgLy8gY29sbGFwc2UgdW5ub3JtYWxpemVkIHJ1bnMgaW50byBhIHNpbmdsZSB0b2tlblxyXG59ID0ge30pIHtcclxuXHRpbml0KCk7XHJcblx0bGV0IGlucHV0ID0gZXhwbG9kZV9jcChuYW1lKS5yZXZlcnNlKCk7XHJcblx0bGV0IGVhdGVuID0gW107XHJcblx0bGV0IHRva2VucyA9IFtdO1xyXG5cdHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcclxuXHRcdGxldCBlbW9qaSA9IGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoaW5wdXQsIGVhdGVuKTtcclxuXHRcdGlmIChlbW9qaSkge1xyXG5cdFx0XHR0b2tlbnMucHVzaCh7XHJcblx0XHRcdFx0dHlwZTogVFlfRU1PSkksXHJcblx0XHRcdFx0ZW1vamk6IGVtb2ppLnNsaWNlKCksIC8vIGNvcHkgZW1vamlcclxuXHRcdFx0XHRpbnB1dDogZWF0ZW4sXHJcblx0XHRcdFx0Y3BzOiBmaWx0ZXJfZmUwZihlbW9qaSlcclxuXHRcdFx0fSk7XHJcblx0XHRcdGVhdGVuID0gW107IC8vIHJlc2V0IGJ1ZmZlclxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGNwID0gaW5wdXQucG9wKCk7XHJcblx0XHRcdGlmIChjcCA9PSBTVE9QKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX1NUT1AsIGNwfSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9WQUxJRCwgY3BzOiBbY3BdfSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoSUdOT1JFRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX0lHTk9SRUQsIGNwfSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IGNwcyA9IE1BUFBFRC5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmIChjcHMpIHtcclxuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9NQVBQRUQsIGNwLCBjcHM6IGNwcy5zbGljZSgpfSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9ESVNBTExPV0VELCBjcH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAobmYpIHtcclxuXHRcdGZvciAobGV0IGkgPSAwLCBzdGFydCA9IC0xOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCB0b2tlbiA9IHRva2Vuc1tpXTtcclxuXHRcdFx0aWYgKGlzX3ZhbGlkX29yX21hcHBlZCh0b2tlbi50eXBlKSkge1xyXG5cdFx0XHRcdGlmIChyZXF1aXJlc19jaGVjayh0b2tlbi5jcHMpKSB7IC8vIG5vcm1hbGl6YXRpb24gbWlnaHQgYmUgbmVlZGVkXHJcblx0XHRcdFx0XHRsZXQgZW5kID0gaSArIDE7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBwb3MgPSBlbmQ7IHBvcyA8IHRva2Vucy5sZW5ndGg7IHBvcysrKSB7IC8vIGZpbmQgYWRqYWNlbnQgdGV4dFxyXG5cdFx0XHRcdFx0XHRsZXQge3R5cGUsIGNwc30gPSB0b2tlbnNbcG9zXTtcclxuXHRcdFx0XHRcdFx0aWYgKGlzX3ZhbGlkX29yX21hcHBlZCh0eXBlKSkge1xyXG5cdFx0XHRcdFx0XHRcdGlmICghcmVxdWlyZXNfY2hlY2soY3BzKSkgYnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0ZW5kID0gcG9zICsgMTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlICE9PSBUWV9JR05PUkVEKSB7IC8vIHx8IHR5cGUgIT09IFRZX0RJU0FMTE9XRUQpIHsgXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChzdGFydCA8IDApIHN0YXJ0ID0gaTtcclxuXHRcdFx0XHRcdGxldCBzbGljZSA9IHRva2Vucy5zbGljZShzdGFydCwgZW5kKTtcclxuXHRcdFx0XHRcdGxldCBjcHMwID0gc2xpY2UuZmxhdE1hcCh4ID0+IGlzX3ZhbGlkX29yX21hcHBlZCh4LnR5cGUpID8geC5jcHMgOiBbXSk7IC8vIHN0cmlwIGp1bmsgdG9rZW5zXHJcblx0XHRcdFx0XHRsZXQgY3BzID0gbmZjKGNwczApO1xyXG5cdFx0XHRcdFx0aWYgKGNvbXBhcmVfYXJyYXlzKGNwcywgY3BzMCkpIHsgLy8gYnVuZGxlIGludG8gYW4gbmZjIHRva2VuXHJcblx0XHRcdFx0XHRcdHRva2Vucy5zcGxpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0LCB7XHJcblx0XHRcdFx0XHRcdFx0dHlwZTogVFlfTkZDLCBcclxuXHRcdFx0XHRcdFx0XHRpbnB1dDogY3BzMCwgLy8gdGhlcmUgYXJlIDMgc3RhdGVzOiB0b2tlbnMwID09KHByb2Nlc3MpPT4gaW5wdXQgPT0obmZjKT0+IHRva2Vucy9jcHNcclxuXHRcdFx0XHRcdFx0XHRjcHMsIFxyXG5cdFx0XHRcdFx0XHRcdHRva2VuczA6IGNvbGxhcHNlX3ZhbGlkX3Rva2VucyhzbGljZSksXHJcblx0XHRcdFx0XHRcdFx0dG9rZW5zOiBlbnNfdG9rZW5pemUoc3RyX2Zyb21fY3BzKGNwcyksIHtuZjogZmFsc2V9KVxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0aSA9IHN0YXJ0O1xyXG5cdFx0XHRcdFx0fSBlbHNlIHsgXHJcblx0XHRcdFx0XHRcdGkgPSBlbmQgLSAxOyAvLyBza2lwIHRvIGVuZCBvZiBzbGljZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c3RhcnQgPSAtMTsgLy8gcmVzZXRcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c3RhcnQgPSBpOyAvLyByZW1lbWJlciBsYXN0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKHRva2VuLnR5cGUgIT09IFRZX0lHTk9SRUQpIHsgLy8gMjAyMjEwMjQ6IGlzIHRoaXMgY29ycmVjdD9cclxuXHRcdFx0XHRzdGFydCA9IC0xOyAvLyByZXNldFxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBjb2xsYXBzZV92YWxpZF90b2tlbnModG9rZW5zKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNfdmFsaWRfb3JfbWFwcGVkKHR5cGUpIHtcclxuXHRyZXR1cm4gdHlwZSA9PSBUWV9WQUxJRCB8fCB0eXBlID09IFRZX01BUFBFRDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVxdWlyZXNfY2hlY2soY3BzKSB7XHJcblx0cmV0dXJuIGNwcy5zb21lKGNwID0+IE5GQ19DSEVDSy5oYXMoY3ApKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29sbGFwc2VfdmFsaWRfdG9rZW5zKHRva2Vucykge1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAodG9rZW5zW2ldLnR5cGUgPT0gVFlfVkFMSUQpIHtcclxuXHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0d2hpbGUgKGogPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tqXS50eXBlID09IFRZX1ZBTElEKSBqKys7XHJcblx0XHRcdHRva2Vucy5zcGxpY2UoaSwgaiAtIGksIHt0eXBlOiBUWV9WQUxJRCwgY3BzOiB0b2tlbnMuc2xpY2UoaSwgaikuZmxhdE1hcCh4ID0+IHguY3BzKX0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gdG9rZW5zO1xyXG59XG5cbmV4cG9ydCB7IGVuc19iZWF1dGlmeSwgZW5zX2Vtb2ppLCBlbnNfbm9ybWFsaXplLCBlbnNfbm9ybWFsaXplX2ZyYWdtZW50LCBlbnNfc3BsaXQsIGVuc190b2tlbml6ZSwgaXNfY29tYmluaW5nX21hcmssIG5mYywgbmZkLCBzYWZlX3N0cl9mcm9tX2Nwcywgc2hvdWxkX2VzY2FwZSB9O1xuIiwiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBoZXhsaWZ5LCBhc3NlcnRBcmd1bWVudCwgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGVuc19ub3JtYWxpemUgfSBmcm9tIFwiQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZVwiO1xuY29uc3QgWmVyb3MgPSBuZXcgVWludDhBcnJheSgzMik7XG5aZXJvcy5maWxsKDApO1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnQoY29tcCkge1xuICAgIGFzc2VydEFyZ3VtZW50KGNvbXAubGVuZ3RoICE9PSAwLCBcImludmFsaWQgRU5TIG5hbWU7IGVtcHR5IGNvbXBvbmVudFwiLCBcImNvbXBcIiwgY29tcCk7XG4gICAgcmV0dXJuIGNvbXA7XG59XG5mdW5jdGlvbiBlbnNOYW1lU3BsaXQobmFtZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gdG9VdGY4Qnl0ZXMoZW5zTm9ybWFsaXplKG5hbWUpKTtcbiAgICBjb25zdCBjb21wcyA9IFtdO1xuICAgIGlmIChuYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY29tcHM7XG4gICAgfVxuICAgIGxldCBsYXN0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGQgPSBieXRlc1tpXTtcbiAgICAgICAgLy8gQSBzZXBhcmF0b3IgKGkuZS4gXCIuXCIpOyBjb3B5IHRoaXMgY29tcG9uZW50XG4gICAgICAgIGlmIChkID09PSAweDJlKSB7XG4gICAgICAgICAgICBjb21wcy5wdXNoKGNoZWNrQ29tcG9uZW50KGJ5dGVzLnNsaWNlKGxhc3QsIGkpKSk7XG4gICAgICAgICAgICBsYXN0ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhlcmUgd2FzIGEgc3RyYXkgc2VwYXJhdG9yIGF0IHRoZSBlbmQgb2YgdGhlIG5hbWVcbiAgICBhc3NlcnRBcmd1bWVudChsYXN0IDwgYnl0ZXMubGVuZ3RoLCBcImludmFsaWQgRU5TIG5hbWU7IGVtcHR5IGNvbXBvbmVudFwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgY29tcHMucHVzaChjaGVja0NvbXBvbmVudChieXRlcy5zbGljZShsYXN0KSkpO1xuICAgIHJldHVybiBjb21wcztcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIEVOUyAlJW5hbWUlJSBub3JtYWxpemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zTm9ybWFsaXplKG5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IGxhYmVsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnNfbm9ybWFsaXplKG5hbWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIEVOUyBuYW1lICgke2Vycm9yLm1lc3NhZ2V9KWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUlbmFtZSUlIGlzIGEgdmFsaWQgRU5TIG5hbWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTmFtZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChlbnNOYW1lU3BsaXQobmFtZSkubGVuZ3RoICE9PSAwKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBbW2xpbmstbmFtZWhhc2hdXSBmb3IgJSVuYW1lJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuYW1laGFzaChuYW1lKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIEVOUyBuYW1lOyBub3QgYSBzdHJpbmdcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIGFzc2VydEFyZ3VtZW50KG5hbWUubGVuZ3RoLCBgaW52YWxpZCBFTlMgbmFtZSAoZW1wdHkgbGFiZWwpYCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIGxldCByZXN1bHQgPSBaZXJvcztcbiAgICBjb25zdCBjb21wcyA9IGVuc05hbWVTcGxpdChuYW1lKTtcbiAgICB3aGlsZSAoY29tcHMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGtlY2NhazI1Nihjb25jYXQoW3Jlc3VsdCwga2VjY2FrMjU2KChjb21wcy5wb3AoKSkpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgRE5TIGVuY29kZWQgJSVuYW1lJSUuXG4gKlxuICogIFRoaXMgaXMgdXNlZCBmb3IgdmFyaW91cyBwYXJ0cyBvZiBFTlMgbmFtZSByZXNvbHV0aW9uLCBzdWNoXG4gKiAgYXMgdGhlIHdpbGRjYXJkIHJlc29sdXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkbnNFbmNvZGUobmFtZSkge1xuICAgIHJldHVybiBoZXhsaWZ5KGNvbmNhdChlbnNOYW1lU3BsaXQobmFtZSkubWFwKChjb21wKSA9PiB7XG4gICAgICAgIC8vIEROUyBkb2VzIG5vdCBhbGxvdyBjb21wb25lbnRzIG92ZXIgNjMgYnl0ZXMgaW4gbGVuZ3RoXG4gICAgICAgIGlmIChjb21wLmxlbmd0aCA+IDYzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEROUyBlbmNvZGVkIGVudHJ5OyBsZW5ndGggZXhjZWVkcyA2MyBieXRlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGNvbXAubGVuZ3RoICsgMSk7XG4gICAgICAgIGJ5dGVzLnNldChjb21wLCAxKTtcbiAgICAgICAgYnl0ZXNbMF0gPSBieXRlcy5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSkpKSArIFwiMDBcIjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hbWVoYXNoLmpzLm1hcCIsImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5mdW5jdGlvbiBhY2Nlc3NTZXRpZnkoYWRkciwgc3RvcmFnZUtleXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBnZXRBZGRyZXNzKGFkZHIpLFxuICAgICAgICBzdG9yYWdlS2V5czogc3RvcmFnZUtleXMubWFwKChzdG9yYWdlS2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcoc3RvcmFnZUtleSwgMzIpLCBcImludmFsaWQgc2xvdFwiLCBgc3RvcmFnZUtleXNbJHtpbmRleH1dYCwgc3RvcmFnZUtleSk7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZUtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KVxuICAgIH07XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tBY2Nlc3NMaXN0XV0gZnJvbSBhbnkgZXRoZXJzLXN1cHBvcnRlZCBhY2Nlc3MtbGlzdCBzdHJ1Y3R1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHNldCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNldCkpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzZXQubGVuZ3RoID09PSAyLCBcImludmFsaWQgc2xvdCBzZXRcIiwgYHZhbHVlWyR7aW5kZXh9XWAsIHNldCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShzZXRbMF0sIHNldFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzZXQgIT0gbnVsbCAmJiB0eXBlb2YgKHNldCkgPT09IFwib2JqZWN0XCIsIFwiaW52YWxpZCBhZGRyZXNzLXNsb3Qgc2V0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShzZXQuYWRkcmVzcywgc2V0LnN0b3JhZ2VLZXlzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlICE9IG51bGwgJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIsIFwiaW52YWxpZCBhY2Nlc3MgbGlzdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3Qua2V5cyh2YWx1ZSkubWFwKChhZGRyKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdmFsdWVbYWRkcl0ucmVkdWNlKChhY2N1bSwgc3RvcmFnZUtleSkgPT4ge1xuICAgICAgICAgICAgYWNjdW1bc3RvcmFnZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoYWRkciwgT2JqZWN0LmtleXMoc3RvcmFnZUtleXMpLnNvcnQoKSk7XG4gICAgfSk7XG4gICAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IChhLmFkZHJlc3MubG9jYWxlQ29tcGFyZShiLmFkZHJlc3MpKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY2Vzc2xpc3QuanMubWFwIiwiaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYsIFNpZ25pbmdLZXkgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG4vKipcbiAqICBSZXR1cm5zIHRoZSBhZGRyZXNzIGZvciB0aGUgJSVrZXklJS5cbiAqXG4gKiAgVGhlIGtleSBtYXkgYmUgYW55IHN0YW5kYXJkIGZvcm0gb2YgcHVibGljIGtleSBvciBhIHByaXZhdGUga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUFkZHJlc3Moa2V5KSB7XG4gICAgbGV0IHB1YmtleTtcbiAgICBpZiAodHlwZW9mIChrZXkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHB1YmtleSA9IFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShrZXksIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHB1YmtleSA9IGtleS5wdWJsaWNLZXk7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZGRyZXNzKGtlY2NhazI1NihcIjB4XCIgKyBwdWJrZXkuc3Vic3RyaW5nKDQpKS5zdWJzdHJpbmcoMjYpKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIHJlY292ZXJlZCBhZGRyZXNzIGZvciB0aGUgcHJpdmF0ZSBrZXkgdGhhdCB3YXNcbiAqICB1c2VkIHRvIHNpZ24gJSVkaWdlc3QlJSB0aGF0IHJlc3VsdGVkIGluICUlc2lnbmF0dXJlJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBjb21wdXRlQWRkcmVzcyhTaWduaW5nS2V5LnJlY292ZXJQdWJsaWNLZXkoZGlnZXN0LCBzaWduYXR1cmUpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIiwiaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYsIFNpZ25hdHVyZSwgU2lnbmluZ0tleSB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGVjb2RlUmxwLCBlbmNvZGVSbHAsIGdldEJ5dGVzLCBnZXRCaWdJbnQsIGdldE51bWJlciwgaGV4bGlmeSwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgdG9CZUFycmF5LCB6ZXJvUGFkVmFsdWUgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi9hY2Nlc3NsaXN0LmpzXCI7XG5pbXBvcnQgeyByZWNvdmVyQWRkcmVzcyB9IGZyb20gXCIuL2FkZHJlc3MuanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8yID0gQmlnSW50KDIpO1xuY29uc3QgQk5fMjcgPSBCaWdJbnQoMjcpO1xuY29uc3QgQk5fMjggPSBCaWdJbnQoMjgpO1xuY29uc3QgQk5fMzUgPSBCaWdJbnQoMzUpO1xuY29uc3QgQk5fTUFYX1VJTlQgPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG5mdW5jdGlvbiBoYW5kbGVBZGRyZXNzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZGRyZXNzKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFjY2Vzc0xpc3QodmFsdWUsIHBhcmFtKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGFjY2Vzc0xpc3RpZnkodmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGVycm9yLm1lc3NhZ2UsIHBhcmFtLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlTnVtYmVyKF92YWx1ZSwgcGFyYW0pIHtcbiAgICBpZiAoX3ZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBnZXROdW1iZXIoX3ZhbHVlLCBwYXJhbSk7XG59XG5mdW5jdGlvbiBoYW5kbGVVaW50KF92YWx1ZSwgcGFyYW0pIHtcbiAgICBpZiAoX3ZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgcGFyYW0pO1xuICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlIDw9IEJOX01BWF9VSU5ULCBcInZhbHVlIGV4Y2VlZHMgdWludCBzaXplXCIsIHBhcmFtLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKF92YWx1ZSwgbmFtZSkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCByZXN1bHQgPSB0b0JlQXJyYXkodmFsdWUpO1xuICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5sZW5ndGggPD0gMzIsIGB2YWx1ZSB0b28gbGFyZ2VgLCBgdHguJHtuYW1lfWAsIHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZm9ybWF0QWNjZXNzTGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKS5tYXAoKHNldCkgPT4gW3NldC5hZGRyZXNzLCBzZXQuc3RvcmFnZUtleXNdKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUxlZ2FjeShkYXRhKSB7XG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGRhdGEpO1xuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOSB8fCBmaWVsZHMubGVuZ3RoID09PSA2KSwgXCJpbnZhbGlkIGZpZWxkIGNvdW50IGZvciBsZWdhY3kgdHJhbnNhY3Rpb25cIiwgXCJkYXRhXCIsIGRhdGEpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAwLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1swXSwgXCJub25jZVwiKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZVVpbnQoZmllbGRzWzFdLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbMl0sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1szXSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s0XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbNV0pLFxuICAgICAgICBjaGFpbklkOiBCTl8wXG4gICAgfTtcbiAgICAvLyBMZWdhY3kgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gNikge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIGNvbnN0IHYgPSBoYW5kbGVVaW50KGZpZWxkc1s2XSwgXCJ2XCIpO1xuICAgIGNvbnN0IHIgPSBoYW5kbGVVaW50KGZpZWxkc1s3XSwgXCJyXCIpO1xuICAgIGNvbnN0IHMgPSBoYW5kbGVVaW50KGZpZWxkc1s4XSwgXCJzXCIpO1xuICAgIGlmIChyID09PSBCTl8wICYmIHMgPT09IEJOXzApIHtcbiAgICAgICAgLy8gRUlQLTE1NSB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgICAgICB0eC5jaGFpbklkID0gdjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIEVJUC0xNTUgY2hhaW4gSUQgKG9yIDAgZm9yIGxlZ2FjeSlcbiAgICAgICAgbGV0IGNoYWluSWQgPSAodiAtIEJOXzM1KSAvIEJOXzI7XG4gICAgICAgIGlmIChjaGFpbklkIDwgQk5fMCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IEJOXzA7XG4gICAgICAgIH1cbiAgICAgICAgdHguY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIC8vIFNpZ25lZCBMZWdhY3kgVHJhbnNhY3Rpb25cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoY2hhaW5JZCAhPT0gQk5fMCB8fCAodiA9PT0gQk5fMjcgfHwgdiA9PT0gQk5fMjgpLCBcIm5vbi1jYW5vbmljYWwgbGVnYWN5IHZcIiwgXCJ2XCIsIGZpZWxkc1s2XSk7XG4gICAgICAgIHR4LnNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHtcbiAgICAgICAgICAgIHI6IHplcm9QYWRWYWx1ZShmaWVsZHNbN10sIDMyKSxcbiAgICAgICAgICAgIHM6IHplcm9QYWRWYWx1ZShmaWVsZHNbOF0sIDMyKSxcbiAgICAgICAgICAgIHZcbiAgICAgICAgfSk7XG4gICAgICAgIHR4Lmhhc2ggPSBrZWNjYWsyNTYoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVMZWdhY3kodHgsIHNpZykge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlIHx8IDAsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNQcmljZSB8fCAwLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQgfHwgMCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKCh0eC50byAhPSBudWxsKSA/IGdldEFkZHJlc3ModHgudG8pIDogXCIweFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LnZhbHVlIHx8IDAsIFwidmFsdWVcIiksXG4gICAgICAgICh0eC5kYXRhIHx8IFwiMHhcIiksXG4gICAgXTtcbiAgICBsZXQgY2hhaW5JZCA9IEJOXzA7XG4gICAgaWYgKHR4LmNoYWluSWQgIT0gQk5fMCkge1xuICAgICAgICAvLyBBIGNoYWluSWQgd2FzIHByb3ZpZGVkOyBpZiBub24temVybyB3ZSdsbCB1c2UgRUlQLTE1NVxuICAgICAgICBjaGFpbklkID0gZ2V0QmlnSW50KHR4LmNoYWluSWQsIFwidHguY2hhaW5JZFwiKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBhIGNoYWluSWQgaW4gdGhlIHR4IGFuZCBhbiBFSVAtMTU1IHYgaW4gdGhlIHNpZ25hdHVyZSxcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZXkgYWdyZWUgd2l0aCBlYWNoIG90aGVyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCFzaWcgfHwgc2lnLm5ldHdvcmtWID09IG51bGwgfHwgc2lnLmxlZ2FjeUNoYWluSWQgPT09IGNoYWluSWQsIFwidHguY2hhaW5JZC9zaWcudiBtaXNtYXRjaFwiLCBcInNpZ1wiLCBzaWcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eC5zaWduYXR1cmUpIHtcbiAgICAgICAgLy8gTm8gZXhwbGljaXQgY2hhaW5JZCwgYnV0IEVJUC0xNTUgaGF2ZSBhIGRlcml2ZWQgaW1wbGljaXQgY2hhaW5JZFxuICAgICAgICBjb25zdCBsZWdhY3kgPSB0eC5zaWduYXR1cmUubGVnYWN5Q2hhaW5JZDtcbiAgICAgICAgaWYgKGxlZ2FjeSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gbGVnYWN5O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJlcXVlc3RpbmcgYW4gdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICBpZiAoIXNpZykge1xuICAgICAgICAvLyBXZSBoYXZlIGFuIEVJUC0xNTUgdHJhbnNhY3Rpb24gKGNoYWluSWQgd2FzIHNwZWNpZmllZCBhbmQgbm9uLXplcm8pXG4gICAgICAgIGlmIChjaGFpbklkICE9PSBCTl8wKSB7XG4gICAgICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoY2hhaW5JZCkpO1xuICAgICAgICAgICAgZmllbGRzLnB1c2goXCIweFwiKTtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKFwiMHhcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZVJscChmaWVsZHMpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogV2Ugc2hvdWxkIHByb2JhYmx5IGNoZWNrIHRoYXQgdHguc2lnbmF0dXJlLCBjaGFpbklkLCBhbmQgc2lnXG4gICAgLy8gICAgICAgIG1hdGNoIGJ1dCB0aGF0IGxvZ2ljIGNvdWxkIGJyZWFrIGV4aXN0aW5nIGNvZGUsIHNvIHNjaGVkdWxlXG4gICAgLy8gICAgICAgIHRoaXMgZm9yIHRoZSBuZXh0IG1ham9yIGJ1bXAuXG4gICAgLy8gQ29tcHV0ZSB0aGUgRUlQLTE1NSB2XG4gICAgbGV0IHYgPSBCaWdJbnQoMjcgKyBzaWcueVBhcml0eSk7XG4gICAgaWYgKGNoYWluSWQgIT09IEJOXzApIHtcbiAgICAgICAgdiA9IFNpZ25hdHVyZS5nZXRDaGFpbklkVihjaGFpbklkLCBzaWcudik7XG4gICAgfVxuICAgIGVsc2UgaWYgKEJpZ0ludChzaWcudikgIT09IHYpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidHguY2hhaW5JZC9zaWcudiBtaXNtYXRjaFwiLCBcInNpZ1wiLCBzaWcpO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIHNpZ25hdHVyZVxuICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheSh2KSk7XG4gICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5yKSk7XG4gICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XG4gICAgcmV0dXJuIGVuY29kZVJscChmaWVsZHMpO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMpIHtcbiAgICBsZXQgeVBhcml0eTtcbiAgICB0cnkge1xuICAgICAgICB5UGFyaXR5ID0gaGFuZGxlTnVtYmVyKGZpZWxkc1swXSwgXCJ5UGFyaXR5XCIpO1xuICAgICAgICBpZiAoeVBhcml0eSAhPT0gMCAmJiB5UGFyaXR5ICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgeVBhcml0eVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCB5UGFyaXR5XCIsIFwieVBhcml0eVwiLCBmaWVsZHNbMF0pO1xuICAgIH1cbiAgICBjb25zdCByID0gemVyb1BhZFZhbHVlKGZpZWxkc1sxXSwgMzIpO1xuICAgIGNvbnN0IHMgPSB6ZXJvUGFkVmFsdWUoZmllbGRzWzJdLCAzMik7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20oeyByLCBzLCB5UGFyaXR5IH0pO1xuICAgIHR4LnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcDE1NTkoZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IGRlY29kZVJscChnZXRCeXRlcyhkYXRhKS5zbGljZSgxKSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSA5IHx8IGZpZWxkcy5sZW5ndGggPT09IDEyKSwgXCJpbnZhbGlkIGZpZWxkIGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAyXCIsIFwiZGF0YVwiLCBoZXhsaWZ5KGRhdGEpKTtcbiAgICBjb25zdCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpO1xuICAgIGNvbnN0IG1heEZlZVBlckdhcyA9IGhhbmRsZVVpbnQoZmllbGRzWzNdLCBcIm1heEZlZVBlckdhc1wiKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMixcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlVWludChmaWVsZHNbMF0sIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMV0sIFwibm9uY2VcIiksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgbWF4RmVlUGVyR2FzOiBtYXhGZWVQZXJHYXMsXG4gICAgICAgIGdhc1ByaWNlOiBudWxsLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbNF0sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1s1XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s2XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbN10pLFxuICAgICAgICBhY2Nlc3NMaXN0OiBoYW5kbGVBY2Nlc3NMaXN0KGZpZWxkc1s4XSwgXCJhY2Nlc3NMaXN0XCIpLFxuICAgIH07XG4gICAgLy8gVW5zaWduZWQgRUlQLTE1NTkgVHJhbnNhY3Rpb25cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gOSkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHR4Lmhhc2ggPSBrZWNjYWsyNTYoZGF0YSk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoOSkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXAxNTU5KHR4LCBzaWcpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5jaGFpbklkIHx8IDAsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlIHx8IDAsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAwLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQgfHwgMCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKCh0eC50byAhPSBudWxsKSA/IGdldEFkZHJlc3ModHgudG8pIDogXCIweFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LnZhbHVlIHx8IDAsIFwidmFsdWVcIiksXG4gICAgICAgICh0eC5kYXRhIHx8IFwiMHhcIiksXG4gICAgICAgIChmb3JtYXRBY2Nlc3NMaXN0KHR4LmFjY2Vzc0xpc3QgfHwgW10pKVxuICAgIF07XG4gICAgaWYgKHNpZykge1xuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnlQYXJpdHksIFwieVBhcml0eVwiKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdChbXCIweDAyXCIsIGVuY29kZVJscChmaWVsZHMpXSk7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXAyOTMwKGRhdGEpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBkZWNvZGVSbHAoZ2V0Qnl0ZXMoZGF0YSkuc2xpY2UoMSkpO1xuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOCB8fCBmaWVsZHMubGVuZ3RoID09PSAxMSksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMVwiLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxuICAgICAgICBnYXNQcmljZTogaGFuZGxlVWludChmaWVsZHNbMl0sIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1szXSwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzRdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZVVpbnQoZmllbGRzWzVdLCBcInZhbHVlXCIpLFxuICAgICAgICBkYXRhOiBoZXhsaWZ5KGZpZWxkc1s2XSksXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGhhbmRsZUFjY2Vzc0xpc3QoZmllbGRzWzddLCBcImFjY2Vzc0xpc3RcIilcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0yOTMwIFRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDgpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICB0eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xuICAgIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLnNsaWNlKDgpKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMjkzMCh0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCB8fCAwLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSB8fCAwLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzUHJpY2UgfHwgMCwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0IHx8IDAsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICgodHgudG8gIT0gbnVsbCkgPyBnZXRBZGRyZXNzKHR4LnRvKSA6IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSB8fCAwLCBcInZhbHVlXCIpLFxuICAgICAgICAodHguZGF0YSB8fCBcIjB4XCIpLFxuICAgICAgICAoZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKSlcbiAgICBdO1xuICAgIGlmIChzaWcpIHtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInJlY292ZXJ5UGFyYW1cIikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXQoW1wiMHgwMVwiLCBlbmNvZGVSbHAoZmllbGRzKV0pO1xufVxuLyoqXG4gKiAgQSAqKlRyYW5zYWN0aW9uKiogZGVzY3JpYmVzIGFuIG9wZXJhdGlvbiB0byBiZSBleGVjdXRlZCBvblxuICogIEV0aGVyZXVtIGJ5IGFuIEV4dGVybmFsbHkgT3duZWQgQWNjb3VudCAoRU9BKS4gSXQgaW5jbHVkZXNcbiAqICB3aG8gKHRoZSBbW3RvXV0gYWRkcmVzcyksIHdoYXQgKHRoZSBbW2RhdGFdXSkgYW5kIGhvdyBtdWNoICh0aGVcbiAqICBbW3ZhbHVlXV0gaW4gZXRoZXIpIHRoZSBvcGVyYXRpb24gc2hvdWxkIGVudGFpbC5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICB0eCA9IG5ldyBUcmFuc2FjdGlvbigpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgdHguZGF0YSA9IFwiMHgxMjM0XCI7XG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbiB7XG4gICAgI3R5cGU7XG4gICAgI3RvO1xuICAgICNkYXRhO1xuICAgICNub25jZTtcbiAgICAjZ2FzTGltaXQ7XG4gICAgI2dhc1ByaWNlO1xuICAgICNtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAjbWF4RmVlUGVyR2FzO1xuICAgICN2YWx1ZTtcbiAgICAjY2hhaW5JZDtcbiAgICAjc2lnO1xuICAgICNhY2Nlc3NMaXN0O1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKlxuICAgICAqICBJZiBudWxsLCB0aGUgdHlwZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgaW5mZXJyZWQgYmFzZWQgb25cbiAgICAgKiAgZXhwbGljaXQgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuI3R5cGU7IH1cbiAgICBzZXQgdHlwZSh2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYXNlIFwibGVnYWN5XCI6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIFwiYmVybGluXCI6XG4gICAgICAgICAgICBjYXNlIFwiZWlwLTI5MzBcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhc2UgXCJsb25kb25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtMTU1OVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlXCIsIFwidHlwZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqL1xuICAgIGdldCB0eXBlTmFtZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFwibGVnYWN5XCI7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBcImVpcC0yOTMwXCI7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBcImVpcC0xNTU5XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGB0b2BgIGFkZHJlc3MgZm9yIHRoZSB0cmFuc2FjdGlvbiBvciBgYG51bGxgYCBpZiB0aGVcbiAgICAgKiAgdHJhbnNhY3Rpb24gaXMgYW4gYGBpbml0YGAgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy4jdG87IH1cbiAgICBzZXQgdG8odmFsdWUpIHtcbiAgICAgICAgdGhpcy4jdG8gPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gbm9uY2UuXG4gICAgICovXG4gICAgZ2V0IG5vbmNlKCkgeyByZXR1cm4gdGhpcy4jbm9uY2U7IH1cbiAgICBzZXQgbm9uY2UodmFsdWUpIHsgdGhpcy4jbm9uY2UgPSBnZXROdW1iZXIodmFsdWUsIFwidmFsdWVcIik7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBsaW1pdC5cbiAgICAgKi9cbiAgICBnZXQgZ2FzTGltaXQoKSB7IHJldHVybiB0aGlzLiNnYXNMaW1pdDsgfVxuICAgIHNldCBnYXNMaW1pdCh2YWx1ZSkgeyB0aGlzLiNnYXNMaW1pdCA9IGdldEJpZ0ludCh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZS5cbiAgICAgKlxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MgdGhpcyBkZWZpbmVzIHRoZSBmZWUgdGhhdCB3aWxsIGJlIHBhaWQuIE9uXG4gICAgICogIEVJUC0xNTU5IG5ldHdvcmtzLCB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgZ2FzUHJpY2UoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jZ2FzUHJpY2U7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICh0aGlzLnR5cGUgPT09IDAgfHwgdGhpcy50eXBlID09PSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgZ2FzUHJpY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ2FzUHJpY2UgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcImdhc1ByaWNlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gcHJpb3JpdHkgZmVlIHBlciB1bml0IG9mIGdhcyB0byBwYXkuIE9uIGxlZ2FjeVxuICAgICAqICBuZXR3b3JrcyB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBtYXhQcmlvcml0eUZlZVBlckdhcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNtYXhQcmlvcml0eUZlZVBlckdhcyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRCaWdJbnQodmFsdWUsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB0b3RhbCBmZWUgcGVyIHVuaXQgb2YgZ2FzIHRvIHBheS4gT24gbGVnYWN5XG4gICAgICogIG5ldHdvcmtzIHRoaXMgc2hvdWxkIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBtYXhGZWVQZXJHYXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4RmVlUGVyR2FzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgbWF4RmVlUGVyR2FzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI21heEZlZVBlckdhcyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRCaWdJbnQodmFsdWUsIFwibWF4RmVlUGVyR2FzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGRhdGEuIEZvciBgYGluaXRgYCB0cmFuc2FjdGlvbnMgdGhpcyBpcyB0aGVcbiAgICAgKiAgZGVwbG95bWVudCBjb2RlLlxuICAgICAqL1xuICAgIGdldCBkYXRhKCkgeyByZXR1cm4gdGhpcy4jZGF0YTsgfVxuICAgIHNldCBkYXRhKHZhbHVlKSB7IHRoaXMuI2RhdGEgPSBoZXhsaWZ5KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYW1vdW50IG9mIGV0aGVyIChpbiB3ZWkpIHRvIHNlbmQgaW4gdGhpcyB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkgeyByZXR1cm4gdGhpcy4jdmFsdWU7IH1cbiAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jdmFsdWUgPSBnZXRCaWdJbnQodmFsdWUsIFwidmFsdWVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW4gSUQgdGhpcyB0cmFuc2FjdGlvbiBpcyB2YWxpZCBvbi5cbiAgICAgKi9cbiAgICBnZXQgY2hhaW5JZCgpIHsgcmV0dXJuIHRoaXMuI2NoYWluSWQ7IH1cbiAgICBzZXQgY2hhaW5JZCh2YWx1ZSkgeyB0aGlzLiNjaGFpbklkID0gZ2V0QmlnSW50KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqICBJZiBzaWduZWQsIHRoZSBzaWduYXR1cmUgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHNpZ25hdHVyZSgpIHsgcmV0dXJuIHRoaXMuI3NpZyB8fCBudWxsOyB9XG4gICAgc2V0IHNpZ25hdHVyZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNzaWcgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogU2lnbmF0dXJlLmZyb20odmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGFjY2VzcyBsaXN0LlxuICAgICAqXG4gICAgICogIEFuIGFjY2VzcyBsaXN0IHBlcm1pdHMgZGlzY291bnRlZCAoYnV0IHByZS1wYWlkKSBhY2Nlc3MgdG9cbiAgICAgKiAgYnl0ZWNvZGUgYW5kIHN0YXRlIHZhcmlhYmxlIGFjY2VzcyB3aXRoaW4gY29udHJhY3QgZXhlY3V0aW9uLlxuICAgICAqL1xuICAgIGdldCBhY2Nlc3NMaXN0KCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2FjY2Vzc0xpc3QgfHwgbnVsbDtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDEgfHwgdGhpcy50eXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgYWNjZXNzTGlzdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNhY2Nlc3NMaXN0ID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGFjY2Vzc0xpc3RpZnkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBUcmFuc2FjdGlvbiB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLiN0eXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jdG8gPSBudWxsO1xuICAgICAgICB0aGlzLiNub25jZSA9IDA7XG4gICAgICAgIHRoaXMuI2dhc0xpbWl0ID0gQmlnSW50KDApO1xuICAgICAgICB0aGlzLiNnYXNQcmljZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI21heFByaW9yaXR5RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGF0YSA9IFwiMHhcIjtcbiAgICAgICAgdGhpcy4jdmFsdWUgPSBCaWdJbnQoMCk7XG4gICAgICAgIHRoaXMuI2NoYWluSWQgPSBCaWdJbnQoMCk7XG4gICAgICAgIHRoaXMuI3NpZyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2FjY2Vzc0xpc3QgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2gsIGlmIHNpZ25lZC4gT3RoZXJ3aXNlLCBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgaGFzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmF0dXJlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYodGhpcy5zZXJpYWxpemVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwcmUtaW1hZ2UgaGFzaCBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdGhlIGRpZ2VzdCB0aGF0IGEgW1tTaWduZXJdXSBtdXN0IHNpZ24gdG8gYXV0aG9yaXplXG4gICAgICogIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHVuc2lnbmVkSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih0aGlzLnVuc2lnbmVkU2VyaWFsaXplZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgc2VuZGluZyBhZGRyZXNzLCBpZiBzaWduZWQuIE90aGVyd2lzZSwgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGZyb20oKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hdHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjb3ZlckFkZHJlc3ModGhpcy51bnNpZ25lZEhhc2gsIHRoaXMuc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwdWJsaWMga2V5IG9mIHRoZSBzZW5kZXIsIGlmIHNpZ25lZC4gT3RoZXJ3aXNlLCBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgZnJvbVB1YmxpY0tleSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmF0dXJlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTaWduaW5nS2V5LnJlY292ZXJQdWJsaWNLZXkodGhpcy51bnNpZ25lZEhhc2gsIHRoaXMuc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiBzaWduZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCBwcm9wZXJ0aWVzIHJlcXVpcmluZyBhIHNpZ25lZFxuICAgICAqICB0cmFuc2FjdGlvbiBhcmUgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNTaWduZWQoKSB7XG4gICAgICAgIC8vaXNTaWduZWQoKTogdGhpcyBpcyBTaWduZWRUcmFuc2FjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZSAhPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyB0aHJvd3MgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIHVuc2lnbmVkLiBGb3IgdGhlIHByZS1pbWFnZSxcbiAgICAgKiAgdXNlIFtbdW5zaWduZWRTZXJpYWxpemVkXV0uXG4gICAgICovXG4gICAgZ2V0IHNlcmlhbGl6ZWQoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLnNpZ25hdHVyZSAhPSBudWxsLCBcImNhbm5vdCBzZXJpYWxpemUgdW5zaWduZWQgdHJhbnNhY3Rpb247IG1heWJlIHlvdSBtZWFudCAudW5zaWduZWRTZXJpYWxpemVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIi5zZXJpYWxpemVkXCIgfSk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5pbmZlclR5cGUoKSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplTGVnYWN5KHRoaXMsIHRoaXMuc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDI5MzAodGhpcywgdGhpcy5zaWduYXR1cmUpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMTU1OSh0aGlzLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiLnNlcmlhbGl6ZWRcIiB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBwcmUtaW1hZ2UuXG4gICAgICpcbiAgICAgKiAgVGhlIGhhc2ggb2YgdGhpcyBpcyB0aGUgZGlnZXN0IHdoaWNoIG5lZWRzIHRvIGJlIHNpZ25lZCB0b1xuICAgICAqICBhdXRob3JpemUgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgdW5zaWduZWRTZXJpYWxpemVkKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaW5mZXJUeXBlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUxlZ2FjeSh0aGlzKTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDI5MzAodGhpcyk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAxNTU5KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIi51bnNpZ25lZFNlcmlhbGl6ZWRcIiB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgbW9zdCBcImxpa2VseVwiIHR5cGU7IGN1cnJlbnRseSB0aGUgaGlnaGVzdFxuICAgICAqICBzdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICBpbmZlclR5cGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pbmZlclR5cGVzKCkucG9wKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVmFsaWRhdGVzIHRoZSBleHBsaWNpdCBwcm9wZXJ0aWVzIGFuZCByZXR1cm5zIGEgbGlzdCBvZiBjb21wYXRpYmxlXG4gICAgICogIHRyYW5zYWN0aW9uIHR5cGVzLlxuICAgICAqL1xuICAgIGluZmVyVHlwZXMoKSB7XG4gICAgICAgIC8vIENoZWNrcyB0aGF0IHRoZXJlIGFyZSBubyBjb25mbGljdGluZyBwcm9wZXJ0aWVzIHNldFxuICAgICAgICBjb25zdCBoYXNHYXNQcmljZSA9IHRoaXMuZ2FzUHJpY2UgIT0gbnVsbDtcbiAgICAgICAgY29uc3QgaGFzRmVlID0gKHRoaXMubWF4RmVlUGVyR2FzICE9IG51bGwgfHwgdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKTtcbiAgICAgICAgY29uc3QgaGFzQWNjZXNzTGlzdCA9ICh0aGlzLmFjY2Vzc0xpc3QgIT0gbnVsbCk7XG4gICAgICAgIC8vaWYgKGhhc0dhc1ByaWNlICYmIGhhc0ZlZSkge1xuICAgICAgICAvLyAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2FjdGlvbiBjYW5ub3QgaGF2ZSBnYXNQcmljZSBhbmQgbWF4RmVlUGVyR2FzXCIpO1xuICAgICAgICAvL31cbiAgICAgICAgaWYgKHRoaXMubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5tYXhGZWVQZXJHYXMgPj0gdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcywgXCJwcmlvcml0eUZlZSBjYW5ub3QgYmUgbW9yZSB0aGFuIG1heEZlZVwiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRoaXMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9pZiAodGhpcy50eXBlID09PSAyICYmIGhhc0dhc1ByaWNlKSB7XG4gICAgICAgIC8vICAgIHRocm93IG5ldyBFcnJvcihcImVpcC0xNTU5IHRyYW5zYWN0aW9uIGNhbm5vdCBoYXZlIGdhc1ByaWNlXCIpO1xuICAgICAgICAvL31cbiAgICAgICAgYXNzZXJ0KCFoYXNGZWUgfHwgKHRoaXMudHlwZSAhPT0gMCAmJiB0aGlzLnR5cGUgIT09IDEpLCBcInRyYW5zYWN0aW9uIHR5cGUgY2Fubm90IGhhdmUgbWF4RmVlUGVyR2FzIG9yIG1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZTogdGhpcyB9KTtcbiAgICAgICAgYXNzZXJ0KHRoaXMudHlwZSAhPT0gMCB8fCAhaGFzQWNjZXNzTGlzdCwgXCJsZWdhY3kgdHJhbnNhY3Rpb24gY2Fubm90IGhhdmUgYWNjZXNzTGlzdFwiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRoaXMgfSk7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgICAgIC8vIEV4cGxpY2l0IHR5cGVcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eXBlcy5wdXNoKHRoaXMudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzRmVlKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0dhc1ByaWNlKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0FjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZXMucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNBY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDEpO1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHlwZXMuc29ydCgpO1xuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBhIGxlZ2FjeSB0cmFuc2FjdGlvbiAoaS5lLlxuICAgICAqICBgYHR5cGUgPT09IDBgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqICBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0xlZ2FjeSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgYmVybGluIGhhcmRmb3JtIHRyYW5zYWN0aW9uIChpLmUuXG4gICAgICogIGBgdHlwZSA9PT0gMWBgKS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoZSByZWxhdGVkIHByb3BlcnRpZXMgYXJlXG4gICAgICogIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzQmVybGluKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBsb25kb24gaGFyZGZvcm0gdHJhbnNhY3Rpb24gKGkuZS5cbiAgICAgKiAgYGB0eXBlID09PSAyYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcbiAgICAgKiAgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyB0cmFuc2FjaXRvbi5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20odGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBKU09OLWZyaWVuZGx5IG9iamVjdC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHMgPSAodikgPT4ge1xuICAgICAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIHRvOiB0aGlzLnRvLFxuICAgICAgICAgICAgLy8gICAgICAgICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICBub25jZTogdGhpcy5ub25jZSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBzKHRoaXMuZ2FzTGltaXQpLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHModGhpcy5nYXNQcmljZSksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogcyh0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogcyh0aGlzLm1heEZlZVBlckdhcyksXG4gICAgICAgICAgICB2YWx1ZTogcyh0aGlzLnZhbHVlKSxcbiAgICAgICAgICAgIGNoYWluSWQ6IHModGhpcy5jaGFpbklkKSxcbiAgICAgICAgICAgIHNpZzogdGhpcy5zaWduYXR1cmUgPyB0aGlzLnNpZ25hdHVyZS50b0pTT04oKSA6IG51bGwsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0OiB0aGlzLmFjY2Vzc0xpc3RcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhICoqVHJhbnNhY3Rpb24qKiBmcm9tIGEgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBvciBhXG4gICAgICogIFRyYW5zYWN0aW9uLWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHR4KSB7XG4gICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZ2V0Qnl0ZXModHgpO1xuICAgICAgICAgICAgaWYgKHBheWxvYWRbMF0gPj0gMHg3ZikgeyAvLyBAVE9ETzogPiB2cyA+PSA/P1xuICAgICAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUxlZ2FjeShwYXlsb2FkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHBheWxvYWRbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUVpcDI5MzAocGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlRWlwMTU1OShwYXlsb2FkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmcm9tXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIGlmICh0eC50eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gdHgudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgudG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnRvID0gdHgudG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm5vbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ub25jZSA9IHR4Lm5vbmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5nYXNMaW1pdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuZ2FzTGltaXQgPSB0eC5nYXNMaW1pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lmdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1heEZlZVBlckdhcyA9IHR4Lm1heEZlZVBlckdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IHR4LmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHR4LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gdHguY2hhaW5JZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh0eC5zaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5hY2Nlc3NMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hY2Nlc3NMaXN0ID0gdHguYWNjZXNzTGlzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguaGFzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuaXNTaWduZWQoKSwgXCJ1bnNpZ25lZCB0cmFuc2FjdGlvbiBjYW5ub3QgZGVmaW5lIGhhc2hcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuaGFzaCA9PT0gdHguaGFzaCwgXCJoYXNoIG1pc21hdGNoXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5pc1NpZ25lZCgpLCBcInVuc2lnbmVkIHRyYW5zYWN0aW9uIGNhbm5vdCBkZWZpbmUgZnJvbVwiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5mcm9tLnRvTG93ZXJDYXNlKCkgPT09ICh0eC5mcm9tIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBtaXNtYXRjaFwiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zYWN0aW9uLmpzLm1hcCIsIi8vaW1wb3J0IHsgVHlwZWREYXRhRG9tYWluLCBUeXBlZERhdGFGaWVsZCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm92aWRlcmFic3RyYWN0LXNpZ25lclwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyByZWNvdmVyQWRkcmVzcyB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBoZXhsaWZ5LCBpc0hleFN0cmluZywgbWFzaywgdG9CZUhleCwgdG9RdWFudGl0eSwgdG9Ud29zLCB6ZXJvUGFkVmFsdWUsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuL2lkLmpzXCI7XG5jb25zdCBwYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xucGFkZGluZy5maWxsKDApO1xuY29uc3QgQk5fXzEgPSBCaWdJbnQoLTEpO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl9NQVhfVUlOVDI1NiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbjtcbjtcbmZ1bmN0aW9uIGhleFBhZFJpZ2h0KHZhbHVlKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh2YWx1ZSk7XG4gICAgY29uc3QgcGFkT2Zmc2V0ID0gYnl0ZXMubGVuZ3RoICUgMzI7XG4gICAgaWYgKHBhZE9mZnNldCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KFtieXRlcywgcGFkZGluZy5zbGljZShwYWRPZmZzZXQpXSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbn1cbmNvbnN0IGhleFRydWUgPSB0b0JlSGV4KEJOXzEsIDMyKTtcbmNvbnN0IGhleEZhbHNlID0gdG9CZUhleChCTl8wLCAzMik7XG5jb25zdCBkb21haW5GaWVsZFR5cGVzID0ge1xuICAgIG5hbWU6IFwic3RyaW5nXCIsXG4gICAgdmVyc2lvbjogXCJzdHJpbmdcIixcbiAgICBjaGFpbklkOiBcInVpbnQyNTZcIixcbiAgICB2ZXJpZnlpbmdDb250cmFjdDogXCJhZGRyZXNzXCIsXG4gICAgc2FsdDogXCJieXRlczMyXCJcbn07XG5jb25zdCBkb21haW5GaWVsZE5hbWVzID0gW1xuICAgIFwibmFtZVwiLCBcInZlcnNpb25cIiwgXCJjaGFpbklkXCIsIFwidmVyaWZ5aW5nQ29udHJhY3RcIiwgXCJzYWx0XCJcbl07XG5mdW5jdGlvbiBjaGVja1N0cmluZyhrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiLCBgaW52YWxpZCBkb21haW4gdmFsdWUgZm9yICR7SlNPTi5zdHJpbmdpZnkoa2V5KX1gLCBgZG9tYWluLiR7a2V5fWAsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59XG5jb25zdCBkb21haW5DaGVja3MgPSB7XG4gICAgbmFtZTogY2hlY2tTdHJpbmcoXCJuYW1lXCIpLFxuICAgIHZlcnNpb246IGNoZWNrU3RyaW5nKFwidmVyc2lvblwiKSxcbiAgICBjaGFpbklkOiBmdW5jdGlvbiAoX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJkb21haW4uY2hhaW5JZFwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gMCwgXCJpbnZhbGlkIGNoYWluIElEXCIsIFwiZG9tYWluLmNoYWluSWRcIiwgX3ZhbHVlKTtcbiAgICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvUXVhbnRpdHkodmFsdWUpO1xuICAgIH0sXG4gICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInZlcmlmeWluZ0NvbnRyYWN0XCJgLCBcImRvbWFpbi52ZXJpZnlpbmdDb250cmFjdFwiLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzYWx0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh2YWx1ZSwgXCJkb21haW4uc2FsdFwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYnl0ZXMubGVuZ3RoID09PSAzMiwgYGludmFsaWQgZG9tYWluIHZhbHVlIFwic2FsdFwiYCwgXCJkb21haW4uc2FsdFwiLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gZ2V0QmFzZUVuY29kZXIodHlwZSkge1xuICAgIC8vIGludFhYIGFuZCB1aW50WFhcbiAgICB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXih1PylpbnQoXFxkKikkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkID0gKG1hdGNoWzFdID09PSBcIlwiKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh3aWR0aCAlIDggPT09IDAgJiYgd2lkdGggIT09IDAgJiYgd2lkdGggPD0gMjU2ICYmIChtYXRjaFsyXSA9PSBudWxsIHx8IG1hdGNoWzJdID09PSBTdHJpbmcod2lkdGgpKSwgXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgYm91bmRzVXBwZXIgPSBtYXNrKEJOX01BWF9VSU5UMjU2LCBzaWduZWQgPyAod2lkdGggLSAxKSA6IHdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc0xvd2VyID0gc2lnbmVkID8gKChib3VuZHNVcHBlciArIEJOXzEpICogQk5fXzEpIDogQk5fMDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IGJvdW5kc0xvd2VyICYmIHZhbHVlIDw9IGJvdW5kc1VwcGVyLCBgdmFsdWUgb3V0LW9mLWJvdW5kcyBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b0JlSGV4KHNpZ25lZCA/IHRvVHdvcyh2YWx1ZSwgMjU2KSA6IHZhbHVlLCAzMik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGJ5dGVzWFhcbiAgICB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCspJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQod2lkdGggIT09IDAgJiYgd2lkdGggPD0gMzIgJiYgbWF0Y2hbMV0gPT09IFN0cmluZyh3aWR0aCksIFwiaW52YWxpZCBieXRlcyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYnl0ZXMubGVuZ3RoID09PSB3aWR0aCwgYGludmFsaWQgbGVuZ3RoIGZvciAke3R5cGV9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleFBhZFJpZ2h0KHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB6ZXJvUGFkVmFsdWUoZ2V0QWRkcmVzcyh2YWx1ZSksIDMyKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImJvb2xcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgoIXZhbHVlKSA/IGhleEZhbHNlIDogaGV4VHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJieXRlc1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGVuY29kZVR5cGUobmFtZSwgZmllbGRzKSB7XG4gICAgcmV0dXJuIGAke25hbWV9KCR7ZmllbGRzLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+ICh0eXBlICsgXCIgXCIgKyBuYW1lKSkuam9pbihcIixcIil9KWA7XG59XG4vKipcbiAqICBBICoqVHlwZWREYXRhRW5jb2RlKiogcHJlcGFyZXMgYW5kIGVuY29kZXMgW1tsaW5rLWVpcC03MTJdXSBwYXlsb2Fkc1xuICogIGZvciBzaWduZWQgdHlwZWQgZGF0YS5cbiAqXG4gKiAgVGhpcyBpcyB1c2VmdWwgZm9yIHRob3NlIHRoYXQgd2lzaCB0byBjb21wdXRlIHZhcmlvdXMgY29tcG9uZW50cyBvZiBhXG4gKiAgdHlwZWQgZGF0YSBoYXNoLCBwcmltYXJ5IHR5cGVzLCBvciBzdWItY29tcG9uZW50cywgYnV0IGdlbmVyYWxseSB0aGVcbiAqICBoaWdoZXIgbGV2ZWwgW1tTaWduZXItc2lnblR5cGVkRGF0YV1dIGlzIG1vcmUgdXNlZnVsLlxuICovXG5leHBvcnQgY2xhc3MgVHlwZWREYXRhRW5jb2RlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcmltYXJ5IHR5cGUgZm9yIHRoZSBzdHJ1Y3R1cmVkIFtbdHlwZXNdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGRlcml2ZWQgYXV0b21hdGljYWxseSBmcm9tIHRoZSBbW3R5cGVzXV0sIHNpbmNlIG5vXG4gICAgICogIHJlY3Vyc2lvbiBpcyBwb3NzaWJsZSwgb25jZSB0aGUgREFHIGZvciB0aGUgdHlwZXMgaXMgY29uc3R1cmN0ZWRcbiAgICAgKiAgaW50ZXJuYWxseSwgdGhlIHByaW1hcnkgdHlwZSBtdXN0IGJlIHRoZSBvbmx5IHJlbWFpbmluZyB0eXBlIHdpdGhcbiAgICAgKiAgbm8gcGFyZW50IG5vZGVzLlxuICAgICAqL1xuICAgIHByaW1hcnlUeXBlO1xuICAgICN0eXBlcztcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGVzLlxuICAgICAqL1xuICAgIGdldCB0eXBlcygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy4jdHlwZXMpO1xuICAgIH1cbiAgICAjZnVsbFR5cGVzO1xuICAgICNlbmNvZGVyQ2FjaGU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlR5cGVkRGF0YUVuY29kZXIqKiBmb3IgJSV0eXBlcyUlLlxuICAgICAqXG4gICAgICogIFRoaXMgcGVyZm9ybXMgYWxsIG5lY2Vzc2FyeSBjaGVja2luZyB0aGF0IHR5cGVzIGFyZSB2YWxpZCBhbmRcbiAgICAgKiAgZG8gbm90IHZpb2xhdGUgdGhlIFtbbGluay1laXAtNzEyXV0gc3RydWN0dXJhbCBjb25zdHJhaW50cyBhc1xuICAgICAqICB3ZWxsIGFzIGNvbXB1dGVzIHRoZSBbW3ByaW1hcnlUeXBlXV0uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHlwZXMpIHtcbiAgICAgICAgdGhpcy4jdHlwZXMgPSBKU09OLnN0cmluZ2lmeSh0eXBlcyk7XG4gICAgICAgIHRoaXMuI2Z1bGxUeXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZW5jb2RlckNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMaW5rIHN0cnVjdCB0eXBlcyB0byB0aGVpciBkaXJlY3QgY2hpbGQgc3RydWN0c1xuICAgICAgICBjb25zdCBsaW5rcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTGluayBzdHJ1Y3RzIHRvIHN0cnVjdHMgd2hpY2ggY29udGFpbiB0aGVtIGFzIGEgY2hpbGRcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTGluayBhbGwgc3VidHlwZXMgd2l0aGluIGEgZ2l2ZW4gc3RydWN0XG4gICAgICAgIGNvbnN0IHN1YnR5cGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBPYmplY3Qua2V5cyh0eXBlcykuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICAgICAgbGlua3Muc2V0KHR5cGUsIG5ldyBTZXQoKSk7XG4gICAgICAgICAgICBwYXJlbnRzLnNldCh0eXBlLCBbXSk7XG4gICAgICAgICAgICBzdWJ0eXBlcy5zZXQodHlwZSwgbmV3IFNldCgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0eXBlcykge1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZWFjaCBmaWVsZCBoYXMgYSB1bmlxdWUgbmFtZVxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KCF1bmlxdWVOYW1lcy5oYXMoZmllbGQubmFtZSksIGBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZSAke0pTT04uc3RyaW5naWZ5KGZpZWxkLm5hbWUpfSBpbiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzLmFkZChmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGJhc2UgdHlwZSAoZHJvcCBhbnkgYXJyYXkgc3BlY2lmaWVycylcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlVHlwZSA9IChmaWVsZC50eXBlLm1hdGNoKC9eKFteXFx4NWJdKikoXFx4NWJ8JCkvKSlbMV0gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChiYXNlVHlwZSAhPT0gbmFtZSwgYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgYSBiYXNlIGVuY29kaW5nIHR5cGU/XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKGJhc2VUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQocGFyZW50cy5oYXMoYmFzZVR5cGUpLCBgdW5rbm93biB0eXBlICR7SlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBsaW5rYWdlXG4gICAgICAgICAgICAgICAgcGFyZW50cy5nZXQoYmFzZVR5cGUpLnB1c2gobmFtZSk7XG4gICAgICAgICAgICAgICAgbGlua3MuZ2V0KG5hbWUpLmFkZChiYXNlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVkdWNlIHRoZSBwcmltYXJ5IHR5cGVcbiAgICAgICAgY29uc3QgcHJpbWFyeVR5cGVzID0gQXJyYXkuZnJvbShwYXJlbnRzLmtleXMoKSkuZmlsdGVyKChuKSA9PiAocGFyZW50cy5nZXQobikubGVuZ3RoID09PSAwKSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHByaW1hcnlUeXBlcy5sZW5ndGggIT09IDAsIFwibWlzc2luZyBwcmltYXJ5IHR5cGVcIiwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHByaW1hcnlUeXBlcy5sZW5ndGggPT09IDEsIGBhbWJpZ3VvdXMgcHJpbWFyeSB0eXBlcyBvciB1bnVzZWQgdHlwZXM6ICR7cHJpbWFyeVR5cGVzLm1hcCgodCkgPT4gKEpTT04uc3RyaW5naWZ5KHQpKSkuam9pbihcIiwgXCIpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHJpbWFyeVR5cGU6IHByaW1hcnlUeXBlc1swXSB9KTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlc1xuICAgICAgICBmdW5jdGlvbiBjaGVja0NpcmN1bGFyKHR5cGUsIGZvdW5kKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghZm91bmQuaGFzKHR5cGUpLCBgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2UgdG8gJHtKU09OLnN0cmluZ2lmeSh0eXBlKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgIGZvdW5kLmFkZCh0eXBlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgbGlua3MuZ2V0KHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRzLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNoZWNrIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgY2hlY2tDaXJjdWxhcihjaGlsZCwgZm91bmQpO1xuICAgICAgICAgICAgICAgIC8vIE1hcmsgYWxsIGFuY2VzdG9ycyBhcyBoYXZpbmcgdGhpcyBkZWNlbmRhbnRcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN1YnR5cGUgb2YgZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VidHlwZXMuZ2V0KHN1YnR5cGUpLmFkZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm91bmQuZGVsZXRlKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrQ2lyY3VsYXIodGhpcy5wcmltYXJ5VHlwZSwgbmV3IFNldCgpKTtcbiAgICAgICAgLy8gQ29tcHV0ZSBlYWNoIGZ1bGx5IGRlc2NyaWJlIHR5cGVcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgc2V0XSBvZiBzdWJ0eXBlcykge1xuICAgICAgICAgICAgY29uc3Qgc3QgPSBBcnJheS5mcm9tKHNldCk7XG4gICAgICAgICAgICBzdC5zb3J0KCk7XG4gICAgICAgICAgICB0aGlzLiNmdWxsVHlwZXMuc2V0KG5hbWUsIGVuY29kZVR5cGUobmFtZSwgdHlwZXNbbmFtZV0pICsgc3QubWFwKCh0KSA9PiBlbmNvZGVUeXBlKHQsIHR5cGVzW3RdKSkuam9pbihcIlwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnRoZSBlbmNvZGVyIGZvciB0aGUgc3BlY2lmaWMgJSV0eXBlJSUuXG4gICAgICovXG4gICAgZ2V0RW5jb2Rlcih0eXBlKSB7XG4gICAgICAgIGxldCBlbmNvZGVyID0gdGhpcy4jZW5jb2RlckNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFlbmNvZGVyKSB7XG4gICAgICAgICAgICBlbmNvZGVyID0gdGhpcy4jZ2V0RW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIHRoaXMuI2VuY29kZXJDYWNoZS5zZXQodHlwZSwgZW5jb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgfVxuICAgICNnZXRFbmNvZGVyKHR5cGUpIHtcbiAgICAgICAgLy8gQmFzaWMgZW5jb2RlciB0eXBlIChhZGRyZXNzLCBib29sLCB1aW50MjU2LCBldGMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKC4qKShcXHg1YihcXGQqKVxceDVkKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJ0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBjb25zdCBzdWJFbmNvZGVyID0gdGhpcy5nZXRFbmNvZGVyKHN1YnR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KCFtYXRjaFszXSB8fCBwYXJzZUludChtYXRjaFszXSkgPT09IHZhbHVlLmxlbmd0aCwgYGFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7cGFyc2VJbnQobWF0Y2hbM10pfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB2YWx1ZS5tYXAoc3ViRW5jb2Rlcik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2Z1bGxUeXBlcy5oYXMoc3VidHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm1hcChrZWNjYWsyNTYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGNvbmNhdChyZXN1bHQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMudHlwZXNbdHlwZV07XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRUeXBlID0gaWQodGhpcy4jZnVsbFR5cGVzLmdldCh0eXBlKSk7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZmllbGRzLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2Z1bGxUeXBlcy5oYXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhbHVlcy51bnNoaWZ0KGVuY29kZWRUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY2F0KHZhbHVlcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxsIHR5cGUgZm9yICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGVuY29kZVR5cGUobmFtZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNmdWxsVHlwZXMuZ2V0KG5hbWUpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQsIGB1bmtub3duIHR5cGU6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlICUldHlwZSUlLlxuICAgICAqL1xuICAgIGVuY29kZURhdGEodHlwZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBoYXNoIG9mICUldmFsdWUlJSBmb3IgdGhlIHR5cGUgb2YgJSVuYW1lJSUuXG4gICAgICovXG4gICAgaGFzaFN0cnVjdChuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHRoaXMuZW5jb2RlRGF0YShuYW1lLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxsZWQgZW5jb2RlZCAlJXZhbHVlJSUgZm9yIHRoZSBbW3R5cGVzXV0uXG4gICAgICovXG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZURhdGEodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoIG9mIHRoZSBmdWxseSBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlIFtbdHlwZXNdXS5cbiAgICAgKi9cbiAgICBoYXNoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hTdHJ1Y3QodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgX3Zpc2l0KHR5cGUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodHlwZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXiguKikoXFx4NWIoXFxkKilcXHg1ZCkkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIW1hdGNoWzNdIHx8IHBhcnNlSW50KG1hdGNoWzNdKSA9PT0gdmFsdWUubGVuZ3RoLCBgYXJyYXkgbGVuZ3RoIG1pc21hdGNoOyBleHBlY3RlZCBsZW5ndGggJHtwYXJzZUludChtYXRjaFszXSl9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiB0aGlzLl92aXNpdChtYXRjaFsxXSwgdiwgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJ1Y3RcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy50eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoKGFjY3VtLCB7IG5hbWUsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gdGhpcy5fdmlzaXQodHlwZSwgdmFsdWVbbmFtZV0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGB1bmtub3duIHR5cGU6ICR7dHlwZX1gLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDYWxsICUlY2FsYmFjayUlIGZvciBlYWNoIHZhbHVlIGluICUldmFsdWUlJSwgcGFzc2luZyB0aGUgdHlwZSBhbmRcbiAgICAgKiAgY29tcG9uZW50IHdpdGhpbiAlJXZhbHVlJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyB1c2VmdWwgZm9yIHJlcGxhY2luZyBhZGRyZXNzZXMgb3Igb3RoZXIgdHJhbnNmb3JtYXRpb24gdGhhdFxuICAgICAqICBtYXkgYmUgZGVzaXJlZCBvbiBlYWNoIGNvbXBvbmVudCwgYmFzZWQgb24gaXRzIHR5cGUuXG4gICAgICovXG4gICAgdmlzaXQodmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdCh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqVHlwZWREYXRhRW5jb2RlcioqIGZvciAlJXR5cGVzJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZERhdGFFbmNvZGVyKHR5cGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcHJpbWFyeSB0eXBlIGZvciAlJXR5cGVzJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFByaW1hcnlUeXBlKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLnByaW1hcnlUeXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoZWQgc3RydWN0IGZvciAlJXZhbHVlJSUgdXNpbmcgJSV0eXBlcyUlIGFuZCAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaFN0cnVjdChuYW1lLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykuaGFzaFN0cnVjdChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGRvbWFpbiBoYXNoIGZvciAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBoYXNoRG9tYWluKGRvbWFpbikge1xuICAgICAgICBjb25zdCBkb21haW5GaWVsZHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRvbWFpbikge1xuICAgICAgICAgICAgaWYgKGRvbWFpbltuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gZG9tYWluRmllbGRUeXBlc1tuYW1lXTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGUsIGBpbnZhbGlkIHR5cGVkLWRhdGEgZG9tYWluIGtleTogJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcImRvbWFpblwiLCBkb21haW4pO1xuICAgICAgICAgICAgZG9tYWluRmllbGRzLnB1c2goeyBuYW1lLCB0eXBlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRvbWFpbkZpZWxkcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGEubmFtZSkgLSBkb21haW5GaWVsZE5hbWVzLmluZGV4T2YoYi5uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmhhc2hTdHJ1Y3QoXCJFSVA3MTJEb21haW5cIiwgeyBFSVA3MTJEb21haW46IGRvbWFpbkZpZWxkcyB9LCBkb21haW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxseSBlbmNvZGVkIFtbbGluay1laXAtNzEyXV0gJSV2YWx1ZSUlIGZvciAlJXR5cGVzJSUgd2l0aCAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBlbmNvZGUoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgICAgICBcIjB4MTkwMVwiLFxuICAgICAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoRG9tYWluKGRvbWFpbiksXG4gICAgICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2godmFsdWUpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoIG9mIHRoZSBmdWxseSBlbmNvZGVkIFtbbGluay1laXAtNzEyXV0gJSV2YWx1ZSUlIGZvciAlJXR5cGVzJSUgd2l0aCAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBoYXNoKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYoVHlwZWREYXRhRW5jb2Rlci5lbmNvZGUoZG9tYWluLCB0eXBlcywgdmFsdWUpKTtcbiAgICB9XG4gICAgLy8gUmVwbGFjZXMgYWxsIGFkZHJlc3MgdHlwZXMgd2l0aCBFTlMgbmFtZXMgd2l0aCB0aGVpciBsb29rZWQgdXAgYWRkcmVzc1xuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRvIHRoZSB2YWx1ZSBmcm9tIHJlc29sdmluZyBhbGwgYWRkcmVzc2VzIGluICUldmFsdWUlJSBmb3JcbiAgICAgKiAlJXR5cGVzJSUgYW5kIHRoZSAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyByZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIHJlc29sdmVOYW1lKSB7XG4gICAgICAgIC8vIE1ha2UgYSBjb3B5IHRvIGlzb2xhdGUgaXQgZnJvbSB0aGUgb2JqZWN0IHBhc3NlZCBpblxuICAgICAgICBkb21haW4gPSBPYmplY3QuYXNzaWduKHt9LCBkb21haW4pO1xuICAgICAgICAvLyBBbGxvdyBwYXNzaW5nIG51bGwgdG8gaWdub3JlIHZhbHVlXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRvbWFpbikge1xuICAgICAgICAgICAgaWYgKGRvbWFpbltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZG9tYWluW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9vayB1cCBhbGwgRU5TIG5hbWVzXG4gICAgICAgIGNvbnN0IGVuc0NhY2hlID0ge307XG4gICAgICAgIC8vIERvIHdlIG5lZWQgdG8gbG9vayB1cCB0aGUgZG9tYWluJ3MgdmVyaWZ5aW5nQ29udHJhY3Q/XG4gICAgICAgIGlmIChkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgJiYgIWlzSGV4U3RyaW5nKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCwgMjApKSB7XG4gICAgICAgICAgICBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdID0gXCIweFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGFyZSBnb2luZyB0byB1c2UgdGhlIGVuY29kZXIgdG8gdmlzaXQgYWxsIHRoZSBiYXNlIHZhbHVlc1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcbiAgICAgICAgLy8gR2V0IGEgbGlzdCBvZiBhbGwgdGhlIGFkZHJlc3Nlc1xuICAgICAgICBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiAhaXNIZXhTdHJpbmcodmFsdWUsIDIwKSkge1xuICAgICAgICAgICAgICAgIGVuc0NhY2hlW3ZhbHVlXSA9IFwiMHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIExvb2t1cCBlYWNoIG5hbWVcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGVuc0NhY2hlKSB7XG4gICAgICAgICAgICBlbnNDYWNoZVtuYW1lXSA9IGF3YWl0IHJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGRvbWFpbiB2ZXJpZnlpbmdDb250cmFjdCBpZiBuZWVkZWRcbiAgICAgICAgaWYgKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCAmJiBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdKSB7XG4gICAgICAgICAgICBkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgPSBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcGxhY2UgYWxsIEVOUyBuYW1lcyB3aXRoIHRoZWlyIGFkZHJlc3NcbiAgICAgICAgdmFsdWUgPSBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiBlbnNDYWNoZVt2YWx1ZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5zQ2FjaGVbdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgZG9tYWluLCB2YWx1ZSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgSlNPTi1lbmNvZGVkIHBheWxvYWQgZXhwZWN0ZWQgYnkgbm9kZXMgd2hpY2ggaW1wbGVtZW50XG4gICAgICogIHRoZSBKU09OLVJQQyBbW2xpbmstZWlwLTcxMl1dIG1ldGhvZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UGF5bG9hZChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZG9tYWluIGZpZWxkc1xuICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmhhc2hEb21haW4oZG9tYWluKTtcbiAgICAgICAgLy8gRGVyaXZlIHRoZSBFSVA3MTJEb21haW4gU3RydWN0IHJlZmVyZW5jZSB0eXBlXG4gICAgICAgIGNvbnN0IGRvbWFpblZhbHVlcyA9IHt9O1xuICAgICAgICBjb25zdCBkb21haW5UeXBlcyA9IFtdO1xuICAgICAgICBkb21haW5GaWVsZE5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9tYWluW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb21haW5WYWx1ZXNbbmFtZV0gPSBkb21haW5DaGVja3NbbmFtZV0odmFsdWUpO1xuICAgICAgICAgICAgZG9tYWluVHlwZXMucHVzaCh7IG5hbWUsIHR5cGU6IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcbiAgICAgICAgY29uc3QgdHlwZXNXaXRoRG9tYWluID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZXMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlc1dpdGhEb21haW4uRUlQNzEyRG9tYWluID09IG51bGwsIFwidHlwZXMgbXVzdCBub3QgY29udGFpbiBFSVA3MTJEb21haW4gdHlwZVwiLCBcInR5cGVzLkVJUDcxMkRvbWFpblwiLCB0eXBlcyk7XG4gICAgICAgIHR5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW4gPSBkb21haW5UeXBlcztcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRhdGEgc3RydWN0dXJlcyBhbmQgdHlwZXNcbiAgICAgICAgZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZXM6IHR5cGVzV2l0aERvbWFpbixcbiAgICAgICAgICAgIGRvbWFpbjogZG9tYWluVmFsdWVzLFxuICAgICAgICAgICAgcHJpbWFyeVR5cGU6IGVuY29kZXIucHJpbWFyeVR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBieXRlc1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKikvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShnZXRCeXRlcyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1aW50IG9yIGludFxuICAgICAgICAgICAgICAgIGlmICh0eXBlLm1hdGNoKC9edT9pbnQvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QmlnSW50KHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgYWRkcmVzcyB1c2VkIHRvIHNpZ24gdGhlIHR5cGVkIGRhdGEgZm9yIHRoZSAlJXNpZ25hdHVyZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5VHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCBzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gcmVjb3ZlckFkZHJlc3MoVHlwZWREYXRhRW5jb2Rlci5oYXNoKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSwgc2lnbmF0dXJlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVkLWRhdGEuanMubWFwIiwiLyoqXG4gKiAgQSBmcmFnbWVudCBpcyBhIHNpbmdsZSBpdGVtIGZyb20gYW4gQUJJLCB3aGljaCBtYXkgcmVwcmVzZW50IGFueSBvZjpcbiAqXG4gKiAgLSBbRnVuY3Rpb25zXShGdW5jdGlvbkZyYWdtZW50KVxuICogIC0gW0V2ZW50c10oRXZlbnRGcmFnbWVudClcbiAqICAtIFtDb25zdHJ1Y3RvcnNdKENvbnN0cnVjdG9yRnJhZ21lbnQpXG4gKiAgLSBDdXN0b20gW0Vycm9yc10oRXJyb3JGcmFnbWVudClcbiAqICAtIFtGYWxsYmFjayBvciBSZWNlaXZlXShGYWxsYmFja0ZyYWdtZW50KSBmdW5jdGlvbnNcbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS9hYmkvYWJpLWNvZGVyOkZyYWdtZW50cyAgW2Fib3V0LWZyYWdtZW50c11cbiAqL1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGFzc2VydCwgYXNzZXJ0UHJpdmF0ZSwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbjtcbi8vIFsgXCJhXCIsIFwiYlwiIF0gPT4geyBcImFcIjogMSwgXCJiXCI6IDEgfVxuZnVuY3Rpb24gc2V0aWZ5KGl0ZW1zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgIGl0ZW1zLmZvckVhY2goKGspID0+IHJlc3VsdC5hZGQoaykpO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG59XG5jb25zdCBfa3dWaXNpYkRlcGxveSA9IFwiZXh0ZXJuYWwgcHVibGljIHBheWFibGVcIjtcbmNvbnN0IEt3VmlzaWJEZXBsb3kgPSBzZXRpZnkoX2t3VmlzaWJEZXBsb3kuc3BsaXQoXCIgXCIpKTtcbi8vIFZpc2liaWxpdHkgS2V5d29yZHNcbmNvbnN0IF9rd1Zpc2liID0gXCJjb25zdGFudCBleHRlcm5hbCBpbnRlcm5hbCBwYXlhYmxlIHByaXZhdGUgcHVibGljIHB1cmUgdmlld1wiO1xuY29uc3QgS3dWaXNpYiA9IHNldGlmeShfa3dWaXNpYi5zcGxpdChcIiBcIikpO1xuY29uc3QgX2t3VHlwZXMgPSBcImNvbnN0cnVjdG9yIGVycm9yIGV2ZW50IGZhbGxiYWNrIGZ1bmN0aW9uIHJlY2VpdmUgc3RydWN0XCI7XG5jb25zdCBLd1R5cGVzID0gc2V0aWZ5KF9rd1R5cGVzLnNwbGl0KFwiIFwiKSk7XG5jb25zdCBfa3dNb2RpZmllcnMgPSBcImNhbGxkYXRhIG1lbW9yeSBzdG9yYWdlIHBheWFibGUgaW5kZXhlZFwiO1xuY29uc3QgS3dNb2RpZmllcnMgPSBzZXRpZnkoX2t3TW9kaWZpZXJzLnNwbGl0KFwiIFwiKSk7XG5jb25zdCBfa3dPdGhlciA9IFwidHVwbGUgcmV0dXJuc1wiO1xuLy8gQWxsIEtleXdvcmRzXG5jb25zdCBfa2V5d29yZHMgPSBbX2t3VHlwZXMsIF9rd01vZGlmaWVycywgX2t3T3RoZXIsIF9rd1Zpc2liXS5qb2luKFwiIFwiKTtcbmNvbnN0IEtleXdvcmRzID0gc2V0aWZ5KF9rZXl3b3Jkcy5zcGxpdChcIiBcIikpO1xuLy8gU2luZ2xlIGNoYXJhY3RlciB0b2tlbnNcbmNvbnN0IFNpbXBsZVRva2VucyA9IHtcbiAgICBcIihcIjogXCJPUEVOX1BBUkVOXCIsIFwiKVwiOiBcIkNMT1NFX1BBUkVOXCIsXG4gICAgXCJbXCI6IFwiT1BFTl9CUkFDS0VUXCIsIFwiXVwiOiBcIkNMT1NFX0JSQUNLRVRcIixcbiAgICBcIixcIjogXCJDT01NQVwiLCBcIkBcIjogXCJBVFwiXG59O1xuLy8gUGFyc2VyIHJlZ2V4ZXMgdG8gY29uc3VtZSB0aGUgbmV4dCB0b2tlblxuY29uc3QgcmVnZXhXaGl0ZXNwYWNlUHJlZml4ID0gbmV3IFJlZ0V4cChcIl4oXFxcXHMqKVwiKTtcbmNvbnN0IHJlZ2V4TnVtYmVyUHJlZml4ID0gbmV3IFJlZ0V4cChcIl4oWzAtOV0rKVwiKTtcbmNvbnN0IHJlZ2V4SWRQcmVmaXggPSBuZXcgUmVnRXhwKFwiXihbYS16QS1aJF9dW2EtekEtWjAtOSRfXSopXCIpO1xuLy8gUGFyc2VyIHJlZ2V4cyB0byBjaGVjayB2YWxpZGl0eVxuY29uc3QgcmVnZXhJZCA9IG5ldyBSZWdFeHAoXCJeKFthLXpBLVokX11bYS16QS1aMC05JF9dKikkXCIpO1xuY29uc3QgcmVnZXhUeXBlID0gbmV3IFJlZ0V4cChcIl4oYWRkcmVzc3xib29sfGJ5dGVzKFswLTldKil8c3RyaW5nfHU/aW50KFswLTldKikpJFwiKTtcbmNsYXNzIFRva2VuU3RyaW5nIHtcbiAgICAjb2Zmc2V0O1xuICAgICN0b2tlbnM7XG4gICAgZ2V0IG9mZnNldCgpIHsgcmV0dXJuIHRoaXMuI29mZnNldDsgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLiN0b2tlbnMubGVuZ3RoIC0gdGhpcy4jb2Zmc2V0OyB9XG4gICAgY29uc3RydWN0b3IodG9rZW5zKSB7XG4gICAgICAgIHRoaXMuI29mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuI3Rva2VucyA9IHRva2Vucy5zbGljZSgpO1xuICAgIH1cbiAgICBjbG9uZSgpIHsgcmV0dXJuIG5ldyBUb2tlblN0cmluZyh0aGlzLiN0b2tlbnMpOyB9XG4gICAgcmVzZXQoKSB7IHRoaXMuI29mZnNldCA9IDA7IH1cbiAgICAjc3ViVG9rZW5TdHJpbmcoZnJvbSA9IDAsIHRvID0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHRoaXMuI3Rva2Vucy5zbGljZShmcm9tLCB0bykubWFwKCh0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShPYmplY3QuYXNzaWduKHt9LCB0LCB7XG4gICAgICAgICAgICAgICAgbWF0Y2g6ICh0Lm1hdGNoIC0gZnJvbSksXG4gICAgICAgICAgICAgICAgbGlua0JhY2s6ICh0LmxpbmtCYWNrIC0gZnJvbSksXG4gICAgICAgICAgICAgICAgbGlua05leHQ6ICh0LmxpbmtOZXh0IC0gZnJvbSksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4sIGlmIGl0IGlzIGEga2V5d29yZCBpbiBhbGxvd2VkOyB0aHJvd3MgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBvcEtleXdvcmQoYWxsb3dlZCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKHRvcC50eXBlICE9PSBcIktFWVdPUkRcIiB8fCAhYWxsb3dlZC5oYXModG9wLnRleHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIGtleXdvcmQgJHt0b3AudGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3AoKS50ZXh0O1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmV4dCB0b2tlbiBpZiBpdCBpcyBgdHlwZWA7IHRocm93cyBpZiBvdXQgb2YgdG9rZW5zXG4gICAgcG9wVHlwZSh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLnBlZWsoKS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7dHlwZX07IGdvdCAke0pTT04uc3RyaW5naWZ5KHRoaXMucGVlaygpKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3AoKS50ZXh0O1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIGEgXCIoXCIgVE9LRU5TIFwiKVwiXG4gICAgcG9wUGFyZW4oKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiT1BFTl9QQVJFTlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgc3RhcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jc3ViVG9rZW5TdHJpbmcodGhpcy4jb2Zmc2V0ICsgMSwgdG9wLm1hdGNoICsgMSk7XG4gICAgICAgIHRoaXMuI29mZnNldCA9IHRvcC5tYXRjaCArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIGl0ZW1zIHdpdGhpbiBcIihcIiBJVEVNMSBcIixcIiBJVEVNMiBcIixcIiAuLi4gXCIpXCJcbiAgICBwb3BQYXJhbXMoKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiT1BFTl9QQVJFTlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgc3RhcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLiNvZmZzZXQgPCB0b3AubWF0Y2ggLSAxKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5wZWVrKCkubGlua05leHQ7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLiNzdWJUb2tlblN0cmluZyh0aGlzLiNvZmZzZXQgKyAxLCBsaW5rKSk7XG4gICAgICAgICAgICB0aGlzLiNvZmZzZXQgPSBsaW5rO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI29mZnNldCA9IHRvcC5tYXRjaCArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHRvcCBUb2tlbiwgdGhyb3dpbmcgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBlZWsoKSB7XG4gICAgICAgIGlmICh0aGlzLiNvZmZzZXQgPj0gdGhpcy4jdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3V0LW9mLWJvdW5kc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jdG9rZW5zW3RoaXMuI29mZnNldF07XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG5leHQgdmFsdWUsIGlmIGl0IGlzIGEga2V5d29yZCBpbiBgYWxsb3dlZGBcbiAgICBwZWVrS2V5d29yZChhbGxvd2VkKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVla1R5cGUoXCJLRVlXT1JEXCIpO1xuICAgICAgICByZXR1cm4gKHRvcCAhPSBudWxsICYmIGFsbG93ZWQuaGFzKHRvcCkpID8gdG9wIDogbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4gaWYgaXQgaXMgYHR5cGVgXG4gICAgcGVla1R5cGUodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICByZXR1cm4gKHRvcC50eXBlID09PSB0eXBlKSA/IHRvcC50ZXh0IDogbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbmV4dCB0b2tlbjsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwb3AoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucGVlaygpO1xuICAgICAgICB0aGlzLiNvZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy4jb2Zmc2V0OyBpIDwgdGhpcy4jdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuI3Rva2Vuc1tpXTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKGAke3Rva2VuLnR5cGV9OiR7dG9rZW4udGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYDxUb2tlblN0cmluZyAke3Rva2Vucy5qb2luKFwiIFwiKX0+YDtcbiAgICB9XG59XG5mdW5jdGlvbiBsZXgodGV4dCkge1xuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGNvbnN0IHRocm93RXJyb3IgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICBjb25zdCB0b2tlbiA9IChvZmZzZXQgPCB0ZXh0Lmxlbmd0aCkgPyBKU09OLnN0cmluZ2lmeSh0ZXh0W29mZnNldF0pIDogXCIkRU9JXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0b2tlbiAke3Rva2VufSBhdCAke29mZnNldH06ICR7bWVzc2FnZX1gKTtcbiAgICB9O1xuICAgIGxldCBicmFja2V0cyA9IFtdO1xuICAgIGxldCBjb21tYXMgPSBbXTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICB3aGlsZSAob2Zmc2V0IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIGFueSBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgbGV0IGN1ciA9IHRleHQuc3Vic3RyaW5nKG9mZnNldCk7XG4gICAgICAgIGxldCBtYXRjaCA9IGN1ci5tYXRjaChyZWdleFdoaXRlc3BhY2VQcmVmaXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgICAgICBjdXIgPSB0ZXh0LnN1YnN0cmluZyhvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VuID0geyBkZXB0aDogYnJhY2tldHMubGVuZ3RoLCBsaW5rQmFjazogLTEsIGxpbmtOZXh0OiAtMSwgbWF0Y2g6IC0xLCB0eXBlOiBcIlwiLCB0ZXh0OiBcIlwiLCBvZmZzZXQsIHZhbHVlOiAtMSB9O1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGxldCB0eXBlID0gKFNpbXBsZVRva2Vuc1tjdXJbMF1dIHx8IFwiXCIpO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgdG9rZW4udHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gY3VyWzBdO1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJPUEVOX1BBUkVOXCIpIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBjb21tYXMucHVzaCh0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFwiQ0xPU0VfUEFSRU5cIikge1xuICAgICAgICAgICAgICAgIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihcIm5vIG1hdGNoaW5nIG9wZW4gYnJhY2tldFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW4ubWF0Y2ggPSBicmFja2V0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2VuLm1hdGNoXSkubWF0Y2ggPSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB0b2tlbi5kZXB0aC0tO1xuICAgICAgICAgICAgICAgIHRva2VuLmxpbmtCYWNrID0gY29tbWFzLnBvcCgpO1xuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW4ubGlua0JhY2tdKS5saW5rTmV4dCA9IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJDT01NQVwiKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ubGlua0JhY2sgPSBjb21tYXMucG9wKCk7XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbi5saW5rQmFja10pLmxpbmtOZXh0ID0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgY29tbWFzLnB1c2godG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJPUEVOX0JSQUNLRVRcIikge1xuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIkJSQUNLRVRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQ0xPU0VfQlJBQ0tFVFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBDTE9TRV9CUkFDS0VUXG4gICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IHRva2Vucy5wb3AoKS50ZXh0O1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgPT09IFwiTlVNQkVSXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0b2tlbnMucG9wKCkudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gdmFsdWUgKyBzdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKS52YWx1ZSA9IGdldE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSAhPT0gXCJCUkFDS0VUXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBvcGVuaW5nIGJyYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKS50ZXh0ICs9IHN1ZmZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4SWRQcmVmaXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIG9mZnNldCArPSB0b2tlbi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChLZXl3b3Jkcy5oYXModG9rZW4udGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJLRVlXT1JEXCI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4udGV4dC5tYXRjaChyZWdleFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiVFlQRVwiO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiSURcIjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4TnVtYmVyUHJlZml4KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gXCJOVU1CRVJcIjtcbiAgICAgICAgICAgIG9mZnNldCArPSB0b2tlbi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCB0b2tlbiAke0pTT04uc3RyaW5naWZ5KGN1clswXSl9IGF0IHBvc2l0aW9uICR7b2Zmc2V0fWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHRva2Vucy5tYXAoKHQpID0+IE9iamVjdC5mcmVlemUodCkpKTtcbn1cbi8vIENoZWNrIG9ubHkgb25lIG9mIGBhbGxvd2VkYCBpcyBpbiBgc2V0YFxuZnVuY3Rpb24gYWxsb3dTaW5nbGUoc2V0LCBhbGxvd2VkKSB7XG4gICAgbGV0IGluY2x1ZGVkID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYWxsb3dlZC5rZXlzKCkpIHtcbiAgICAgICAgaWYgKHNldC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgaW5jbHVkZWQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbmNsdWRlZC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29uZmxpY3RpbmcgdHlwZXM6ICR7aW5jbHVkZWQuam9pbihcIiwgXCIpfWApO1xuICAgIH1cbn1cbi8vIEZ1bmN0aW9ucyB0byBwcm9jZXNzIGEgU29saWRpdHkgU2lnbmF0dXJlIFRva2VuU3RyaW5nIGZyb20gbGVmdC10by1yaWdodCBmb3IuLi5cbi8vIC4uLnRoZSBuYW1lIHdpdGggYW4gb3B0aW9uYWwgdHlwZSwgcmV0dXJuaW5nIHRoZSBuYW1lXG5mdW5jdGlvbiBjb25zdW1lTmFtZSh0eXBlLCB0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLnBlZWtLZXl3b3JkKEt3VHlwZXMpKSB7XG4gICAgICAgIGNvbnN0IGtleXdvcmQgPSB0b2tlbnMucG9wKCkudGV4dDtcbiAgICAgICAgaWYgKGtleXdvcmQgIT09IHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHt0eXBlfSwgZ290ICR7a2V5d29yZH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zLnBvcFR5cGUoXCJJRFwiKTtcbn1cbi8vIC4uLmFsbCBrZXl3b3JkcyBtYXRjaGluZyBhbGxvd2VkLCByZXR1cm5pbmcgdGhlIGtleXdvcmRzXG5mdW5jdGlvbiBjb25zdW1lS2V5d29yZHModG9rZW5zLCBhbGxvd2VkKSB7XG4gICAgY29uc3Qga2V5d29yZHMgPSBuZXcgU2V0KCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3Qga2V5d29yZCA9IHRva2Vucy5wZWVrVHlwZShcIktFWVdPUkRcIik7XG4gICAgICAgIGlmIChrZXl3b3JkID09IG51bGwgfHwgKGFsbG93ZWQgJiYgIWFsbG93ZWQuaGFzKGtleXdvcmQpKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICBpZiAoa2V5d29yZHMuaGFzKGtleXdvcmQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZSBrZXl3b3JkczogJHtKU09OLnN0cmluZ2lmeShrZXl3b3JkKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBrZXl3b3Jkcy5hZGQoa2V5d29yZCk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGtleXdvcmRzKTtcbn1cbi8vIC4uLmFsbCB2aXNpYmlsaXR5IGtleXdvcmRzLCByZXR1cm5pbmcgdGhlIGNvYWxlc2NlZCBtdXRhYmlsaXR5XG5mdW5jdGlvbiBjb25zdW1lTXV0YWJpbGl0eSh0b2tlbnMpIHtcbiAgICBsZXQgbW9kaWZpZXJzID0gY29uc3VtZUtleXdvcmRzKHRva2VucywgS3dWaXNpYik7XG4gICAgLy8gRGV0ZWN0IGNvbmZsaWN0aW5nIG1vZGlmaWVyc1xuICAgIGFsbG93U2luZ2xlKG1vZGlmaWVycywgc2V0aWZ5KFwiY29uc3RhbnQgcGF5YWJsZSBub25wYXlhYmxlXCIuc3BsaXQoXCIgXCIpKSk7XG4gICAgYWxsb3dTaW5nbGUobW9kaWZpZXJzLCBzZXRpZnkoXCJwdXJlIHZpZXcgcGF5YWJsZSBub25wYXlhYmxlXCIuc3BsaXQoXCIgXCIpKSk7XG4gICAgLy8gUHJvY2VzcyBtdXRhYmlsaXR5IHN0YXRlc1xuICAgIGlmIChtb2RpZmllcnMuaGFzKFwidmlld1wiKSkge1xuICAgICAgICByZXR1cm4gXCJ2aWV3XCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwicHVyZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJwdXJlXCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwicGF5YWJsZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJwYXlhYmxlXCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwibm9ucGF5YWJsZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJub25wYXlhYmxlXCI7XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgbGVnYWN5IGBjb25zdGFudGAgbGFzdFxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwiY29uc3RhbnRcIikpIHtcbiAgICAgICAgcmV0dXJuIFwidmlld1wiO1xuICAgIH1cbiAgICByZXR1cm4gXCJub25wYXlhYmxlXCI7XG59XG4vLyAuLi5hIHBhcmFtZXRlciBsaXN0LCByZXR1cm5pbmcgdGhlIFBhcmFtVHlwZSBsaXN0XG5mdW5jdGlvbiBjb25zdW1lUGFyYW1zKHRva2VucywgYWxsb3dJbmRleGVkKSB7XG4gICAgcmV0dXJuIHRva2Vucy5wb3BQYXJhbXMoKS5tYXAoKHQpID0+IFBhcmFtVHlwZS5mcm9tKHQsIGFsbG93SW5kZXhlZCkpO1xufVxuLy8gLi4uYSBnYXMgbGltaXQsIHJldHVybmluZyBhIEJpZ051bWJlciBvciBudWxsIGlmIG5vbmVcbmZ1bmN0aW9uIGNvbnN1bWVHYXModG9rZW5zKSB7XG4gICAgaWYgKHRva2Vucy5wZWVrVHlwZShcIkFUXCIpKSB7XG4gICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgaWYgKHRva2Vucy5wZWVrVHlwZShcIk5VTUJFUlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh0b2tlbnMucG9wKCkudGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBnYXNcIik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29uc3VtZUVvaSh0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgdG9rZW5zOiAke3Rva2Vucy50b1N0cmluZygpfWApO1xuICAgIH1cbn1cbmNvbnN0IHJlZ2V4QXJyYXlUeXBlID0gbmV3IFJlZ0V4cCgvXiguKilcXFsoWzAtOV0qKVxcXSQvKTtcbmZ1bmN0aW9uIHZlcmlmeUJhc2ljVHlwZSh0eXBlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4VHlwZSk7XG4gICAgYXNzZXJ0QXJndW1lbnQobWF0Y2gsIFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICBpZiAodHlwZSA9PT0gXCJ1aW50XCIpIHtcbiAgICAgICAgcmV0dXJuIFwidWludDI1NlwiO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJpbnRcIikge1xuICAgICAgICByZXR1cm4gXCJpbnQyNTZcIjtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgIC8vIGJ5dGVzWFhcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChsZW5ndGggIT09IDAgJiYgbGVuZ3RoIDw9IDMyLCBcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgLy8gaW50WFggb3IgdWludFhYXG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHNpemUgIT09IDAgJiYgc2l6ZSA8PSAyNTYgJiYgKHNpemUgJSA4KSA9PT0gMCwgXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbn1cbi8vIE1ha2UgdGhlIEZyYWdtZW50IGNvbnN0cnVjdG9ycyBlZmZlY3RpdmVseSBwcml2YXRlXG5jb25zdCBfZ3VhcmQgPSB7fTtcbmNvbnN0IGludGVybmFsID0gU3ltYm9sLmZvcihcIl9ldGhlcnNfaW50ZXJuYWxcIik7XG5jb25zdCBQYXJhbVR5cGVJbnRlcm5hbCA9IFwiX1BhcmFtVHlwZUludGVybmFsXCI7XG5jb25zdCBFcnJvckZyYWdtZW50SW50ZXJuYWwgPSBcIl9FcnJvckludGVybmFsXCI7XG5jb25zdCBFdmVudEZyYWdtZW50SW50ZXJuYWwgPSBcIl9FdmVudEludGVybmFsXCI7XG5jb25zdCBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwgPSBcIl9Db25zdHJ1Y3RvckludGVybmFsXCI7XG5jb25zdCBGYWxsYmFja0ZyYWdtZW50SW50ZXJuYWwgPSBcIl9GYWxsYmFja0ludGVybmFsXCI7XG5jb25zdCBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwgPSBcIl9GdW5jdGlvbkludGVybmFsXCI7XG5jb25zdCBTdHJ1Y3RGcmFnbWVudEludGVybmFsID0gXCJfU3RydWN0SW50ZXJuYWxcIjtcbi8qKlxuICogIEVhY2ggaW5wdXQgYW5kIG91dHB1dCBvZiBhIFtbRnJhZ21lbnRdXSBpcyBhbiBBcnJheSBvZiAqKlBhcmFtVHlwZSoqLlxuICovXG5leHBvcnQgY2xhc3MgUGFyYW1UeXBlIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGxvY2FsIG5hbWUgb2YgdGhlIHBhcmFtZXRlciAob3IgYGBcIlwiYGAgaWYgdW5ib3VuZClcbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbHkgcXVhbGlmaWVkIHR5cGUgKGUuZy4gYGBcImFkZHJlc3NcImBgLCBgYFwidHVwbGUoYWRkcmVzcylcImBgLFxuICAgICAqICBgYFwidWludDI1NlszXVtdXCJgYClcbiAgICAgKi9cbiAgICB0eXBlO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmFzZSB0eXBlIChlLmcuIGBgXCJhZGRyZXNzXCJgYCwgYGBcInR1cGxlXCJgYCwgYGBcImFycmF5XCJgYClcbiAgICAgKi9cbiAgICBiYXNlVHlwZTtcbiAgICAvKipcbiAgICAgKiAgVHJ1ZSBpZiB0aGUgcGFyYW1ldGVycyBpcyBpbmRleGVkLlxuICAgICAqXG4gICAgICogIEZvciBub24taW5kZXhhYmxlIHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgaW5kZXhlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbXBvbmVudHMgZm9yIHRoZSB0dXBsZS5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLXR1cGxlIHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgY29tcG9uZW50cztcbiAgICAvKipcbiAgICAgKiAgVGhlIGFycmF5IGxlbmd0aCwgb3IgYGAtMWBgIGZvciBkeW5hbWljLWxlbmd0aGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLWFycmF5IHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgYXJyYXlMZW5ndGg7XG4gICAgLyoqXG4gICAgICogIFRoZSB0eXBlIG9mIGVhY2ggY2hpbGQgaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogIEZvciBub24tYXJyYXkgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBhcnJheUNoaWxkcmVuO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcG9uZW50cywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pIHtcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIlBhcmFtVHlwZVwiKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBQYXJhbVR5cGVJbnRlcm5hbCB9KTtcbiAgICAgICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSBPYmplY3QuZnJlZXplKGNvbXBvbmVudHMuc2xpY2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIGlmIChhcnJheUxlbmd0aCA9PSBudWxsIHx8IGFycmF5Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcnJheUxlbmd0aCAhPSBudWxsIHx8IGFycmF5Q2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgbmFtZSwgdHlwZSwgYmFzZVR5cGUsIGluZGV4ZWQsIGNvbXBvbmVudHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSxcbiAgICAgKlxuICAgICAqICBgYHNpZ2hhc2hcIiA9PiBcIih1aW50MjU2LGFkZHJlc3MpXCJgYFxuICAgICAqXG4gICAgICogIGBgXCJtaW5pbWFsXCIgPT4gXCJ0dXBsZSh1aW50MjU2LGFkZHJlc3MpIGluZGV4ZWRcImBgXG4gICAgICpcbiAgICAgKiAgYGBcImZ1bGxcIiA9PiBcInR1cGxlKHVpbnQyNTYgZm9vLCBhZGRyZXNzIGJhcikgaW5kZXhlZCBiYXpcImBgXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lIHx8IFwiXCI7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoXCJqc29uXCIpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnR5cGUgKz0gYFskeyh0aGlzLmFycmF5TGVuZ3RoIDwgMCA/IFwiXCIgOiBTdHJpbmcodGhpcy5hcnJheUxlbmd0aCkpfV1gO1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICgodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSA/IFwidHVwbGVcIiA6IHRoaXMudHlwZSksXG4gICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRoaXMuaW5kZXhlZCkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmluZGV4ZWQgPSB0aGlzLmluZGV4ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cy5tYXAoKGMpID0+IEpTT04ucGFyc2UoYy5mb3JtYXQoZm9ybWF0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBgWyR7KHRoaXMuYXJyYXlMZW5ndGggPCAwID8gXCJcIiA6IFN0cmluZyh0aGlzLmFycmF5TGVuZ3RoKSl9XWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy50eXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIoXCIgKyB0aGlzLmNvbXBvbmVudHMubWFwKChjb21wKSA9PiBjb21wLmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IFwiZnVsbFwiKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBpbmRleGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBcImZ1bGxcIiAmJiB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhbiBBcnJheSB0eXBlLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGdhdXJkIGVuc3VyaW5nIHRoYXQgW1thcnJheUNoaWxkcmVuXV1cbiAgICAgKiAgYW5kIFtbYXJyYXlMZW5ndGhdXSBhcmUgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhc2VUeXBlID09PSBcImFycmF5XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGEgVHVwbGUgdHlwZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbY29tcG9uZW50c11dXG4gICAgICogIGlzIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzVHVwbGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhbiBJbmRleGFibGUgdHlwZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbaW5kZXhlZF1dXG4gICAgICogIGlzIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzSW5kZXhhYmxlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW5kZXhlZCAhPSBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdhbGtzIHRoZSAqKlBhcmFtVHlwZSoqIHdpdGggJSV2YWx1ZSUlLCBjYWxsaW5nICUlcHJvY2VzcyUlXG4gICAgICogIG9uIGVhY2ggdHlwZSwgZGVzdHJ1Y3RpbmcgdGhlICUldmFsdWUlJSByZWN1cnNpdmVseS5cbiAgICAgKi9cbiAgICB3YWxrKHZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXJyYXkgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hcnJheUxlbmd0aCAhPT0gLTEgJiYgdmFsdWUubGVuZ3RoICE9PSB0aGlzLmFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gKF90aGlzLmFycmF5Q2hpbGRyZW4ud2Fsayh2LCBwcm9jZXNzKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHVwbGUgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodiwgaSkgPT4gKF90aGlzLmNvbXBvbmVudHNbaV0ud2Fsayh2LCBwcm9jZXNzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9jZXNzKHRoaXMudHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAjd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2Vzcywgc2V0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhcnJheSB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5TGVuZ3RoICE9PSAtMSAmJiB2YWx1ZS5sZW5ndGggIT09IHRoaXMuYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSB0aGlzLmFycmF5Q2hpbGRyZW47XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5zbGljZSgpO1xuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkVHlwZS4jd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2VzcywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0VmFsdWUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHM7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBvYmplY3QgaW50byBhbiBhcnJheVxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgKHZhbHVlKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb21wb25lbnRzLm1hcCgocGFyYW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdXNlIG9iamVjdCB2YWx1ZSB3aXRoIHVubmFtZWQgY29tcG9uZW50c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXJhbS5uYW1lIGluIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIHZhbHVlIGZvciBjb21wb25lbnQgJHtwYXJhbS5uYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtwYXJhbS5uYW1lXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNbaW5kZXhdLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRWYWx1ZShyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3ModGhpcy50eXBlLCB2YWx1ZSk7XG4gICAgICAgIGlmIChyZXN1bHQudGhlbikge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyBzZXRWYWx1ZShhd2FpdCByZXN1bHQpOyB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdhbGtzIHRoZSAqKlBhcmFtVHlwZSoqIHdpdGggJSV2YWx1ZSUlLCBhc3luY2hyb25vdXNseSBjYWxsaW5nXG4gICAgICogICUlcHJvY2VzcyUlIG9uIGVhY2ggdHlwZSwgZGVzdHJ1Y3RpbmcgdGhlICUldmFsdWUlJSByZWN1cnNpdmVseS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiBiZSB1c2VkIHRvIHJlc29sdmUgRU5TIG5hZXMgYnkgd2Fsa2luZyBhbmQgcmVzb2x2aW5nIGVhY2hcbiAgICAgKiAgYGBcImFkZHJlc3NcImBgIHR5cGUuXG4gICAgICovXG4gICAgYXN5bmMgd2Fsa0FzeW5jKHZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFt2YWx1ZV07XG4gICAgICAgIHRoaXMuI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipQYXJhbVR5cGUqKiBmb3IgJSVvYmolJS5cbiAgICAgKlxuICAgICAqICBJZiAlJWFsbG93SW5kZXhlZCUlIHRoZW4gdGhlIGBgaW5kZXhlZGBgIGtleXdvcmQgaXMgcGVybWl0dGVkLFxuICAgICAqICBvdGhlcndpc2UgdGhlIGBgaW5kZXhlZGBgIGtleXdvcmQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmosIGFsbG93SW5kZXhlZCkge1xuICAgICAgICBpZiAoUGFyYW1UeXBlLmlzUGFyYW1UeXBlKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyYW1UeXBlLmZyb20obGV4KG9iaiksIGFsbG93SW5kZXhlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHBhcmFtIHR5cGVcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBcIlwiLCBiYXNlVHlwZSA9IFwiXCI7XG4gICAgICAgICAgICBsZXQgY29tcHMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJ0dXBsZVwiXSkpLmhhcyhcInR1cGxlXCIpIHx8IG9iai5wZWVrVHlwZShcIk9QRU5fUEFSRU5cIikpIHtcbiAgICAgICAgICAgICAgICAvLyBUdXBsZVxuICAgICAgICAgICAgICAgIGJhc2VUeXBlID0gXCJ0dXBsZVwiO1xuICAgICAgICAgICAgICAgIGNvbXBzID0gb2JqLnBvcFBhcmFtcygpLm1hcCgodCkgPT4gUGFyYW1UeXBlLmZyb20odCkpO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBgdHVwbGUoJHtjb21wcy5tYXAoKGMpID0+IGMuZm9ybWF0KCkpLmpvaW4oXCIsXCIpfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsXG4gICAgICAgICAgICAgICAgdHlwZSA9IHZlcmlmeUJhc2ljVHlwZShvYmoucG9wVHlwZShcIlRZUEVcIikpO1xuICAgICAgICAgICAgICAgIGJhc2VUeXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBBcnJheVxuICAgICAgICAgICAgbGV0IGFycmF5Q2hpbGRyZW4gPSBudWxsO1xuICAgICAgICAgICAgbGV0IGFycmF5TGVuZ3RoID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChvYmoubGVuZ3RoICYmIG9iai5wZWVrVHlwZShcIkJSQUNLRVRcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBicmFja2V0ID0gb2JqLnBvcCgpOyAvL2FycmF5c1tpXTtcbiAgICAgICAgICAgICAgICBhcnJheUNoaWxkcmVuID0gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIFwiXCIsIHR5cGUsIGJhc2VUeXBlLCBudWxsLCBjb21wcywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGFycmF5TGVuZ3RoID0gYnJhY2tldC52YWx1ZTtcbiAgICAgICAgICAgICAgICB0eXBlICs9IGJyYWNrZXQudGV4dDtcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IFwiYXJyYXlcIjtcbiAgICAgICAgICAgICAgICBjb21wcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaW5kZXhlZCA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBrZXl3b3JkcyA9IGNvbnN1bWVLZXl3b3JkcyhvYmosIEt3TW9kaWZpZXJzKTtcbiAgICAgICAgICAgIGlmIChrZXl3b3Jkcy5oYXMoXCJpbmRleGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSAob2JqLnBlZWtUeXBlKFwiSURcIikgPyBvYmoucG9wKCkudGV4dCA6IFwiXCIpO1xuICAgICAgICAgICAgaWYgKG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsZWZ0b3ZlciB0b2tlbnNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUsIHR5cGUsIGJhc2VUeXBlLCBpbmRleGVkLCBjb21wcywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSBvYmoubmFtZTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIW5hbWUgfHwgKHR5cGVvZiAobmFtZSkgPT09IFwic3RyaW5nXCIgJiYgbmFtZS5tYXRjaChyZWdleElkKSksIFwiaW52YWxpZCBuYW1lXCIsIFwib2JqLm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGxldCBpbmRleGVkID0gb2JqLmluZGV4ZWQ7XG4gICAgICAgIGlmIChpbmRleGVkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFsbG93SW5kZXhlZCwgXCJwYXJhbWV0ZXIgY2Fubm90IGJlIGluZGV4ZWRcIiwgXCJvYmouaW5kZXhlZFwiLCBvYmouaW5kZXhlZCk7XG4gICAgICAgICAgICBpbmRleGVkID0gISFpbmRleGVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gb2JqLnR5cGU7XG4gICAgICAgIGxldCBhcnJheU1hdGNoID0gdHlwZS5tYXRjaChyZWdleEFycmF5VHlwZSk7XG4gICAgICAgIGlmIChhcnJheU1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBhcnJheUxlbmd0aCA9IHBhcnNlSW50KGFycmF5TWF0Y2hbMl0gfHwgXCItMVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5Q2hpbGRyZW4gPSBQYXJhbVR5cGUuZnJvbSh7XG4gICAgICAgICAgICAgICAgdHlwZTogYXJyYXlNYXRjaFsxXSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBvYmouY29tcG9uZW50c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUgfHwgXCJcIiwgdHlwZSwgXCJhcnJheVwiLCBpbmRleGVkLCBudWxsLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwidHVwbGVcIiB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJ0dXBsZShcIiAvKiBmaXg6ICkgKi8pIHx8IHR5cGUuc3RhcnRzV2l0aChcIihcIiAvKiBmaXg6ICkgKi8pKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wcyA9IChvYmouY29tcG9uZW50cyAhPSBudWxsKSA/IG9iai5jb21wb25lbnRzLm1hcCgoYykgPT4gUGFyYW1UeXBlLmZyb20oYykpIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHR1cGxlID0gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUgfHwgXCJcIiwgdHlwZSwgXCJ0dXBsZVwiLCBpbmRleGVkLCBjb21wcywgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAvLyBAVE9ETzogdXNlIGxleGVyIHRvIHZhbGlkYXRlIGFuZCBub3JtYWxpemUgdHlwZVxuICAgICAgICAgICAgcmV0dXJuIHR1cGxlO1xuICAgICAgICB9XG4gICAgICAgIHR5cGUgPSB2ZXJpZnlCYXNpY1R5cGUob2JqLnR5cGUpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUgfHwgXCJcIiwgdHlwZSwgdHlwZSwgaW5kZXhlZCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgKipQYXJhbVR5cGUqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNQYXJhbVR5cGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IFBhcmFtVHlwZUludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBbiBhYnN0cmFjdCBjbGFzcyB0byByZXByZXNlbnQgQW4gaW5kaXZpZHVhbCBmcmFnbWVudCBmcm9tIGEgcGFyc2UgQUJJLlxuICovXG5leHBvcnQgY2xhc3MgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZSBvZiB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGlucHV0cyBmb3IgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGlucHV0cztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdHlwZSwgaW5wdXRzKSB7XG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJGcmFnbWVudFwiKTtcbiAgICAgICAgaW5wdXRzID0gT2JqZWN0LmZyZWV6ZShpbnB1dHMuc2xpY2UoKSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyB0eXBlLCBpbnB1dHMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRnJhZ21lbnQqKiBmb3IgJSVvYmolJSwgd2ljaCBjYW4gYmUgYW55IHN1cHBvcnRlZFxuICAgICAqICBBQkkgZnJnYW1lbnQgdHlwZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gVHJ5IHBhcnNpbmcgSlNPTi4uLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBGcmFnbWVudC5mcm9tKEpTT04ucGFyc2Uob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICAvLyAuLi5vdGhlcndpc2UsIHVzZSB0aGUgaHVtYW4tcmVhZGFibGUgbGV4ZXJcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIC8vIEh1bWFuLXJlYWRhYmxlIEFCSSAoYWxyZWFkeSBsZXhlZClcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBvYmoucGVla0tleXdvcmQoS3dUeXBlcyk7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjogcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6IHJldHVybiBFdmVudEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVjZWl2ZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFsbGJhY2tGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6IHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RydWN0XCI6IHJldHVybiBTdHJ1Y3RGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChvYmopID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBKU09OIEFCSVxuICAgICAgICAgICAgc3dpdGNoIChvYmoudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOiByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHJldHVybiBFcnJvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjogcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWxsYmFja1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWNlaXZlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWxsYmFja0ZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjogcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJ1Y3RcIjogcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYHVuc3VwcG9ydGVkIHR5cGU6ICR7b2JqLnR5cGV9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJGcmFnbWVudC5mcm9tXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIGZyZ2FtZW50IG9iamVjdFwiLCBcIm9ialwiLCBvYmopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbQ29uc3RydWN0b3JGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0NvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhbiBbW0Vycm9yRnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFcnJvcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gW1tFdmVudEZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzRXZlbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgW1tGdW5jdGlvbkZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgW1tTdHJ1Y3RGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1N0cnVjdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gU3RydWN0RnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gYWJzdHJhY3QgY2xhc3MgdG8gcmVwcmVzZW50IEFuIGluZGl2aWR1YWwgZnJhZ21lbnRcbiAqICB3aGljaCBoYXMgYSBuYW1lIGZyb20gYSBwYXJzZSBBQkkuXG4gKi9cbmV4cG9ydCBjbGFzcyBOYW1lZEZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdHlwZSwgbmFtZSwgaW5wdXRzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCB0eXBlLCBpbnB1dHMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiICYmIG5hbWUubWF0Y2gocmVnZXhJZCksIFwiaW52YWxpZCBpZGVudGlmaWVyXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgaW5wdXRzID0gT2JqZWN0LmZyZWV6ZShpbnB1dHMuc2xpY2UoKSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGpvaW5QYXJhbXMoZm9ybWF0LCBwYXJhbXMpIHtcbiAgICByZXR1cm4gXCIoXCIgKyBwYXJhbXMubWFwKChwKSA9PiBwLmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IFwiZnVsbFwiKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKVwiO1xufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgLy9DdXN0b20gRXJyb3IvLy5cbiAqL1xuZXhwb3J0IGNsYXNzIEVycm9yRnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgaW5wdXRzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcImVycm9yXCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRXJyb3JGcmFnbWVudEludGVybmFsIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEN1c3RvbSBFcnJvciBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBpZCh0aGlzLmZvcm1hdChcInNpZ2hhc2hcIikpLnN1YnN0cmluZygwLCAxMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZnJhZ21lbnQgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJlcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5hbWUgKyBqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipFcnJvckZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChFcnJvckZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZXJyb3JcIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3JGcmFnbWVudChfZ3VhcmQsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvckZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFuXG4gICAgICogICoqRXJyb3JGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBFcnJvckZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhbiBFdmVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50RnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgV2hldGhlciB0aGlzIGV2ZW50IGlzIGFub255bW91cy5cbiAgICAgKi9cbiAgICBhbm9ueW1vdXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIGlucHV0cywgYW5vbnltb3VzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcImV2ZW50XCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRXZlbnRGcmFnbWVudEludGVybmFsIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYW5vbnltb3VzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEV2ZW50IHRvcGljIGhhc2guXG4gICAgICovXG4gICAgZ2V0IHRvcGljSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIGlkKHRoaXMuZm9ybWF0KFwic2lnaGFzaFwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZXZlbnQgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJldmVudFwiLFxuICAgICAgICAgICAgICAgIGFub255bW91czogdGhpcy5hbm9ueW1vdXMsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpKSA9PiBKU09OLnBhcnNlKGkuZm9ybWF0KGZvcm1hdCkpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcImV2ZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubmFtZSArIGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cykpO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIiAmJiB0aGlzLmFub255bW91cykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJhbm9ueW1vdXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgdG9waWMgaGFzaCBmb3IgYW4gZXZlbnQgd2l0aCAlJW5hbWUlJSBhbmQgJSVwYXJhbXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0VG9waWNIYXNoKG5hbWUsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSAocGFyYW1zIHx8IFtdKS5tYXAoKHApID0+IFBhcmFtVHlwZS5mcm9tKHApKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBuZXcgRXZlbnRGcmFnbWVudChfZ3VhcmQsIG5hbWUsIHBhcmFtcywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQudG9waWNIYXNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkV2ZW50RnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKEV2ZW50RnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGV2ZW50IGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcImV2ZW50XCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaiwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBhbm9ueW1vdXMgPSAhIWNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJhbm9ueW1vdXNcIl0pKS5oYXMoXCJhbm9ueW1vdXNcIik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50RnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBpbnB1dHMsIGFub255bW91cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudEZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcCgocCkgPT4gUGFyYW1UeXBlLmZyb20ocCwgdHJ1ZSkpIDogW10sICEhb2JqLmFub255bW91cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFuXG4gICAgICogICoqRXZlbnRGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBFdmVudEZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIGNvbnN0cnVjdG9yLlxuICovXG5leHBvcnQgY2xhc3MgQ29uc3RydWN0b3JGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgV2hldGhlciB0aGUgY29uc3RydWN0b3IgY2FuIHJlY2VpdmUgYW4gZW5kb3dtZW50LlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNvbW1lbmRlZCBnYXMgbGltaXQgZm9yIGRlcGxveW1lbnQgb3IgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2FzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB0eXBlLCBpbnB1dHMsIHBheWFibGUsIGdhcykge1xuICAgICAgICBzdXBlcihndWFyZCwgdHlwZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwYXlhYmxlLCBnYXMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29uc3RydWN0b3IgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGFzc2VydChmb3JtYXQgIT0gbnVsbCAmJiBmb3JtYXQgIT09IFwic2lnaGFzaFwiLCBcImNhbm5vdCBmb3JtYXQgYSBjb25zdHJ1Y3RvciBmb3Igc2lnaGFzaFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmb3JtYXQoc2lnaGFzaClcIiB9KTtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogKHRoaXMucGF5YWJsZSA/IFwicGF5YWJsZVwiIDogXCJ1bmRlZmluZWRcIiksXG4gICAgICAgICAgICAgICAgcGF5YWJsZTogdGhpcy5wYXlhYmxlLFxuICAgICAgICAgICAgICAgIGdhczogKCh0aGlzLmdhcyAhPSBudWxsKSA/IHRoaXMuZ2FzIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtgY29uc3RydWN0b3Ike2pvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cyl9YF07XG4gICAgICAgIHJlc3VsdC5wdXNoKCh0aGlzLnBheWFibGUpID8gXCJwYXlhYmxlXCIgOiBcIm5vbnBheWFibGVcIik7XG4gICAgICAgIGlmICh0aGlzLmdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChgQCR7dGhpcy5nYXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkNvbnN0cnVjdG9yRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKENvbnN0cnVjdG9yRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGNvbnN0dWN0b3IgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcImNvbnN0cnVjdG9yXCJdKSk7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdCBwYXlhYmxlID0gISFjb25zdW1lS2V5d29yZHMob2JqLCBLd1Zpc2liRGVwbG95KS5oYXMoXCJwYXlhYmxlXCIpO1xuICAgICAgICAgICAgY29uc3QgZ2FzID0gY29uc3VtZUdhcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvckZyYWdtZW50KF9ndWFyZCwgXCJjb25zdHJ1Y3RvclwiLCBpbnB1dHMsIHBheWFibGUsIGdhcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvckZyYWdtZW50KF9ndWFyZCwgXCJjb25zdHJ1Y3RvclwiLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sICEhb2JqLnBheWFibGUsIChvYmouZ2FzICE9IG51bGwpID8gb2JqLmdhcyA6IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXG4gICAgICogICoqQ29uc3RydWN0b3JGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIG1ldGhvZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEZhbGxiYWNrRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIElmIHRoZSBmdW5jdGlvbiBjYW4gYmUgc2VudCB2YWx1ZSBkdXJpbmcgaW52b2NhdGlvbi5cbiAgICAgKi9cbiAgICBwYXlhYmxlO1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBpbnB1dHMsIHBheWFibGUpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZmFsbGJhY2tcIiwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBGYWxsYmFja0ZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwYXlhYmxlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZhbGxiYWNrIGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBjb25zdCB0eXBlID0gKCh0aGlzLmlucHV0cy5sZW5ndGggPT09IDApID8gXCJyZWNlaXZlXCIgOiBcImZhbGxiYWNrXCIpO1xuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVNdXRhYmlsaXR5ID0gKHRoaXMucGF5YWJsZSA/IFwicGF5YWJsZVwiIDogXCJub25wYXlhYmxlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHsgdHlwZSwgc3RhdGVNdXRhYmlsaXR5IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0eXBlfSgpJHt0aGlzLnBheWFibGUgPyBcIiBwYXlhYmxlXCIgOiBcIlwifWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRmFsbGJhY2tGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRmFsbGJhY2tGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRmFsbGJhY2tGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZmFsbGJhY2sgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JPYmogPSBvYmoudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IHRvcElzVmFsaWQgPSBvYmoucGVla0tleXdvcmQoc2V0aWZ5KFtcImZhbGxiYWNrXCIsIFwicmVjZWl2ZVwiXSkpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodG9wSXNWYWxpZCwgXCJ0eXBlIG11c3QgYmUgZmFsbGJhY2sgb3IgcmVjZWl2ZVwiLCBcIm9ialwiLCBlcnJvck9iaik7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gb2JqLnBvcEtleXdvcmQoc2V0aWZ5KFtcImZhbGxiYWNrXCIsIFwicmVjZWl2ZVwiXSkpO1xuICAgICAgICAgICAgLy8gcmVjZWl2ZSgpXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJyZWNlaXZlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5wdXRzLmxlbmd0aCA9PT0gMCwgYHJlY2VpdmUgY2Fubm90IGhhdmUgYXJndW1lbnRzYCwgXCJvYmouaW5wdXRzXCIsIGlucHV0cyk7XG4gICAgICAgICAgICAgICAgY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcInBheWFibGVcIl0pKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgW10sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFsbGJhY2soKSBbcGF5YWJsZV1cbiAgICAgICAgICAgIC8vIGZhbGxiYWNrKGJ5dGVzKSBbcGF5YWJsZV0gcmV0dXJucyAoYnl0ZXMpXG4gICAgICAgICAgICBsZXQgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgaWYgKGlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpbnB1dHMubGVuZ3RoID09PSAxICYmIGlucHV0c1swXS50eXBlID09PSBcImJ5dGVzXCIsIFwiaW52YWxpZCBmYWxsYmFjayBpbnB1dHNcIiwgXCJvYmouaW5wdXRzXCIsIGlucHV0cy5tYXAoKGkpID0+IGkuZm9ybWF0KFwibWluaW1hbFwiKSkuam9pbihcIiwgXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0cyA9IFtQYXJhbVR5cGUuZnJvbShcImJ5dGVzXCIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG11dGFiaWxpdHkgPSBjb25zdW1lTXV0YWJpbGl0eShvYmopO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQobXV0YWJpbGl0eSA9PT0gXCJub25wYXlhYmxlXCIgfHwgbXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIsIFwiZmFsbGJhY2sgY2Fubm90IGJlIGNvbnN0YW50c1wiLCBcIm9iai5zdGF0ZU11dGFiaWxpdHlcIiwgbXV0YWJpbGl0eSk7XG4gICAgICAgICAgICBpZiAoY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcInJldHVybnNcIl0pKS5oYXMoXCJyZXR1cm5zXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChvdXRwdXRzLmxlbmd0aCA9PT0gMSAmJiBvdXRwdXRzWzBdLnR5cGUgPT09IFwiYnl0ZXNcIiwgXCJpbnZhbGlkIGZhbGxiYWNrIG91dHB1dHNcIiwgXCJvYmoub3V0cHV0c1wiLCBvdXRwdXRzLm1hcCgoaSkgPT4gaS5mb3JtYXQoXCJtaW5pbWFsXCIpKS5qb2luKFwiLCBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgaW5wdXRzLCBtdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai50eXBlID09PSBcInJlY2VpdmVcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgW10sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJmYWxsYmFja1wiKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBbUGFyYW1UeXBlLmZyb20oXCJieXRlc1wiKV07XG4gICAgICAgICAgICBjb25zdCBwYXlhYmxlID0gKG9iai5zdGF0ZU11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIGlucHV0cywgcGF5YWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBmYWxsYmFjayBkZXNjcmlwdGlvblwiLCBcIm9ialwiLCBvYmopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXG4gICAgICogICoqRmFsbGJhY2tGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBGYWxsYmFja0ZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIG1ldGhvZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uRnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGlzIGNvbnN0YW50IChlLmcuIGBgcHVyZWBgIG9yIGBgdmlld2BgIGZ1bmN0aW9ucykuXG4gICAgICovXG4gICAgY29uc3RhbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSByZXR1cm5lZCB0eXBlcyBmb3IgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgb3V0cHV0cztcbiAgICAvKipcbiAgICAgKiAgVGhlIHN0YXRlIG11dGFiaWxpdHkgKGUuZy4gYGBwYXlhYmxlYGAsIGBgbm9ucGF5YWJsZWBgLCBgYHZpZXdgYFxuICAgICAqICBvciBgYHB1cmVgYClcbiAgICAgKi9cbiAgICBzdGF0ZU11dGFiaWxpdHk7XG4gICAgLyoqXG4gICAgICogIElmIHRoZSBmdW5jdGlvbiBjYW4gYmUgc2VudCB2YWx1ZSBkdXJpbmcgaW52b2NhdGlvbi5cbiAgICAgKi9cbiAgICBwYXlhYmxlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcmVjb21tZW5kZWQgZ2FzIGxpbWl0IHRvIHNlbmQgd2hlbiBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZ2FzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBzdGF0ZU11dGFiaWxpdHksIGlucHV0cywgb3V0cHV0cywgZ2FzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcImZ1bmN0aW9uXCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRnVuY3Rpb25GcmFnbWVudEludGVybmFsIH0pO1xuICAgICAgICBvdXRwdXRzID0gT2JqZWN0LmZyZWV6ZShvdXRwdXRzLnNsaWNlKCkpO1xuICAgICAgICBjb25zdCBjb25zdGFudCA9IChzdGF0ZU11dGFiaWxpdHkgPT09IFwidmlld1wiIHx8IHN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwdXJlXCIpO1xuICAgICAgICBjb25zdCBwYXlhYmxlID0gKHN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgY29uc3RhbnQsIGdhcywgb3V0cHV0cywgcGF5YWJsZSwgc3RhdGVNdXRhYmlsaXR5IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEZ1bmN0aW9uIHNlbGVjdG9yLlxuICAgICAqL1xuICAgIGdldCBzZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIGlkKHRoaXMuZm9ybWF0KFwic2lnaGFzaFwiKSkuc3Vic3RyaW5nKDAsIDEwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcInNpZ2hhc2hcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGNvbnN0YW50OiB0aGlzLmNvbnN0YW50LFxuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogKCh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpID8gdGhpcy5zdGF0ZU11dGFiaWxpdHkgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIHBheWFibGU6IHRoaXMucGF5YWJsZSxcbiAgICAgICAgICAgICAgICBnYXM6ICgodGhpcy5nYXMgIT0gbnVsbCkgPyB0aGlzLmdhcyA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGkpID0+IEpTT04ucGFyc2UoaS5mb3JtYXQoZm9ybWF0KSkpLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IHRoaXMub3V0cHV0cy5tYXAoKG8pID0+IEpTT04ucGFyc2Uoby5mb3JtYXQoZm9ybWF0KSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcImZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubmFtZSArIGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cykpO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuc3RhdGVNdXRhYmlsaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dHMgJiYgdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwicmV0dXJuc1wiKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5vdXRwdXRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5nYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGBAJHt0aGlzLmdhcy50b1N0cmluZygpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHNlbGVjdG9yIGZvciBhIGZ1bmN0aW9uIHdpdGggJSVuYW1lJSUgYW5kICUlcGFyYW1zJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFNlbGVjdG9yKG5hbWUsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSAocGFyYW1zIHx8IFtdKS5tYXAoKHApID0+IFBhcmFtVHlwZS5mcm9tKHApKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBuZXcgRnVuY3Rpb25GcmFnbWVudChfZ3VhcmQsIG5hbWUsIFwidmlld1wiLCBwYXJhbXMsIFtdLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LnNlbGVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkZ1bmN0aW9uRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKEZ1bmN0aW9uRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGZ1bmN0aW9uIGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcImZ1bmN0aW9uXCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdCBtdXRhYmlsaXR5ID0gY29uc3VtZU11dGFiaWxpdHkob2JqKTtcbiAgICAgICAgICAgIGxldCBvdXRwdXRzID0gW107XG4gICAgICAgICAgICBpZiAoY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcInJldHVybnNcIl0pKS5oYXMoXCJyZXR1cm5zXCIpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGdhcyA9IGNvbnN1bWVHYXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25GcmFnbWVudChfZ3VhcmQsIG5hbWUsIG11dGFiaWxpdHksIGlucHV0cywgb3V0cHV0cywgZ2FzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGVNdXRhYmlsaXR5ID0gb2JqLnN0YXRlTXV0YWJpbGl0eTtcbiAgICAgICAgLy8gVXNlIGxlZ2FjeSBTb2xpZGl0eSBBQkkgbG9naWMgaWYgc3RhdGVNdXRhYmlsaXR5IGlzIG1pc3NpbmdcbiAgICAgICAgaWYgKHN0YXRlTXV0YWJpbGl0eSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInBheWFibGVcIjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG9iai5jb25zdGFudCkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJ2aWV3XCI7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmouY29uc3RhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJwYXlhYmxlXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKG9iai5wYXlhYmxlKSA9PT0gXCJib29sZWFuXCIgJiYgIW9iai5wYXlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcIm5vbnBheWFibGVcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAob2JqLnBheWFibGUpID09PSBcImJvb2xlYW5cIiAmJiAhb2JqLnBheWFibGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcIm5vbnBheWFibGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogdmVyaWZ5U3RhdGUgZm9yIHN0YXRlTXV0YWJpbGl0eSAoZS5nLiB0aHJvdyBpZlxuICAgICAgICAvLyAgICAgICAgcGF5YWJsZTogZmFsc2UgYnV0IHN0YXRlTXV0YWJpbGl0eSBpcyBcIm5vbnBheWFibGVcIilcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIHN0YXRlTXV0YWJpbGl0eSwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdLCBvYmoub3V0cHV0cyA/IG9iai5vdXRwdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSwgKG9iai5nYXMgIT0gbnVsbCkgPyBvYmouZ2FzIDogbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipGdW5jdGlvbkZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgc3RydWN0dXJlLlxuICovXG5leHBvcnQgY2xhc3MgU3RydWN0RnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgaW5wdXRzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcInN0cnVjdFwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IFN0cnVjdEZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc3RydWN0IGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipTdHJ1Y3RGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJ1Y3RGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgc3RydWN0IGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcInN0cnVjdFwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3RGcmFnbWVudChfZ3VhcmQsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3RGcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10pO1xuICAgIH1cbiAgICAvLyBAVE9ETzogZml4IHRoaXMgcmV0dXJuIHR5cGVcbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXG4gICAgICogICoqU3RydWN0RnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gU3RydWN0RnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJhZ21lbnRzLmpzLm1hcCIsIi8qKlxuICogIFdoZW4gc2VuZGluZyB2YWx1ZXMgdG8gb3IgcmVjZWl2aW5nIHZhbHVlcyBmcm9tIGEgW1tDb250cmFjdF1dLCB0aGVcbiAqICBkYXRhIGlzIGdlbmVyYWxseSBlbmNvZGVkIHVzaW5nIHRoZSBbQUJJIHN0YW5kYXJkXShsaW5rLXNvbGMtYWJpKS5cbiAqXG4gKiAgVGhlIEFiaUNvZGVyIHByb3ZpZGVzIGEgdXRpbGl0eSB0byBlbmNvZGUgdmFsdWVzIHRvIEFCSSBkYXRhIGFuZFxuICogIGRlY29kZSB2YWx1ZXMgZnJvbSBBQkkgZGF0YS5cbiAqXG4gKiAgTW9zdCBvZiB0aGUgdGltZSwgZGV2ZWxvcGVycyBzaG91bGQgZmF2b3VyIHRoZSBbW0NvbnRyYWN0XV0gY2xhc3MsXG4gKiAgd2hpY2ggZnVydGhlciBhYnN0cmFjdHMgYSBsb3Qgb2YgdGhlIGZpbmVyIGRldGFpbHMgb2YgQUJJIGRhdGEuXG4gKlxuICogIEBfc2VjdGlvbiBhcGkvYWJpL2FiaS1jb2RlcjpBQkkgRW5jb2RpbmdcbiAqL1xuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0V0aGVyZXVtLUNvbnRyYWN0LUFCSVxuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnRDb3VudCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFJlYWRlciwgV3JpdGVyIH0gZnJvbSBcIi4vY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBBZGRyZXNzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYWRkcmVzcy5qc1wiO1xuaW1wb3J0IHsgQXJyYXlDb2RlciB9IGZyb20gXCIuL2NvZGVycy9hcnJheS5qc1wiO1xuaW1wb3J0IHsgQm9vbGVhbkNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2Jvb2xlYW4uanNcIjtcbmltcG9ydCB7IEJ5dGVzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYnl0ZXMuanNcIjtcbmltcG9ydCB7IEZpeGVkQnl0ZXNDb2RlciB9IGZyb20gXCIuL2NvZGVycy9maXhlZC1ieXRlcy5qc1wiO1xuaW1wb3J0IHsgTnVsbENvZGVyIH0gZnJvbSBcIi4vY29kZXJzL251bGwuanNcIjtcbmltcG9ydCB7IE51bWJlckNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL251bWJlci5qc1wiO1xuaW1wb3J0IHsgU3RyaW5nQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvc3RyaW5nLmpzXCI7XG5pbXBvcnQgeyBUdXBsZUNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL3R1cGxlLmpzXCI7XG5pbXBvcnQgeyBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHMuanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnksIG1ha2VFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLy8gaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xNy9jb250cm9sLXN0cnVjdHVyZXMuaHRtbFxuY29uc3QgUGFuaWNSZWFzb25zID0gbmV3IE1hcCgpO1xuUGFuaWNSZWFzb25zLnNldCgweDAwLCBcIkdFTkVSSUNfUEFOSUNcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MDEsIFwiQVNTRVJUX0ZBTFNFXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDExLCBcIk9WRVJGTE9XXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDEyLCBcIkRJVklERV9CWV9aRVJPXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDIxLCBcIkVOVU1fUkFOR0VfRVJST1JcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MjIsIFwiQkFEX1NUT1JBR0VfREFUQVwiKTtcblBhbmljUmVhc29ucy5zZXQoMHgzMSwgXCJTVEFDS19VTkRFUkZMT1dcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MzIsIFwiQVJSQVlfUkFOR0VfRVJST1JcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4NDEsIFwiT1VUX09GX01FTU9SWVwiKTtcblBhbmljUmVhc29ucy5zZXQoMHg1MSwgXCJVTklOSVRJQUxJWkVEX0ZVTkNUSU9OX0NBTExcIik7XG5jb25zdCBwYXJhbVR5cGVCeXRlcyA9IG5ldyBSZWdFeHAoL15ieXRlcyhbMC05XSopJC8pO1xuY29uc3QgcGFyYW1UeXBlTnVtYmVyID0gbmV3IFJlZ0V4cCgvXih1P2ludCkoWzAtOV0qKSQvKTtcbmxldCBkZWZhdWx0Q29kZXIgPSBudWxsO1xuZnVuY3Rpb24gZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oYWN0aW9uLCB0eCwgZGF0YSwgYWJpQ29kZXIpIHtcbiAgICBsZXQgbWVzc2FnZSA9IFwibWlzc2luZyByZXZlcnQgZGF0YVwiO1xuICAgIGxldCByZWFzb24gPSBudWxsO1xuICAgIGNvbnN0IGludm9jYXRpb24gPSBudWxsO1xuICAgIGxldCByZXZlcnQgPSBudWxsO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcImV4ZWN1dGlvbiByZXZlcnRlZFwiO1xuICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgICAgICBkYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAobm8gZGF0YSBwcmVzZW50OyBsaWtlbHkgcmVxdWlyZShmYWxzZSkgb2NjdXJyZWRcIjtcbiAgICAgICAgICAgIHJlYXNvbiA9IFwicmVxdWlyZShmYWxzZSlcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggJSAzMiAhPT0gNCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSByZWFzb247IGludmFsaWQgZGF0YSBsZW5ndGgpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgPT09IFwiMHgwOGMzNzlhMFwiKSB7XG4gICAgICAgICAgICAvLyBFcnJvcihzdHJpbmcpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlYXNvbiA9IGFiaUNvZGVyLmRlY29kZShbXCJzdHJpbmdcIl0sIGJ5dGVzLnNsaWNlKDQpKVswXTtcbiAgICAgICAgICAgICAgICByZXZlcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJFcnJvcihzdHJpbmcpXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiRXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlYXNvbl1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYDogJHtKU09OLnN0cmluZ2lmeShyZWFzb24pfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIChjb3VsZCBub3QgZGVjb2RlIHJlYXNvbjsgaW52YWxpZCBzdHJpbmcgZGF0YSlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKSA9PT0gXCIweDRlNDg3YjcxXCIpIHtcbiAgICAgICAgICAgIC8vIFBhbmljKHVpbnQyNTYpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBOdW1iZXIoYWJpQ29kZXIuZGVjb2RlKFtcInVpbnQyNTZcIl0sIGJ5dGVzLnNsaWNlKDQpKVswXSk7XG4gICAgICAgICAgICAgICAgcmV2ZXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiUGFuaWModWludDI1NilcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJQYW5pY1wiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbY29kZV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYXNvbiA9IGBQYW5pYyBkdWUgdG8gJHtQYW5pY1JlYXNvbnMuZ2V0KGNvZGUpIHx8IFwiVU5LTk9XTlwifSgke2NvZGV9KWA7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgOiAke3JlYXNvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSBwYW5pYyBjb2RlKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAodW5rbm93biBjdXN0b20gZXJyb3IpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIHRvOiAodHgudG8gPyBnZXRBZGRyZXNzKHR4LnRvKSA6IG51bGwpLFxuICAgICAgICBkYXRhOiAodHguZGF0YSB8fCBcIjB4XCIpXG4gICAgfTtcbiAgICBpZiAodHguZnJvbSkge1xuICAgICAgICB0cmFuc2FjdGlvbi5mcm9tID0gZ2V0QWRkcmVzcyh0eC5mcm9tKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VFcnJvcihtZXNzYWdlLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgYWN0aW9uLCBkYXRhLCByZWFzb24sIHRyYW5zYWN0aW9uLCBpbnZvY2F0aW9uLCByZXZlcnRcbiAgICB9KTtcbn1cbi8qKlxuICogIFRoZSAqKkFiaUNvZGVyKiogaXMgYSBsb3ctbGV2ZWwgY2xhc3MgcmVzcG9uc2libGUgZm9yIGVuY29kaW5nIEphdmFTY3JpcHRcbiAqICB2YWx1ZXMgaW50byBiaW5hcnkgZGF0YSBhbmQgZGVjb2RpbmcgYmluYXJ5IGRhdGEgaW50byBKYXZhU2NyaXB0IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFiaUNvZGVyIHtcbiAgICAjZ2V0Q29kZXIocGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUNvZGVyKHRoaXMuI2dldENvZGVyKHBhcmFtLmFycmF5Q2hpbGRyZW4pLCBwYXJhbS5hcnJheUxlbmd0aCwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZUNvZGVyKHBhcmFtLmNvbXBvbmVudHMubWFwKChjKSA9PiB0aGlzLiNnZXRDb2RlcihjKSksIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocGFyYW0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhbkNvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVzQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOdWxsQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdT9pbnRbMC05XSpcbiAgICAgICAgbGV0IG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVOdW1iZXIpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzaXplICE9PSAwICYmIHNpemUgPD0gMjU2ICYmIChzaXplICUgOCkgPT09IDAsIFwiaW52YWxpZCBcIiArIG1hdGNoWzFdICsgXCIgYml0IGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29kZXIoc2l6ZSAvIDgsIChtYXRjaFsxXSA9PT0gXCJpbnRcIiksIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ5dGVzWzAtOV0rXG4gICAgICAgIG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVCeXRlcyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzaXplICE9PSAwICYmIHNpemUgPD0gMzIsIFwiaW52YWxpZCBieXRlcyBsZW5ndGhcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpeGVkQnl0ZXNDb2RlcihzaXplLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHR5cGVcIiwgXCJ0eXBlXCIsIHBhcmFtLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBkZWZhdWx0IHZhbHVlcyBmb3IgdGhlIGdpdmVuICUldHlwZXMlJS5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgYSBgYHVpbnRgYCBpcyBieSBkZWZhdWx0IGBgMGBgIGFuZCBgYGJvb2xgYFxuICAgICAqICBpcyBieSBkZWZhdWx0IGBgZmFsc2VgYC5cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0VmFsdWUodHlwZXMpIHtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuICAgICAgICByZXR1cm4gY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGUgdGhlICUldmFsdWVzJSUgYXMgdGhlICUldHlwZXMlJSBpbnRvIEFCSSBkYXRhLlxuICAgICAqXG4gICAgICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAgICAgKi9cbiAgICBlbmNvZGUodHlwZXMsIHZhbHVlcykge1xuICAgICAgICBhc3NlcnRBcmd1bWVudENvdW50KHZhbHVlcy5sZW5ndGgsIHR5cGVzLmxlbmd0aCwgXCJ0eXBlcy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoXCIpO1xuICAgICAgICBjb25zdCBjb2RlcnMgPSB0eXBlcy5tYXAoKHR5cGUpID0+IHRoaXMuI2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gKG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpKTtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgICAgICBjb2Rlci5lbmNvZGUod3JpdGVyLCB2YWx1ZXMpO1xuICAgICAgICByZXR1cm4gd3JpdGVyLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGUgdGhlIEFCSSAlJWRhdGElJSBhcyB0aGUgJSV0eXBlcyUlIGludG8gdmFsdWVzLlxuICAgICAqXG4gICAgICogIElmICUlbG9vc2UlJSBkZWNvZGluZyBpcyBlbmFibGVkLCB0aGVuIHN0cmljdCBwYWRkaW5nIGlzXG4gICAgICogIG5vdCBlbmZvcmNlZC4gU29tZSBvbGRlciB2ZXJzaW9ucyBvZiBTb2xpZGl0eSBpbmNvcnJlY3RseVxuICAgICAqICBwYWRkZWQgZXZlbnQgZGF0YSBlbWl0dGVkIGZyb20gYGBleHRlcm5hbGBgIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBkZWNvZGUodHlwZXMsIGRhdGEsIGxvb3NlKSB7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSBuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKTtcbiAgICAgICAgcmV0dXJuIGNvZGVyLmRlY29kZShuZXcgUmVhZGVyKGRhdGEsIGxvb3NlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBzaGFyZWQgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgZGVmYXVsdCBbW0FiaUNvZGVyXV0uXG4gICAgICpcbiAgICAgKiAgT24gdGhlIGZpcnN0IGNhbGwsIHRoZSBpbnN0YW5jZSBpcyBjcmVhdGVkIGludGVybmFsbHkuXG4gICAgICovXG4gICAgc3RhdGljIGRlZmF1bHRBYmlDb2RlcigpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDb2RlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0Q29kZXIgPSBuZXcgQWJpQ29kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdENvZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhbiBldGhlcnMtY29tcGF0aWJsZSBbW0NhbGxFeGNlcHRpb25FcnJvcl1dIEVycm9yIGZvciB0aGUgZ2l2ZW5cbiAgICAgKiAgcmVzdWx0ICUlZGF0YSUlIGZvciB0aGUgW1tDYWxsRXhjZXB0aW9uQWN0aW9uXV0gJSVhY3Rpb24lJSBhZ2FpbnN0XG4gICAgICogIHRoZSBUcmFuc2FjdGlvbiAlJXR4JSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEsIEFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmktY29kZXIuanMubWFwIiwiLyoqXG4gKiAgVGhlIEludGVyZmFjZSBjbGFzcyBpcyBhIGxvdy1sZXZlbCBjbGFzcyB0aGF0IGFjY2VwdHMgYW5cbiAqICBBQkkgYW5kIHByb3ZpZGVzIGFsbCB0aGUgbmVjZXNzYXJ5IGZ1bmN0aW9uYWxpdHkgdG8gZW5jb2RlXG4gKiAgYW5kIGRlY29kZSBwYXJhbWF0ZXJzIHRvIGFuZCByZXN1bHRzIGZyb20gbWV0aG9kcywgZXZlbnRzXG4gKiAgYW5kIGVycm9ycy5cbiAqXG4gKiAgSXQgYWxzbyBwcm92aWRlcyBzZXZlcmFsIGNvbnZlbmllbmNlIG1ldGhvZHMgdG8gYXV0b21hdGljYWxseVxuICogIHNlYXJjaCBhbmQgZmluZCBtYXRjaGluZyB0cmFuc2FjdGlvbnMgYW5kIGV2ZW50cyB0byBwYXJzZSB0aGVtLlxuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL2FiaTpJbnRlcmZhY2VzICBbaW50ZXJmYWNlc11cbiAqL1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaWQgfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhU2xpY2UsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGdldEJ5dGVzQ29weSwgaGV4bGlmeSwgemVyb1BhZEJ5dGVzLCB6ZXJvUGFkVmFsdWUsIGlzSGV4U3RyaW5nLCBkZWZpbmVQcm9wZXJ0aWVzLCBhc3NlcnRBcmd1bWVudCwgdG9CZUhleCwgYXNzZXJ0IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBBYmlDb2RlciB9IGZyb20gXCIuL2FiaS1jb2Rlci5qc1wiO1xuaW1wb3J0IHsgY2hlY2tSZXN1bHRFcnJvcnMsIFJlc3VsdCB9IGZyb20gXCIuL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuaW1wb3J0IHsgQ29uc3RydWN0b3JGcmFnbWVudCwgRXJyb3JGcmFnbWVudCwgRXZlbnRGcmFnbWVudCwgRnJhZ21lbnQsIEZ1bmN0aW9uRnJhZ21lbnQsIFBhcmFtVHlwZSB9IGZyb20gXCIuL2ZyYWdtZW50cy5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi90eXBlZC5qc1wiO1xuZXhwb3J0IHsgY2hlY2tSZXN1bHRFcnJvcnMsIFJlc3VsdCB9O1xuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VMb2ddXSB0byBhdXRvbWF0aWNhbGx5IG1hdGNoIGEgTG9nIHRvIGl0cyBldmVudFxuICogIGZvciBwYXJzaW5nLCBhICoqTG9nRGVzY3JpcHRpb24qKiBpcyByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIExvZ0Rlc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50IGZvciB0aGUgYGB0b3BpYzBgYC5cbiAgICAgKi9cbiAgICBmcmFnbWVudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIEV2ZW50LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxsIEV2ZW50IHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBzaWduYXR1cmU7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3BpYyBoYXNoIGZvciB0aGUgRXZlbnQuXG4gICAgICovXG4gICAgdG9waWM7XG4gICAgLyoqXG4gICAgICogIFRoZSBhcmd1bWVudHMgcGFzc2VkIGludG8gdGhlIEV2ZW50IHdpdGggYGBlbWl0YGAuXG4gICAgICovXG4gICAgYXJncztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIHRvcGljLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgc2lnbmF0dXJlLCB0b3BpYywgYXJnc1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqICBXaGVuIHVzaW5nIHRoZSBbW0ludGVyZmFjZS1wYXJzZVRyYW5zYWN0aW9uXV0gdG8gYXV0b21hdGljYWxseSBtYXRjaFxuICogIGEgdHJhbnNhY3Rpb24gZGF0YSB0byBpdHMgZnVuY3Rpb24gZm9yIHBhcnNpbmcsXG4gKiAgYSAqKlRyYW5zYWN0aW9uRGVzY3JpcHRpb24qKiBpcyByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uRGVzY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZnJhZ21lbnQgZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBGdW5jdGlvbiBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgRnVuY3Rpb24gZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgYXJncztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZ1bGwgRnVuY3Rpb24gc2lnbmF0dXJlIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIHNpZ25hdHVyZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbGVjdG9yIGZvciB0aGUgRnVuY3Rpb24gZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgc2VsZWN0b3I7XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHZhbHVlYGAgKGluIHdlaSkgZnJvbSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgdmFsdWU7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50LCBzZWxlY3RvciwgYXJncywgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGZyYWdtZW50LCBuYW1lLCBhcmdzLCBzaWduYXR1cmUsIHNlbGVjdG9yLCB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqICBXaGVuIHVzaW5nIHRoZSBbW0ludGVyZmFjZS1wYXJzZUVycm9yXV0gdG8gYXV0b21hdGljYWxseSBtYXRjaCBhblxuICogIGVycm9yIGZvciBhIGNhbGwgcmVzdWx0IGZvciBwYXJzaW5nLCBhbiAqKkVycm9yRGVzY3JpcHRpb24qKiBpcyByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEVycm9yRGVzY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBFcnJvci5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgRXJyb3Igd2l0aCBgYHJldmVydGBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxsIEVycm9yIHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBzaWduYXR1cmU7XG4gICAgLyoqXG4gICAgICogIFRoZSBzZWxlY3RvciBmb3IgdGhlIEVycm9yLlxuICAgICAqL1xuICAgIHNlbGVjdG9yO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgc2VsZWN0b3IsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGZyYWdtZW50LCBuYW1lLCBhcmdzLCBzaWduYXR1cmUsIHNlbGVjdG9yXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIEFuICoqSW5kZXhlZCoqIGlzIHVzZWQgYXMgYSB2YWx1ZSB3aGVuIGEgdmFsdWUgdGhhdCBkb2VzIG5vdFxuICogIGZpdCB3aXRoaW4gYSB0b3BpYyAoaS5lLiBub3QgYSBmaXhlZC1sZW5ndGgsIDMyLWJ5dGUgdHlwZSkuIEl0XG4gKiAgaXMgdGhlIGBga2VjY2FrMjU2YGAgb2YgdGhlIHZhbHVlLCBhbmQgdXNlZCBmb3IgdHlwZXMgc3VjaCBhc1xuICogIGFycmF5cywgdHVwbGVzLCBieXRlcyBhbmQgc3RyaW5ncy5cbiAqL1xuZXhwb3J0IGNsYXNzIEluZGV4ZWQge1xuICAgIC8qKlxuICAgICAqICBUaGUgYGBrZWNjYWsyNTZgYCBvZiB0aGUgdmFsdWUgbG9nZ2VkLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIF9pc0luZGV4ZWQ7XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgaWYgJSV2YWx1ZSUlIGlzIGFuICoqSW5kZXhlZCoqLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIGZvciBwcm9wZXJ0eSBhY2Nlc3MuXG4gICAgICovXG4gICAgc3RhdGljIGlzSW5kZXhlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzSW5kZXhlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihoYXNoKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBoYXNoLCBfaXNJbmRleGVkOiB0cnVlIH0pO1xuICAgIH1cbn1cbi8vIGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL3YwLjguMTMvY29udHJvbC1zdHJ1Y3R1cmVzLmh0bWw/aGlnaGxpZ2h0PXBhbmljI3BhbmljLXZpYS1hc3NlcnQtYW5kLWVycm9yLXZpYS1yZXF1aXJlXG5jb25zdCBQYW5pY1JlYXNvbnMgPSB7XG4gICAgXCIwXCI6IFwiZ2VuZXJpYyBwYW5pY1wiLFxuICAgIFwiMVwiOiBcImFzc2VydChmYWxzZSlcIixcbiAgICBcIjE3XCI6IFwiYXJpdGhtZXRpYyBvdmVyZmxvd1wiLFxuICAgIFwiMThcIjogXCJkaXZpc2lvbiBvciBtb2R1bG8gYnkgemVyb1wiLFxuICAgIFwiMzNcIjogXCJlbnVtIG92ZXJmbG93XCIsXG4gICAgXCIzNFwiOiBcImludmFsaWQgZW5jb2RlZCBzdG9yYWdlIGJ5dGUgYXJyYXkgYWNjZXNzZWRcIixcbiAgICBcIjQ5XCI6IFwib3V0LW9mLWJvdW5kcyBhcnJheSBhY2Nlc3M7IHBvcHBpbmcgb24gYW4gZW1wdHkgYXJyYXlcIixcbiAgICBcIjUwXCI6IFwib3V0LW9mLWJvdW5kcyBhY2Nlc3Mgb2YgYW4gYXJyYXkgb3IgYnl0ZXNOXCIsXG4gICAgXCI2NVwiOiBcIm91dCBvZiBtZW1vcnlcIixcbiAgICBcIjgxXCI6IFwidW5pbml0aWFsaXplZCBmdW5jdGlvblwiLFxufTtcbmNvbnN0IEJ1aWx0aW5FcnJvcnMgPSB7XG4gICAgXCIweDA4YzM3OWEwXCI6IHtcbiAgICAgICAgc2lnbmF0dXJlOiBcIkVycm9yKHN0cmluZylcIixcbiAgICAgICAgbmFtZTogXCJFcnJvclwiLFxuICAgICAgICBpbnB1dHM6IFtcInN0cmluZ1wiXSxcbiAgICAgICAgcmVhc29uOiAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGByZXZlcnRlZCB3aXRoIHJlYXNvbiBzdHJpbmcgJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlKX1gO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcIjB4NGU0ODdiNzFcIjoge1xuICAgICAgICBzaWduYXR1cmU6IFwiUGFuaWModWludDI1NilcIixcbiAgICAgICAgbmFtZTogXCJQYW5pY1wiLFxuICAgICAgICBpbnB1dHM6IFtcInVpbnQyNTZcIl0sXG4gICAgICAgIHJlYXNvbjogKGNvZGUpID0+IHtcbiAgICAgICAgICAgIGxldCByZWFzb24gPSBcInVua25vd24gcGFuaWMgY29kZVwiO1xuICAgICAgICAgICAgaWYgKGNvZGUgPj0gMCAmJiBjb2RlIDw9IDB4ZmYgJiYgUGFuaWNSZWFzb25zW2NvZGUudG9TdHJpbmcoKV0pIHtcbiAgICAgICAgICAgICAgICByZWFzb24gPSBQYW5pY1JlYXNvbnNbY29kZS50b1N0cmluZygpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgcmV2ZXJ0ZWQgd2l0aCBwYW5pYyBjb2RlIDB4JHtjb2RlLnRvU3RyaW5nKDE2KX0gKCR7cmVhc29ufSlgO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogIEFuIEludGVyZmFjZSBhYnN0cmFjdHMgbWFueSBvZiB0aGUgbG93LWxldmVsIGRldGFpbHMgZm9yXG4gKiAgZW5jb2RpbmcgYW5kIGRlY29kaW5nIHRoZSBkYXRhIG9uIHRoZSBibG9ja2NoYWluLlxuICpcbiAqICBBbiBBQkkgcHJvdmlkZXMgaW5mb3JtYXRpb24gb24gaG93IHRvIGVuY29kZSBkYXRhIHRvIHNlbmQgdG9cbiAqICBhIENvbnRyYWN0LCBob3cgdG8gZGVjb2RlIHRoZSByZXN1bHRzIGFuZCBldmVudHMgYW5kIGhvdyB0b1xuICogIGludGVycHJldCByZXZlcnQgZXJyb3JzLlxuICpcbiAqICBUaGUgQUJJIGNhbiBiZSBzcGVjaWZpZWQgYnkgW2FueSBzdXBwb3J0ZWQgZm9ybWF0XShJbnRlcmZhY2VBYmkpLlxuICovXG5leHBvcnQgY2xhc3MgSW50ZXJmYWNlIHtcbiAgICAvKipcbiAgICAgKiAgQWxsIHRoZSBDb250cmFjdCBBQkkgbWVtYmVycyAoaS5lLiBtZXRob2RzLCBldmVudHMsIGVycm9ycywgZXRjKS5cbiAgICAgKi9cbiAgICBmcmFnbWVudHM7XG4gICAgLyoqXG4gICAgICogIFRoZSBDb250cmFjdCBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBkZXBsb3k7XG4gICAgLyoqXG4gICAgICogIFRoZSBGYWxsYmFjayBtZXRob2QsIGlmIGFueS5cbiAgICAgKi9cbiAgICBmYWxsYmFjaztcbiAgICAvKipcbiAgICAgKiAgSWYgcmVjZWl2aW5nIGV0aGVyIGlzIHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICByZWNlaXZlO1xuICAgICNlcnJvcnM7XG4gICAgI2V2ZW50cztcbiAgICAjZnVuY3Rpb25zO1xuICAgIC8vICAgICNzdHJ1Y3RzOiBNYXA8c3RyaW5nLCBTdHJ1Y3RGcmFnbWVudD47XG4gICAgI2FiaUNvZGVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgSW50ZXJmYWNlIGZvciB0aGUgJSVmcmFnbWVudHMlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMpIHtcbiAgICAgICAgbGV0IGFiaSA9IFtdO1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudHMpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBhYmkgPSBKU09OLnBhcnNlKGZyYWdtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhYmkgPSBmcmFnbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZnVuY3Rpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNlcnJvcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2V2ZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gICAgICAgIHRoaXMuI3N0cnVjdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGZyYWdzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgYSBvZiBhYmkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnJhZ3MucHVzaChGcmFnbWVudC5mcm9tKGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRUVcIiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZnJhZ21lbnRzOiBPYmplY3QuZnJlZXplKGZyYWdzKVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgbGV0IHJlY2VpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jYWJpQ29kZXIgPSB0aGlzLmdldEFiaUNvZGVyKCk7XG4gICAgICAgIC8vIEFkZCBhbGwgZnJhZ21lbnRzIGJ5IHRoZWlyIHNpZ25hdHVyZVxuICAgICAgICB0aGlzLmZyYWdtZW50cy5mb3JFYWNoKChmcmFnbWVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBidWNrZXQ7XG4gICAgICAgICAgICBzd2l0Y2ggKGZyYWdtZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVwbG95KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImR1cGxpY2F0ZSBkZWZpbml0aW9uIC0gY29uc3RydWN0b3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBkZXBsb3k6IGZyYWdtZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KCFmYWxsYmFjayB8fCBmcmFnbWVudC5wYXlhYmxlICE9PSBmYWxsYmFjay5wYXlhYmxlLCBcImNvbmZsaWN0aW5nIGZhbGxiYWNrIGZyYWdtZW50c1wiLCBgZnJhZ21lbnRzWyR7aW5kZXh9XWAsIGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrID0gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlID0gZmFsbGJhY2sucGF5YWJsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwib3V0cHV0XCIsICg8RnVuY3Rpb25GcmFnbWVudD5mcmFnbWVudCkub3V0cHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2Z1bmN0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSB0aGlzLiNldmVudHM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSB0aGlzLiNlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFR3byBpZGVudGljYWwgZW50cmllczsgaWdub3JlIGl0XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgICAgIGlmIChidWNrZXQuaGFzKHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWNrZXQuc2V0KHNpZ25hdHVyZSwgZnJhZ21lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgd2UgZG8gbm90IGhhdmUgYSBjb25zdHJ1Y3RvciBhZGQgYSBkZWZhdWx0XG4gICAgICAgIGlmICghdGhpcy5kZXBsb3kpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgICAgIGRlcGxveTogQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKFwiY29uc3RydWN0b3IoKVwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGZhbGxiYWNrLCByZWNlaXZlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgZW50aXJlIEh1bWFuLVJlYWRhYmxlIEFCSSwgYXMgYW4gYXJyYXkgb2ZcbiAgICAgKiAgc2lnbmF0dXJlcywgb3B0aW9uYWxseSBhcyAlJW1pbmltYWwlJSBzdHJpbmdzLCB3aGljaFxuICAgICAqICByZW1vdmVzIHBhcmFtZXRlciBuYW1lcyBhbmQgdW5uZWNlZXNhcnkgc3BhY2VzLlxuICAgICAqL1xuICAgIGZvcm1hdChtaW5pbWFsKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IChtaW5pbWFsID8gXCJtaW5pbWFsXCIgOiBcImZ1bGxcIik7XG4gICAgICAgIGNvbnN0IGFiaSA9IHRoaXMuZnJhZ21lbnRzLm1hcCgoZikgPT4gZi5mb3JtYXQoZm9ybWF0KSk7XG4gICAgICAgIHJldHVybiBhYmk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIEpTT04tZW5jb2RlZCBBQkkuIFRoaXMgaXMgdGhlIGZvcm1hdCBTb2xpZGl5XG4gICAgICogIHJldHVybnMuXG4gICAgICovXG4gICAgZm9ybWF0SnNvbigpIHtcbiAgICAgICAgY29uc3QgYWJpID0gdGhpcy5mcmFnbWVudHMubWFwKChmKSA9PiBmLmZvcm1hdChcImpzb25cIikpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlLWJ1bmRsZSB0aGUgSlNPTiBmcmFnbWVudHMgYSBiaXRcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFiaS5tYXAoKGopID0+IEpTT04ucGFyc2UoaikpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBBQkkgY29kZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZW5jb2RlIGFuZCBkZWNvZGUgYmluYXJ5XG4gICAgICogIGRhdGEuXG4gICAgICovXG4gICAgZ2V0QWJpQ29kZXIoKSB7XG4gICAgICAgIHJldHVybiBBYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXIoKTtcbiAgICB9XG4gICAgLy8gRmluZCBhIGZ1bmN0aW9uIGRlZmluaXRpb24gYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAodW5sZXNzIGl0IGlzIGFtYmlndW91cylcbiAgICAjZ2V0RnVuY3Rpb24oa2V5LCB2YWx1ZXMsIGZvcmNlVW5pcXVlKSB7XG4gICAgICAgIC8vIFNlbGVjdG9yXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmcmFnbWVudCBvZiB0aGlzLiNmdW5jdGlvbnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09IGZyYWdtZW50LnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGZyYWdtZW50XSBvZiB0aGlzLiNmdW5jdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFZhbHVlID0gKHZhbHVlcy5sZW5ndGggPiAwKSA/IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZUxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGFsbG93T3B0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKFR5cGVkLmlzVHlwZWQobGFzdFZhbHVlKSAmJiBsYXN0VmFsdWUudHlwZSA9PT0gXCJvdmVycmlkZXNcIikge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd09wdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVMZW5ndGgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGVzIHRoYXQgZG9uJ3QgaGF2ZSBhIGNvbXBhdGlibGUgbGVuZ3RoLiBUaGUgYXJnc1xuICAgICAgICAgICAgICAgIC8vIG1heSBjb250YWluIGFuIG92ZXJyaWRlcywgc28gdGhlIG1hdGNoIG1heSBoYXZlIG4gb3IgbiAtIDEgcGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBtYXRjaGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBtYXRjaGluZ1tpXS5pbnB1dHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRzICE9PSB2YWx1ZUxlbmd0aCAmJiAoIWFsbG93T3B0aW9ucyB8fCBpbnB1dHMgIT09IHZhbHVlTGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBtYXRjaCB0aGUgVHlwZWQgc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IG1hdGNoaW5nW2ldLmlucHV0cztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhIHR5cGVkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVR5cGVkLmlzVHlwZWQodmFsdWVzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIHBhc3QgdGhlIGlucHV0c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPj0gaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbal0udHlwZSA9PT0gXCJvdmVycmlkZXNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB2YWx1ZSB0eXBlIG1hdGNoZXMgdGhlIGlucHV0IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbal0udHlwZSAhPT0gaW5wdXRzW2pdLmJhc2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBzaW5nbGUgbWF0Y2hpbmcgc2lnbmF0dXJlIHdpdGggYW4gb3ZlcnJpZGVzLCBidXQgdGhlXG4gICAgICAgICAgICAvLyBsYXN0IHZhbHVlIGlzIHNvbWV0aGluZyB0aGF0IGNhbm5vdCBwb3NzaWJseSBiZSBhbiBvcHRpb25zXG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAxICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoICE9PSBtYXRjaGluZ1swXS5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdEFyZyA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RBcmcgPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGxhc3RBcmcpIHx8IHR5cGVvZiAobGFzdEFyZykgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKDAsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPiAxICYmIGZvcmNlVW5pcXVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hTdHIgPSBtYXRjaGluZy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0uZm9ybWF0KCkpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBhbWJpZ3VvdXMgZnVuY3Rpb24gZGVzY3JpcHRpb24gKGkuZS4gbWF0Y2hlcyAke21hdGNoU3RyfSlgLCBcImtleVwiLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2Z1bmN0aW9ucy5nZXQoRnVuY3Rpb25GcmFnbWVudC5mcm9tKGtleSkuZm9ybWF0KCkpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBmdW5jdGlvbiBuYW1lIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSBmdW5jdGlvbiBzZWxlY3RvcixcbiAgICAgKiAgZnVuY3Rpb24gbmFtZSBvciBmdW5jdGlvbiBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICovXG4gICAgZ2V0RnVuY3Rpb25OYW1lKGtleSkge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuI2dldEZ1bmN0aW9uKGtleSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcImtleVwiLCBrZXkpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJWtleSUlIChhIGZ1bmN0aW9uIHNlbGVjdG9yLCBmdW5jdGlvbiBuYW1lIG9yXG4gICAgICogIGZ1bmN0aW9uIHNpZ25hdHVyZSkgaXMgcHJlc2VudCBpbiB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIEluIHRoZSBjYXNlIG9mIGEgZnVuY3Rpb24gbmFtZSwgdGhlIG5hbWUgbWF5IGJlIGFtYmlndW91cywgc29cbiAgICAgKiAgYWNjZXNzaW5nIHRoZSBbW0Z1bmN0aW9uRnJhZ21lbnRdXSBtYXkgcmVxdWlyZSByZWZpbmVtZW50LlxuICAgICAqL1xuICAgIGhhc0Z1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiNnZXRGdW5jdGlvbihrZXksIG51bGwsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgW1tGdW5jdGlvbkZyYWdtZW50XV0gZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIGZ1bmN0aW9uXG4gICAgICogIHNlbGVjdG9yLCBmdW5jdGlvbiBuYW1lIG9yIGZ1bmN0aW9uIHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJZiAlJXZhbHVlcyUlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHVzZSB0aGUgVHlwZWQgQVBJIHRvIGhhbmRsZVxuICAgICAqICBhbWJpZ3VvdXMgY2FzZXMgd2hlcmUgbXVsdGlwbGUgZnVuY3Rpb25zIG1hdGNoIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUla2V5JSUgYW5kICUldmFsdWVzJSUgZG8gbm90IHJlZmluZSB0byBhIHNpbmdsZSBmdW5jdGlvbiBpblxuICAgICAqICB0aGUgQUJJLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0RnVuY3Rpb24oa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldEZ1bmN0aW9uKGtleSwgdmFsdWVzIHx8IG51bGwsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSXRlcmF0ZSBvdmVyIGFsbCBmdW5jdGlvbnMsIGNhbGxpbmcgJSVjYWxsYmFjayUlLCBzb3J0ZWQgYnkgdGhlaXIgbmFtZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoRnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuI2Z1bmN0aW9ucy5rZXlzKCkpO1xuICAgICAgICBuYW1lcy5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBjYWxsYmFjaygodGhpcy4jZnVuY3Rpb25zLmdldChuYW1lKSksIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZpbmQgYW4gZXZlbnQgZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxuICAgICNnZXRFdmVudChrZXksIHZhbHVlcywgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgLy8gRXZlbnRUb3BpY1xuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUb3BpYyA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmcmFnbWVudCBvZiB0aGlzLiNldmVudHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRUb3BpYyA9PT0gZnJhZ21lbnQudG9waWNIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGZyYWdtZW50XSBvZiB0aGlzLiNldmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGVzIHRoYXQgZG9uJ3QgaGF2ZSBhIGNvbXBhdGlibGUgbGVuZ3RoLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBtYXRjaGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmdbaV0uaW5wdXRzLmxlbmd0aCA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBtYXRjaCB0aGUgVHlwZWQgc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IG1hdGNoaW5nW2ldLmlucHV0cztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhIHR5cGVkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVR5cGVkLmlzVHlwZWQodmFsdWVzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB2YWx1ZSB0eXBlIG1hdGNoZXMgdGhlIGlucHV0IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbal0udHlwZSAhPT0gaW5wdXRzW2pdLmJhc2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEgJiYgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFN0ciA9IG1hdGNoaW5nLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobS5mb3JtYXQoKSkpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGFtYmlndW91cyBldmVudCBkZXNjcmlwdGlvbiAoaS5lLiBtYXRjaGVzICR7bWF0Y2hTdHJ9KWAsIFwia2V5XCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZXZlbnRzLmdldChFdmVudEZyYWdtZW50LmZyb20oa2V5KS5mb3JtYXQoKSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGV2ZW50IG5hbWUgZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIHRvcGljIGhhc2gsXG4gICAgICogIGV2ZW50IG5hbWUgb3IgZXZlbnQgc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqL1xuICAgIGdldEV2ZW50TmFtZShrZXkpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLiNnZXRFdmVudChrZXksIG51bGwsIGZhbHNlKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZXZlbnRcIiwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50Lm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVrZXklJSAoYW4gZXZlbnQgdG9waWMgaGFzaCwgZXZlbnQgbmFtZSBvclxuICAgICAqICBldmVudCBzaWduYXR1cmUpIGlzIHByZXNlbnQgaW4gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJbiB0aGUgY2FzZSBvZiBhbiBldmVudCBuYW1lLCB0aGUgbmFtZSBtYXkgYmUgYW1iaWd1b3VzLCBzb1xuICAgICAqICBhY2Nlc3NpbmcgdGhlIFtbRXZlbnRGcmFnbWVudF1dIG1heSByZXF1aXJlIHJlZmluZW1lbnQuXG4gICAgICovXG4gICAgaGFzRXZlbnQoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuI2dldEV2ZW50KGtleSwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBbW0V2ZW50RnJhZ21lbnRdXSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgdG9waWMgaGFzaCxcbiAgICAgKiAgZXZlbnQgbmFtZSBvciBldmVudCBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSWYgJSV2YWx1ZXMlJSBpcyBwcm92aWRlZCwgaXQgd2lsbCB1c2UgdGhlIFR5cGVkIEFQSSB0byBoYW5kbGVcbiAgICAgKiAgYW1iaWd1b3VzIGNhc2VzIHdoZXJlIG11bHRpcGxlIGV2ZW50cyBtYXRjaCBieSBuYW1lLlxuICAgICAqXG4gICAgICogIElmIHRoZSAlJWtleSUlIGFuZCAlJXZhbHVlcyUlIGRvIG5vdCByZWZpbmUgdG8gYSBzaW5nbGUgZXZlbnQgaW5cbiAgICAgKiAgdGhlIEFCSSwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIGdldEV2ZW50KGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnZXRFdmVudChrZXksIHZhbHVlcyB8fCBudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEl0ZXJhdGUgb3ZlciBhbGwgZXZlbnRzLCBjYWxsaW5nICUlY2FsbGJhY2slJSwgc29ydGVkIGJ5IHRoZWlyIG5hbWUuXG4gICAgICovXG4gICAgZm9yRWFjaEV2ZW50KGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gQXJyYXkuZnJvbSh0aGlzLiNldmVudHMua2V5cygpKTtcbiAgICAgICAgbmFtZXMuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgY2FsbGJhY2soKHRoaXMuI2V2ZW50cy5nZXQobmFtZSkpLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBbW0Vycm9yRnJhZ21lbnRdXSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGFuIGVycm9yXG4gICAgICogIHNlbGVjdG9yLCBlcnJvciBuYW1lIG9yIGVycm9yIHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJZiAlJXZhbHVlcyUlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHVzZSB0aGUgVHlwZWQgQVBJIHRvIGhhbmRsZVxuICAgICAqICBhbWJpZ3VvdXMgY2FzZXMgd2hlcmUgbXVsdGlwbGUgZXJyb3JzIG1hdGNoIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUla2V5JSUgYW5kICUldmFsdWVzJSUgZG8gbm90IHJlZmluZSB0byBhIHNpbmdsZSBlcnJvciBpblxuICAgICAqICB0aGUgQUJJLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0RXJyb3Ioa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoQnVpbHRpbkVycm9yc1tzZWxlY3Rvcl0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKEJ1aWx0aW5FcnJvcnNbc2VsZWN0b3JdLnNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2Vycm9ycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gZnJhZ21lbnQuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2Vycm9ycykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIkVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShcImVycm9yIEVycm9yKHN0cmluZylcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiUGFuaWNcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgUGFuaWModWludDI1NilcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoU3RyID0gbWF0Y2hpbmcubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtLmZvcm1hdCgpKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgYW1iaWd1b3VzIGVycm9yIGRlc2NyaXB0aW9uIChpLmUuICR7bWF0Y2hTdHJ9KWAsIFwibmFtZVwiLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGtleSA9IEVycm9yRnJhZ21lbnQuZnJvbShrZXkpLmZvcm1hdCgpO1xuICAgICAgICBpZiAoa2V5ID09PSBcIkVycm9yKHN0cmluZylcIikge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShcImVycm9yIEVycm9yKHN0cmluZylcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSA9PT0gXCJQYW5pYyh1aW50MjU2KVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgUGFuaWModWludDI1NilcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZXJyb3JzLmdldChrZXkpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSXRlcmF0ZSBvdmVyIGFsbCBlcnJvcnMsIGNhbGxpbmcgJSVjYWxsYmFjayUlLCBzb3J0ZWQgYnkgdGhlaXIgbmFtZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoRXJyb3IoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuI2Vycm9ycy5rZXlzKCkpO1xuICAgICAgICBuYW1lcy5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBjYWxsYmFjaygodGhpcy4jZXJyb3JzLmdldChuYW1lKSksIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEdldCB0aGUgNC1ieXRlIHNlbGVjdG9yIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYSBmdW5jdGlvblxuICAgIC8qXG5nZXRTZWxlY3RvcihmcmFnbWVudDogRXJyb3JGcmFnbWVudCB8IEZ1bmN0aW9uRnJhZ21lbnQpOiBzdHJpbmcge1xuICAgIGlmICh0eXBlb2YoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXM6IEFycmF5PEZyYWdtZW50PiA9IFsgXTtcblxuICAgICAgICB0cnkgeyBtYXRjaGVzLnB1c2godGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCkpOyB9IGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHRyeSB7IG1hdGNoZXMucHVzaCh0aGlzLmdldEVycm9yKDxzdHJpbmc+ZnJhZ21lbnQpKTsgfSBjYXRjaCAoXykgeyB9XG5cbiAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5rbm93biBmcmFnbWVudFwiLCBcImtleVwiLCBmcmFnbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYW1iaWd1b3VzIGZyYWdtZW50IG1hdGNoZXMgZnVuY3Rpb24gYW5kIGVycm9yXCIsIFwia2V5XCIsIGZyYWdtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYWdtZW50ID0gbWF0Y2hlc1swXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVNsaWNlKGlkKGZyYWdtZW50LmZvcm1hdCgpKSwgMCwgNCk7XG59XG4gICAgKi9cbiAgICAvLyBHZXQgdGhlIDMyLWJ5dGUgdG9waWMgaGFzaCB1c2VkIGJ5IFNvbGlkaXR5IHRvIGlkZW50aWZ5IGFuIGV2ZW50XG4gICAgLypcbiAgICBnZXRFdmVudFRvcGljKGZyYWdtZW50OiBFdmVudEZyYWdtZW50KTogc3RyaW5nIHtcbiAgICAgICAgLy9pZiAodHlwZW9mKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikgeyBmcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCk7IH1cbiAgICAgICAgcmV0dXJuIGlkKGZyYWdtZW50LmZvcm1hdCgpKTtcbiAgICB9XG4gICAgKi9cbiAgICBfZGVjb2RlUGFyYW1zKHBhcmFtcywgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKHBhcmFtcywgZGF0YSk7XG4gICAgfVxuICAgIF9lbmNvZGVQYXJhbXMocGFyYW1zLCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2FiaUNvZGVyLmVuY29kZShwYXJhbXMsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGVzIGEgYGB0eC5kYXRhYGAgb2JqZWN0IGZvciBkZXBsb3lpbmcgdGhlIENvbnRyYWN0IHdpdGhcbiAgICAgKiAgdGhlICUldmFsdWVzJSUgYXMgdGhlIGNvbnN0cnVjdG9yIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBlbmNvZGVEZXBsb3kodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGVQYXJhbXModGhpcy5kZXBsb3kuaW5wdXRzLCB2YWx1ZXMgfHwgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRGVjb2RlcyB0aGUgcmVzdWx0ICUlZGF0YSUlIChlLmcuIGZyb20gYW4gYGBldGhfY2FsbGBgKSBmb3IgdGhlXG4gICAgICogIHNwZWNpZmllZCBlcnJvciAoc2VlIFtbZ2V0RXJyb3JdXSBmb3IgdmFsaWQgdmFsdWVzIGZvclxuICAgICAqICAlJWtleSUlKS5cbiAgICAgKlxuICAgICAqICBNb3N0IGRldmVsb3BlcnMgc2hvdWxkIHByZWZlciB0aGUgW1twYXJzZUNhbGxSZXN1bHRdXSBtZXRob2QgaW5zdGVhZCxcbiAgICAgKiAgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVjdCBhIGBgQ0FMTF9FWENFUFRJT05gYCBhbmQgdGhyb3cgdGhlXG4gICAgICogIGNvcnJlc3BvbmRpbmcgZXJyb3IuXG4gICAgICovXG4gICAgZGVjb2RlRXJyb3JSZXN1bHQoZnJhZ21lbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXJyb3JcIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YVNsaWNlKGRhdGEsIDAsIDQpID09PSBmcmFnbWVudC5zZWxlY3RvciwgYGRhdGEgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGVycm9yICR7ZnJhZ21lbnQubmFtZX0uYCwgXCJkYXRhXCIsIGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgZGF0YVNsaWNlKGRhdGEsIDQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgdGhlIHRyYW5zYWN0aW9uIHJldmVydCBkYXRhIGZvciBhIGNhbGwgcmVzdWx0IHRoYXRcbiAgICAgKiAgcmV2ZXJ0ZWQgZnJvbSB0aGUgdGhlIENvbnRyYWN0IHdpdGggdGhlIHNlcGNpZmllZCAlJWVycm9yJSVcbiAgICAgKiAgKHNlZSBbW2dldEVycm9yXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3IgJSVmcmFnbWVudCUlKSB3aXRoIHRoZSAlJXZhbHVlcyUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VkIGJ5IG1vc3QgZGV2ZWxvcGVycywgdW5sZXNzIHRyeWluZyB0byBtb2NrXG4gICAgICogIGEgcmVzdWx0IGZyb20gYSBDb250cmFjdC5cbiAgICAgKi9cbiAgICBlbmNvZGVFcnJvclJlc3VsdChmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXJyb3IoZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGVycm9yXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICAgICAgZnJhZ21lbnQuc2VsZWN0b3IsXG4gICAgICAgICAgICB0aGlzLl9lbmNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCB2YWx1ZXMgfHwgW10pXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRGVjb2RlcyB0aGUgJSVkYXRhJSUgZnJvbSBhIHRyYW5zYWN0aW9uIGBgdHguZGF0YWBgIGZvclxuICAgICAqICB0aGUgZnVuY3Rpb24gc3BlY2lmaWVkIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXNcbiAgICAgKiAgZm9yICUlZnJhZ21lbnQlJSkuXG4gICAgICpcbiAgICAgKiAgTW9zdCBkZXZlbG9wZXJzIHNob3VsZCBwcmVmZXIgdGhlIFtbcGFyc2VUcmFuc2FjdGlvbl1dIG1ldGhvZFxuICAgICAqICBpbnN0ZWFkLCB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBkZWNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZnVuY3Rpb25cIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YVNsaWNlKGRhdGEsIDAsIDQpID09PSBmcmFnbWVudC5zZWxlY3RvciwgYGRhdGEgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGZ1bmN0aW9uICR7ZnJhZ21lbnQubmFtZX0uYCwgXCJkYXRhXCIsIGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgZGF0YVNsaWNlKGRhdGEsIDQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgdGhlIGBgdHguZGF0YWBgIGZvciBhIHRyYW5zYWN0aW9uIHRoYXQgY2FsbHMgdGhlIGZ1bmN0aW9uXG4gICAgICogIHNwZWNpZmllZCAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzIGZvciAlJWZyYWdtZW50JSUpIHdpdGhcbiAgICAgKiAgdGhlICUldmFsdWVzJSUuXG4gICAgICovXG4gICAgZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZnVuY3Rpb25cIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgICAgICBmcmFnbWVudC5zZWxlY3RvcixcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSByZXN1bHQgJSVkYXRhJSUgKGUuZy4gZnJvbSBhbiBgYGV0aF9jYWxsYGApIGZvciB0aGVcbiAgICAgKiAgc3BlY2lmaWVkIGZ1bmN0aW9uIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yXG4gICAgICogICUla2V5JSUpLlxuICAgICAqXG4gICAgICogIE1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcHJlZmVyIHRoZSBbW3BhcnNlQ2FsbFJlc3VsdF1dIG1ldGhvZCBpbnN0ZWFkLFxuICAgICAqICB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IGEgYGBDQUxMX0VYQ0VQVElPTmBgIGFuZCB0aHJvdyB0aGVcbiAgICAgKiAgY29ycmVzcG9uZGluZyBlcnJvci5cbiAgICAgKi9cbiAgICBkZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWVzc2FnZSA9IFwiaW52YWxpZCBsZW5ndGggZm9yIHJlc3VsdCBkYXRhXCI7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KGRhdGEpO1xuICAgICAgICBpZiAoKGJ5dGVzLmxlbmd0aCAlIDMyKSA9PT0gMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50Lm91dHB1dHMsIGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcImNvdWxkIG5vdCBkZWNvZGUgcmVzdWx0IGRhdGFcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxsIHJldHVybmVkIGRhdGEgd2l0aCBubyBlcnJvciwgYnV0IHRoZSBkYXRhIGlzIGp1bmtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBtZXNzYWdlLCBcIkJBRF9EQVRBXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBoZXhsaWZ5KGJ5dGVzKSxcbiAgICAgICAgICAgIGluZm86IHsgbWV0aG9kOiBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmU6IGZyYWdtZW50LmZvcm1hdCgpIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1ha2VFcnJvcihfZGF0YSwgdHgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XG4gICAgICAgIGNvbnN0IGVycm9yID0gQWJpQ29kZXIuZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oXCJjYWxsXCIsIHR4LCBkYXRhKTtcbiAgICAgICAgLy8gTm90IGEgYnVpbHQtaW4gZXJyb3I7IHRyeSBmaW5kaW5nIGEgY3VzdG9tIGVycm9yXG4gICAgICAgIGNvbnN0IGN1c3RvbVByZWZpeCA9IFwiZXhlY3V0aW9uIHJldmVydGVkICh1bmtub3duIGN1c3RvbSBlcnJvcilcIjtcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChjdXN0b21QcmVmaXgpKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGhleGxpZnkoZGF0YS5zbGljZSgwLCA0KSk7XG4gICAgICAgICAgICBjb25zdCBlZiA9IHRoaXMuZ2V0RXJyb3Ioc2VsZWN0b3IpO1xuICAgICAgICAgICAgaWYgKGVmKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuI2FiaUNvZGVyLmRlY29kZShlZi5pbnB1dHMsIGRhdGEuc2xpY2UoNCkpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5yZXZlcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlZi5uYW1lLCBzaWduYXR1cmU6IGVmLmZvcm1hdCgpLCBhcmdzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnJlYXNvbiA9IGVycm9yLnJldmVydC5zaWduYXR1cmU7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgZXhlY3V0aW9uIHJldmVydGVkOiAke2Vycm9yLnJlYXNvbn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gYGV4ZWN1dGlvbiByZXZlcnRlZCAoY291bHQgbm90IGRlY29kZSBjdXN0b20gZXJyb3IpYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBpbnZvY2F0aW9uLCBpZiBhdmFpbGFibGVcbiAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZVRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgZXJyb3IuaW52b2NhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHBhcnNlZC5uYW1lLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogcGFyc2VkLnNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBwYXJzZWQuYXJnc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGVzIHRoZSByZXN1bHQgZGF0YSAoZS5nLiBmcm9tIGFuIGBgZXRoX2NhbGxgYCkgZm9yIHRoZVxuICAgICAqICBzcGVjaWZpZWQgZnVuY3Rpb24gKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlc1xuICAgICAqICBmb3IgJSVmcmFnbWVudCUlKSB3aXRoICUldmFsdWVzJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWQgYnkgbW9zdCBkZXZlbG9wZXJzLCB1bmxlc3MgdHJ5aW5nIHRvIG1vY2tcbiAgICAgKiAgYSByZXN1bHQgZnJvbSBhIENvbnRyYWN0LlxuICAgICAqL1xuICAgIGVuY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZnVuY3Rpb25cIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleGxpZnkodGhpcy4jYWJpQ29kZXIuZW5jb2RlKGZyYWdtZW50Lm91dHB1dHMsIHZhbHVlcyB8fCBbXSkpO1xuICAgIH1cbiAgICAvKlxuICAgICAgICBzcGVsdW5rKGlucHV0czogQXJyYXk8UGFyYW1UeXBlPiwgdmFsdWVzOiBSZWFkb25seUFycmF5PGFueT4sIHByb2Nlc3NmdW5jOiAodHlwZTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiBQcm9taXNlPGFueT4pOiBQcm9taXNlPEFycmF5PGFueT4+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzOiBBcnJheTxQcm9taXNlPD4+ID0gWyBdO1xuICAgICAgICAgICAgY29uc3QgcHJvY2VzcyA9IGZ1bmN0aW9uKHR5cGU6IFBhcmFtVHlwZSwgdmFsdWU6IGFueSk6IGFueSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzY2VuZCh0eXBlLmNoaWxkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlLiA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgY29uc3QgZGVzY2VuZCA9IGZ1bmN0aW9uIChpbnB1dHM6IEFycmF5PFBhcmFtVHlwZT4sIHZhbHVlczogUmVhZG9ubHlBcnJheTxhbnk+KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0cy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHsgdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG1pc21hdGNoXCIpOyB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxhbnk+ID0gWyBdO1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJmaWx0ZXJpbmcgd2l0aCB0dXBsZXMgb3IgYXJyYXlzIG5vdCBzdXBwb3J0ZWRcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2godmFsdWUubWFwKCh2YWx1ZSkgPT4gZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgKi9cbiAgICAvLyBDcmVhdGUgdGhlIGZpbHRlciBmb3IgdGhlIGV2ZW50IHdpdGggc2VhcmNoIGNyaXRlcmlhIChlLmcuIGZvciBldGhfZmlsdGVyTG9nKVxuICAgIGVuY29kZUZpbHRlclRvcGljcyhmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXZlbnQoZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGV2ZW50XCIsIFwiZXZlbnRGcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KHZhbHVlcy5sZW5ndGggPD0gZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCwgYHRvbyBtYW55IGFyZ3VtZW50cyBmb3IgJHtmcmFnbWVudC5mb3JtYXQoKX1gLCBcIlVORVhQRUNURURfQVJHVU1FTlRcIiwgeyBjb3VudDogdmFsdWVzLmxlbmd0aCwgZXhwZWN0ZWRDb3VudDogZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCB9KTtcbiAgICAgICAgY29uc3QgdG9waWNzID0gW107XG4gICAgICAgIGlmICghZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICB0b3BpY3MucHVzaChmcmFnbWVudC50b3BpY0hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBVc2UgdGhlIGNvZGVycyBmb3IgdGhpczsgdG8gcHJvcGVybHkgc3VwcG9ydCB0dXBsZXMsIGV0Yy5cbiAgICAgICAgY29uc3QgZW5jb2RlVG9waWMgPSAocGFyYW0sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGhleGxpZnkodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcImJvb2xcIiAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA/IFwiMHgwMVwiIDogXCIweDAwXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZS5tYXRjaCgvXnU/aW50LykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvQmVIZXgodmFsdWUpOyAvLyBAVE9ETzogU2hvdWxkIHRoaXMgdG9Ud29zPz9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUubWF0Y2goL15ieXRlcy8pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB6ZXJvUGFkQnl0ZXModmFsdWUsIDMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWRkcmVzc2VzIGFyZSB2YWxpZFxuICAgICAgICAgICAgICAgIHRoaXMuI2FiaUNvZGVyLmVuY29kZShbXCJhZGRyZXNzXCJdLCBbdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB6ZXJvUGFkVmFsdWUoaGV4bGlmeSh2YWx1ZSksIDMyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyYW0gPSBmcmFnbWVudC5pbnB1dHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPT0gbnVsbCwgXCJjYW5ub3QgZmlsdGVyIG5vbi1pbmRleGVkIHBhcmFtZXRlcnM7IG11c3QgYmUgbnVsbFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImZpbHRlcmluZyB3aXRoIHR1cGxlcyBvciBhcnJheXMgbm90IHN1cHBvcnRlZFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKHZhbHVlLm1hcCgodmFsdWUpID0+IGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVHJpbSBvZmYgdHJhaWxpbmcgbnVsbHNcbiAgICAgICAgd2hpbGUgKHRvcGljcy5sZW5ndGggJiYgdG9waWNzW3RvcGljcy5sZW5ndGggLSAxXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdG9waWNzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3BpY3M7XG4gICAgfVxuICAgIGVuY29kZUV2ZW50TG9nKGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3BpY3MgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YVR5cGVzID0gW107XG4gICAgICAgIGNvbnN0IGRhdGFWYWx1ZXMgPSBbXTtcbiAgICAgICAgaWYgKCFmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHRvcGljcy5wdXNoKGZyYWdtZW50LnRvcGljSGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWVzLmxlbmd0aCA9PT0gZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCwgXCJldmVudCBhcmd1bWVudHMvdmFsdWVzIG1pc21hdGNoXCIsIFwidmFsdWVzXCIsIHZhbHVlcyk7XG4gICAgICAgIGZyYWdtZW50LmlucHV0cy5mb3JFYWNoKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goaWQodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJieXRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGtlY2NhazI1Nih2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE9cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2godGhpcy4jYWJpQ29kZXIuZW5jb2RlKFtwYXJhbS50eXBlXSwgW3ZhbHVlXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICBkYXRhVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuI2FiaUNvZGVyLmVuY29kZShkYXRhVHlwZXMsIGRhdGFWYWx1ZXMpLFxuICAgICAgICAgICAgdG9waWNzOiB0b3BpY3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gRGVjb2RlIGEgZmlsdGVyIGZvciB0aGUgZXZlbnQgYW5kIHRoZSBzZWFyY2ggY3JpdGVyaWFcbiAgICBkZWNvZGVFdmVudExvZyhmcmFnbWVudCwgZGF0YSwgdG9waWNzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXZlbnQoZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGV2ZW50XCIsIFwiZXZlbnRGcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvcGljcyAhPSBudWxsICYmICFmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VG9waWMgPSBmcmFnbWVudC50b3BpY0hhc2g7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh0b3BpY3NbMF0sIDMyKSAmJiB0b3BpY3NbMF0udG9Mb3dlckNhc2UoKSA9PT0gZXZlbnRUb3BpYywgXCJmcmFnbWVudC90b3BpYyBtaXNtYXRjaFwiLCBcInRvcGljc1swXVwiLCB0b3BpY3NbMF0pO1xuICAgICAgICAgICAgdG9waWNzID0gdG9waWNzLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ZWQgPSBbXTtcbiAgICAgICAgY29uc3Qgbm9uSW5kZXhlZCA9IFtdO1xuICAgICAgICBjb25zdCBkeW5hbWljID0gW107XG4gICAgICAgIGZyYWdtZW50LmlucHV0cy5mb3JFYWNoKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgcGFyYW0udHlwZSA9PT0gXCJieXRlc1wiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVkLnB1c2goUGFyYW1UeXBlLmZyb20oeyB0eXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogcGFyYW0ubmFtZSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9uSW5kZXhlZC5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0SW5kZXhlZCA9ICh0b3BpY3MgIT0gbnVsbCkgPyB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoaW5kZXhlZCwgY29uY2F0KHRvcGljcykpIDogbnVsbDtcbiAgICAgICAgY29uc3QgcmVzdWx0Tm9uSW5kZXhlZCA9IHRoaXMuI2FiaUNvZGVyLmRlY29kZShub25JbmRleGVkLCBkYXRhLCB0cnVlKTtcbiAgICAgICAgLy9jb25zdCByZXN1bHQ6IChBcnJheTxhbnk+ICYgeyBbIGtleTogc3RyaW5nIF06IGFueSB9KSA9IFsgXTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgbGV0IG5vbkluZGV4ZWRJbmRleCA9IDAsIGluZGV4ZWRJbmRleCA9IDA7XG4gICAgICAgIGZyYWdtZW50LmlucHV0cy5mb3JFYWNoKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRJbmRleGVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgSW5kZXhlZChudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZHluYW1pY1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgSW5kZXhlZChyZXN1bHRJbmRleGVkW2luZGV4ZWRJbmRleCsrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHRJbmRleGVkW2luZGV4ZWRJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdE5vbkluZGV4ZWRbbm9uSW5kZXhlZEluZGV4KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBrZXlzLnB1c2gocGFyYW0ubmFtZSB8fCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBSZXN1bHQuZnJvbUl0ZW1zKHZhbHVlcywga2V5cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSB0cmFuc2FjdGlvbiwgZmluZGluZyB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGZ1bmN0aW9uIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJuIG51bGwuXG4gICAgICovXG4gICAgcGFyc2VUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXModHguZGF0YSwgXCJ0eC5kYXRhXCIpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludCgodHgudmFsdWUgIT0gbnVsbCkgPyB0eC52YWx1ZSA6IDAsIFwidHgudmFsdWVcIik7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbihoZXhsaWZ5KGRhdGEuc2xpY2UoMCwgNCkpKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuI2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5pbnB1dHMsIGRhdGEuc2xpY2UoNCkpO1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uRGVzY3JpcHRpb24oZnJhZ21lbnQsIGZyYWdtZW50LnNlbGVjdG9yLCBhcmdzLCB2YWx1ZSk7XG4gICAgfVxuICAgIHBhcnNlQ2FsbFJlc3VsdChkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGFyc2VzIGEgcmVjZWlwdCBsb2csIGZpbmRpbmcgdGhlIG1hdGNoaW5nIGV2ZW50IGFuZCBleHRyYWN0c1xuICAgICAqICB0aGUgcGFyYW1ldGVyIHZhbHVlcyBhbG9uZyB3aXRoIG90aGVyIHVzZWZ1bCBldmVudCBkZXRhaWxzLlxuICAgICAqXG4gICAgICogIElmIHRoZSBtYXRjaGluZyBldmVudCBjYW5ub3QgYmUgZm91bmQsIHJldHVybnMgbnVsbC5cbiAgICAgKi9cbiAgICBwYXJzZUxvZyhsb2cpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pO1xuICAgICAgICBpZiAoIWZyYWdtZW50IHx8IGZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IElmIGFub255bW91cywgYW5kIHRoZSBvbmx5IG1ldGhvZCwgYW5kIHRoZSBpbnB1dCBjb3VudCBtYXRjaGVzLCBzaG91bGQgd2UgcGFyc2U/XG4gICAgICAgIC8vICAgICAgICBQcm9iYWJseSBub3QsIGJlY2F1c2UganVzdCBiZWNhdXNlIGl0IGlzIHRoZSBvbmx5IGV2ZW50IGluIHRoZSBBQkkgZG9lc1xuICAgICAgICAvLyAgICAgICAgbm90IG1lYW4gd2UgaGF2ZSB0aGUgZnVsbCBBQkk7IG1heWJlIGp1c3QgYSBmcmFnbWVudD9cbiAgICAgICAgcmV0dXJuIG5ldyBMb2dEZXNjcmlwdGlvbihmcmFnbWVudCwgZnJhZ21lbnQudG9waWNIYXNoLCB0aGlzLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGFyc2VzIGEgcmV2ZXJ0IGRhdGEsIGZpbmRpbmcgdGhlIG1hdGNoaW5nIGVycm9yIGFuZCBleHRyYWN0c1xuICAgICAqICB0aGUgcGFyYW1ldGVyIHZhbHVlcyBhbG9uZyB3aXRoIG90aGVyIHVzZWZ1bCBlcnJvciBkZXRhaWxzLlxuICAgICAqXG4gICAgICogIElmIHRoZSBtYXRjaGluZyBlcnJvciBjYW5ub3QgYmUgZm91bmQsIHJldHVybnMgbnVsbC5cbiAgICAgKi9cbiAgICBwYXJzZUVycm9yKGRhdGEpIHtcbiAgICAgICAgY29uc3QgaGV4RGF0YSA9IGhleGxpZnkoZGF0YSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5nZXRFcnJvcihkYXRhU2xpY2UoaGV4RGF0YSwgMCwgNCkpO1xuICAgICAgICBpZiAoIWZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50LmlucHV0cywgZGF0YVNsaWNlKGhleERhdGEsIDQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvckRlc2NyaXB0aW9uKGZyYWdtZW50LCBmcmFnbWVudC5zZWxlY3RvciwgYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbSW50ZXJmYWNlXV0gZnJvbSB0aGUgQUJJICUldmFsdWUlJS5cbiAgICAgKlxuICAgICAqICBUaGUgJSV2YWx1ZSUlIG1heSBiZSBwcm92aWRlZCBhcyBhbiBleGlzdGluZyBbW0ludGVyZmFjZV1dIG9iamVjdCxcbiAgICAgKiAgYSBKU09OLWVuY29kZWQgQUJJIG9yIGFueSBIdW1hbi1SZWFkYWJsZSBBQkkgZm9ybWF0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIC8vIEFscmVhZHkgYW4gSW50ZXJmYWNlLCB3aGljaCBpcyBpbW11dGFibGVcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW50ZXJmYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlNPTlxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKEpTT04ucGFyc2UodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXliZSBhbiBpbnRlcmZhY2UgZnJvbSBhbiBvbGRlciB2ZXJzaW9uLCBvciBmcm9tIGEgc3ltbGlua2VkIGNvcHlcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUuZm9ybWF0KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZSh2YWx1ZS5mb3JtYXQoXCJqc29uXCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheSBvZiBmcmFnbWVudHNcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UodmFsdWUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiLCIvL2ltcG9ydCB7IHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBoZXhsaWZ5LCByZXNvbHZlUHJvcGVydGllcywgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgaXNFcnJvciwgbWFrZUVycm9yIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGdldFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRvSnNvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbn1cbi8vIEBUT0RPPyA8VCBleHRlbmRzIEZlZURhdGEgPSB7IH0+IGltcGxlbWVudHMgUmVxdWlyZWQ8VD5cbi8qKlxuICogIEEgKipGZWVEYXRhKiogd3JhcHMgYWxsIHRoZSBmZWUtcmVsYXRlZCB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoXG4gKiAgdGhlIG5ldHdvcmsuXG4gKi9cbmV4cG9ydCBjbGFzcyBGZWVEYXRhIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZSBmb3IgbGVnYWN5IG5ldHdvcmtzLlxuICAgICAqL1xuICAgIGdhc1ByaWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBmZWUgdG8gcGF5IHBlciBnYXMuXG4gICAgICpcbiAgICAgKiAgVGhlIGJhc2UgZmVlIHBlciBnYXMgaXMgZGVmaW5lZCBieSB0aGUgbmV0d29yayBhbmQgYmFzZWQgb25cbiAgICAgKiAgY29uZ2VzdGlvbiwgaW5jcmVhc2luZyB0aGUgY29zdCBkdXJpbmcgdGltZXMgb2YgaGVhdnkgbG9hZFxuICAgICAqICBhbmQgbG93ZXJpbmcgd2hlbiBsZXNzIGJ1c3kuXG4gICAgICpcbiAgICAgKiAgVGhlIGFjdHVhbCBmZWUgcGVyIGdhcyB3aWxsIGJlIHRoZSBiYXNlIGZlZSBmb3IgdGhlIGJsb2NrXG4gICAgICogIGFuZCB0aGUgcHJpb3JpdHkgZmVlLCB1cCB0byB0aGUgbWF4IGZlZSBwZXIgZ2FzLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCBiZSBgYG51bGxgYCBvbiBsZWdhY3kgbmV0d29ya3MgKGkuZS4gW3ByZS1FSVAtMTU1OV0obGluay1laXAtMTU1OSkpXG4gICAgICovXG4gICAgbWF4RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkaXRpb25hbCBhbW91dCB0byBwYXkgcGVyIGdhcyB0byBlbmNvdXJhZ2UgYSB2YWxpZGF0b3JcbiAgICAgKiAgdG8gaW5jbHVkZSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhlIHB1cnBvc2Ugb2YgdGhpcyBpcyB0byBjb21wZW5zYXRlIHRoZSB2YWxpZGF0b3IgZm9yIHRoZVxuICAgICAqICBhZGp1c3RlZCByaXNrIGZvciBpbmNsdWRpbmcgYSBnaXZlbiB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgYmUgYGBudWxsYGAgb24gbGVnYWN5IG5ldHdvcmtzIChpLmUuIFtwcmUtRUlQLTE1NTldKGxpbmstZWlwLTE1NTkpKVxuICAgICAqL1xuICAgIG1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IEZlZURhdGEgZm9yICUlZ2FzUHJpY2UlJSwgJSVtYXhGZWVQZXJHYXMlJSBhbmRcbiAgICAgKiAgJSVtYXhQcmlvcml0eUZlZVBlckdhcyUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZ2FzUHJpY2U6IGdldFZhbHVlKGdhc1ByaWNlKSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogZ2V0VmFsdWUobWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBnZXRWYWx1ZShtYXhQcmlvcml0eUZlZVBlckdhcylcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1mcmllbmRseSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJGZWVEYXRhXCIsXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKGdhc1ByaWNlKSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogdG9Kc29uKG1heEZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogdG9Kc29uKG1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG47XG4vKipcbiAqICBSZXR1cm5zIGEgY29weSBvZiAlJXJlcSUlIHdpdGggYWxsIHByb3BlcnRpZXMgY29lcmNlZCB0byB0aGVpciBzdHJpY3RcbiAqICB0eXBlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHlSZXF1ZXN0KHJlcSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIC8vIFRoZXNlIGNvdWxkIGJlIGFkZHJlc3NlcywgRU5TIG5hbWVzIG9yIEFkZHJlc3NhYmxlc1xuICAgIGlmIChyZXEudG8pIHtcbiAgICAgICAgcmVzdWx0LnRvID0gcmVxLnRvO1xuICAgIH1cbiAgICBpZiAocmVxLmZyb20pIHtcbiAgICAgICAgcmVzdWx0LmZyb20gPSByZXEuZnJvbTtcbiAgICB9XG4gICAgaWYgKHJlcS5kYXRhKSB7XG4gICAgICAgIHJlc3VsdC5kYXRhID0gaGV4bGlmeShyZXEuZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGJpZ0ludEtleXMgPSBcImNoYWluSWQsZ2FzTGltaXQsZ2FzUHJpY2UsbWF4RmVlUGVyR2FzLG1heFByaW9yaXR5RmVlUGVyR2FzLHZhbHVlXCIuc3BsaXQoLywvKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBiaWdJbnRLZXlzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiByZXEpIHx8IHJlcVtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtrZXldID0gZ2V0QmlnSW50KHJlcVtrZXldLCBgcmVxdWVzdC4ke2tleX1gKTtcbiAgICB9XG4gICAgY29uc3QgbnVtYmVyS2V5cyA9IFwidHlwZSxub25jZVwiLnNwbGl0KC8sLyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgbnVtYmVyS2V5cykge1xuICAgICAgICBpZiAoIShrZXkgaW4gcmVxKSB8fCByZXFba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRba2V5XSA9IGdldE51bWJlcihyZXFba2V5XSwgYHJlcXVlc3QuJHtrZXl9YCk7XG4gICAgfVxuICAgIGlmIChyZXEuYWNjZXNzTGlzdCkge1xuICAgICAgICByZXN1bHQuYWNjZXNzTGlzdCA9IGFjY2Vzc0xpc3RpZnkocmVxLmFjY2Vzc0xpc3QpO1xuICAgIH1cbiAgICBpZiAoXCJibG9ja1RhZ1wiIGluIHJlcSkge1xuICAgICAgICByZXN1bHQuYmxvY2tUYWcgPSByZXEuYmxvY2tUYWc7XG4gICAgfVxuICAgIGlmIChcImVuYWJsZUNjaXBSZWFkXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5lbmFibGVDY2lwUmVhZCA9ICEhcmVxLmVuYWJsZUNjaXBSZWFkO1xuICAgIH1cbiAgICBpZiAoXCJjdXN0b21EYXRhXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5jdXN0b21EYXRhID0gcmVxLmN1c3RvbURhdGE7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBBICoqQmxvY2sqKiByZXByZXNlbnRzIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCBhIGZ1bGwgYmxvY2sgb25cbiAqICBFdGhlcmV1bS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIGNvbm5lY3RlZCB0byB0aGUgYmxvY2sgdXNlZCB0byBmZXRjaCBhZGRpdGlvbmFsIGRldGFpbHNcbiAgICAgKiAgaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyLCBzb21ldGltZXMgY2FsbGVkIHRoZSBibG9jayBoZWlnaHQuIFRoaXMgaXMgYVxuICAgICAqICBzZXF1ZW50aWFsIG51bWJlciB0aGF0IGlzIG9uZSBoaWdoZXIgdGhhbiB0aGUgcGFyZW50IGJsb2NrLlxuICAgICAqL1xuICAgIG51bWJlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2guXG4gICAgICpcbiAgICAgKiAgVGhpcyBoYXNoIGluY2x1ZGVzIGFsbCBwcm9wZXJ0aWVzLCBzbyBjYW4gYmUgc2FmZWx5IHVzZWQgdG8gaWRlbnRpZnlcbiAgICAgKiAgYW4gZXhhY3Qgc2V0IG9mIGJsb2NrIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRpbWVzdGFtcCBmb3IgdGhpcyBibG9jaywgd2hpY2ggaXMgdGhlIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlXG4gICAgICogIGVwb2NoIHRoYXQgdGhpcyBibG9jayB3YXMgaW5jbHVkZWQuXG4gICAgICovXG4gICAgdGltZXN0YW1wO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaCBvZiB0aGUgcGFyZW50IGJsb2NrLlxuICAgICAqL1xuICAgIHBhcmVudEhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBub25jZS5cbiAgICAgKlxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MsIHRoaXMgaXMgdGhlIHJhbmRvbSBudW1iZXIgaW5zZXJ0ZWQgd2hpY2hcbiAgICAgKiAgcGVybWl0dGVkIHRoZSBkaWZmaWN1bHR5IHRhcmdldCB0byBiZSByZWFjaGVkLlxuICAgICAqL1xuICAgIG5vbmNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGlmZmljdWx0eSB0YXJnZXQuXG4gICAgICpcbiAgICAgKiAgT24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzIGlzIHRoZSBwcm9vZi1vZi13b3JrIHRhcmdldCByZXF1aXJlZFxuICAgICAqICBmb3IgYSBibG9jayB0byBtZWV0IHRoZSBwcm90b2NvbCBydWxlcyB0byBiZSBpbmNsdWRlZC5cbiAgICAgKlxuICAgICAqICBPbiBtb2Rlcm4gbmV0d29ya3MsIHRoaXMgaXMgYSByYW5kb20gbnVtYmVyIGFycml2ZWQgYXQgdXNpbmdcbiAgICAgKiAgcmFuZGFvLiAgQFRPRE86IEZpbmQgbGlua3M/XG4gICAgICovXG4gICAgZGlmZmljdWx0eTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRvdGFsIGdhcyBsaW1pdCBmb3IgdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBnYXNMaW1pdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRvdGFsIGdhcyB1c2VkIGluIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgZ2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1pbmVyIGNvaW5iYXNlIGFkZHJlc3MsIHdpaGNoIHJlY2VpdmVzIGFueSBzdWJzaWRpZXMgZm9yXG4gICAgICogIGluY2x1ZGluZyB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIG1pbmVyO1xuICAgIC8qKlxuICAgICAqICBBbnkgZXh0cmEgZGF0YSB0aGUgdmFsaWRhdG9yIHdpc2hlZCB0byBpbmNsdWRlLlxuICAgICAqL1xuICAgIGV4dHJhRGF0YTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJhc2UgZmVlIHBlciBnYXMgdGhhdCBhbGwgdHJhbnNhY3Rpb25zIGluIHRoaXMgYmxvY2sgd2VyZVxuICAgICAqICBjaGFyZ2VkLlxuICAgICAqXG4gICAgICogIFRoaXMgYWRqdXN0cyBhZnRlciBlYWNoIGJsb2NrLCBkZXBlbmRpbmcgb24gaG93IGNvbmdlc3RlZCB0aGUgbmV0d29ya1xuICAgICAqICBpcy5cbiAgICAgKi9cbiAgICBiYXNlRmVlUGVyR2FzO1xuICAgICN0cmFuc2FjdGlvbnM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkJsb2NrKiogb2JqZWN0LlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgbmVjZXNzYXJ5IGFzIHRoZSB1bmxlc3MgaW1wbGVtZW50aW5nIGFcbiAgICAgKiAgbG93LWxldmVsIGxpYnJhcnkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYmxvY2ssIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3RyYW5zYWN0aW9ucyA9IGJsb2NrLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0eCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICBoYXNoOiBnZXRWYWx1ZShibG9jay5oYXNoKSxcbiAgICAgICAgICAgIG51bWJlcjogYmxvY2subnVtYmVyLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBibG9jay50aW1lc3RhbXAsXG4gICAgICAgICAgICBwYXJlbnRIYXNoOiBibG9jay5wYXJlbnRIYXNoLFxuICAgICAgICAgICAgbm9uY2U6IGJsb2NrLm5vbmNlLFxuICAgICAgICAgICAgZGlmZmljdWx0eTogYmxvY2suZGlmZmljdWx0eSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBibG9jay5nYXNMaW1pdCxcbiAgICAgICAgICAgIGdhc1VzZWQ6IGJsb2NrLmdhc1VzZWQsXG4gICAgICAgICAgICBtaW5lcjogYmxvY2subWluZXIsXG4gICAgICAgICAgICBleHRyYURhdGE6IGJsb2NrLmV4dHJhRGF0YSxcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IGdldFZhbHVlKGJsb2NrLmJhc2VGZWVQZXJHYXMpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgbGlzdCBvZiB0cmFuc2FjdGlvbiBoYXNoZXMsIGluIHRoZSBvcmRlclxuICAgICAqICB0aGV5IHdlcmUgZXhlY3V0ZWQgd2l0aGluIHRoZSBibG9jay5cbiAgICAgKi9cbiAgICBnZXQgdHJhbnNhY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eC5oYXNoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGNvbXBsZXRlIHRyYW5zYWN0aW9ucywgaW4gdGhlIG9yZGVyIHRoZXlcbiAgICAgKiAgd2VyZSBleGVjdXRlZCB3aXRoaW4gdGhlIGJsb2NrLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgb25seSBhdmFpbGFibGUgZm9yIGJsb2NrcyB3aGljaCBwcmVmZXRjaGVkXG4gICAgICogIHRyYW5zYWN0aW9ucywgYnkgcGFzc2luZyBgYHRydWVgYCB0byAlJXByZWZldGNoVHhzJSVcbiAgICAgKiAgaW50byBbW1Byb3ZpZGVyLWdldEJsb2NrXV0uXG4gICAgICovXG4gICAgZ2V0IHByZWZldGNoZWRUcmFuc2FjdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHR4cyA9IHRoaXMuI3RyYW5zYWN0aW9ucy5zbGljZSgpO1xuICAgICAgICAvLyBEb2Vzbid0IG1hdHRlci4uLlxuICAgICAgICBpZiAodHhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBwcmVmZXRjaGVkIHRoZSB0cmFuc2FjdGlvbnNcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiAodHhzWzBdKSA9PT0gXCJvYmplY3RcIiwgXCJ0cmFuc2FjdGlvbnMgd2VyZSBub3QgcHJlZmV0Y2hlZCB3aXRoIGJsb2NrIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRyYW5zYWN0aW9uUmVzcG9uc2VzKClcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR4cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWZyaWVuZGx5IHZhbHVlLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBiYXNlRmVlUGVyR2FzLCBkaWZmaWN1bHR5LCBleHRyYURhdGEsIGdhc0xpbWl0LCBnYXNVc2VkLCBoYXNoLCBtaW5lciwgbm9uY2UsIG51bWJlciwgcGFyZW50SGFzaCwgdGltZXN0YW1wLCB0cmFuc2FjdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJCbG9ja1wiLFxuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogdG9Kc29uKGJhc2VGZWVQZXJHYXMpLFxuICAgICAgICAgICAgZGlmZmljdWx0eTogdG9Kc29uKGRpZmZpY3VsdHkpLFxuICAgICAgICAgICAgZXh0cmFEYXRhLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHRvSnNvbihnYXNMaW1pdCksXG4gICAgICAgICAgICBnYXNVc2VkOiB0b0pzb24oZ2FzVXNlZCksXG4gICAgICAgICAgICBoYXNoLCBtaW5lciwgbm9uY2UsIG51bWJlciwgcGFyZW50SGFzaCwgdGltZXN0YW1wLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25zLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgdHhzID0gdGhpcy50cmFuc2FjdGlvbnM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eHNbaW5kZXgrK10sIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBudW1iZXIgb2YgdHJhbnNhY3Rpb25zIGluIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI3RyYW5zYWN0aW9ucy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1qcy1kYXRlXV0gdGhpcyBibG9jayB3YXMgaW5jbHVkZWQgYXQuXG4gICAgICovXG4gICAgZ2V0IGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVzdGFtcCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy50aW1lc3RhbXAgKiAxMDAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgdHJhbnNhY3Rpb24gYXQgJSVpbmRleGUlJSB3aXRoaW4gdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbihpbmRleE9ySGFzaCkge1xuICAgICAgICAvLyBGaW5kIHRoZSBpbnRlcm5hbCB2YWx1ZSBieSBpdHMgaW5kZXggb3IgaGFzaFxuICAgICAgICBsZXQgdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgKGluZGV4T3JIYXNoKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdHggPSB0aGlzLiN0cmFuc2FjdGlvbnNbaW5kZXhPckhhc2hdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGluZGV4T3JIYXNoLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGhpcy4jdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IGhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR4ID0gdjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodi5oYXNoID09PSBoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0eCA9IHY7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gc3VjaCB0eFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0eCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiBhICoqQmxvY2sqKiB3YXMgZmV0Y2hlZCB3aXRoIGEgcmVxdWVzdCB0byBpbmNsdWRlIHRoZSB0cmFuc2FjdGlvbnNcbiAgICAgKiAgdGhpcyB3aWxsIGFsbG93IHN5bmNocm9ub3VzIGFjY2VzcyB0byB0aG9zZSB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIHRyYW5zYWN0aW9ucyB3ZXJlIG5vdCBwcmVmZXRjaGVkLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0UHJlZmV0Y2hlZFRyYW5zYWN0aW9uKGluZGV4T3JIYXNoKSB7XG4gICAgICAgIGNvbnN0IHR4cyA9IHRoaXMucHJlZmV0Y2hlZFRyYW5zYWN0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiAoaW5kZXhPckhhc2gpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHhzW2luZGV4T3JIYXNoXTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleE9ySGFzaCA9IGluZGV4T3JIYXNoLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAoY29uc3QgdHggb2YgdHhzKSB7XG4gICAgICAgICAgICBpZiAodHguaGFzaCA9PT0gaW5kZXhPckhhc2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwibm8gbWF0Y2hpbmcgdHJhbnNhY3Rpb25cIiwgXCJpbmRleE9ySGFzaFwiLCBpbmRleE9ySGFzaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyBibG9jayBiZWVuIG1pbmVkLiBUaGlzIHByb3ZpZGVzIGEgdHlwZSBndWFyZFxuICAgICAqICBmb3IgYWxsIHByb3BlcnRpZXMgb24gYSBbW01pbmVkQmxvY2tdXS5cbiAgICAgKi9cbiAgICBpc01pbmVkKCkgeyByZXR1cm4gISF0aGlzLmhhc2g7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgYmxvY2sgaXMgYW4gW1tsaW5rLWVpcC0yOTMwXV0gYmxvY2suXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuYmFzZUZlZVBlckdhcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIG9ycGhhbmVkRXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc01pbmVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlT3JwaGFuZWRCbG9ja0ZpbHRlcih0aGlzKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBMb2dcbi8qKlxuICogIEEgKipMb2cqKiBpbiBFdGhlcmV1bSByZXByZXNlbnRzIGFuIGV2ZW50IHRoYXQgaGFzIGJlZW4gaW5jbHVkZWQgaW4gYVxuICogIHRyYW5zYWN0aW9uIHVzaW5nIHRoZSBgYExPRypgYCBvcGNvZGVzLCB3aGljaCBhcmUgbW9zdCBjb21tb25seSB1c2VkIGJ5XG4gKiAgU29saWRpdHkncyBlbWl0IGZvciBhbm5vdW5jaW5nIGV2ZW50cy5cbiAqL1xuZXhwb3J0IGNsYXNzIExvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGxvZyB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgZGV0YWlsc1xuICAgICAqICBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0aGlzIGxvZyBvY2N1cnJlZCBpbi4gVXNlIHRoZVxuICAgICAqICBbW0xvZy1nZXRUcmFuc2FjdGlvbl1dIHRvIGdldCB0aGUgW1tUcmFuc2FjdGlvblJlc3BvbnNlXV0uXG4gICAgICovXG4gICAgdHJhbnNhY3Rpb25IYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaCBvZiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgaW4uIFVzZSB0aGVcbiAgICAgKiAgW1tMb2ctZ2V0QmxvY2tdXSB0byBnZXQgdGhlIFtbQmxvY2tdXS5cbiAgICAgKi9cbiAgICBibG9ja0hhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgb2YgdGhlIGJsb2NrIHRoaXMgbG9nIG9jY3VycmVkIGluLiBJdCBpcyBwcmVmZXJyZWRcbiAgICAgKiAgdG8gdXNlIHRoZSBbW0Jsb2NrLWhhc2hdXSB3aGVuIGZldGNoaW5nIHRoZSByZWxhdGVkIFtbQmxvY2tdXSxcbiAgICAgKiAgc2luY2UgaW4gdGhlIGNhc2Ugb2YgYW4gb3JwaGFuZWQgYmxvY2ssIHRoZSBibG9jayBhdCB0aGF0IGhlaWdodCBtYXlcbiAgICAgKiAgaGF2ZSBjaGFuZ2VkLlxuICAgICAqL1xuICAgIGJsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgKipMb2cqKiByZXByZXNlbnRzIGEgYmxvY2sgdGhhdCB3YXMgcmVtb3ZlZCBkdWUgdG8gYW4gb3JwaGFuZWRcbiAgICAgKiAgYmxvY2ssIHRoaXMgd2lsbCBiZSB0cnVlLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIG9ubHkgaGFwcGVuIHdpdGhpbiBhbiBvcnBoYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAgICovXG4gICAgcmVtb3ZlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IHRoYXQgZW1pdHRlZCB0aGlzIGxvZy5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGlzIGxvZyB3aGVuIGl0IHdhcyBlbWl0dGVkLlxuICAgICAqL1xuICAgIGRhdGE7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleGVkIHRvcGljcyBpbmNsdWRlZCBpbiB0aGlzIGxvZyB3aGVuIGl0IHdhcyBlbWl0dGVkLlxuICAgICAqXG4gICAgICogIEFsbCB0b3BpY3MgYXJlIGluY2x1ZGVkIGluIHRoZSBibG9vbSBmaWx0ZXJzLCBzbyB0aGV5IGNhbiBiZVxuICAgICAqICBlZmZpY2llbnRseSBmaWx0ZXJlZCB1c2luZyB0aGUgW1tQcm92aWRlci1nZXRMb2dzXV0gbWV0aG9kLlxuICAgICAqL1xuICAgIHRvcGljcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgYXQuIFRoaXMgaXMgZ2VuZXJhbGx5XG4gICAgICogIG5vdCB1c2VmdWwgdG8gZGV2ZWxvcGVycywgYnV0IGNhbiBiZSB1c2VkIHdpdGggdGhlIHZhcmlvdXMgcm9vdHNcbiAgICAgKiAgdG8gcHJvb2YgaW5jbHVzaW9uIHdpdGhpbiBhIGJsb2NrLlxuICAgICAqL1xuICAgIGluZGV4O1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBvZiB0aGlzIGxvZy5cbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvbkluZGV4O1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2csIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgY29uc3QgdG9waWNzID0gT2JqZWN0LmZyZWV6ZShsb2cudG9waWNzLnNsaWNlKCkpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogbG9nLnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogbG9nLmJsb2NrSGFzaCxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBsb2cuYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICByZW1vdmVkOiBsb2cucmVtb3ZlZCxcbiAgICAgICAgICAgIGFkZHJlc3M6IGxvZy5hZGRyZXNzLFxuICAgICAgICAgICAgZGF0YTogbG9nLmRhdGEsXG4gICAgICAgICAgICB0b3BpY3MsXG4gICAgICAgICAgICBpbmRleDogbG9nLmluZGV4LFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbG9nLnRyYW5zYWN0aW9uSW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IGFkZHJlc3MsIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsIGRhdGEsIGluZGV4LCByZW1vdmVkLCB0b3BpY3MsIHRyYW5zYWN0aW9uSGFzaCwgdHJhbnNhY3Rpb25JbmRleCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcImxvZ1wiLFxuICAgICAgICAgICAgYWRkcmVzcywgYmxvY2tIYXNoLCBibG9ja051bWJlciwgZGF0YSwgaW5kZXgsXG4gICAgICAgICAgICByZW1vdmVkLCB0b3BpY3MsIHRyYW5zYWN0aW9uSGFzaCwgdHJhbnNhY3Rpb25JbmRleFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgYmxvY2sgdGhhdCB0aGlzIGxvZyBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKHRoaXMuYmxvY2tIYXNoKTtcbiAgICAgICAgYXNzZXJ0KCEhYmxvY2ssIFwiZmFpbGVkIHRvIGZpbmQgdHJhbnNhY3Rpb25cIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdHJhbnNhY3Rpb24gdGhhdCB0aGlzIGxvZyBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHRoaXMudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgYXNzZXJ0KCEhdHgsIFwiZmFpbGVkIHRvIGZpbmQgdHJhbnNhY3Rpb25cIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdCBmb3QgdGhlIHRyYW5zYWN0aW9uIHRoYXQgdGhpc1xuICAgICAqICBsb2cgb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KCkge1xuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodGhpcy50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICBhc3NlcnQoISFyZWNlaXB0LCBcImZhaWxlZCB0byBmaW5kIHRyYW5zYWN0aW9uIHJlY2VpcHRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICByZW1vdmVkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW1vdmVkTG9nRmlsdGVyKHRoaXMpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFRyYW5zYWN0aW9uIFJlY2VpcHRcbi8qXG5leHBvcnQgaW50ZXJmYWNlIExlZ2FjeVRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgYnl6YW50aXVtOiBmYWxzZTtcbiAgICBzdGF0dXM6IG51bGw7XG4gICAgcm9vdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJ5emFudGl1bVRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgYnl6YW50aXVtOiB0cnVlO1xuICAgIHN0YXR1czogbnVtYmVyO1xuICAgIHJvb3Q6IG51bGw7XG59XG4qL1xuLyoqXG4gKiAgQSAqKlRyYW5zYWN0aW9uUmVjZWlwdCoqIGluY2x1ZGVzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgYVxuICogIHRyYW5zYWN0aW9uIHRoYXQgaXMgb25seSBhdmFpbGFibGUgYWZ0ZXIgaXQgaGFzIGJlZW4gbWluZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvblJlY2VpcHQge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgY29ubmVjdGVkIHRvIHRoZSBsb2cgdXNlZCB0byBmZXRjaCBhZGRpdGlvbmFsIGRldGFpbHNcbiAgICAgKiAgaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyB0aGUgdHJhbnNhY3Rpb24gd2FzIHNlbmQgdG8uXG4gICAgICovXG4gICAgdG87XG4gICAgLyoqXG4gICAgICogIFRoZSBzZW5kZXIgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGZyb207XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRyZXNzIG9mIHRoZSBjb250cmFjdCBpZiB0aGUgdHJhbnNhY3Rpb24gd2FzIGRpcmVjdGx5XG4gICAgICogIHJlc3BvbnNpYmxlIGZvciBkZXBsb3lpbmcgb25lLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgbm9uLW51bGwgKipvbmx5KiogaWYgdGhlIGBgdG9gYCBpcyBlbXB0eSBhbmQgdGhlIGBgZGF0YWBgXG4gICAgICogIHdhcyBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQgYXMgaW5pdGNvZGUuXG4gICAgICovXG4gICAgY29udHJhY3RBZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gaGFzaC5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggb2YgdGhpcyB0cmFuc2FjdGlvbiB3aXRoaW4gdGhlIGJsb2NrIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBpbmRleDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2ggb2YgdGhlIFtbQmxvY2tdXSB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKi9cbiAgICBibG9ja0hhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgb2YgdGhlIFtbQmxvY2tdXSB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKi9cbiAgICBibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb29tIGZpbHRlciBieXRlcyB0aGF0IHJlcHJlc2VudCBhbGwgbG9ncyB0aGF0IG9jY3VycmVkIHdpdGhpblxuICAgICAqICB0aGlzIHRyYW5zYWN0aW9uLiBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZnVsIGZvciBtb3N0IGRldmVsb3BlcnMsXG4gICAgICogIGJ1dCBjYW4gYmUgdXNlZCB0byB2YWxpZGF0ZSB0aGUgaW5jbHVkZWQgbG9ncy5cbiAgICAgKi9cbiAgICBsb2dzQmxvb207XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgYW1vdW50IG9mIGdhcyB1c2VkIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgV2hlbiBjcmVhdGluZyBhIHRyYW5zYWN0aW9uLCB0aGUgYW1vdW50IG9mIGdhcyB0aGF0IHdpbGwgYmUgdXNlZCBjYW5cbiAgICAgKiAgb25seSBiZSBhcHByb3hpbWF0ZWQsIGJ1dCB0aGUgc2VuZGVyIG11c3QgcGF5IHRoZSBnYXMgZmVlIGZvciB0aGVcbiAgICAgKiAgZW50aXJlIGdhcyBsaW1pdC4gQWZ0ZXIgdGhlIHRyYW5zYWN0aW9uLCB0aGUgZGlmZmVyZW5jZSBpcyByZWZ1bmRlZC5cbiAgICAgKi9cbiAgICBnYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYW1vdW50IG9mIGdhcyB1c2VkIGJ5IGFsbCB0cmFuc2FjdGlvbnMgd2l0aGluIHRoZSBibG9jayBmb3IgdGhpc1xuICAgICAqICBhbmQgYWxsIHRyYW5zYWN0aW9ucyB3aXRoIGEgbG93ZXIgYGBpbmRleGBgLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgZm9yIGRldmVsb3BlcnMgYnV0IGNhbiBiZSB1c2VkIHRvXG4gICAgICogIHZhbGlkYXRlIGNlcnRhaW4gYXNwZWN0cyBvZiBleGVjdXRpb24uXG4gICAgICovXG4gICAgY3VtdWxhdGl2ZUdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgZ2FzIHByaWNlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbi5cbiAgICAgKlxuICAgICAqICBEdWUgdG8gdGhlIGNvbXBsZXhpdHkgb2YgW1tsaW5rLWVpcC0xNTU5XV0gdGhpcyB2YWx1ZSBjYW4gb25seVxuICAgICAqICBiZSBjYWx1Y2xhdGVkIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCwgc25jZSB0aGUgYmFzZVxuICAgICAqICBmZWUgaXMgcHJvdG9jb2wtZW5mb3JjZWQuXG4gICAgICovXG4gICAgZ2FzUHJpY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTI3MThdXSB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLy9yZWFkb25seSBieXphbnRpdW0hOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqICBUaGUgc3RhdHVzIG9mIHRoaXMgdHJhbnNhY3Rpb24sIGluZGljYXRpbmcgc3VjY2VzcyAoaS5lLiBgYDFgYCkgb3JcbiAgICAgKiAgYSByZXZlcnQgKGkuZS4gYGAwYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYXZhaWxhYmxlIGluIHBvc3QtYnl6YW50aXVtIGJsb2NrcywgYnV0IHNvbWUgYmFja2VuZHMgbWF5XG4gICAgICogIGJhY2tmaWxsIHRoaXMgdmFsdWUuXG4gICAgICovXG4gICAgc3RhdHVzO1xuICAgIC8qKlxuICAgICAqICBUaGUgcm9vdCBoYXNoIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBubyBwcmVzZW50IGFuZCB3YXMgb25seSBpbmNsdWRlZCBpbiBwcmUtYnl6YW50aXVtIGJsb2NrcywgYnV0XG4gICAgICogIGNvdWxkIGJlIHVzZWQgdG8gdmFsaWRhdGUgY2VydGFpbiBwYXJ0cyBvZiB0aGUgcmVjZWlwdC5cbiAgICAgKi9cbiAgICByb290O1xuICAgICNsb2dzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eCwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jbG9ncyA9IE9iamVjdC5mcmVlemUodHgubG9ncy5tYXAoKGxvZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2cobG9nLCBwcm92aWRlcik7XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGV0IGdhc1ByaWNlID0gQk5fMDtcbiAgICAgICAgaWYgKHR4LmVmZmVjdGl2ZUdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdhc1ByaWNlID0gdHguZWZmZWN0aXZlR2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICAgICAgZnJvbTogdHguZnJvbSxcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogdHguY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgaGFzaDogdHguaGFzaCxcbiAgICAgICAgICAgIGluZGV4OiB0eC5pbmRleCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogdHguYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHR4LmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgbG9nc0Jsb29tOiB0eC5sb2dzQmxvb20sXG4gICAgICAgICAgICBnYXNVc2VkOiB0eC5nYXNVc2VkLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IHR4LmN1bXVsYXRpdmVHYXNVc2VkLFxuICAgICAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgICAgICB0eXBlOiB0eC50eXBlLFxuICAgICAgICAgICAgLy9ieXphbnRpdW06IHR4LmJ5emFudGl1bSxcbiAgICAgICAgICAgIHN0YXR1czogdHguc3RhdHVzLFxuICAgICAgICAgICAgcm9vdDogdHgucm9vdFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBsb2dzIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBsb2dzKCkgeyByZXR1cm4gdGhpcy4jbG9nczsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyB0bywgZnJvbSwgY29udHJhY3RBZGRyZXNzLCBoYXNoLCBpbmRleCwgYmxvY2tIYXNoLCBibG9ja051bWJlciwgbG9nc0Jsb29tLCBsb2dzLCAvL2J5emFudGl1bSwgXG4gICAgICAgIHN0YXR1cywgcm9vdCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcIlRyYW5zYWN0aW9uUmVjZWlwdFwiLFxuICAgICAgICAgICAgYmxvY2tIYXNoLCBibG9ja051bWJlcixcbiAgICAgICAgICAgIC8vYnl6YW50aXVtLCBcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgIGN1bXVsYXRpdmVHYXNVc2VkOiB0b0pzb24odGhpcy5jdW11bGF0aXZlR2FzVXNlZCksXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRvSnNvbih0aGlzLmdhc1ByaWNlKSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IHRvSnNvbih0aGlzLmdhc1VzZWQpLFxuICAgICAgICAgICAgaGFzaCwgaW5kZXgsIGxvZ3MsIGxvZ3NCbG9vbSwgcm9vdCwgc3RhdHVzLCB0b1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMubG9ncy5sZW5ndGg7IH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdGhpcy5sb2dzW2luZGV4KytdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgZmVlIGZvciB0aGlzIHRyYW5zYWN0aW9uLCBpbiB3ZWkuXG4gICAgICovXG4gICAgZ2V0IGZlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FzVXNlZCAqIHRoaXMuZ2FzUHJpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYmxvY2sgdGhpcyB0cmFuc2FjdGlvbiBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKHRoaXMuYmxvY2tIYXNoKTtcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRoaXMgdHJhbnNhY3Rpb24gb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBleGVjdXRpb24gb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBTdXBwb3J0IGZvciB0aGlzIGZlYXR1cmUgaXMgbGltaXRlZCwgYXMgaXQgcmVxdWlyZXMgYW4gYXJjaGl2ZSBub2RlXG4gICAgICogIHdpdGggdGhlIGBgZGVidWdfYGAgb3IgYGB0cmFjZV9gYCBBUEkgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXN1bHQoKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlc3VsdCh0aGlzLmhhc2gpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBudW1iZXIgb2YgY29uZmlybWF0aW9ucyB0aGlzIHRyYW5zYWN0aW9uIGhhcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb25maXJtYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKSkgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlb3JkZXJlZEV2ZW50KG90aGVyKSB7XG4gICAgICAgIGFzc2VydCghb3RoZXIgfHwgb3RoZXIuaXNNaW5lZCgpLCBcInVubWluZWQgJ290aGVyJyB0cmFuc2N0aW9uIGNhbm5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW9yZGVyZWRFdmVudChvdGhlcilcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMsIG90aGVyKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb25SZXNwb25zZSoqIGluY2x1ZGVzIGFsbCBwcm9wZXJ0aWVzIGFib3V0IGEgdHJhbnNhY3Rpb25cbiAqICB0aGF0IHdhcyBzZW50IHRvIHRoZSBuZXR3b3JrLCB3aGljaCBtYXkgb3IgbWF5IG5vdCBiZSBpbmNsdWRlZCBpbiBhXG4gKiAgYmxvY2suXG4gKlxuICogIFRoZSBbW1RyYW5zYWN0aW9uUmVzcG9uc2UtaXNNaW5lZF1dIGNhbiBiZSB1c2VkIHRvIGNoZWNrIGlmIHRoZVxuICogIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkIGFzIHdlbGwgYXMgdHlwZSBndWFyZCB0aGF0IHRoZSBvdGhlcndpc2VcbiAqICBwb3NzaWJseSBgYG51bGxgYCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25SZXNwb25zZSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciB0aGlzIGlzIGNvbm5lY3RlZCB0bywgd2hpY2ggd2lsbCBpbmZsdWVuY2UgaG93IGl0c1xuICAgICAqICBtZXRob2RzIHdpbGwgcmVzb2x2ZSBpdHMgYXN5bmMgaW5zcGVjdGlvbiBtZXRob2RzLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYGBudWxsYGAgZm9yIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGJsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2tIYXNoIG9mIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYGBudWxsYGAgZm9yIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGJsb2NrSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgYmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHJlc2lkZXMgYXQuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTI3MThdXSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0eXBlLiBUaGlzIGlzXG4gICAgICogIGBgMGBgIGZvciBsZWdhY3kgdHJhbnNhY3Rpb25zIHR5cGVzLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNlaXZlciBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIElmIGBgbnVsbGBgLCB0aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyBhbiBpbml0Y29kZSB0cmFuc2FjdGlvbi5cbiAgICAgKiAgVGhpcyBtZWFucyB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyB0aGUgW1tkYXRhXV0gd2lsbCBiZSBkZXBsb3llZFxuICAgICAqICBhcyBhIG5ldyBjb250cmFjdCBvbiBjaGFpbiAoYXNzdW1pbmcgaXQgZG9lcyBub3QgcmV2ZXJ0KSBhbmQgdGhlXG4gICAgICogIGFkZHJlc3MgbWF5IGJlIGNvbXB1dGVkIHVzaW5nIFtbZ2V0Q3JlYXRlQWRkcmVzc11dLlxuICAgICAqL1xuICAgIHRvO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VuZGVyIG9mIHRoaXMgdHJhbnNhY3Rpb24uIEl0IGlzIGltcGxpY2l0bHkgY29tcHV0ZWRcbiAgICAgKiAgZnJvbSB0aGUgdHJhbnNhY3Rpb24gcHJlLWltYWdlIGhhc2ggKGFzIHRoZSBkaWdlc3QpIGFuZCB0aGVcbiAgICAgKiAgW1tzaWduYXR1cmVdXSB1c2luZyBlY3JlY292ZXIuXG4gICAgICovXG4gICAgZnJvbTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5vbmNlLCB3aGljaCBpcyB1c2VkIHRvIHByZXZlbnQgcmVwbGF5IGF0dGFja3MgYW5kIG9mZmVyXG4gICAgICogIGEgbWV0aG9kIHRvIGVuc3VyZSB0cmFuc2FjdGlvbnMgZnJvbSBhIGdpdmVuIHNlbmRlciBhcmUgZXhwbGljaXRseVxuICAgICAqICBvcmRlcmVkLlxuICAgICAqXG4gICAgICogIFdoZW4gc2VuZGluZyBhIHRyYW5zYWN0aW9uLCB0aGlzIG11c3QgYmUgZXF1YWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAqICB0cmFuc2FjdGlvbnMgZXZlciBzZW50IGJ5IFtbZnJvbV1dLlxuICAgICAqL1xuICAgIG5vbmNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB1bml0cyBvZiBnYXMgdGhpcyB0cmFuc2FjdGlvbiBjYW4gY29uc3VtZS4gSWYgZXhlY3V0aW9uXG4gICAgICogIGV4Y2VlZHMgdGhpcywgdGhlIGVudHJpZXMgdHJhbnNhY3Rpb24gaXMgcmV2ZXJ0ZWQgYW5kIHRoZSBzZW5kZXJcbiAgICAgKiAgaXMgY2hhcmdlZCBmb3IgdGhlIGZ1bGwgYW1vdW50LCBkZXNwaXRlIG5vdCBzdGF0ZSBjaGFuZ2VzIGJlaW5nIG1hZGUuXG4gICAgICovXG4gICAgZ2FzTGltaXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgcHJpY2UgY2FuIGhhdmUgdmFyaW91cyB2YWx1ZXMsIGRlcGVuZGluZyBvbiB0aGUgbmV0d29yay5cbiAgICAgKlxuICAgICAqICBJbiBtb2Rlcm4gbmV0d29ya3MsIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgaW5jbHVkZWQgdGhpcyBpc1xuICAgICAqICB0aGUgLy9lZmZlY3RpdmUgZ2FzIHByaWNlLy8gKHRoZSBmZWUgcGVyIGdhcyB0aGF0IHdhcyBhY3R1YWxseVxuICAgICAqICBjaGFyZ2VkKSwgd2hpbGUgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGhhdmUgbm90IGJlZW4gaW5jbHVkZWQgeWV0XG4gICAgICogIGlzIHRoZSBbW21heEZlZVBlckdhc11dLlxuICAgICAqXG4gICAgICogIEZvciBsZWdhY3kgdHJhbnNhY3Rpb25zLCBvciB0cmFuc2FjdGlvbnMgb24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzXG4gICAgICogIGlzIHRoZSBmZWUgdGhhdCB3aWxsIGJlIGNoYXJnZWQgcGVyIHVuaXQgb2YgZ2FzIHRoZSB0cmFuc2FjdGlvblxuICAgICAqICBjb25zdW1lcy5cbiAgICAgKi9cbiAgICBnYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gcHJpb3JpdHkgZmVlIChwZXIgdW5pdCBvZiBnYXMpIHRvIGFsbG93IGFcbiAgICAgKiAgdmFsaWRhdG9yIHRvIGNoYXJnZSB0aGUgc2VuZGVyLiBUaGlzIGlzIGluY2x1c2l2ZSBvZiB0aGVcbiAgICAgKiAgW1ttYXhGZWVGZWVQZXJHYXNdXS5cbiAgICAgKi9cbiAgICBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gZmVlIChwZXIgdW5pdCBvZiBnYXMpIHRvIGFsbG93IHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgKiAgdG8gY2hhcmdlIHRoZSBzZW5kZXIuXG4gICAgICovXG4gICAgbWF4RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGF0YS5cbiAgICAgKi9cbiAgICBkYXRhO1xuICAgIC8qKlxuICAgICAqICBUaGUgdmFsdWUsIGluIHdlaS4gVXNlIFtbZm9ybWF0RXRoZXJdXSB0byBmb3JtYXQgdGhpcyB2YWx1ZVxuICAgICAqICBhcyBldGhlci5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElELlxuICAgICAqL1xuICAgIGNoYWluSWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QgZm9yIHRyYW5zYWN0aW9uIHR5cGVzIHRoYXRcbiAgICAgKiAgc3VwcG9ydCBpdCwgb3RoZXJ3aXNlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGFjY2Vzc0xpc3Q7XG4gICAgI3N0YXJ0QmxvY2s7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR4LCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuYmxvY2tOdW1iZXIgPSAodHguYmxvY2tOdW1iZXIgIT0gbnVsbCkgPyB0eC5ibG9ja051bWJlciA6IG51bGw7XG4gICAgICAgIHRoaXMuYmxvY2tIYXNoID0gKHR4LmJsb2NrSGFzaCAhPSBudWxsKSA/IHR4LmJsb2NrSGFzaCA6IG51bGw7XG4gICAgICAgIHRoaXMuaGFzaCA9IHR4Lmhhc2g7XG4gICAgICAgIHRoaXMuaW5kZXggPSB0eC5pbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gdHgudHlwZTtcbiAgICAgICAgdGhpcy5mcm9tID0gdHguZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHR4LnRvIHx8IG51bGw7XG4gICAgICAgIHRoaXMuZ2FzTGltaXQgPSB0eC5nYXNMaW1pdDtcbiAgICAgICAgdGhpcy5ub25jZSA9IHR4Lm5vbmNlO1xuICAgICAgICB0aGlzLmRhdGEgPSB0eC5kYXRhO1xuICAgICAgICB0aGlzLnZhbHVlID0gdHgudmFsdWU7XG4gICAgICAgIHRoaXMuZ2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyA9ICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSA/IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzIDogbnVsbDtcbiAgICAgICAgdGhpcy5tYXhGZWVQZXJHYXMgPSAodHgubWF4RmVlUGVyR2FzICE9IG51bGwpID8gdHgubWF4RmVlUGVyR2FzIDogbnVsbDtcbiAgICAgICAgdGhpcy5jaGFpbklkID0gdHguY2hhaW5JZDtcbiAgICAgICAgdGhpcy5zaWduYXR1cmUgPSB0eC5zaWduYXR1cmU7XG4gICAgICAgIHRoaXMuYWNjZXNzTGlzdCA9ICh0eC5hY2Nlc3NMaXN0ICE9IG51bGwpID8gdHguYWNjZXNzTGlzdCA6IG51bGw7XG4gICAgICAgIHRoaXMuI3N0YXJ0QmxvY2sgPSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tOdW1iZXIsIGJsb2NrSGFzaCwgaW5kZXgsIGhhc2gsIHR5cGUsIHRvLCBmcm9tLCBub25jZSwgZGF0YSwgc2lnbmF0dXJlLCBhY2Nlc3NMaXN0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiVHJhbnNhY3Rpb25SZWNlaXB0XCIsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0LCBibG9ja051bWJlciwgYmxvY2tIYXNoLFxuICAgICAgICAgICAgY2hhaW5JZDogdG9Kc29uKHRoaXMuY2hhaW5JZCksXG4gICAgICAgICAgICBkYXRhLCBmcm9tLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHRvSnNvbih0aGlzLmdhc0xpbWl0KSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiB0b0pzb24odGhpcy5nYXNQcmljZSksXG4gICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0b0pzb24odGhpcy5tYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRvSnNvbih0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG5vbmNlLCBzaWduYXR1cmUsIHRvLCBpbmRleCwgdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB0b0pzb24odGhpcy52YWx1ZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgQmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBpbmNsdWRlZCB5ZXQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIGxldCBibG9ja051bWJlciA9IHRoaXMuYmxvY2tOdW1iZXI7XG4gICAgICAgIGlmIChibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICh0eCkge1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gdHguYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5wcm92aWRlci5nZXRCbG9jayhibG9ja051bWJlcik7XG4gICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoaXMgdHJhbnNhY3Rpb24gYmVpbmcgcmUtcmVxdWVzdGVkIGZyb20gdGhlXG4gICAgICogIHByb3ZpZGVyLiBUaGlzIGNhbiBiZSB1c2VkIGlmIHlvdSBoYXZlIGFuIHVubWluZWQgdHJhbnNhY3Rpb25cbiAgICAgKiAgYW5kIHdpc2ggdG8gZ2V0IGFuIHVwLXRvLWRhdGUgcG9wdWxhdGVkIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGUgbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgdGhpcyB0cmFuc2FjdGlvbiBoYXMuXG4gICAgICovXG4gICAgYXN5bmMgY29uZmlybWF0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgeyB0eCwgYmxvY2tOdW1iZXIgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICB0eDogdGhpcy5nZXRUcmFuc2FjdGlvbigpLFxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTm90IG1pbmVkIHlldC4uLlxuICAgICAgICAgICAgaWYgKHR4ID09IG51bGwgfHwgdHguYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXIgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhbmQgaGFzXG4gICAgICogICUlY29uZmlybXMlJSBibG9ja3MgaW5jbHVkaW5nIGl0IChkZWZhdWx0OiBgYDFgYCkgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJXRpbWVvdXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiByZXNvbHZlIHRvIGBgbnVsbGBgIG9ubHkgaWYgJSVjb25maXJtcyUlIGlzIGBgMGBgXG4gICAgICogIGFuZCB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkLCBvdGhlcndpc2UgdGhpcyB3aWxsXG4gICAgICogIHdhaXQgdW50aWwgZW5vdWdoIGNvbmZpcm1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdChfY29uZmlybXMsIF90aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1zID0gKF9jb25maXJtcyA9PSBudWxsKSA/IDEgOiBfY29uZmlybXM7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoX3RpbWVvdXQgPT0gbnVsbCkgPyAwIDogX3RpbWVvdXQ7XG4gICAgICAgIGxldCBzdGFydEJsb2NrID0gdGhpcy4jc3RhcnRCbG9jaztcbiAgICAgICAgbGV0IG5leHRTY2FuID0gLTE7XG4gICAgICAgIGxldCBzdG9wU2Nhbm5pbmcgPSAoc3RhcnRCbG9jayA9PT0gLTEpID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICBjb25zdCBjaGVja1JlcGxhY2VtZW50ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGNvdW50IGZvciB0aGlzIHNlbmRlclxuICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgbm9uY2UgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpLFxuICAgICAgICAgICAgICAgIG5vbmNlOiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5mcm9tKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBObyB0cmFuc2FjdGlvbiBvciBvdXIgbm9uY2UgaGFzIG5vdCBiZWVuIG1pbmVkIHlldDsgYnV0IHdlXG4gICAgICAgICAgICAvLyBjYW4gc3RhcnQgc2Nhbm5pbmcgbGF0ZXIgd2hlbiB3ZSBkbyBzdGFydFxuICAgICAgICAgICAgaWYgKG5vbmNlIDwgdGhpcy5ub25jZSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0QmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSB3ZXJlIG1pbmVkOyBubyByZXBsYWNlbWVudFxuICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWluZWQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAobWluZWQgJiYgbWluZWQuYmxvY2tOdW1iZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHdlcmUgcmVwbGFjZWQ7IHN0YXJ0IHNjYW5uaW5nIGZvciB0aGF0IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAvLyBTdGFydGluZyB0byBzY2FuOyBsb29rIGJhY2sgYSBmZXcgZXh0cmEgYmxvY2tzIGZvciBzYWZldHlcbiAgICAgICAgICAgIGlmIChuZXh0U2NhbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuZXh0U2NhbiA9IHN0YXJ0QmxvY2sgLSAzO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0U2NhbiA8IHRoaXMuI3N0YXJ0QmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNjYW4gPSB0aGlzLiNzdGFydEJsb2NrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChuZXh0U2NhbiA8PSBibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbmV4dCBibG9jayB0byBzY2FuXG4gICAgICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKG5leHRTY2FuLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuOyBidXQgd2UnbGwgdHJ5IGFnYWluIHNob3J0bHlcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIHdlcmUgbWluZWQ7IG5vIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYXNoIG9mIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNoID09PSB0aGlzLmhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggZm9yIHRoZSB0cmFuc2FjdGlvbiB0aGF0IHJlcGxhY2VkIHVzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9jay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IGJsb2NrLmdldFRyYW5zYWN0aW9uKGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHguZnJvbSA9PT0gdGhpcy5mcm9tICYmIHR4Lm5vbmNlID09PSB0aGlzLm5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eC5oYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW47IGJ1dCB3ZSdsbCB0cnkgYWdhaW4gc2hvcnRseVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgcmV0cnkgdGhpcyBvbiB0aGUgbmV4dCBibG9jayAodGhpcyBjYXNlIGNvdWxkIGJlIG9wdGltaXplZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyICsgMSkgPCBjb25maXJtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb24gd2Ugd2VyZSByZXBsYWNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlYXNvbiA9IFwicmVwbGFjZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5kYXRhID09PSB0aGlzLmRhdGEgJiYgdHgudG8gPT09IHRoaXMudG8gJiYgdHgudmFsdWUgPT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcInJlcHJpY2VkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eC5kYXRhID09PSBcIjB4XCIgJiYgdHguZnJvbSA9PT0gdHgudG8gJiYgdHgudmFsdWUgPT09IEJOXzApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcImNhbmNlbGxlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInRyYW5zYWN0aW9uIHdhcyByZXBsYWNlZFwiLCBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxsZWQ6IChyZWFzb24gPT09IFwicmVwbGFjZWRcIiB8fCByZWFzb24gPT09IFwiY2FuY2VsbGVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudDogdHgucmVwbGFjZWFibGVUcmFuc2FjdGlvbihzdGFydEJsb2NrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiB0eC5oYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRTY2FuKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoZWNrUmVjZWlwdCA9IChyZWNlaXB0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsIHx8IHJlY2VpcHQuc3RhdHVzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwidHJhbnNhY3Rpb24gZXhlY3V0aW9uIHJldmVydGVkXCIsIFwiQ0FMTF9FWENFUFRJT05cIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLCByZWFzb246IG51bGwsIGludm9jYXRpb246IG51bGwsIHJldmVydDogbnVsbCxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0bzogcmVjZWlwdC50byxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogcmVjZWlwdC5mcm9tLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBcIlwiIC8vIEBUT0RPOiBpbiB2Nywgc3BsaXQgb3V0IHNlbmRUcmFuc2FjdGlvbiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgfSwgcmVjZWlwdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLmhhc2gpO1xuICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1JlY2VpcHQocmVjZWlwdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY2VpcHQpIHtcbiAgICAgICAgICAgIGlmICgoYXdhaXQgcmVjZWlwdC5jb25maXJtYXRpb25zKCkpID49IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUmVjZWlwdChyZWNlaXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHJlcGxhY2VtZW50OyB0aHJvd3MgaWYgYSByZXBsYWNlbWVudCB3YXMgZm91bmRcbiAgICAgICAgICAgIGF3YWl0IGNoZWNrUmVwbGFjZW1lbnQoKTtcbiAgICAgICAgICAgIC8vIEFsbG93IG51bGwgb25seSB3aGVuIHRoZSBjb25maXJtcyBpcyAwXG4gICAgICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWl0ZXIgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBMaXN0IG9mIHRoaW5ncyB0byBjYW5jZWwgd2hlbiB3ZSBoYXZlIGEgcmVzdWx0IChvbmUgd2F5IG9yIHRoZSBvdGhlcilcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxlcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHsgY2FuY2VsbGVycy5mb3JFYWNoKChjKSA9PiBjKCkpOyB9O1xuICAgICAgICAgICAgLy8gT24gY2FuY2VsLCBzdG9wIHNjYW5uaW5nIGZvciByZXBsYWNlbWVudHNcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHN0b3BTY2FubmluZyA9IHRydWU7IH0pO1xuICAgICAgICAgICAgLy8gU2V0IHVwIGFueSB0aW1lb3V0IHJlcXVlc3RlZFxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJ3YWl0IGZvciB0cmFuc2FjdGlvbiB0aW1lb3V0XCIsIFwiVElNRU9VVFwiKSk7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgY2xlYXJUaW1lb3V0KHRpbWVyKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eExpc3RlbmVyID0gYXN5bmMgKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEb25lOyByZXR1cm4gaXQhXG4gICAgICAgICAgICAgICAgaWYgKChhd2FpdCByZWNlaXB0LmNvbmZpcm1hdGlvbnMoKSkgPj0gY29uZmlybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNoZWNrUmVjZWlwdChyZWNlaXB0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHRoaXMucHJvdmlkZXIub2ZmKHRoaXMuaGFzaCwgdHhMaXN0ZW5lcik7IH0pO1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbih0aGlzLmhhc2gsIHR4TGlzdGVuZXIpO1xuICAgICAgICAgICAgLy8gV2Ugc3VwcG9ydCByZXBsYWNlbWVudCBkZXRlY3Rpb247IHN0YXJ0IGNoZWNraW5nXG4gICAgICAgICAgICBpZiAoc3RhcnRCbG9jayA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZUxpc3RlbmVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGEgcmVwbGFjZW1lbnQ7IHRoaXMgdGhyb3dzIG9ubHkgaWYgb25lIGlzIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjaGVja1JlcGxhY2VtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB3ZXJlIHJlcGxhY2VkICh3aXRoIGVub3VnaCBjb25maXJtcyk7IHJlLXRocm93IHRoZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNjaGV1ZGxlIGEgY2hlY2sgb24gdGhlIG5leHQgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub25jZShcImJsb2NrXCIsIHJlcGxhY2VMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHRoaXMucHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB3YWl0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBlZmZlY3RpdmUgb25seSBhcyBvZiB0aGUgdGltZSB0aGUgVHJhbnNhY3Rpb25SZXNwb25zZVxuICAgICAqICB3YXMgaW5zdGFudGlhdGVkLiBUbyBnZXQgdXAtdG8tZGF0ZSBpbmZvcm1hdGlvbiwgdXNlXG4gICAgICogIFtbZ2V0VHJhbnNhY3Rpb25dXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIG5vbi1udWxsIHByb3BlcnR5IHZhbHVlcyBmb3IgcHJvcGVydGllcyB0aGF0IGFyZSBudWxsIGZvclxuICAgICAqICB1bm1pbmVkIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBpc01pbmVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmxvY2tIYXNoICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIGxlZ2FjeSAoaS5lLiBgYHR5cGUgPT0gMGBgKVxuICAgICAqICB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNMZWdhY3koKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBCZXJsaW4gKGkuZS4gYGB0eXBlID09IDFgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTIwNzBdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNCZXJsaW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBMb25kb24gKGkuZS4gYGB0eXBlID09IDJgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTE1NTldXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBmaWx0ZXIgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBvcnBoYW4gZXZlbnRzXG4gICAgICogIHRoYXQgZXZpY3QgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICByZW1vdmVkRXZlbnQoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLmlzTWluZWQoKSwgXCJ1bm1pbmVkIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBmaWx0ZXIgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBvcnBoYW4gZXZlbnRzXG4gICAgICogIHRoYXQgcmUtb3JkZXIgdGhpcyBldmVudCBhZ2FpbnN0ICUlb3RoZXIlJS5cbiAgICAgKi9cbiAgICByZW9yZGVyZWRFdmVudChvdGhlcikge1xuICAgICAgICBhc3NlcnQodGhpcy5pc01pbmVkKCksIFwidW5taW5lZCB0cmFuc2FjdGlvbiBjYW5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW1vdmVFdmVudCgpXCIgfSk7XG4gICAgICAgIGFzc2VydCghb3RoZXIgfHwgb3RoZXIuaXNNaW5lZCgpLCBcInVubWluZWQgJ290aGVyJyB0cmFuc2FjdGlvbiBjYW5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW1vdmVFdmVudCgpXCIgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzLCBvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UgaW5zdGFuY2Ugd2hpY2ggaGFzIHRoZSBhYmlsaXR5IHRvXG4gICAgICogIGRldGVjdCAoYW5kIHRocm93IGFuIGVycm9yKSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgcmVwbGFjZWQsIHdoaWNoXG4gICAgICogIHdpbGwgYmVnaW4gc2Nhbm5pbmcgYXQgJSVzdGFydEJsb2NrJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgZ2VuZXJhbGx5IG5vdCBiZSB1c2VkIGJ5IGRldmVsb3BlcnMgYW5kIGlzIGludGVuZGVkXG4gICAgICogIHByaW1hcmlseSBmb3IgaW50ZXJuYWwgdXNlLiBTZXR0aW5nIGFuIGluY29ycmVjdCAlJXN0YXJ0QmxvY2slJSBjYW5cbiAgICAgKiAgaGF2ZSBkZXZhc3RhdGluZyBwZXJmb3JtYW5jZSBjb25zZXF1ZW5jZXMgaWYgdXNlZCBpbmNvcnJlY3RseS5cbiAgICAgKi9cbiAgICByZXBsYWNlYWJsZVRyYW5zYWN0aW9uKHN0YXJ0QmxvY2spIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcihzdGFydEJsb2NrKSAmJiBzdGFydEJsb2NrID49IDAsIFwiaW52YWxpZCBzdGFydEJsb2NrXCIsIFwic3RhcnRCbG9ja1wiLCBzdGFydEJsb2NrKTtcbiAgICAgICAgY29uc3QgdHggPSBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSh0aGlzLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgdHguI3N0YXJ0QmxvY2sgPSBzdGFydEJsb2NrO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlT3JwaGFuZWRCbG9ja0ZpbHRlcihibG9jaykge1xuICAgIHJldHVybiB7IG9ycGhhbjogXCJkcm9wLWJsb2NrXCIsIGhhc2g6IGJsb2NrLmhhc2gsIG51bWJlcjogYmxvY2subnVtYmVyIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlcih0eCwgb3RoZXIpIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwicmVvcmRlci10cmFuc2FjdGlvblwiLCB0eCwgb3RoZXIgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0eCkge1xuICAgIHJldHVybiB7IG9ycGhhbjogXCJkcm9wLXRyYW5zYWN0aW9uXCIsIHR4IH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZW1vdmVkTG9nRmlsdGVyKGxvZykge1xuICAgIHJldHVybiB7IG9ycGhhbjogXCJkcm9wLWxvZ1wiLCBsb2c6IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogbG9nLnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogbG9nLmJsb2NrSGFzaCxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBsb2cuYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICBhZGRyZXNzOiBsb2cuYWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IGxvZy5kYXRhLFxuICAgICAgICAgICAgdG9waWNzOiBPYmplY3QuZnJlZXplKGxvZy50b3BpY3Muc2xpY2UoKSksXG4gICAgICAgICAgICBpbmRleDogbG9nLmluZGV4XG4gICAgICAgIH0gfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLmpzLm1hcCIsIi8vIGltcG9ydCBmcm9tIHByb3ZpZGVyLnRzIGluc3RlYWQgb2YgaW5kZXgudHMgdG8gcHJldmVudCBjaXJjdWxhciBkZXBcbi8vIGZyb20gRXRoZXJzY2FuUHJvdmlkZXJcbmltcG9ydCB7IExvZywgVHJhbnNhY3Rpb25SZWNlaXB0LCBUcmFuc2FjdGlvblJlc3BvbnNlIH0gZnJvbSBcIi4uL3Byb3ZpZGVycy9wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgRXZlbnRQYXlsb2FkIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vKipcbiAqICBBbiAqKkV2ZW50TG9nKiogY29udGFpbnMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHBhcnNlZCBmcm9tIHRoZSBbW0xvZ11dLlxuICovXG5leHBvcnQgY2xhc3MgRXZlbnRMb2cgZXh0ZW5kcyBMb2cge1xuICAgIC8qKlxuICAgICAqICBUaGUgQ29udHJhY3QgSW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGludGVyZmFjZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGV2ZW50LlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgcGFyc2VkIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGV2ZW50IGJ5IGBgZW1pdGBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9nLCBpZmFjZSwgZnJhZ21lbnQpIHtcbiAgICAgICAgc3VwZXIobG9nLCBsb2cucHJvdmlkZXIpO1xuICAgICAgICBjb25zdCBhcmdzID0gaWZhY2UuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFyZ3MsIGZyYWdtZW50LCBpbnRlcmZhY2U6IGlmYWNlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIGdldCBldmVudE5hbWUoKSB7IHJldHVybiB0aGlzLmZyYWdtZW50Lm5hbWU7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNpZ25hdHVyZSBvZiB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50U2lnbmF0dXJlKCkgeyByZXR1cm4gdGhpcy5mcmFnbWVudC5mb3JtYXQoKTsgfVxufVxuLyoqXG4gKiAgQW4gKipFdmVudExvZyoqIGNvbnRhaW5zIGFkZGl0aW9uYWwgcHJvcGVydGllcyBwYXJzZWQgZnJvbSB0aGUgW1tMb2ddXS5cbiAqL1xuZXhwb3J0IGNsYXNzIFVuZGVjb2RlZEV2ZW50TG9nIGV4dGVuZHMgTG9nIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGVycm9yIGVuY291bnRlZCB3aGVuIHRyeWluZyB0byBkZWNvZGUgdGhlIGxvZy5cbiAgICAgKi9cbiAgICBlcnJvcjtcbiAgICAvKipcbiAgICAgKiBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2csIGVycm9yKSB7XG4gICAgICAgIHN1cGVyKGxvZywgbG9nLnByb3ZpZGVyKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGVycm9yIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCoqIGluY2x1ZGVzIHRoZSBwYXJzZWQgbG9ncyBmcm9tIGFcbiAqICBbW1RyYW5zYWN0aW9uUmVjZWlwdF1dLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQgZXh0ZW5kcyBUcmFuc2FjdGlvblJlY2VpcHQge1xuICAgICNpZmFjZTtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaWZhY2UsIHByb3ZpZGVyLCB0eCkge1xuICAgICAgICBzdXBlcih0eCwgcHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNpZmFjZSA9IGlmYWNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHBhcnNlZCBsb2dzIGZvciBhbnkgW1tMb2ddXSB3aGljaCBoYXMgYSBtYXRjaGluZyBldmVudCBpbiB0aGVcbiAgICAgKiAgQ29udHJhY3QgQUJJLlxuICAgICAqL1xuICAgIGdldCBsb2dzKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIubG9ncy5tYXAoKGxvZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBsb2cudG9waWNzLmxlbmd0aCA/IHRoaXMuI2lmYWNlLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRMb2cobG9nLCB0aGlzLiNpZmFjZSwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmRlY29kZWRFdmVudExvZyhsb2csIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKiogd2lsbCByZXR1cm4gYVxuICogIFtbQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHRdXSB3aGVuIHdhaXRlZCBvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSBleHRlbmRzIFRyYW5zYWN0aW9uUmVzcG9uc2Uge1xuICAgICNpZmFjZTtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaWZhY2UsIHByb3ZpZGVyLCB0eCkge1xuICAgICAgICBzdXBlcih0eCwgcHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNpZmFjZSA9IGlmYWNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgb25jZSB0aGlzIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkIGFuZCBoYXNcbiAgICAgKiAgJSVjb25maXJtcyUlIGJsb2NrcyBpbmNsdWRpbmcgaXQgKGRlZmF1bHQ6IGBgMWBgKSB3aXRoIGFuXG4gICAgICogIG9wdGlvbmFsICUldGltZW91dCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIHJlc29sdmUgdG8gYGBudWxsYGAgb25seSBpZiAlJWNvbmZpcm1zJSUgaXMgYGAwYGBcbiAgICAgKiAgYW5kIHRoZSB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gbWluZWQsIG90aGVyd2lzZSB0aGlzIHdpbGxcbiAgICAgKiAgd2FpdCB1bnRpbCBlbm91Z2ggY29uZmlybWF0aW9ucyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0KGNvbmZpcm1zKSB7XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCBzdXBlci53YWl0KGNvbmZpcm1zKTtcbiAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLiNpZmFjZSwgdGhpcy5wcm92aWRlciwgcmVjZWlwdCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCoqIGlzIGluY2x1ZGVkIGFzIHRoZSBsYXN0IHBhcmFtZXRlciB0b1xuICogIENvbnRyYWN0IEV2ZW50cyB3aGVuIHRoZSBldmVudCBkb2VzIG5vdCBtYXRjaCBhbnkgZXZlbnRzIGluIHRoZSBBQkkuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdFVua25vd25FdmVudFBheWxvYWQgZXh0ZW5kcyBFdmVudFBheWxvYWQge1xuICAgIC8qKlxuICAgICAqICBUaGUgbG9nIHdpdGggbm8gbWF0Y2hpbmcgZXZlbnRzLlxuICAgICAqL1xuICAgIGxvZztcbiAgICAvKipcbiAgICAgKiAgQF9ldmVudDpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlciwgbG9nKSB7XG4gICAgICAgIHN1cGVyKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGxvZyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBibG9jayB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9nLmdldEJsb2NrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gdGhlIGV2ZW50IG9jY3VyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvZy5nZXRUcmFuc2FjdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHQgdGhlIGV2ZW50IG9jY3VyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2cuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkNvbnRyYWN0RXZlbnRQYXlsb2FkKiogaXMgaW5jbHVkZWQgYXMgdGhlIGxhc3QgcGFyYW1ldGVyIHRvXG4gKiAgQ29udHJhY3QgRXZlbnRzIHdoZW4gdGhlIGV2ZW50IGlzIGtub3duLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3RFdmVudFBheWxvYWQgZXh0ZW5kcyBDb250cmFjdFVua25vd25FdmVudFBheWxvYWQge1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlciwgZnJhZ21lbnQsIF9sb2cpIHtcbiAgICAgICAgc3VwZXIoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIsIG5ldyBFdmVudExvZyhfbG9nLCBjb250cmFjdC5pbnRlcmZhY2UsIGZyYWdtZW50KSk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIHRoaXMubG9nLmRhdGEsIHRoaXMubG9nLnRvcGljcyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhcmdzLCBmcmFnbWVudCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBldmVudCBuYW1lLlxuICAgICAqL1xuICAgIGdldCBldmVudE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50Lm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZXZlbnQgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIGdldCBldmVudFNpZ25hdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3JhcHBlcnMuanMubWFwIiwiaW1wb3J0IHsgSW50ZXJmYWNlLCBUeXBlZCB9IGZyb20gXCIuLi9hYmkvaW5kZXguanNcIjtcbmltcG9ydCB7IGlzQWRkcmVzc2FibGUsIHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbi8vIGltcG9ydCBmcm9tIHByb3ZpZGVyLnRzIGluc3RlYWQgb2YgaW5kZXgudHMgdG8gcHJldmVudCBjaXJjdWxhciBkZXBcbi8vIGZyb20gRXRoZXJzY2FuUHJvdmlkZXJcbmltcG9ydCB7IGNvcHlSZXF1ZXN0LCBMb2cgfSBmcm9tIFwiLi4vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGlzQ2FsbEV4Y2VwdGlvbiwgaXNIZXhTdHJpbmcsIHJlc29sdmVQcm9wZXJ0aWVzLCBpc0Vycm9yLCBtYWtlRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IENvbnRyYWN0RXZlbnRQYXlsb2FkLCBDb250cmFjdFVua25vd25FdmVudFBheWxvYWQsIENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSwgRXZlbnRMb2csIFVuZGVjb2RlZEV2ZW50TG9nIH0gZnJvbSBcIi4vd3JhcHBlcnMuanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5mdW5jdGlvbiBjYW5DYWxsKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmNhbGwpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gY2FuRXN0aW1hdGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuZXN0aW1hdGVHYXMpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gY2FuUmVzb2x2ZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5yZXNvbHZlTmFtZSkgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBjYW5TZW5kKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnNlbmRUcmFuc2FjdGlvbikgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBnZXRSZXNvbHZlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChjYW5SZXNvbHZlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5jbGFzcyBQcmVwYXJlZFRvcGljRmlsdGVyIHtcbiAgICAjZmlsdGVyO1xuICAgIGZyYWdtZW50O1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncykge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZnJhZ21lbnQgfSk7XG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50c1wiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBkZXNjZW5kIGludG8gYXJncyBhbmQgcmVzb2x2ZSBhbnkgYWRkcmVzc2VzXG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwicmVzb2x2ZU5hbWVcIik7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gY2FuUmVzb2x2ZShydW5uZXIpID8gcnVubmVyIDogbnVsbDtcbiAgICAgICAgdGhpcy4jZmlsdGVyID0gKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkQXJncyA9IGF3YWl0IFByb21pc2UuYWxsKGZyYWdtZW50LmlucHV0cy5tYXAoKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChhcmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtLndhbGtBc3luYyhhcmdzW2luZGV4XSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHZhbHVlLm1hcCgodikgPT4gcmVzb2x2ZUFkZHJlc3ModiwgcmVzb2x2ZXIpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUFkZHJlc3ModmFsdWUsIHJlc29sdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZpbHRlclRvcGljcyhmcmFnbWVudCwgcmVzb2x2ZWRBcmdzKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZ2V0VG9waWNGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmaWx0ZXI7XG4gICAgfVxufVxuLy8gQSA9IEFyZ3VtZW50cyBwYXNzZWQgaW4gYXMgYSB0dXBsZVxuLy8gUiA9IFRoZSByZXN1bHQgdHlwZSBvZiB0aGUgY2FsbCAoaS5lLiBpZiBvbmx5IG9uZSByZXR1cm4gdHlwZSxcbi8vICAgICB0aGUgcXVhbGlmaWVkIHR5cGUsIG90aGVyd2lzZSBSZXN1bHQpXG4vLyBEID0gVGhlIHR5cGUgdGhlIGRlZmF1bHQgY2FsbCB3aWxsIHJldHVybiAoaS5lLiBSIGZvciB2aWV3L3B1cmUsXG4vLyAgICAgVHJhbnNhY3Rpb25SZXNwb25zZSBvdGhlcndpc2UpXG4vL2V4cG9ydCBpbnRlcmZhY2UgQ29udHJhY3RNZXRob2Q8QSBleHRlbmRzIEFycmF5PGFueT4gPSBBcnJheTxhbnk+LCBSID0gYW55LCBEIGV4dGVuZHMgUiB8IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSA9IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZT4ge1xuZnVuY3Rpb24gZ2V0UnVubmVyKHZhbHVlLCBmZWF0dXJlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlW2ZlYXR1cmVdKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnByb3ZpZGVyICYmIHR5cGVvZiAodmFsdWUucHJvdmlkZXJbZmVhdHVyZV0pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnByb3ZpZGVyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFByb3ZpZGVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5wcm92aWRlciB8fCBudWxsO1xufVxuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb3B5T3ZlcnJpZGVzKGFyZywgYWxsb3dlZCkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgb3ZlcnJpZGVzIHBhc3NlZCBpbiBhcmUgYSB2YWxpZCBvdmVycmlkZXMgb2JqZWN0XG4gICAgY29uc3QgX292ZXJyaWRlcyA9IFR5cGVkLmRlcmVmZXJlbmNlKGFyZywgXCJvdmVycmlkZXNcIik7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChfb3ZlcnJpZGVzKSA9PT0gXCJvYmplY3RcIiwgXCJpbnZhbGlkIG92ZXJyaWRlcyBwYXJhbWV0ZXJcIiwgXCJvdmVycmlkZXNcIiwgYXJnKTtcbiAgICAvLyBDcmVhdGUgYSBzaGFsbG93IGNvcHkgKHdlJ2xsIGRlZXAtaWZ5IGFueXRoaW5nIG5lZWRlZCBkdXJpbmcgbm9ybWFsaXppbmcpXG4gICAgY29uc3Qgb3ZlcnJpZGVzID0gY29weVJlcXVlc3QoX292ZXJyaWRlcyk7XG4gICAgYXNzZXJ0QXJndW1lbnQob3ZlcnJpZGVzLnRvID09IG51bGwgfHwgKGFsbG93ZWQgfHwgW10pLmluZGV4T2YoXCJ0b1wiKSA+PSAwLCBcImNhbm5vdCBvdmVycmlkZSB0b1wiLCBcIm92ZXJyaWRlcy50b1wiLCBvdmVycmlkZXMudG8pO1xuICAgIGFzc2VydEFyZ3VtZW50KG92ZXJyaWRlcy5kYXRhID09IG51bGwgfHwgKGFsbG93ZWQgfHwgW10pLmluZGV4T2YoXCJkYXRhXCIpID49IDAsIFwiY2Fubm90IG92ZXJyaWRlIGRhdGFcIiwgXCJvdmVycmlkZXMuZGF0YVwiLCBvdmVycmlkZXMuZGF0YSk7XG4gICAgLy8gUmVzb2x2ZSBhbnkgZnJvbVxuICAgIGlmIChvdmVycmlkZXMuZnJvbSkge1xuICAgICAgICBvdmVycmlkZXMuZnJvbSA9IG92ZXJyaWRlcy5mcm9tO1xuICAgIH1cbiAgICByZXR1cm4gb3ZlcnJpZGVzO1xufVxuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlQXJncyhfcnVubmVyLCBpbnB1dHMsIGFyZ3MpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZXNjZW5kIGludG8gYXJncyBhbmQgcmVzb2x2ZSBhbnkgYWRkcmVzc2VzXG4gICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKF9ydW5uZXIsIFwicmVzb2x2ZU5hbWVcIik7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBjYW5SZXNvbHZlKHJ1bm5lcikgPyBydW5uZXIgOiBudWxsO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChpbnB1dHMubWFwKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIHBhcmFtLndhbGtBc3luYyhhcmdzW2luZGV4XSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKHZhbHVlLCB0eXBlKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzcyh2YWx1ZSwgcmVzb2x2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9KSk7XG59XG5mdW5jdGlvbiBidWlsZFdyYXBwZWRGYWxsYmFjayhjb250cmFjdCkge1xuICAgIGNvbnN0IHBvcHVsYXRlVHJhbnNhY3Rpb24gPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIC8vIElmIGFuIG92ZXJyaWRlcyB3YXMgcGFzc2VkIGluLCBjb3B5IGl0IGFuZCBub3JtYWxpemUgdGhlIHZhbHVlc1xuICAgICAgICBjb25zdCB0eCA9IChhd2FpdCBjb3B5T3ZlcnJpZGVzKG92ZXJyaWRlcywgW1wiZGF0YVwiXSkpO1xuICAgICAgICB0eC50byA9IGF3YWl0IGNvbnRyYWN0LmdldEFkZHJlc3MoKTtcbiAgICAgICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSBhd2FpdCByZXNvbHZlQWRkcmVzcyh0eC5mcm9tLCBnZXRSZXNvbHZlcihjb250cmFjdC5ydW5uZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZmFjZSA9IGNvbnRyYWN0LmludGVyZmFjZTtcbiAgICAgICAgY29uc3Qgbm9WYWx1ZSA9IChnZXRCaWdJbnQoKHR4LnZhbHVlIHx8IEJOXzApLCBcIm92ZXJyaWRlcy52YWx1ZVwiKSA9PT0gQk5fMCk7XG4gICAgICAgIGNvbnN0IG5vRGF0YSA9ICgodHguZGF0YSB8fCBcIjB4XCIpID09PSBcIjB4XCIpO1xuICAgICAgICBpZiAoaWZhY2UuZmFsbGJhY2sgJiYgIWlmYWNlLmZhbGxiYWNrLnBheWFibGUgJiYgaWZhY2UucmVjZWl2ZSAmJiAhbm9EYXRhICYmICFub1ZhbHVlKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJjYW5ub3Qgc2VuZCBkYXRhIHRvIHJlY2VpdmUgb3Igc2VuZCB2YWx1ZSB0byBub24tcGF5YWJsZSBmYWxsYmFja1wiLCBcIm92ZXJyaWRlc1wiLCBvdmVycmlkZXMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGlmYWNlLmZhbGxiYWNrIHx8IG5vRGF0YSwgXCJjYW5ub3Qgc2VuZCBkYXRhIHRvIHJlY2VpdmUtb25seSBjb250cmFjdFwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIHR4LmRhdGEpO1xuICAgICAgICAvLyBPbmx5IGFsbG93IHBheWFibGUgY29udHJhY3RzIHRvIHNldCBub24temVybyB2YWx1ZVxuICAgICAgICBjb25zdCBwYXlhYmxlID0gaWZhY2UucmVjZWl2ZSB8fCAoaWZhY2UuZmFsbGJhY2sgJiYgaWZhY2UuZmFsbGJhY2sucGF5YWJsZSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHBheWFibGUgfHwgbm9WYWx1ZSwgXCJjYW5ub3Qgc2VuZCB2YWx1ZSB0byBub24tcGF5YWJsZSBmYWxsYmFja1wiLCBcIm92ZXJyaWRlcy52YWx1ZVwiLCB0eC52YWx1ZSk7XG4gICAgICAgIC8vIE9ubHkgYWxsb3cgZmFsbGJhY2sgY29udHJhY3RzIHRvIHNldCBub24tZW1wdHkgZGF0YVxuICAgICAgICBhc3NlcnRBcmd1bWVudChpZmFjZS5mYWxsYmFjayB8fCBub0RhdGEsIFwiY2Fubm90IHNlbmQgZGF0YSB0byByZWNlaXZlLW9ubHkgY29udHJhY3RcIiwgXCJvdmVycmlkZXMuZGF0YVwiLCB0eC5kYXRhKTtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH07XG4gICAgY29uc3Qgc3RhdGljQ2FsbCA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJjYWxsXCIpO1xuICAgICAgICBhc3NlcnQoY2FuQ2FsbChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGNhbGxpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiY2FsbFwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24ob3ZlcnJpZGVzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBydW5uZXIuY2FsbCh0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNDYWxsRXhjZXB0aW9uKGVycm9yKSAmJiBlcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY29udHJhY3QuaW50ZXJmYWNlLm1ha2VFcnJvcihlcnJvci5kYXRhLCB0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2VuZCA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gY29udHJhY3QucnVubmVyO1xuICAgICAgICBhc3NlcnQoY2FuU2VuZChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHNlbmRpbmcgdHJhbnNhY3Rpb25zXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHJ1bm5lci5zZW5kVHJhbnNhY3Rpb24oYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbihvdmVycmlkZXMpKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihjb250cmFjdC5ydW5uZXIpO1xuICAgICAgICAvLyBAVE9ETzogdGhlIHByb3ZpZGVyIGNhbiBiZSBudWxsOyBtYWtlIGEgY3VzdG9tIGR1bW15IHByb3ZpZGVyIHRoYXQgd2lsbCB0aHJvdyBhXG4gICAgICAgIC8vIG1lYW5pbmdmdWwgZXJyb3JcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UoY29udHJhY3QuaW50ZXJmYWNlLCBwcm92aWRlciwgdHgpO1xuICAgIH07XG4gICAgY29uc3QgZXN0aW1hdGVHYXMgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiZXN0aW1hdGVHYXNcIik7XG4gICAgICAgIGFzc2VydChjYW5Fc3RpbWF0ZShydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGdhcyBlc3RpbWF0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImVzdGltYXRlR2FzXCIgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCBydW5uZXIuZXN0aW1hdGVHYXMoYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbihvdmVycmlkZXMpKTtcbiAgICB9O1xuICAgIGNvbnN0IG1ldGhvZCA9IGFzeW5jIChvdmVycmlkZXMpID0+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlbmQob3ZlcnJpZGVzKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnRpZXMobWV0aG9kLCB7XG4gICAgICAgIF9jb250cmFjdDogY29udHJhY3QsXG4gICAgICAgIGVzdGltYXRlR2FzLFxuICAgICAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uLFxuICAgICAgICBzZW5kLCBzdGF0aWNDYWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkV3JhcHBlZE1ldGhvZChjb250cmFjdCwga2V5KSB7XG4gICAgY29uc3QgZ2V0RnJhZ21lbnQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRGdW5jdGlvbihrZXksIGFyZ3MpO1xuICAgICAgICBhc3NlcnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnJhZ21lbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICBpbmZvOiB7IGtleSwgYXJncyB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfTtcbiAgICBjb25zdCBwb3B1bGF0ZVRyYW5zYWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBnZXRGcmFnbWVudCguLi5hcmdzKTtcbiAgICAgICAgLy8gSWYgYW4gb3ZlcnJpZGVzIHdhcyBwYXNzZWQgaW4sIGNvcHkgaXQgYW5kIG5vcm1hbGl6ZSB0aGUgdmFsdWVzXG4gICAgICAgIGxldCBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggKyAxID09PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgb3ZlcnJpZGVzID0gYXdhaXQgY29weU92ZXJyaWRlcyhhcmdzLnBvcCgpKTtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZXMuZnJvbSkge1xuICAgICAgICAgICAgICAgIG92ZXJyaWRlcy5mcm9tID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3Mob3ZlcnJpZGVzLmZyb20sIGdldFJlc29sdmVyKGNvbnRyYWN0LnJ1bm5lcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoICE9PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJuYWwgZXJyb3I6IGZyYWdtZW50IGlucHV0cyBkb2Vzbid0IG1hdGNoIGFyZ3VtZW50czsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRBcmdzID0gYXdhaXQgcmVzb2x2ZUFyZ3MoY29udHJhY3QucnVubmVyLCBmcmFnbWVudC5pbnB1dHMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3ZlcnJpZGVzLCBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICB0bzogY29udHJhY3QuZ2V0QWRkcmVzcygpLFxuICAgICAgICAgICAgZGF0YTogY29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgcmVzb2x2ZWRBcmdzKVxuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNDYWxsID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RhdGljQ2FsbFJlc3VsdCguLi5hcmdzKTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGNvbnN0IHNlbmQgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBjb250cmFjdC5ydW5uZXI7XG4gICAgICAgIGFzc2VydChjYW5TZW5kKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc2VuZGluZyB0cmFuc2FjdGlvbnNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcnVubmVyLnNlbmRUcmFuc2FjdGlvbihhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKC4uLmFyZ3MpKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihjb250cmFjdC5ydW5uZXIpO1xuICAgICAgICAvLyBAVE9ETzogdGhlIHByb3ZpZGVyIGNhbiBiZSBudWxsOyBtYWtlIGEgY3VzdG9tIGR1bW15IHByb3ZpZGVyIHRoYXQgd2lsbCB0aHJvdyBhXG4gICAgICAgIC8vIG1lYW5pbmdmdWwgZXJyb3JcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UoY29udHJhY3QuaW50ZXJmYWNlLCBwcm92aWRlciwgdHgpO1xuICAgIH07XG4gICAgY29uc3QgZXN0aW1hdGVHYXMgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImVzdGltYXRlR2FzXCIpO1xuICAgICAgICBhc3NlcnQoY2FuRXN0aW1hdGUocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBnYXMgZXN0aW1hdGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJlc3RpbWF0ZUdhc1wiIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgcnVubmVyLmVzdGltYXRlR2FzKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24oLi4uYXJncykpO1xuICAgIH07XG4gICAgY29uc3Qgc3RhdGljQ2FsbFJlc3VsdCA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiY2FsbFwiKTtcbiAgICAgICAgYXNzZXJ0KGNhbkNhbGwocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBjYWxsaW5nXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImNhbGxcIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKC4uLmFyZ3MpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgcnVubmVyLmNhbGwodHgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikgJiYgZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNvbnRyYWN0LmludGVyZmFjZS5tYWtlRXJyb3IoZXJyb3IuZGF0YSwgdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBnZXRGcmFnbWVudCguLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgcmVzdWx0KTtcbiAgICB9O1xuICAgIGNvbnN0IG1ldGhvZCA9IGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XG4gICAgICAgIGlmIChmcmFnbWVudC5jb25zdGFudCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHN0YXRpY0NhbGwoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlbmQoLi4uYXJncyk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKG1ldGhvZCwge1xuICAgICAgICBuYW1lOiBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RnVuY3Rpb25OYW1lKGtleSksXG4gICAgICAgIF9jb250cmFjdDogY29udHJhY3QsIF9rZXk6IGtleSxcbiAgICAgICAgZ2V0RnJhZ21lbnQsXG4gICAgICAgIGVzdGltYXRlR2FzLFxuICAgICAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uLFxuICAgICAgICBzZW5kLCBzdGF0aWNDYWxsLCBzdGF0aWNDYWxsUmVzdWx0LFxuICAgIH0pO1xuICAgIC8vIE9ubHkgd29ya3Mgb24gbm9uLWFtYmlndW91cyBrZXlzIChyZWZpbmVkIGZyYWdtZW50IGlzIGFsd2F5cyBub24tYW1iaWd1b3VzKVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRob2QsIFwiZnJhZ21lbnRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEZ1bmN0aW9uKGtleSk7XG4gICAgICAgICAgICBhc3NlcnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnJhZ21lbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgICAgIGluZm86IHsga2V5IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkV3JhcHBlZEV2ZW50KGNvbnRyYWN0LCBrZXkpIHtcbiAgICBjb25zdCBnZXRGcmFnbWVudCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGtleSwgYXJncyk7XG4gICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgIGluZm86IHsga2V5LCBhcmdzIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9O1xuICAgIGNvbnN0IG1ldGhvZCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJlcGFyZWRUb3BpY0ZpbHRlcihjb250cmFjdCwgZ2V0RnJhZ21lbnQoLi4uYXJncyksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydGllcyhtZXRob2QsIHtcbiAgICAgICAgbmFtZTogY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50TmFtZShrZXkpLFxuICAgICAgICBfY29udHJhY3Q6IGNvbnRyYWN0LCBfa2V5OiBrZXksXG4gICAgICAgIGdldEZyYWdtZW50XG4gICAgfSk7XG4gICAgLy8gT25seSB3b3JrcyBvbiBub24tYW1iaWd1b3VzIGtleXMgKHJlZmluZWQgZnJhZ21lbnQgaXMgYWx3YXlzIG5vbi1hbWJpZ3VvdXMpXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGhvZCwgXCJmcmFnbWVudFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoa2V5KTtcbiAgICAgICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyBrZXkgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxuLy8gVGhlIGNvbWJpbmF0aW9uIG9mIFR5cGVTY3J5cGUsIFByaXZhdGUgRmllbGRzIGFuZCBQcm94aWVzIG1ha2VzXG4vLyB0aGUgd29ybGQgZ28gYm9vbTsgc28gd2UgaGlkZSB2YXJpYWJsZXMgd2l0aCBzb21lIHRyaWNrZXJ5IGtlZXBpbmdcbi8vIGEgc3ltYm9sIGF0dGFjaGVkIHRvIGVhY2ggQmFzZUNvbnRyYWN0IHdoaWNoIGl0cyBzdWItY2xhc3MgKGV2ZW5cbi8vIHZpYSBhIFByb3h5KSBjYW4gcmVhY2ggYW5kIHVzZSB0byBsb29rIHVwIGl0cyBpbnRlcm5hbCB2YWx1ZXMuXG5jb25zdCBpbnRlcm5hbCA9IFN5bWJvbC5mb3IoXCJfZXRoZXJzSW50ZXJuYWxfY29udHJhY3RcIik7XG5jb25zdCBpbnRlcm5hbFZhbHVlcyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBzZXRJbnRlcm5hbChjb250cmFjdCwgdmFsdWVzKSB7XG4gICAgaW50ZXJuYWxWYWx1ZXMuc2V0KGNvbnRyYWN0W2ludGVybmFsXSwgdmFsdWVzKTtcbn1cbmZ1bmN0aW9uIGdldEludGVybmFsKGNvbnRyYWN0KSB7XG4gICAgcmV0dXJuIGludGVybmFsVmFsdWVzLmdldChjb250cmFjdFtpbnRlcm5hbF0pO1xufVxuZnVuY3Rpb24gaXNEZWZlcnJlZCh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgKFwiZ2V0VG9waWNGaWx0ZXJcIiBpbiB2YWx1ZSkgJiZcbiAgICAgICAgKHR5cGVvZiAodmFsdWUuZ2V0VG9waWNGaWx0ZXIpID09PSBcImZ1bmN0aW9uXCIpICYmIHZhbHVlLmZyYWdtZW50KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFN1YkluZm8oY29udHJhY3QsIGV2ZW50KSB7XG4gICAgbGV0IHRvcGljcztcbiAgICBsZXQgZnJhZ21lbnQgPSBudWxsO1xuICAgIC8vIENvbnZlcnQgbmFtZWQgZXZlbnRzIHRvIHRvcGljSGFzaCBhbmQgZ2V0IHRoZSBmcmFnbWVudCBmb3JcbiAgICAvLyBldmVudHMgd2hpY2ggbmVlZCBkZWNvbnN0cnVjdGluZy5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgY29uc3QgdG9waWNIYXNoaWZ5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhuYW1lLCAzMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KG5hbWUpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJhZ21lbnQsIFwidW5rbm93biBmcmFnbWVudFwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQudG9waWNIYXNoO1xuICAgICAgICB9O1xuICAgICAgICAvLyBBcnJheSBvZiBUb3BpY3MgYW5kIE5hbWVzOyBlLmcuIGBbIFwiMHgxMjM0Li4uODlhYlwiLCBcIlRyYW5zZmVyKGFkZHJlc3MpXCIgXWBcbiAgICAgICAgdG9waWNzID0gZXZlbnQubWFwKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLm1hcCh0b3BpY0hhc2hpZnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvcGljSGFzaGlmeShlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50ID09PSBcIipcIikge1xuICAgICAgICB0b3BpY3MgPSBbbnVsbF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAoZXZlbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChpc0hleFN0cmluZyhldmVudCwgMzIpKSB7XG4gICAgICAgICAgICAvLyBUb3BpYyBIYXNoXG4gICAgICAgICAgICB0b3BpY3MgPSBbZXZlbnRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTmFtZSBvciBTaWduYXR1cmU7IGUuZy4gYFwiVHJhbnNmZXJcIiwgYFwiVHJhbnNmZXIoYWRkcmVzcylcImBcbiAgICAgICAgICAgIGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcInVua25vd24gZnJhZ21lbnRcIiwgXCJldmVudFwiLCBldmVudCk7XG4gICAgICAgICAgICB0b3BpY3MgPSBbZnJhZ21lbnQudG9waWNIYXNoXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0RlZmVycmVkKGV2ZW50KSkge1xuICAgICAgICAvLyBEZWZlcnJlZCBUb3BpYyBGaWx0ZXI7IGUuZy4gYGNvbnRyYWN0LmZpbHRlci5UcmFuc2Zlcihmcm9tKWBcbiAgICAgICAgdG9waWNzID0gYXdhaXQgZXZlbnQuZ2V0VG9waWNGaWx0ZXIoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJmcmFnbWVudFwiIGluIGV2ZW50KSB7XG4gICAgICAgIC8vIENvbnRyYWN0RXZlbnQ7IGUuZy4gYGNvbnRyYWN0LmZpbHRlci5UcmFuc2ZlcmBcbiAgICAgICAgZnJhZ21lbnQgPSBldmVudC5mcmFnbWVudDtcbiAgICAgICAgdG9waWNzID0gW2ZyYWdtZW50LnRvcGljSGFzaF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bmtub3duIGV2ZW50IG5hbWVcIiwgXCJldmVudFwiLCBldmVudCk7XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSB0b3BpY3MgYW5kIHNvcnQgVG9waWNTZXRzXG4gICAgdG9waWNzID0gdG9waWNzLm1hcCgodCkgPT4ge1xuICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKG5ldyBTZXQodC5tYXAoKHQpID0+IHQudG9Mb3dlckNhc2UoKSkpLnZhbHVlcygpKTtcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtcy5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcbiAgICBjb25zdCB0YWcgPSB0b3BpY3MubWFwKCh0KSA9PiB7XG4gICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHQuam9pbihcInxcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSkuam9pbihcIiZcIik7XG4gICAgcmV0dXJuIHsgZnJhZ21lbnQsIHRhZywgdG9waWNzIH07XG59XG5hc3luYyBmdW5jdGlvbiBoYXNTdWIoY29udHJhY3QsIGV2ZW50KSB7XG4gICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbChjb250cmFjdCk7XG4gICAgcmV0dXJuIHN1YnMuZ2V0KChhd2FpdCBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCkpLnRhZykgfHwgbnVsbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFN1Yihjb250cmFjdCwgb3BlcmF0aW9uLCBldmVudCkge1xuICAgIC8vIE1ha2Ugc3VyZSBvdXIgcnVubmVyIGNhbiBhY3R1YWxseSBzdWJzY3JpYmUgdG8gZXZlbnRzXG4gICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihjb250cmFjdC5ydW5uZXIpO1xuICAgIGFzc2VydChwcm92aWRlciwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzdWJzY3JpYmluZ1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbiB9KTtcbiAgICBjb25zdCB7IGZyYWdtZW50LCB0YWcsIHRvcGljcyB9ID0gYXdhaXQgZ2V0U3ViSW5mbyhjb250cmFjdCwgZXZlbnQpO1xuICAgIGNvbnN0IHsgYWRkciwgc3VicyB9ID0gZ2V0SW50ZXJuYWwoY29udHJhY3QpO1xuICAgIGxldCBzdWIgPSBzdWJzLmdldCh0YWcpO1xuICAgIGlmICghc3ViKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSAoYWRkciA/IGFkZHIgOiBjb250cmFjdCk7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHsgYWRkcmVzcywgdG9waWNzIH07XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKGxvZykgPT4ge1xuICAgICAgICAgICAgbGV0IGZvdW5kRnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWdtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZEZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgZnJhZ21lbnQgaXMgbnVsbCwgd2UgZG8gbm90IGRlY29uc3RydWN0IHRoZSBhcmdzIHRvIGVtaXRcbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2ZvdW5kRnJhZ21lbnQgPSBmb3VuZEZyYWdtZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBmcmFnbWVudCA/IGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpIDogW107XG4gICAgICAgICAgICAgICAgZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0RXZlbnRQYXlsb2FkKGNvbnRyYWN0LCBsaXN0ZW5lciwgZXZlbnQsIF9mb3VuZEZyYWdtZW50LCBsb2cpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW1pdChjb250cmFjdCwgZXZlbnQsIFtdLCAobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFVua25vd25FdmVudFBheWxvYWQoY29udHJhY3QsIGxpc3RlbmVyLCBldmVudCwgbG9nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHN0YXJ0aW5nID0gW107XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXJ0aW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0aW5nLnB1c2gocHJvdmlkZXIub24oZmlsdGVyLCBsaXN0ZW5lcikpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdG9wID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXJ0aW5nLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0ZWQgPSBzdGFydGluZztcbiAgICAgICAgICAgIHN0YXJ0aW5nID0gW107XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChzdGFydGVkKTtcbiAgICAgICAgICAgIHByb3ZpZGVyLm9mZihmaWx0ZXIsIGxpc3RlbmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3ViID0geyB0YWcsIGxpc3RlbmVyczogW10sIHN0YXJ0LCBzdG9wIH07XG4gICAgICAgIHN1YnMuc2V0KHRhZywgc3ViKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Yjtcbn1cbi8vIFdlIHVzZSB0aGlzIHRvIGVuc3VyZSBvbmUgZW1pdCByZXNvbHZlcyBiZWZvcmUgZmlyaW5nIHRoZSBuZXh0IHRvXG4vLyBlbnN1cmUgY29ycmVjdCBvcmRlcmluZyAobm90ZSB0aGlzIGNhbm5vdCB0aHJvdyBhbmQganVzdCBhZGRzIHRoZVxuLy8gbm90aWNlIHRvIHRoZSBldmVudCBxdWV1IHVzaW5nIHNldFRpbWVvdXQpLlxubGV0IGxhc3RFbWl0ID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5hc3luYyBmdW5jdGlvbiBfZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIHBheWxvYWRGdW5jKSB7XG4gICAgYXdhaXQgbGFzdEVtaXQ7XG4gICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKGNvbnRyYWN0LCBldmVudCk7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb3VudCA9IHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgIHN1Yi5saXN0ZW5lcnMgPSBzdWIubGlzdGVuZXJzLmZpbHRlcigoeyBsaXN0ZW5lciwgb25jZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhc3NBcmdzID0gQXJyYXkuZnJvbShhcmdzKTtcbiAgICAgICAgaWYgKHBheWxvYWRGdW5jKSB7XG4gICAgICAgICAgICBwYXNzQXJncy5wdXNoKHBheWxvYWRGdW5jKG9uY2UgPyBudWxsIDogbGlzdGVuZXIpKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbChjb250cmFjdCwgLi4ucGFzc0FyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiAhb25jZTtcbiAgICB9KTtcbiAgICBpZiAoc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3ViLnN0b3AoKTtcbiAgICAgICAgZ2V0SW50ZXJuYWwoY29udHJhY3QpLnN1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgIH1cbiAgICByZXR1cm4gKGNvdW50ID4gMCk7XG59XG5hc3luYyBmdW5jdGlvbiBlbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgcGF5bG9hZEZ1bmMpIHtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBsYXN0RW1pdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICBjb25zdCByZXN1bHRQcm9taXNlID0gX2VtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCBwYXlsb2FkRnVuYyk7XG4gICAgbGFzdEVtaXQgPSByZXN1bHRQcm9taXNlO1xuICAgIHJldHVybiBhd2FpdCByZXN1bHRQcm9taXNlO1xufVxuY29uc3QgcGFzc1Byb3BlcnRpZXMgPSBbXCJ0aGVuXCJdO1xuZXhwb3J0IGNsYXNzIEJhc2VDb250cmFjdCB7XG4gICAgLyoqXG4gICAgICogIFRoZSB0YXJnZXQgdG8gY29ubmVjdCB0by5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiBiZSBhbiBhZGRyZXNzLCBFTlMgbmFtZSBvciBhbnkgW1tBZGRyZXNzYWJsZV1dLCBzdWNoIGFzXG4gICAgICogIGFub3RoZXIgY29udHJhY3QuIFRvIGdldCB0aGUgcmVzb3ZsZWQgYWRkcmVzcywgdXNlIHRoZSBgYGdldEFkZHJlc3NgYFxuICAgICAqICBtZXRob2QuXG4gICAgICovXG4gICAgdGFyZ2V0O1xuICAgIC8qKlxuICAgICAqICBUaGUgY29udHJhY3QgSW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGludGVyZmFjZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbm5lY3RlZCBydW5uZXIuIFRoaXMgaXMgZ2VuZXJhbGx5IGEgW1tQcm92aWRlcl1dIG9yIGFcbiAgICAgKiAgW1tTaWduZXJdXSwgd2hpY2ggZGljdGF0ZXMgd2hhdCBvcGVyYXRpb25zIGFyZSBzdXBwb3J0ZWQuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsIGEgKipDb250cmFjdCoqIGNvbm5lY3RlZCB0byBhIFtbUHJvdmlkZXJdXSBtYXlcbiAgICAgKiAgb25seSBleGVjdXRlIHJlYWQtb25seSBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIHJ1bm5lcjtcbiAgICAvKipcbiAgICAgKiAgQWxsIHRoZSBFdmVudHMgYXZhaWxhYmxlIG9uIHRoaXMgY29udHJhY3QuXG4gICAgICovXG4gICAgZmlsdGVycztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgW2ludGVybmFsXTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZhbGxiYWNrIG9yIHJlY2VpdmUgZnVuY3Rpb24gaWYgYW55LlxuICAgICAqL1xuICAgIGZhbGxiYWNrO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IGNvbnRyYWN0IGNvbm5lY3RlZCB0byAlJXRhcmdldCUlIHdpdGggdGhlICUlYWJpJSUgYW5kXG4gICAgICogIG9wdGlvbmFsbHkgY29ubmVjdGVkIHRvIGEgJSVydW5uZXIlJSB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gYmVoYWxmXG4gICAgICogIG9mLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgYWJpLCBydW5uZXIsIF9kZXBsb3lUeCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIgfHwgaXNBZGRyZXNzYWJsZSh0YXJnZXQpLCBcImludmFsaWQgdmFsdWUgZm9yIENvbnRyYWN0IHRhcmdldFwiLCBcInRhcmdldFwiLCB0YXJnZXQpO1xuICAgICAgICBpZiAocnVubmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJ1bm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWZhY2UgPSBJbnRlcmZhY2UuZnJvbShhYmkpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgdGFyZ2V0LCBydW5uZXIsIGludGVyZmFjZTogaWZhY2UgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZToge30gfSk7XG4gICAgICAgIGxldCBhZGRyUHJvbWlzZTtcbiAgICAgICAgbGV0IGFkZHIgPSBudWxsO1xuICAgICAgICBsZXQgZGVwbG95VHggPSBudWxsO1xuICAgICAgICBpZiAoX2RlcGxveVR4KSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHJ1bm5lcik7XG4gICAgICAgICAgICAvLyBAVE9ETzogdGhlIHByb3ZpZGVyIGNhbiBiZSBudWxsOyBtYWtlIGEgY3VzdG9tIGR1bW15IHByb3ZpZGVyIHRoYXQgd2lsbCB0aHJvdyBhXG4gICAgICAgICAgICAvLyBtZWFuaW5nZnVsIGVycm9yXG4gICAgICAgICAgICBkZXBsb3lUeCA9IG5ldyBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UodGhpcy5pbnRlcmZhY2UsIHByb3ZpZGVyLCBfZGVwbG95VHgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBSZXNvbHZlIHRoZSB0YXJnZXQgYXMgdGhlIGFkZHJlc3NcbiAgICAgICAgaWYgKHR5cGVvZiAodGFyZ2V0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBhZGRyID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIGFkZHJQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IGdldFJ1bm5lcihydW5uZXIsIFwicmVzb2x2ZU5hbWVcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5SZXNvbHZlKHJlc29sdmVyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBtYWtlRXJyb3IoXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBuYW1lIHJlc29sdXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZHJQcm9taXNlID0gcmVzb2x2ZXIucmVzb2x2ZU5hbWUodGFyZ2V0KS50aGVuKChhZGRyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG1ha2VFcnJvcihcImFuIEVOUyBuYW1lIHVzZWQgZm9yIGEgY29udHJhY3QgdGFyZ2V0IG11c3QgYmUgY29ycmVjdGx5IGNvbmZpZ3VyZWRcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuYWRkciA9IGFkZHI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWRkclByb21pc2UgPSB0YXJnZXQuZ2V0QWRkcmVzcygpLnRoZW4oKGFkZHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLmFkZHIgPSBhZGRyO1xuICAgICAgICAgICAgICAgIHJldHVybiBhZGRyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IG91ciBwcml2YXRlIHZhbHVlc1xuICAgICAgICBzZXRJbnRlcm5hbCh0aGlzLCB7IGFkZHJQcm9taXNlLCBhZGRyLCBkZXBsb3lUeCwgc3VicyB9KTtcbiAgICAgICAgLy8gQWRkIHRoZSBldmVudCBmaWx0ZXJzXG4gICAgICAgIGNvbnN0IGZpbHRlcnMgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQYXNzIGltcG9ydGFudCBjaGVja3MgKGxpa2UgYHRoZW5gIGZvciBQcm9taXNlKSB0aHJvdWdoXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3ltYm9sXCIgfHwgcGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXZlbnQocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRXJyb3IoZXJyb3IsIFwiSU5WQUxJRF9BUkdVTUVOVFwiKSB8fCBlcnJvci5hcmd1bWVudCAhPT0gXCJrZXlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXM6ICh0YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQYXNzIGltcG9ydGFudCBjaGVja3MgKGxpa2UgYHRoZW5gIGZvciBQcm9taXNlKSB0aHJvdWdoXG4gICAgICAgICAgICAgICAgaWYgKHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCkgfHwgdGhpcy5pbnRlcmZhY2UuaGFzRXZlbnQoU3RyaW5nKHByb3ApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBmaWx0ZXJzIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGZhbGxiYWNrOiAoKGlmYWNlLnJlY2VpdmUgfHwgaWZhY2UuZmFsbGJhY2spID8gKGJ1aWxkV3JhcHBlZEZhbGxiYWNrKHRoaXMpKSA6IG51bGwpXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZXR1cm4gYSBQcm94eSB0aGF0IHdpbGwgcmVzcG9uZCB0byBmdW5jdGlvbnNcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh0aGlzLCB7XG4gICAgICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3ltYm9sXCIgfHwgcHJvcCBpbiB0YXJnZXQgfHwgcGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5kZWZpbmVkIHByb3BlcnRpZXMgc2hvdWxkIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmdldEZ1bmN0aW9uKHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIklOVkFMSURfQVJHVU1FTlRcIikgfHwgZXJyb3IuYXJndW1lbnQgIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3ltYm9sXCIgfHwgcHJvcCBpbiB0YXJnZXQgfHwgcGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmludGVyZmFjZS5oYXNGdW5jdGlvbihwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgQ29udHJhY3QgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSB0YXJnZXQgYW5kIEFCSSwgYnV0XG4gICAgICogIGEgZGlmZmVyZW50ICUlcnVubmVyJSUuXG4gICAgICovXG4gICAgY29ubmVjdChydW5uZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlQ29udHJhY3QodGhpcy50YXJnZXQsIHRoaXMuaW50ZXJmYWNlLCBydW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IENvbnRyYWN0IGluc3RhbmNlIHdpdGggdGhlIHNhbWUgQUJJIGFuZCBydW5uZXIsIGJ1dFxuICAgICAqICBhIGRpZmZlcmVudCAlJXRhcmdldCUlLlxuICAgICAqL1xuICAgIGF0dGFjaCh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlQ29udHJhY3QodGFyZ2V0LCB0aGlzLmludGVyZmFjZSwgdGhpcy5ydW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSByZXNvbHZlZCBhZGRyZXNzIG9mIHRoaXMgQ29udHJhY3QuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWRkcmVzcygpIHsgcmV0dXJuIGF3YWl0IGdldEludGVybmFsKHRoaXMpLmFkZHJQcm9taXNlOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZGVwbG95ZWQgYnl0ZWNvZGUgb3IgbnVsbCBpZiBubyBieXRlY29kZSBpcyBmb3VuZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXREZXBsb3llZENvZGUoKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICBhc3NlcnQocHJvdmlkZXIsIFwicnVubmVyIGRvZXMgbm90IHN1cHBvcnQgLnByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImdldERlcGxveWVkQ29kZVwiIH0pO1xuICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgcHJvdmlkZXIuZ2V0Q29kZShhd2FpdCB0aGlzLmdldEFkZHJlc3MoKSk7XG4gICAgICAgIGlmIChjb2RlID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGlzIENvbnRyYWN0IG9uY2UgdGhlIGJ5dGVjb2RlIGhhcyBiZWVuIGRlcGxveWVkLCBvclxuICAgICAqICByZXNvbHZlIGltbWVkaWF0ZWx5IGlmIGFscmVhZHkgZGVwbG95ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdEZvckRlcGxveW1lbnQoKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdGhlIGRlcGxveWVtZW50IHRyYW5zYWN0aW9uOyBqdXN0IHVzZSB0aGF0ICh0aHJvd3MgaWYgZGVwbG95ZW1lbnQgZmFpbHMpXG4gICAgICAgIGNvbnN0IGRlcGxveVR4ID0gdGhpcy5kZXBsb3ltZW50VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgaWYgKGRlcGxveVR4KSB7XG4gICAgICAgICAgICBhd2FpdCBkZXBsb3lUeC53YWl0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3IgY29kZVxuICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgdGhpcy5nZXREZXBsb3llZENvZGUoKTtcbiAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGNhbiBzdWJzY3JpYmUgdG8gYSBwcm92aWRlciBldmVudFxuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgYXNzZXJ0KHByb3ZpZGVyICE9IG51bGwsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgLnByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIndhaXRGb3JEZXBsb3ltZW50XCIgfSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGVja0NvZGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHRoaXMuZ2V0RGVwbG95ZWRDb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCBjaGVja0NvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2hlY2tDb2RlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSB0cmFuc2FjdGlvbiB1c2VkIHRvIGRlcGxveSB0aGlzIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgb25seSBhdmFpbGFibGUgaWYgdGhpcyBpbnN0YW5jZSB3YXMgcmV0dXJuZWQgZnJvbSBhXG4gICAgICogIFtbQ29udHJhY3RGYWN0b3J5XV0uXG4gICAgICovXG4gICAgZGVwbG95bWVudFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWwodGhpcykuZGVwbG95VHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG5hbWUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBjb250cmFjdFxuICAgICAqICBtZXRob2QgbmFtZSBjb25mbGljdHMgd2l0aCBhIEphdmFTY3JpcHQgbmFtZSBzdWNoIGFzIGBgcHJvdG90eXBlYGAgb3JcbiAgICAgKiAgd2hlbiB1c2luZyBhIENvbnRyYWN0IHByb2dyYW1hdGljYWxseS5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoa2V5KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAga2V5ID0ga2V5LmZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBidWlsZFdyYXBwZWRNZXRob2QodGhpcywga2V5KTtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGV2ZW50IGZvciBhIGdpdmVuIG5hbWUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBjb250cmFjdFxuICAgICAqICBldmVudCBuYW1lIGNvbmZsaWN0cyB3aXRoIGEgSmF2YVNjcmlwdCBuYW1lIHN1Y2ggYXMgYGBwcm90b3R5cGVgYCBvclxuICAgICAqICB3aGVuIHVzaW5nIGEgQ29udHJhY3QgcHJvZ3JhbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIGdldEV2ZW50KGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIChrZXkpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuZm9ybWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkV3JhcHBlZEV2ZW50KHRoaXMsIGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBhc3luYyBxdWVyeVRyYW5zYWN0aW9uKGhhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgfVxuICAgIC8qXG4gICAgLy8gQFRPRE86IHRoaXMgaXMgYSBub24tYmFja3dhcmRzIGNvbXBhdGlibGUgY2hhbmdlLCBidXQgd2lsbCBiZSBhZGRlZFxuICAgIC8vICAgICAgICBpbiB2NyBhbmQgaW4gYSBwb3RlbnRpYWwgU21hcnRDb250cmFjdCBjbGFzcyBpbiBhbiB1cGNvbWluZ1xuICAgIC8vICAgICAgICB2NiByZWxlYXNlXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2g6IHN0cmluZyk6IFByb21pc2U8bnVsbCB8IENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0PiB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICBhc3NlcnQocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IGhhdmUgYSBwcm92aWRlclwiLFxuICAgICAgICAgICAgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicXVlcnlUcmFuc2FjdGlvblwiIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMuaW50ZXJmYWNlLCBwcm92aWRlciwgcmVjZWlwdCk7XG4gICAgfVxuICAgICovXG4gICAgLyoqXG4gICAgICogIFByb3ZpZGUgaGlzdG9yaWMgYWNjZXNzIHRvIGV2ZW50IGRhdGEgZm9yICUlZXZlbnQlJSBpbiB0aGUgcmFuZ2VcbiAgICAgKiAgJSVmcm9tQmxvY2slJSAoZGVmYXVsdDogYGAwYGApIHRvICUldG9CbG9jayUlIChkZWZhdWx0OiBgYFwibGF0ZXN0XCJgYClcbiAgICAgKiAgaW5jbHVzaXZlLlxuICAgICAqL1xuICAgIGFzeW5jIHF1ZXJ5RmlsdGVyKGV2ZW50LCBmcm9tQmxvY2ssIHRvQmxvY2spIHtcbiAgICAgICAgaWYgKGZyb21CbG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICBmcm9tQmxvY2sgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b0Jsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRvQmxvY2sgPSBcImxhdGVzdFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYWRkciwgYWRkclByb21pc2UgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gKGFkZHIgPyBhZGRyIDogKGF3YWl0IGFkZHJQcm9taXNlKSk7XG4gICAgICAgIGNvbnN0IHsgZnJhZ21lbnQsIHRvcGljcyB9ID0gYXdhaXQgZ2V0U3ViSW5mbyh0aGlzLCBldmVudCk7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHsgYWRkcmVzcywgdG9waWNzLCBmcm9tQmxvY2ssIHRvQmxvY2sgfTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgIGFzc2VydChwcm92aWRlciwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3QgaGF2ZSBhIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInF1ZXJ5RmlsdGVyXCIgfSk7XG4gICAgICAgIHJldHVybiAoYXdhaXQgcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpKS5tYXAoKGxvZykgPT4ge1xuICAgICAgICAgICAgbGV0IGZvdW5kRnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWdtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZEZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRMb2cobG9nLCB0aGlzLmludGVyZmFjZSwgZm91bmRGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVuZGVjb2RlZEV2ZW50TG9nKGxvZywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9nKGxvZywgcHJvdmlkZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFkZCBhbiBldmVudCAlJWxpc3RlbmVyJSUgZm9yIHRoZSAlJWV2ZW50JSUuXG4gICAgICovXG4gICAgYXN5bmMgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGdldFN1Yih0aGlzLCBcIm9uXCIsIGV2ZW50KTtcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IGZhbHNlIH0pO1xuICAgICAgICBzdWIuc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBZGQgYW4gZXZlbnQgJSVsaXN0ZW5lciUlIGZvciB0aGUgJSVldmVudCUlLCBidXQgcmVtb3ZlIHRoZSBsaXN0ZW5lclxuICAgICAqICBhZnRlciBpdCBpcyBmaXJlZCBvbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGdldFN1Yih0aGlzLCBcIm9uY2VcIiwgZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgc3ViLnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW1pdCBhbiAlJWV2ZW50JSUgY2FsbGluZyBhbGwgbGlzdGVuZXJzIHdpdGggJSVhcmdzJSUuXG4gICAgICpcbiAgICAgKiAgUmVzb2x2ZXMgdG8gYGB0cnVlYGAgaWYgYW55IGxpc3RlbmVycyB3ZXJlIGNhbGxlZC5cbiAgICAgKi9cbiAgICBhc3luYyBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBlbWl0KHRoaXMsIGV2ZW50LCBhcmdzLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIG9mICUlZXZlbnQlJSBvciB0aGUgdG90YWwgbnVtYmVyXG4gICAgICogIG9mIGxpc3RlbmVycyBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3ViLmxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgZm9yIChjb25zdCB7IGxpc3RlbmVycyB9IG9mIHN1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHRvdGFsICs9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGxpc3RlbmVycyBzdWJzY3JpYmVkIHRvICUlZXZlbnQlJSBvciBhbGwgbGlzdGVuZXJzXG4gICAgICogIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2Ygc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChsaXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlbW92ZSB0aGUgJSVsaXN0ZW5lciUlIGZyb20gdGhlIGxpc3RlbmVycyBmb3IgJSVldmVudCUlIG9yIHJlbW92ZVxuICAgICAqICBhbGwgbGlzdGVuZXJzIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIG9mZihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcikuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHN1Yi5saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCB8fCBzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc3ViLnN0b3AoKTtcbiAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLnN1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIGZvciAlJWV2ZW50JSUgb3IgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgaWZcbiAgICAgKiAgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWIuc3RvcCgpO1xuICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IHRhZywgc3RvcCB9IG9mIHN1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgc3Vicy5kZWxldGUodGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFsaWFzIGZvciBbb25dLlxuICAgICAqL1xuICAgIGFzeW5jIGFkZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxpYXMgZm9yIFtvZmZdLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBDbGFzcyBmb3IgdGhlICUlYWJpJSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ1aWxkQ2xhc3MoYWJpKSB7XG4gICAgICAgIGNsYXNzIEN1c3RvbUNvbnRyYWN0IGV4dGVuZHMgQmFzZUNvbnRyYWN0IHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHJ1bm5lciA9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdXBlcihhZGRyZXNzLCBhYmksIHJ1bm5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEN1c3RvbUNvbnRyYWN0O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBCYXNlQ29udHJhY3Qgd2l0aCBhIHNwZWNpZmllZCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odGFyZ2V0LCBhYmksIHJ1bm5lcikge1xuICAgICAgICBpZiAocnVubmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJ1bm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgdGhpcyh0YXJnZXQsIGFiaSwgcnVubmVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9Db250cmFjdEJhc2UoKSB7XG4gICAgcmV0dXJuIEJhc2VDb250cmFjdDtcbn1cbi8qKlxuICogIEEgW1tCYXNlQ29udHJhY3RdXSB3aXRoIG5vIHR5cGUgZ3VhcmRzIG9uIGl0cyBtZXRob2RzIG9yIGV2ZW50cy5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0IGV4dGVuZHMgX0NvbnRyYWN0QmFzZSgpIHtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRyYWN0LmpzLm1hcCIsIi8qKlxuICogIEVOUyBpcyBhIHNlcnZpY2Ugd2hpY2ggYWxsb3dzIGVhc3ktdG8tcmVtZW1iZXIgbmFtZXMgdG8gbWFwIHRvXG4gKiAgbmV0d29yayBhZGRyZXNzZXMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9lbnMtcmVzb2x2ZXI6RU5TIFJlc29sdmVyICBbYWJvdXQtZW5zLXJzb2x2ZXJdXG4gKi9cbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgWmVyb0FkZHJlc3MgfSBmcm9tIFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDb250cmFjdCB9IGZyb20gXCIuLi9jb250cmFjdC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZG5zRW5jb2RlLCBuYW1laGFzaCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBoZXhsaWZ5LCBpc0hleFN0cmluZywgdG9CZUhleCwgZGVmaW5lUHJvcGVydGllcywgZW5jb2RlQmFzZTU4LCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBpc0Vycm9yLCBGZXRjaFJlcXVlc3QgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8vIEBUT0RPOiBUaGlzIHNob3VsZCB1c2UgdGhlIGZldGNoLWRhdGE6aXBmcyBnYXRld2F5XG4vLyBUcmltIG9mZiB0aGUgaXBmczovLyBwcmVmaXggYW5kIHJldHVybiB0aGUgZGVmYXVsdCBnYXRld2F5IFVSTFxuZnVuY3Rpb24gZ2V0SXBmc0xpbmsobGluaykge1xuICAgIGlmIChsaW5rLm1hdGNoKC9eaXBmczpcXC9cXC9pcGZzXFwvL2kpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZygxMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcLy9pKSkge1xuICAgICAgICBsaW5rID0gbGluay5zdWJzdHJpbmcoNyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBJUEZTIGZvcm1hdFwiLCBcImxpbmtcIiwgbGluayk7XG4gICAgfVxuICAgIHJldHVybiBgaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzLyR7bGlua31gO1xufVxuO1xuO1xuLyoqXG4gKiAgQSBwcm92aWRlciBwbHVnaW4gc3VwZXItY2xhc3MgZm9yIHByb2Nlc3NpbmcgbXVsdGljb2luIGFkZHJlc3MgdHlwZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBNdWx0aWNvaW5Qcm92aWRlclBsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipNdWx0aWNvaW5Qcm92aWRlclBsdWluZyoqIGZvciAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KHByb2l2ZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBpZiAlJWNvaW5UeXBlJSUgaXMgc3VwcG9ydGVkIGJ5IHRoaXMgcGx1Z2luLlxuICAgICAqL1xuICAgIHN1cHBvcnRzQ29pblR5cGUoY29pblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb3ZsZXMgdG8gdGhlIGVuY29kZWQgJSVhZGRyZXNzJSUgZm9yICUlY29pblR5cGUlJS5cbiAgICAgKi9cbiAgICBhc3luYyBlbmNvZGVBZGRyZXNzKGNvaW5UeXBlLCBhZGRyZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGNvaW5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvdmxlcyB0byB0aGUgZGVjb2RlZCAlJWRhdGElJSBmb3IgJSVjb2luVHlwZSUlLlxuICAgICAqL1xuICAgIGFzeW5jIGRlY29kZUFkZHJlc3MoY29pblR5cGUsIGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgY29pblwiKTtcbiAgICB9XG59XG5jb25zdCBCYXNpY011bHRpY29pblBsdWdpbklkID0gXCJvcmcuZXRoZXJzLnBsdWdpbnMucHJvdmlkZXIuQmFzaWNNdWx0aWNvaW5cIjtcbi8qKlxuICogIEEgKipCYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luKiogcHJvdmlkZXMgc2VydmljZSBmb3IgY29tbW9uXG4gKiAgY29pbiB0eXBlcywgd2hpY2ggZG8gbm90IHJlcXVpcmUgYWRkaXRpb25hbCBsaWJyYXJpZXMgdG8gZW5jb2RlIG9yXG4gKiAgZGVjb2RlLlxuICovXG5leHBvcnQgY2xhc3MgQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbiBleHRlbmRzIE11bHRpY29pblByb3ZpZGVyUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4qKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoQmFzaWNNdWx0aWNvaW5QbHVnaW5JZCk7XG4gICAgfVxufVxuY29uc3QgbWF0Y2hlcklwZnMgPSBuZXcgUmVnRXhwKFwiXihpcGZzKTovXFwvKC4qKSRcIiwgXCJpXCIpO1xuY29uc3QgbWF0Y2hlcnMgPSBbXG4gICAgbmV3IFJlZ0V4cChcIl4oaHR0cHMpOi9cXC8oLiopJFwiLCBcImlcIiksXG4gICAgbmV3IFJlZ0V4cChcIl4oZGF0YSk6KC4qKSRcIiwgXCJpXCIpLFxuICAgIG1hdGNoZXJJcGZzLFxuICAgIG5ldyBSZWdFeHAoXCJeZWlwMTU1OlswLTldKy8oZXJjWzAtOV0rKTooLiopJFwiLCBcImlcIiksXG5dO1xuLyoqXG4gKiAgQSBjb25uZWN0ZWQgb2JqZWN0IHRvIGEgcmVzb2x2ZWQgRU5TIG5hbWUgcmVzb2x2ZXIsIHdoaWNoIGNhbiBiZVxuICogIHVzZWQgdG8gcXVlcnkgYWRkaXRpb25hbCBkZXRhaWxzLlxuICovXG5leHBvcnQgY2xhc3MgRW5zUmVzb2x2ZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgY29ubmVjdGVkIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgcmVzb2x2ZXIuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgdGhpcyByZXNvbHZlciB3YXMgcmVzb2x2ZWQgYWdhaW5zdC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8vIEZvciBFSVAtMjU0NCBuYW1lcywgdGhlIGFuY2VzdG9yIHRoYXQgcHJvdmlkZWQgdGhlIHJlc29sdmVyXG4gICAgI3N1cHBvcnRzMjU0NDtcbiAgICAjcmVzb2x2ZXI7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHByb3ZpZGVyLCBhZGRyZXNzLCBuYW1lIH0pO1xuICAgICAgICB0aGlzLiNzdXBwb3J0czI1NDQgPSBudWxsO1xuICAgICAgICB0aGlzLiNyZXNvbHZlciA9IG5ldyBDb250cmFjdChhZGRyZXNzLCBbXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHN1cHBvcnRzSW50ZXJmYWNlKGJ5dGVzNCkgdmlldyByZXR1cm5zIChib29sKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiByZXNvbHZlKGJ5dGVzLCBieXRlcykgdmlldyByZXR1cm5zIChieXRlcylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gYWRkcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIGFkZHIoYnl0ZXMzMiwgdWludCkgdmlldyByZXR1cm5zIChieXRlcylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gdGV4dChieXRlczMyLCBzdHJpbmcpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiBjb250ZW50aGFzaChieXRlczMyKSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxuICAgICAgICBdLCBwcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0cnVlIGlmIHRoZSByZXNvbHZlciBzdXBwb3J0cyB3aWxkY2FyZCByZXNvbHV0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHN1cHBvcnRzV2lsZGNhcmQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNzdXBwb3J0czI1NDQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jc3VwcG9ydHMyNTQ0ID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcmVzb2x2ZXIuc3VwcG9ydHNJbnRlcmZhY2UoXCIweDkwNjFiOTIzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2lsZGNhcmQgcmVzb2x2ZXJzIG11c3QgdW5kZXJzdGFuZCBzdXBwb3J0c0ludGVyZmFjZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcmV0dXJuIHRydWUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTGV0IGZ1dHVyZSBhdHRlbXB0cyB0cnkgYWdhaW4uLi5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jc3VwcG9ydHMyNTQ0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jc3VwcG9ydHMyNTQ0O1xuICAgIH1cbiAgICBhc3luYyAjZmV0Y2goZnVuY05hbWUsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSAocGFyYW1zIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBjb25zdCBpZmFjZSA9IHRoaXMuI3Jlc29sdmVyLmludGVyZmFjZTtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBhcmFtZXRlcnMgaXMgYWx3YXlzIHRoZSBub2RlaGFzaFxuICAgICAgICBwYXJhbXMudW5zaGlmdChuYW1laGFzaCh0aGlzLm5hbWUpKTtcbiAgICAgICAgbGV0IGZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuc3VwcG9ydHNXaWxkY2FyZCgpKSB7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGlmYWNlLmdldEZ1bmN0aW9uKGZ1bmNOYW1lKTtcbiAgICAgICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJtaXNzaW5nIGZyYWdtZW50XCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7XG4gICAgICAgICAgICAgICAgaW5mbzogeyBmdW5jTmFtZSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcmFtcyA9IFtcbiAgICAgICAgICAgICAgICBkbnNFbmNvZGUodGhpcy5uYW1lKSxcbiAgICAgICAgICAgICAgICBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHBhcmFtcylcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBmdW5jTmFtZSA9IFwicmVzb2x2ZShieXRlcyxieXRlcylcIjtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMucHVzaCh7XG4gICAgICAgICAgICBlbmFibGVDY2lwUmVhZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI3Jlc29sdmVyW2Z1bmNOYW1lXSguLi5wYXJhbXMpO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlmYWNlLmRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCByZXN1bHQpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGFkZHJlc3MgZm9yICUlY29pblR5cGUlJSBvciBudWxsIGlmIHRoZVxuICAgICAqICBwcm92aWRlZCAlJWNvaW5UeXBlJSUgaGFzIG5vdCBiZWVuIGNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWRkcmVzcyhjb2luVHlwZSkge1xuICAgICAgICBpZiAoY29pblR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29pblR5cGUgPSA2MDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29pblR5cGUgPT09IDYwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI2ZldGNoKFwiYWRkcihieXRlczMyKVwiKTtcbiAgICAgICAgICAgICAgICAvLyBObyBhZGRyZXNzXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsIHx8IHJlc3VsdCA9PT0gWmVyb0FkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ5IGRlY29kaW5nIGl0cyBFVk0gY2Fub25pY2FsIGNoYWluIGFzIGFuIEVWTSBjaGFpbiBhZGRyZXNzIGZpcnN0XG4gICAgICAgIGlmIChjb2luVHlwZSA+PSAwICYmIGNvaW5UeXBlIDwgMHg4MDAwMDAwMCkge1xuICAgICAgICAgICAgbGV0IGV0aENvaW5UeXBlID0gY29pblR5cGUgKyAweDgwMDAwMDAwO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwiYWRkcihieXRlczMyLHVpbnQpXCIsIFtldGhDb2luVHlwZV0pO1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGRhdGEsIDIwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb2luUGx1Z2luID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5wcm92aWRlci5wbHVnaW5zKSB7XG4gICAgICAgICAgICBpZiAoIShwbHVnaW4gaW5zdGFuY2VvZiBNdWx0aWNvaW5Qcm92aWRlclBsdWdpbikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwbHVnaW4uc3VwcG9ydHNDb2luVHlwZShjb2luVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBjb2luUGx1Z2luID0gcGx1Z2luO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2luUGx1Z2luID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGtlY2NhazI1NihcImFkZHIoYnl0ZXMzMix1aW50MjU2XCIpXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMix1aW50KVwiLCBbY29pblR5cGVdKTtcbiAgICAgICAgLy8gTm8gYWRkcmVzc1xuICAgICAgICBpZiAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgYWRkcmVzc1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgY29pblBsdWdpbi5kZWNvZGVBZGRyZXNzKGNvaW5UeXBlLCBkYXRhKTtcbiAgICAgICAgaWYgKGFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgaW52YWxpZCBjb2luIGRhdGFgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IGBnZXRBZGRyZXNzKCR7Y29pblR5cGV9KWAsXG4gICAgICAgICAgICBpbmZvOiB7IGNvaW5UeXBlLCBkYXRhIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgRUlQLTYzNCB0ZXh0IHJlY29yZCBmb3IgJSVrZXklJSwgb3IgYGBudWxsYGBcbiAgICAgKiAgaWYgdW5jb25maWd1cmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRleHQoa2V5KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcInRleHQoYnl0ZXMzMixzdHJpbmcpXCIsIFtrZXldKTtcbiAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUnNvbHZlcyB0byB0aGUgY29udGVudC1oYXNoIG9yIGBgbnVsbGBgIGlmIHVuY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDb250ZW50SGFzaCgpIHtcbiAgICAgICAgLy8ga2VjY2FrMjU2KFwiY29udGVudGhhc2goKVwiKVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJjb250ZW50aGFzaChieXRlczMyKVwiKTtcbiAgICAgICAgLy8gTm8gY29udGVudGhhc2hcbiAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIElQRlMgKENJRDogMSwgVHlwZTogNzA9REFHLVBCLCA3Mj1saWJwMnAta2V5KVxuICAgICAgICBjb25zdCBpcGZzID0gZGF0YS5tYXRjaCgvXjB4KGUzMDEwMTcwfGU1MDEwMTcyKSgoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKSkkLyk7XG4gICAgICAgIGlmIChpcGZzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWUgPSAoaXBmc1sxXSA9PT0gXCJlMzAxMDE3MFwiKSA/IFwiaXBmc1wiIDogXCJpcG5zXCI7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChpcGZzWzRdLCAxNik7XG4gICAgICAgICAgICBpZiAoaXBmc1s1XS5sZW5ndGggPT09IGxlbmd0aCAqIDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7c2NoZW1lfTovXFwvJHtlbmNvZGVCYXNlNTgoXCIweFwiICsgaXBmc1syXSl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTd2FybSAoQ0lEOiAxLCBUeXBlOiBzd2FybS1tYW5pZmVzdDsgaGFzaC9sZW5ndGggaGFyZC1jb2RlZCB0byBrZWNjYWsyNTYvMzIpXG4gICAgICAgIGNvbnN0IHN3YXJtID0gZGF0YS5tYXRjaCgvXjB4ZTQwMTAxZmEwMTFiMjAoWzAtOWEtZl0qKSQvKTtcbiAgICAgICAgaWYgKHN3YXJtICYmIHN3YXJtWzFdLmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgICAgIHJldHVybiBgYnp6Oi9cXC8ke3N3YXJtWzFdfWA7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgaW52YWxpZCBvciB1bnN1cHBvcnRlZCBjb250ZW50IGhhc2ggZGF0YWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRDb250ZW50SGFzaCgpXCIsXG4gICAgICAgICAgICBpbmZvOiB7IGRhdGEgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBhdmF0YXIgdXJsIG9yIGBgbnVsbGBgIGlmIHRoZSBhdmF0YXIgaXMgZWl0aGVyXG4gICAgICogIHVuY29uZmlndXJlZCBvciBpbmNvcnJlY3RseSBjb25maWd1cmVkIChlLmcuIHJlZmVyZW5jZXMgYW4gTkZUXG4gICAgICogIG5vdCBvd25lZCBieSB0aGUgYWRkcmVzcykuXG4gICAgICpcbiAgICAgKiAgSWYgZGlhZ25vc2luZyBpc3N1ZXMgd2l0aCBjb25maWd1cmF0aW9ucywgdGhlIFtbX2dldEF2YXRhcl1dXG4gICAgICogIG1ldGhvZCBtYXkgYmUgdXNlZnVsLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEF2YXRhcigpIHtcbiAgICAgICAgY29uc3QgYXZhdGFyID0gYXdhaXQgdGhpcy5fZ2V0QXZhdGFyKCk7XG4gICAgICAgIHJldHVybiBhdmF0YXIudXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgV2hlbiByZXNvbHZpbmcgYW4gYXZhdGFyLCB0aGVyZSBhcmUgbWFueSBzdGVwcyBpbnZvbHZlZCwgc3VjaFxuICAgICAqICBmZXRjaGluZyBtZXRhZGF0YSBhbmQgcG9zc2libHkgdmFsaWRhdGluZyBvd25lcnNoaXAgb2YgYW5cbiAgICAgKiAgTkZULlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGV4YW1pbmUgZWFjaCBzdGVwIGFuZCB0aGUgdmFsdWUgaXRcbiAgICAgKiAgd2FzIHdvcmtpbmcgZnJvbS5cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0QXZhdGFyKCkge1xuICAgICAgICBjb25zdCBsaW5rYWdlID0gW3sgdHlwZTogXCJuYW1lXCIsIHZhbHVlOiB0aGlzLm5hbWUgfV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyB0ZXN0IGRhdGEgZm9yIHJpY21vby5ldGhcbiAgICAgICAgICAgIC8vY29uc3QgYXZhdGFyID0gXCJlaXAxNTU6MS9lcmM3MjE6MHgyNjUzODVjN2Y0MTMyMjI4QTBkNTRFQjFBOWU3NDYwYjkxYzBjQzY4LzI5MjMzXCI7XG4gICAgICAgICAgICBjb25zdCBhdmF0YXIgPSBhd2FpdCB0aGlzLmdldFRleHQoXCJhdmF0YXJcIik7XG4gICAgICAgICAgICBpZiAoYXZhdGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFhdmF0YXJcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImF2YXRhclwiLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gYXZhdGFyLm1hdGNoKG1hdGNoZXJzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNjaGVtZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cHNcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGF2YXRhciB9O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaXBmc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBnZXRJcGZzTGluayhhdmF0YXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJpcGZzXCIsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCB2YWx1ZTogdXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzcyMVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJjMTE1NVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gdGhlIEVSQyB0eXBlLCB1c2UgdG9rZW5VUkkodWludDI1Nikgb3IgdXJsKHVpbnQyNTYpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IChzY2hlbWUgPT09IFwiZXJjNzIxXCIpID8gXCJ0b2tlblVSSSh1aW50MjU2KVwiIDogXCJ1cmkodWludDI1NilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IHNjaGVtZSwgdmFsdWU6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvd25lciBvZiB0aGlzIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG93bmVyID0gYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3duZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW93bmVyXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcHMgPSAobWF0Y2hbMl0gfHwgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IGAhJHtzY2hlbWV9Y2FpcGAsIHZhbHVlOiAobWF0Y2hbMl0gfHwgXCJcIikgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbklkID0gY29tcHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyBDb250cmFjdChjb21wc1swXSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVSQy03MjFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHRva2VuVVJJKHVpbnQpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gb3duZXJPZih1aW50KSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHVyaSh1aW50KSB2aWV3IHJldHVybnMgKHN0cmluZylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIGJhbGFuY2VPZihhZGRyZXNzLCB1aW50MjU2KSB2aWV3IHJldHVybnMgKHVpbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGlzIGFjY291bnQgb3ducyB0aGUgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWUgPT09IFwiZXJjNzIxXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbk93bmVyID0gYXdhaXQgY29udHJhY3Qub3duZXJPZih0b2tlbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3duZXIgIT09IHRva2VuT3duZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhb3duZXJcIiwgdmFsdWU6IHRva2VuT3duZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm93bmVyXCIsIHZhbHVlOiB0b2tlbk93bmVyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1lID09PSBcImVyYzExNTVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjb250cmFjdC5iYWxhbmNlT2Yob3duZXIsIHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmFsYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFiYWxhbmNlXCIsIHZhbHVlOiBcIjBcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiYmFsYW5jZVwiLCB2YWx1ZTogYmFsYW5jZS50b1N0cmluZygpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgdG9rZW4gY29udHJhY3QgZm9yIHRoZSBtZXRhZGF0YSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YVVybCA9IGF3YWl0IGNvbnRyYWN0W3NlbGVjdG9yXSh0b2tlbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVVybCA9PSBudWxsIHx8IG1ldGFkYXRhVXJsID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YS11cmxcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybC1iYXNlXCIsIHZhbHVlOiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVSQy0xMTU1IGFsbG93cyBhIGdlbmVyaWMge2lkfSBpbiB0aGUgVVJMXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1lID09PSBcImVyYzExNTVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVXJsID0gbWV0YWRhdGFVcmwucmVwbGFjZShcIntpZH1cIiwgdG9CZUhleCh0b2tlbklkLCAzMikuc3Vic3RyaW5nKDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybC1leHBhbmRlZFwiLCB2YWx1ZTogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gSVBGUyBtZXRhZGF0YSBsaW5rc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhVXJsLm1hdGNoKC9eaXBmczovaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVVybCA9IGdldElwZnNMaW5rKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsXCIsIHZhbHVlOiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdG9rZW4gbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAobmV3IEZldGNoUmVxdWVzdChtZXRhZGF0YVVybCkpLnNlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmFzc2VydE9rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gcmVzcG9uc2UuYm9keUpzb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YVwiLCB2YWx1ZTogcmVzcG9uc2UuYm9keVRleHQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IHJlc3BvbnNlLmJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGFcIiwgdmFsdWU6IGhleGxpZnkoYnl0ZXMpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YVwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGFcIiwgdmFsdWU6IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1bGwgdGhlIGltYWdlIFVSTCBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZVVybCA9IG1ldGFkYXRhLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaW1hZ2VVcmwpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhaW1hZ2VVcmxcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VVcmwubWF0Y2goL14oaHR0cHM6XFwvXFwvfGRhdGE6KS9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gSVBGUyBsaW5rIHRvIGdhdGV3YXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpcGZzID0gaW1hZ2VVcmwubWF0Y2gobWF0Y2hlcklwZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcGZzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhaW1hZ2VVcmwtaXBmc1wiLCB2YWx1ZTogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImltYWdlVXJsLWlwZnNcIiwgdmFsdWU6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVXJsID0gZ2V0SXBmc0xpbmsoaW1hZ2VVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgdmFsdWU6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBpbWFnZVVybCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogbnVsbCB9O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZ2V0RW5zQWRkcmVzcyhwcm92aWRlcikge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgcHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgICAgICBjb25zdCBlbnNQbHVnaW4gPSBuZXR3b3JrLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkVuc1wiKTtcbiAgICAgICAgLy8gTm8gRU5TLi4uXG4gICAgICAgIGFzc2VydChlbnNQbHVnaW4sIFwibmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IEVOU1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0RW5zQWRkcmVzc1wiLCBpbmZvOiB7IG5ldHdvcmsgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVuc1BsdWdpbi5hZGRyZXNzO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgI2dldFJlc29sdmVyKHByb3ZpZGVyLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGVuc0FkZHIgPSBhd2FpdCBFbnNSZXNvbHZlci5nZXRFbnNBZGRyZXNzKHByb3ZpZGVyKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGVuc0FkZHIsIFtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHJlc29sdmVyKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIlxuICAgICAgICAgICAgXSwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgY29uc3QgYWRkciA9IGF3YWl0IGNvbnRyYWN0LnJlc29sdmVyKG5hbWVoYXNoKG5hbWUpLCB7XG4gICAgICAgICAgICAgICAgZW5hYmxlQ2NpcFJlYWQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGFkZHIgPT09IFplcm9BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWRkcjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEVOUyByZWdpc3RyeSBjYW5ub3QgdGhyb3cgZXJyb3JzIG9uIHJlc29sdmVyKGJ5dGVzMzIpLFxuICAgICAgICAgICAgLy8gc28gcHJvYmFibHkgYSBsaW5rIGVycm9yXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmUgdG8gdGhlIEVOUyByZXNvbHZlciBmb3IgJSVuYW1lJSUgdXNpbmcgJSVwcm92aWRlciUlIG9yXG4gICAgICogIGBgbnVsbGBgIGlmIHVuY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbU5hbWUocHJvdmlkZXIsIG5hbWUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnROYW1lID0gbmFtZTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TmFtZSA9PT0gXCJcIiB8fCBjdXJyZW50TmFtZSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9wdGltaXphdGlvbiBzaW5jZSB0aGUgZXRoIG5vZGUgY2Fubm90IGNoYW5nZSBhbmQgZG9lc1xuICAgICAgICAgICAgLy8gbm90IGhhdmUgYSB3aWxkY2FyZCByZXNvbHZlclxuICAgICAgICAgICAgaWYgKG5hbWUgIT09IFwiZXRoXCIgJiYgY3VycmVudE5hbWUgPT09IFwiZXRoXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBjdXJyZW50IG5vZGUgZm9yIGEgcmVzb2x2ZXJcbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSBhd2FpdCBFbnNSZXNvbHZlci4jZ2V0UmVzb2x2ZXIocHJvdmlkZXIsIGN1cnJlbnROYW1lKTtcbiAgICAgICAgICAgIC8vIEZvdW5kIGEgcmVzb2x2ZXIhXG4gICAgICAgICAgICBpZiAoYWRkciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBuZXcgRW5zUmVzb2x2ZXIocHJvdmlkZXIsIGFkZHIsIG5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIExlZ2FjeSByZXNvbHZlciBmb3VuZCwgdXNpbmcgRUlQLTI1NDQgc28gaXQgaXNuJ3Qgc2FmZSB0byB1c2VcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5hbWUgIT09IG5hbWUgJiYgIShhd2FpdCByZXNvbHZlci5zdXBwb3J0c1dpbGRjYXJkKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgICBjdXJyZW50TmFtZSA9IGN1cnJlbnROYW1lLnNwbGl0KFwiLlwiKS5zbGljZSgxKS5qb2luKFwiLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVucy1yZXNvbHZlci5qcy5tYXAiLCIvKipcbiAqICBAX2lnbm9yZVxuICovXG5pbXBvcnQgeyBnZXRBZGRyZXNzLCBnZXRDcmVhdGVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBoZXhsaWZ5LCBpc0hleFN0cmluZywgemVyb1BhZFZhbHVlLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuZXhwb3J0IGZ1bmN0aW9uIGFsbG93TnVsbChmb3JtYXQsIG51bGxWYWx1ZSkge1xuICAgIHJldHVybiAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXQodmFsdWUpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5T2YoZm9ybWF0KSB7XG4gICAgcmV0dXJuICgoYXJyYXkpID0+IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheS5tYXAoKGkpID0+IGZvcm1hdChpKSk7XG4gICAgfSk7XG59XG4vLyBSZXF1aXJlcyBhbiBvYmplY3Qgd2hpY2ggbWF0Y2hlcyBhIGZsZWV0IG9mIG90aGVyIGZvcm1hdHRlcnNcbi8vIEFueSBGb3JtYXRGdW5jIG1heSByZXR1cm4gYHVuZGVmaW5lZGAgdG8gaGF2ZSB0aGUgdmFsdWUgb21pdHRlZFxuLy8gZnJvbSB0aGUgcmVzdWx0IG9iamVjdC4gQ2FsbHMgcHJlc2VydmUgYHRoaXNgLlxuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdChmb3JtYXQsIGFsdE5hbWVzKSB7XG4gICAgcmV0dXJuICgodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGZvcm1hdCkge1xuICAgICAgICAgICAgbGV0IHNyY0tleSA9IGtleTtcbiAgICAgICAgICAgIGlmIChhbHROYW1lcyAmJiBrZXkgaW4gYWx0TmFtZXMgJiYgIShzcmNLZXkgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhbHRLZXkgb2YgYWx0TmFtZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWx0S2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNLZXkgPSBhbHRLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnYgPSBmb3JtYXRba2V5XSh2YWx1ZVtzcmNLZXldKTtcbiAgICAgICAgICAgICAgICBpZiAobnYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IG52O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikgPyBlcnJvci5tZXNzYWdlIDogXCJub3QtYW4tZXJyb3JcIjtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGBpbnZhbGlkIHZhbHVlIGZvciB2YWx1ZS4ke2tleX0gKCR7bWVzc2FnZX0pYCwgXCJCQURfREFUQVwiLCB7IHZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0Qm9vbGVhbih2YWx1ZSkge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSB0cnVlOlxuICAgICAgICBjYXNlIFwidHJ1ZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgIGNhc2UgXCJmYWxzZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgYm9vbGVhbjsgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0YSh2YWx1ZSkge1xuICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHZhbHVlLCB0cnVlKSwgXCJpbnZhbGlkIGRhdGFcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEhhc2godmFsdWUpIHtcbiAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh2YWx1ZSwgMzIpLCBcImludmFsaWQgaGFzaFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VWludDI1Nih2YWx1ZSkge1xuICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludDI1NlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHplcm9QYWRWYWx1ZSh2YWx1ZSwgMzIpO1xufVxuY29uc3QgX2Zvcm1hdExvZyA9IG9iamVjdCh7XG4gICAgYWRkcmVzczogZ2V0QWRkcmVzcyxcbiAgICBibG9ja0hhc2g6IGZvcm1hdEhhc2gsXG4gICAgYmxvY2tOdW1iZXI6IGdldE51bWJlcixcbiAgICBkYXRhOiBmb3JtYXREYXRhLFxuICAgIGluZGV4OiBnZXROdW1iZXIsXG4gICAgcmVtb3ZlZDogYWxsb3dOdWxsKGZvcm1hdEJvb2xlYW4sIGZhbHNlKSxcbiAgICB0b3BpY3M6IGFycmF5T2YoZm9ybWF0SGFzaCksXG4gICAgdHJhbnNhY3Rpb25IYXNoOiBmb3JtYXRIYXNoLFxuICAgIHRyYW5zYWN0aW9uSW5kZXg6IGdldE51bWJlcixcbn0sIHtcbiAgICBpbmRleDogW1wibG9nSW5kZXhcIl1cbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdExvZyh2YWx1ZSkge1xuICAgIHJldHVybiBfZm9ybWF0TG9nKHZhbHVlKTtcbn1cbmNvbnN0IF9mb3JtYXRCbG9jayA9IG9iamVjdCh7XG4gICAgaGFzaDogYWxsb3dOdWxsKGZvcm1hdEhhc2gpLFxuICAgIHBhcmVudEhhc2g6IGZvcm1hdEhhc2gsXG4gICAgbnVtYmVyOiBnZXROdW1iZXIsXG4gICAgdGltZXN0YW1wOiBnZXROdW1iZXIsXG4gICAgbm9uY2U6IGFsbG93TnVsbChmb3JtYXREYXRhKSxcbiAgICBkaWZmaWN1bHR5OiBnZXRCaWdJbnQsXG4gICAgZ2FzTGltaXQ6IGdldEJpZ0ludCxcbiAgICBnYXNVc2VkOiBnZXRCaWdJbnQsXG4gICAgbWluZXI6IGFsbG93TnVsbChnZXRBZGRyZXNzKSxcbiAgICBleHRyYURhdGE6IGZvcm1hdERhdGEsXG4gICAgYmFzZUZlZVBlckdhczogYWxsb3dOdWxsKGdldEJpZ0ludClcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEJsb2NrKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gX2Zvcm1hdEJsb2NrKHZhbHVlKTtcbiAgICByZXN1bHQudHJhbnNhY3Rpb25zID0gdmFsdWUudHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UodHgpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBfZm9ybWF0UmVjZWlwdExvZyA9IG9iamVjdCh7XG4gICAgdHJhbnNhY3Rpb25JbmRleDogZ2V0TnVtYmVyLFxuICAgIGJsb2NrTnVtYmVyOiBnZXROdW1iZXIsXG4gICAgdHJhbnNhY3Rpb25IYXNoOiBmb3JtYXRIYXNoLFxuICAgIGFkZHJlc3M6IGdldEFkZHJlc3MsXG4gICAgdG9waWNzOiBhcnJheU9mKGZvcm1hdEhhc2gpLFxuICAgIGRhdGE6IGZvcm1hdERhdGEsXG4gICAgaW5kZXg6IGdldE51bWJlcixcbiAgICBibG9ja0hhc2g6IGZvcm1hdEhhc2gsXG59LCB7XG4gICAgaW5kZXg6IFtcImxvZ0luZGV4XCJdXG59KTtcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRSZWNlaXB0TG9nKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9mb3JtYXRSZWNlaXB0TG9nKHZhbHVlKTtcbn1cbmNvbnN0IF9mb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQgPSBvYmplY3Qoe1xuICAgIHRvOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgZnJvbTogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgIGNvbnRyYWN0QWRkcmVzczogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgIC8vIHNob3VsZCBiZSBhbGxvd051bGwoaGFzaCksIGJ1dCBicm9rZW4tRUlQLTY1OCBzdXBwb3J0IGlzIGhhbmRsZWQgaW4gcmVjZWlwdFxuICAgIGluZGV4OiBnZXROdW1iZXIsXG4gICAgcm9vdDogYWxsb3dOdWxsKGhleGxpZnkpLFxuICAgIGdhc1VzZWQ6IGdldEJpZ0ludCxcbiAgICBsb2dzQmxvb206IGFsbG93TnVsbChmb3JtYXREYXRhKSxcbiAgICBibG9ja0hhc2g6IGZvcm1hdEhhc2gsXG4gICAgaGFzaDogZm9ybWF0SGFzaCxcbiAgICBsb2dzOiBhcnJheU9mKGZvcm1hdFJlY2VpcHRMb2cpLFxuICAgIGJsb2NrTnVtYmVyOiBnZXROdW1iZXIsXG4gICAgLy9jb25maXJtYXRpb25zOiBhbGxvd051bGwoZ2V0TnVtYmVyLCBudWxsKSxcbiAgICBjdW11bGF0aXZlR2FzVXNlZDogZ2V0QmlnSW50LFxuICAgIGVmZmVjdGl2ZUdhc1ByaWNlOiBhbGxvd051bGwoZ2V0QmlnSW50KSxcbiAgICBzdGF0dXM6IGFsbG93TnVsbChnZXROdW1iZXIpLFxuICAgIHR5cGU6IGFsbG93TnVsbChnZXROdW1iZXIsIDApXG59LCB7XG4gICAgZWZmZWN0aXZlR2FzUHJpY2U6IFtcImdhc1ByaWNlXCJdLFxuICAgIGhhc2g6IFtcInRyYW5zYWN0aW9uSGFzaFwiXSxcbiAgICBpbmRleDogW1widHJhbnNhY3Rpb25JbmRleFwiXSxcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSkge1xuICAgIHJldHVybiBfZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlKHZhbHVlKSB7XG4gICAgLy8gU29tZSBjbGllbnRzIChUZXN0UlBDKSBkbyBzdHJhbmdlIHRoaW5ncyBsaWtlIHJldHVybiAweDAgZm9yIHRoZVxuICAgIC8vIDAgYWRkcmVzczsgY29ycmVjdCB0aGlzIHRvIGJlIGEgcmVhbCBhZGRyZXNzXG4gICAgaWYgKHZhbHVlLnRvICYmIGdldEJpZ0ludCh2YWx1ZS50bykgPT09IEJOXzApIHtcbiAgICAgICAgdmFsdWUudG8gPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBvYmplY3Qoe1xuICAgICAgICBoYXNoOiBmb3JtYXRIYXNoLFxuICAgICAgICB0eXBlOiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXROdW1iZXIodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBhY2Nlc3NMaXN0OiBhbGxvd051bGwoYWNjZXNzTGlzdGlmeSwgbnVsbCksXG4gICAgICAgIGJsb2NrSGFzaDogYWxsb3dOdWxsKGZvcm1hdEhhc2gsIG51bGwpLFxuICAgICAgICBibG9ja051bWJlcjogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXG4gICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IGFsbG93TnVsbChnZXROdW1iZXIsIG51bGwpLFxuICAgICAgICAvL2NvbmZpcm1hdGlvbnM6IGFsbG93TnVsbChnZXROdW1iZXIsIG51bGwpLFxuICAgICAgICBmcm9tOiBnZXRBZGRyZXNzLFxuICAgICAgICAvLyBlaXRoZXIgKGdhc1ByaWNlKSBvciAobWF4UHJpb3JpdHlGZWVQZXJHYXMgKyBtYXhGZWVQZXJHYXMpIG11c3QgYmUgc2V0XG4gICAgICAgIGdhc1ByaWNlOiBhbGxvd051bGwoZ2V0QmlnSW50KSxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxuICAgICAgICBtYXhGZWVQZXJHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxuICAgICAgICBnYXNMaW1pdDogZ2V0QmlnSW50LFxuICAgICAgICB0bzogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgICAgICB2YWx1ZTogZ2V0QmlnSW50LFxuICAgICAgICBub25jZTogZ2V0TnVtYmVyLFxuICAgICAgICBkYXRhOiBmb3JtYXREYXRhLFxuICAgICAgICBjcmVhdGVzOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgICAgIGNoYWluSWQ6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpXG4gICAgfSwge1xuICAgICAgICBkYXRhOiBbXCJpbnB1dFwiXSxcbiAgICAgICAgZ2FzTGltaXQ6IFtcImdhc1wiXVxuICAgIH0pKHZhbHVlKTtcbiAgICAvLyBJZiB0byBhbmQgY3JlYXRlcyBhcmUgZW1wdHksIHBvcHVsYXRlIHRoZSBjcmVhdGVzIGZyb20gdGhlIHZhbHVlXG4gICAgaWYgKHJlc3VsdC50byA9PSBudWxsICYmIHJlc3VsdC5jcmVhdGVzID09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LmNyZWF0ZXMgPSBnZXRDcmVhdGVBZGRyZXNzKHJlc3VsdCk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBDaGVjayBmZWUgZGF0YVxuICAgIC8vIEFkZCBhbiBhY2Nlc3MgbGlzdCB0byBzdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZXNcbiAgICBpZiAoKHZhbHVlLnR5cGUgPT09IDEgfHwgdmFsdWUudHlwZSA9PT0gMikgJiYgdmFsdWUuYWNjZXNzTGlzdCA9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC5hY2Nlc3NMaXN0ID0gW107XG4gICAgfVxuICAgIC8vIENvbXB1dGUgdGhlIHNpZ25hdHVyZVxuICAgIGlmICh2YWx1ZS5zaWduYXR1cmUpIHtcbiAgICAgICAgcmVzdWx0LnNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHZhbHVlLnNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQuc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20odmFsdWUpO1xuICAgIH1cbiAgICAvLyBTb21lIGJhY2tlbmRzIG9taXQgQ2hhaW5JZCBvbiBsZWdhY3kgdHJhbnNhY3Rpb25zLCBidXQgd2UgY2FuIGNvbXB1dGUgaXRcbiAgICBpZiAocmVzdWx0LmNoYWluSWQgPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjaGFpbklkID0gcmVzdWx0LnNpZ25hdHVyZS5sZWdhY3lDaGFpbklkO1xuICAgICAgICBpZiAoY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQFRPRE86IGNoZWNrIGNoYWluSURcbiAgICAvKlxuICAgIGlmICh2YWx1ZS5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGNoYWluSWQgPSB2YWx1ZS5jaGFpbklkO1xuXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhjaGFpbklkKSkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgY2hhaW5JZCA9IHZhbHVlLm5ldHdvcmtJZDtcblxuICAgICAgICAvLyBnZXRoLWV0YyByZXR1cm5zIGNoYWluSWRcbiAgICAgICAgaWYgKGNoYWluSWQgPT0gbnVsbCAmJiByZXN1bHQudiA9PSBudWxsKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gdmFsdWUuY2hhaW5JZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhjaGFpbklkKSkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mKGNoYWluSWQpICE9PSBcIm51bWJlclwiICYmIHJlc3VsdC52ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSAocmVzdWx0LnYgLSAzNSkgLyAyO1xuICAgICAgICAgICAgaWYgKGNoYWluSWQgPCAwKSB7IGNoYWluSWQgPSAwOyB9XG4gICAgICAgICAgICBjaGFpbklkID0gcGFyc2VJbnQoY2hhaW5JZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mKGNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7IGNoYWluSWQgPSAwOyB9XG5cbiAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuICAgIH1cbiAgICAqL1xuICAgIC8vIDB4MDAwMC4uLiBzaG91bGQgYWN0dWFsbHkgYmUgbnVsbFxuICAgIGlmIChyZXN1bHQuYmxvY2tIYXNoICYmIGdldEJpZ0ludChyZXN1bHQuYmxvY2tIYXNoKSA9PT0gQk5fMCkge1xuICAgICAgICByZXN1bHQuYmxvY2tIYXNoID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdC5qcy5tYXAiLCJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL3Byb3BlcnRpZXMuanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBFbnNBZGRyZXNzID0gXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIjtcbi8qKlxuICogIEEgKipOZXR3b3JrUGx1Z2luKiogcHJvdmlkZXMgYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5IG9uIGEgW1tOZXR3b3JrXV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cbiAgICAgKlxuICAgICAqICBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgcmV2ZXJzZS1kb21haW4tbm90YXRpb24sIHdoaWNoIHBlcm1pdHNcbiAgICAgKiAgdW5pcXVlIG5hbWVzIHdpdGggYSBrbm93biBhdXRob3JpdHkgYXMgd2VsbCBhcyBoaWVyYXJjaGFsIGVudHJpZXMuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk5ldHdvcmtQbHVnaW4qKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBwbHVnaW4uXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmV0d29ya1BsdWdpbih0aGlzLm5hbWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipHYXNDb3N0UGx1Z2luKiogYWxsb3dzIGEgbmV0d29yayB0byBwcm92aWRlIGFsdGVybmF0aXZlIHZhbHVlcyB3aGVuXG4gKiAgY29tcHV0aW5nIHRoZSBpbnRyaW5zaWMgZ2FzIHJlcXVpcmVkIGZvciBhIHRyYW5zYWN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgR2FzQ29zdFBsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIHRvIHRyZWF0IHRoZXNlIHZhbHVlcyBhcyB2YWxpZCBmcm9tLlxuICAgICAqXG4gICAgICogIFRoaXMgYWxsb3dzIGEgaGFyZGZvcmsgdG8gaGF2ZSB1cGRhdGVkIHZhbHVlcyBpbmNsdWRlZCBhcyB3ZWxsIGFzXG4gICAgICogIG11bHV0aXBsZSBoYXJkZm9ya3MgdG8gYmUgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIGVmZmVjdGl2ZUJsb2NrO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb25zIGJhc2UgZmVlLlxuICAgICAqL1xuICAgIHR4QmFzZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBmb3IgY3JlYXRpbmcgYSBuZXcgYWNjb3VudC5cbiAgICAgKi9cbiAgICB0eENyZWF0ZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgemVyby1ieXRlIGluIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHR4RGF0YVplcm87XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgcGVyIG5vbi16ZXJvLWJ5dGUgaW4gdGhlIGRhdGEuXG4gICAgICovXG4gICAgdHhEYXRhTm9uemVybztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgc3RvcmFnZSBrZXkgaW4gdGhlIFtbbGluay1laXAtMjkzMF1dIGFjY2VzcyBsaXN0LlxuICAgICAqL1xuICAgIHR4QWNjZXNzTGlzdFN0b3JhZ2VLZXk7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgcGVyIGFkZHJlc3MgaW4gdGhlIFtbbGluay1laXAtMjkzMF1dIGFjY2VzcyBsaXN0LlxuICAgICAqL1xuICAgIHR4QWNjZXNzTGlzdEFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgR2FzQ29zdFBsdWdpbiBmcm9tICUlZWZmZWN0aXZlQmxvY2slJSB1bnRpbCB0aGVcbiAgICAgKiAgbGF0ZXN0IGJsb2NrIG9yIGFub3RoZXIgR2FzQ29zdFBsdWdpbiBzdXBlcmNlZGVzIHRoYXQgYmxvY2sgbnVtYmVyLFxuICAgICAqICB3aXRoIHRoZSBhc3NvY2lhdGVkICUlY29zdHMlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlZmZlY3RpdmVCbG9jaywgY29zdHMpIHtcbiAgICAgICAgaWYgKGVmZmVjdGl2ZUJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIGVmZmVjdGl2ZUJsb2NrID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihgb3JnLmV0aGVycy5uZXR3b3JrLnBsdWdpbnMuR2FzQ29zdCMkeyhlZmZlY3RpdmVCbG9jayB8fCAwKX1gKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7IGVmZmVjdGl2ZUJsb2NrIH07XG4gICAgICAgIGZ1bmN0aW9uIHNldChuYW1lLCBudWxsaXNoKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAoY29zdHMgfHwge30pW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGxpc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiwgYGludmFsdWQgdmFsdWUgZm9yICR7bmFtZX1gLCBcImNvc3RzXCIsIGNvc3RzKTtcbiAgICAgICAgICAgIHByb3BzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KFwidHhCYXNlXCIsIDIxMDAwKTtcbiAgICAgICAgc2V0KFwidHhDcmVhdGVcIiwgMzIwMDApO1xuICAgICAgICBzZXQoXCJ0eERhdGFaZXJvXCIsIDQpO1xuICAgICAgICBzZXQoXCJ0eERhdGFOb256ZXJvXCIsIDE2KTtcbiAgICAgICAgc2V0KFwidHhBY2Nlc3NMaXN0U3RvcmFnZUtleVwiLCAxOTAwKTtcbiAgICAgICAgc2V0KFwidHhBY2Nlc3NMaXN0QWRkcmVzc1wiLCAyNDAwKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCBwcm9wcyk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdhc0Nvc3RQbHVnaW4odGhpcy5lZmZlY3RpdmVCbG9jaywgdGhpcyk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gKipFbnNQbHVnaW4qKiBhbGxvd3MgYSBbW05ldHdvcmtdXSB0byBzcGVjaWZ5IHRoZSBFTlMgUmVnaXN0cnlcbiAqICBDb250cmFjdCBhZGRyZXNzIGFuZCB0aGUgdGFyZ2V0IG5ldHdvcmsgdG8gdXNlIHdoZW4gdXNpbmcgdGhhdFxuICogIGNvbnRyYWN0LlxuICpcbiAqICBWYXJpb3VzIHRlc3RuZXRzIGhhdmUgdGhlaXIgb3duIGluc3RhbmNlIG9mIHRoZSBjb250cmFjdCB0byB1c2UsIGJ1dFxuICogIGluIGdlbmVyYWwsIHRoZSBtYWlubmV0IGluc3RhbmNlIHN1cHBvcnRzIG11bHRpLWNoYWluIGFkZHJlc3NlcyBhbmRcbiAqICBzaG91bGQgYmUgdXNlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEVuc1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgRU5TIFJlZ2lzdHJ0eSBDb250cmFjdCBhZGRyZXNzLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbiBJRCB0aGF0IHRoZSBFTlMgY29udHJhY3QgbGl2ZXMgb24uXG4gICAgICovXG4gICAgdGFyZ2V0TmV0d29yaztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkVuc1BsdWdpbioqIGNvbm5lY3RlZCB0byAlJWFkZHJlc3MlJSBvbiB0aGVcbiAgICAgKiAgJSV0YXJnZXROZXR3b3JrJSUuIFRoZSBkZWZhdWx0IEVOUyBhZGRyZXNzIGFuZCBtYWlubmV0IGlzIHVzZWRcbiAgICAgKiAgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgdGFyZ2V0TmV0d29yaykge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkVuc1wiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBhZGRyZXNzOiAoYWRkcmVzcyB8fCBFbnNBZGRyZXNzKSxcbiAgICAgICAgICAgIHRhcmdldE5ldHdvcms6ICgodGFyZ2V0TmV0d29yayA9PSBudWxsKSA/IDEgOiB0YXJnZXROZXR3b3JrKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW5zUGx1Z2luKHRoaXMuYWRkcmVzcywgdGhpcy50YXJnZXROZXR3b3JrKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqRmVlRGF0YU5ldHdvcmtQbHVnaW4qKiBhbGxvd3MgYSBuZXR3b3JrIHRvIHByb3ZpZGUgYW5kIGFsdGVybmF0ZVxuICogIG1lYW5zIHRvIHNwZWNpZnkgaXRzIGZlZSBkYXRhLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgYSBuZXR3b3JrIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgW1tsaW5rLWVpcC0xNTU5XV0gbWF5XG4gKiAgY2hvb3NlIHRvIHVzZSBhIEdhcyBTdGF0aW9uIHNpdGUgdG8gYXBwcm94aW1hdGUgdGhlIGdhcyBwcmljZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZlZURhdGFOZXR3b3JrUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgI2ZlZURhdGFGdW5jO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIGRhdGEgZnVuY3Rpb24gcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGdldCBmZWVEYXRhRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZlZURhdGFGdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZlZURhdGFOZXR3b3JrUGx1Z2luKiouXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZmVlRGF0YUZ1bmMpIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5GZWVEYXRhXCIpO1xuICAgICAgICB0aGlzLiNmZWVEYXRhRnVuYyA9IGZlZURhdGFGdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGZlZSBkYXRhLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEZlZURhdGEocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2ZlZURhdGFGdW5jKHByb3ZpZGVyKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmVlRGF0YU5ldHdvcmtQbHVnaW4odGhpcy4jZmVlRGF0YUZ1bmMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgI3VybDtcbiAgICAjcHJvY2Vzc0Z1bmM7XG4gICAgLyoqXG4gICAgICogIFRoZSBVUkwgdG8gaW5pdGlhbGl6ZSB0aGUgRmV0Y2hSZXF1ZXN0IHdpdGggaW4gJSVwcm9jZXNzRnVuYyUlLlxuICAgICAqL1xuICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLiN1cmw7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNhbGxiYWNrIHRvIHVzZSB3aGVuIGNvbXB1dGluZyB0aGUgRmVlRGF0YS5cbiAgICAgKi9cbiAgICBnZXQgcHJvY2Vzc0Z1bmMoKSB7IHJldHVybiB0aGlzLiNwcm9jZXNzRnVuYzsgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbioqIHdoaWNoIHdpbGxcbiAgICAgKiAgYmUgdXNlZCB3aGVuIGNvbXB1dGluZyB0aGUgZmVlIGRhdGEgZm9yIHRoZSBuZXR3b3JrLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCwgcHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5GZXRjaFVybEZlZURhdGFQbHVnaW5cIik7XG4gICAgICAgIHRoaXMuI3VybCA9IHVybDtcbiAgICAgICAgdGhpcy4jcHJvY2Vzc0Z1bmMgPSBwcm9jZXNzRnVuYztcbiAgICB9XG4gICAgLy8gV2UgYXJlIGltbXV0YWJsZSwgc28gd2UgY2FuIHNlcnZlIGFzIG91ciBvd24gY2xvbmVcbiAgICBjbG9uZSgpIHsgcmV0dXJuIHRoaXM7IH1cbn1cbi8qXG5leHBvcnQgY2xhc3MgQ3VzdG9tQmxvY2tOZXR3b3JrUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgcmVhZG9ubHkgI2Jsb2NrRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPHN0cmluZz4pID0+IEJsb2NrPHN0cmluZz47XG4gICAgcmVhZG9ubHkgI2Jsb2NrV2l0aFR4c0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxUcmFuc2FjdGlvblJlc3BvbnNlUGFyYW1zPikgPT4gQmxvY2s8VHJhbnNhY3Rpb25SZXNwb25zZT47XG5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxzdHJpbmc+KSA9PiBCbG9jazxzdHJpbmc+LCBibG9ja1dpdGhUeHNGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8VHJhbnNhY3Rpb25SZXNwb25zZVBhcmFtcz4pID0+IEJsb2NrPFRyYW5zYWN0aW9uUmVzcG9uc2U+KSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5uZXR3b3JrLXBsdWdpbnMuY3VzdG9tLWJsb2NrXCIpO1xuICAgICAgICB0aGlzLiNibG9ja0Z1bmMgPSBibG9ja0Z1bmM7XG4gICAgICAgIHRoaXMuI2Jsb2NrV2l0aFR4c0Z1bmMgPSBibG9ja1dpdGhUeHNGdW5jO1xuICAgIH1cblxuICAgIGFzeW5jIGdldEJsb2NrKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPHN0cmluZz4pOiBQcm9taXNlPEJsb2NrPHN0cmluZz4+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jsb2NrRnVuYyhwcm92aWRlciwgYmxvY2spO1xuICAgIH1cblxuICAgIGFzeW5jIGdldEJsb2NraW9ucyhwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxUcmFuc2FjdGlvblJlc3BvbnNlUGFyYW1zPik6IFByb21pc2U8QmxvY2s8VHJhbnNhY3Rpb25SZXNwb25zZT4+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jsb2NrV2l0aFR4c0Z1bmMocHJvdmlkZXIsIGJsb2NrKTtcbiAgICB9XG5cbiAgICBjbG9uZSgpOiBDdXN0b21CbG9ja05ldHdvcmtQbHVnaW4ge1xuICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUJsb2NrTmV0d29ya1BsdWdpbih0aGlzLiNibG9ja0Z1bmMsIHRoaXMuI2Jsb2NrV2l0aFR4c0Z1bmMpO1xuICAgIH1cbn1cbiovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW5zLW5ldHdvcmsuanMubWFwIiwiLyoqXG4gKiAgQSAqKk5ldHdvcmsqKiBlbmNhcHN1bGF0ZXMgdGhlIHZhcmlvdXMgcHJvcGVydGllcyByZXF1aXJlZCB0b1xuICogIGludGVyYWN0IHdpdGggYSBzcGVjaWZpYyBjaGFpbi5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvcHJvdmlkZXJzOk5ldHdvcmtzICBbbmV0d29ya3NdXG4gKi9cbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJpZ0ludCwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRW5zUGx1Z2luLCBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luLCBHYXNDb3N0UGx1Z2luIH0gZnJvbSBcIi4vcGx1Z2lucy1uZXR3b3JrLmpzXCI7XG4vKiAqICogKlxuLy8gTmV0d29ya3Mgd2hpY2ggb3BlcmF0aW9uIGFnYWluc3QgYW4gTDIgY2FuIHVzZSB0aGlzIHBsdWdpbiB0b1xuLy8gc3BlY2lmeSBob3cgdG8gYWNjZXNzIEwxLCBmb3IgdGhlIHB1cnBvc2Ugb2YgcmVzb2x2aW5nIEVOUyxcbi8vIGZvciBleGFtcGxlLlxuZXhwb3J0IGNsYXNzIExheWVyT25lQ29ubmVjdGlvblBsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIHJlYWRvbmx5IHByb3ZpZGVyITogUHJvdmlkZXI7XG4vLyBAVE9ETzogUmVuYW1lIHRvIENoYWluQWNjZXNzIGFuZCBhbGxvdyBmb3IgY29ubmVjdGluZyB0byBhbnkgY2hhaW5cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcjogUHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubGF5ZXItb25lLWNvbm5lY3Rpb25cIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXM8TGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luPih0aGlzLCB7IHByb3ZpZGVyIH0pO1xuICAgIH1cblxuICAgIGNsb25lKCk6IExheWVyT25lQ29ubmVjdGlvblBsdWdpbiB7XG4gICAgICAgIHJldHVybiBuZXcgTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luKHRoaXMucHJvdmlkZXIpO1xuICAgIH1cbn1cbiovXG5jb25zdCBOZXR3b3JrcyA9IG5ldyBNYXAoKTtcbi8qKlxuICogIEEgKipOZXR3b3JrKiogcHJvdmlkZXMgYWNjZXNzIHRvIGEgY2hhaW4ncyBwcm9wZXJ0aWVzIGFuZCBhbGxvd3NcbiAqICBmb3IgcGx1Zy1pbnMgdG8gZXh0ZW5kIGZ1bmN0aW9uYWxpdHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBOZXR3b3JrIHtcbiAgICAjbmFtZTtcbiAgICAjY2hhaW5JZDtcbiAgICAjcGx1Z2lucztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk5ldHdvcmsqKiBmb3IgJSVuYW1lJSUgYW5kICUlY2hhaW5JZCUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGNoYWluSWQpIHtcbiAgICAgICAgdGhpcy4jbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuI2NoYWluSWQgPSBnZXRCaWdJbnQoY2hhaW5JZCk7XG4gICAgICAgIHRoaXMuI3BsdWdpbnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgTmV0d29yay5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IG5hbWU6IHRoaXMubmFtZSwgY2hhaW5JZDogU3RyaW5nKHRoaXMuY2hhaW5JZCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBuZXR3b3JrIGNvbW1vbiBuYW1lLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdGhlIGNhbm9uaWNhbCBuYW1lLCBhcyBuZXR3b3JrcyBtaWdoIGhhdmUgbXVsdGlwbGVcbiAgICAgKiAgbmFtZXMuXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLiNuYW1lOyB9XG4gICAgc2V0IG5hbWUodmFsdWUpIHsgdGhpcy4jbmFtZSA9IHZhbHVlOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBuZXR3b3JrIGNoYWluIElELlxuICAgICAqL1xuICAgIGdldCBjaGFpbklkKCkgeyByZXR1cm4gdGhpcy4jY2hhaW5JZDsgfVxuICAgIHNldCBjaGFpbklkKHZhbHVlKSB7IHRoaXMuI2NoYWluSWQgPSBnZXRCaWdJbnQodmFsdWUsIFwiY2hhaW5JZFwiKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIG1hdGNoZXMgdGhpcyBuZXR3b3JrLiBBbnkgY2hhaW4gSURcbiAgICAgKiAgbXVzdCBtYXRjaCwgYW5kIGlmIG5vIGNoYWluIElEIGlzIHByZXNlbnQsIHRoZSBuYW1lIG11c3QgbWF0Y2guXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgZG9lcyBub3QgY3VycmVudGx5IGNoZWNrIGZvciBhZGRpdGlvbmFsIHByb3BlcnRpZXMsXG4gICAgICogIHN1Y2ggYXMgRU5TIGFkZHJlc3Mgb3IgcGx1Zy1pbiBjb21wYXRpYmlsaXR5LlxuICAgICAqL1xuICAgIG1hdGNoZXMob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvdGhlcikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNoYWluSWQgPT09IGdldEJpZ0ludChvdGhlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIHJldHVybiAodGhpcy5uYW1lID09PSBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob3RoZXIpID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiAob3RoZXIpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFpbklkID09PSBnZXRCaWdJbnQob3RoZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob3RoZXIpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAob3RoZXIuY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNoYWluSWQgPT09IGdldEJpZ0ludChvdGhlci5jaGFpbklkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5uYW1lID09PSBvdGhlci5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBsaXN0IG9mIHBsdWdpbnMgY3VycmVudGx5IGF0dGFjaGVkIHRvIHRoaXMgTmV0d29yay5cbiAgICAgKi9cbiAgICBnZXQgcGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jcGx1Z2lucy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBdHRhY2ggYSBuZXcgJSVwbHVnaW4lJSB0byB0aGlzIE5ldHdvcmsuIFRoZSBuZXR3b3JrIG5hbWVcbiAgICAgKiAgbXVzdCBiZSB1bmlxdWUsIGV4Y2x1ZGluZyBhbnkgZnJhZ21lbnQuXG4gICAgICovXG4gICAgYXR0YWNoUGx1Z2luKHBsdWdpbikge1xuICAgICAgICBpZiAodGhpcy4jcGx1Z2lucy5nZXQocGx1Z2luLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZXBsYWNlIGV4aXN0aW5nIHBsdWdpbjogJHtwbHVnaW4ubmFtZX0gYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcGx1Z2lucy5zZXQocGx1Z2luLm5hbWUsIHBsdWdpbi5jbG9uZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHBsdWdpbiwgaWYgYW55LCBtYXRjaGluZyAlJW5hbWUlJSBleGFjdGx5LiBQbHVnaW5zXG4gICAgICogIHdpdGggZnJhZ21lbnRzIHdpbGwgbm90IGJlIHJldHVybmVkIHVubGVzcyAlJW5hbWUlJSBpbmNsdWRlc1xuICAgICAqICBhIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGdldFBsdWdpbihuYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jcGx1Z2lucy5nZXQobmFtZSkpIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXRzIGEgbGlzdCBvZiBhbGwgcGx1Z2lucyB0aGF0IG1hdGNoICUlbmFtZSUlLCB3aXRoIG90ciB3aXRob3V0XG4gICAgICogIGEgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZ2V0UGx1Z2lucyhiYXNlbmFtZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMucGx1Z2lucy5maWx0ZXIoKHApID0+IChwLm5hbWUuc3BsaXQoXCIjXCIpWzBdID09PSBiYXNlbmFtZSkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBOZXR3b3JrLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBOZXR3b3JrKHRoaXMubmFtZSwgdGhpcy5jaGFpbklkKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgICAgICAgY2xvbmUuYXR0YWNoUGx1Z2luKHBsdWdpbi5jbG9uZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGludHJpbnNpYyBnYXMgcmVxdWlyZWQgZm9yIGEgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgQSBHYXNDb3N0UGx1Z2luIGNhbiBiZSBhdHRhY2hlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdFxuICAgICAqICB2YWx1ZXMuXG4gICAgICovXG4gICAgY29tcHV0ZUludHJpbnNpY0dhcyh0eCkge1xuICAgICAgICBjb25zdCBjb3N0cyA9IHRoaXMuZ2V0UGx1Z2luKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuR2FzQ29zdFwiKSB8fCAobmV3IEdhc0Nvc3RQbHVnaW4oKSk7XG4gICAgICAgIGxldCBnYXMgPSBjb3N0cy50eEJhc2U7XG4gICAgICAgIGlmICh0eC50byA9PSBudWxsKSB7XG4gICAgICAgICAgICBnYXMgKz0gY29zdHMudHhDcmVhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmRhdGEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgdHguZGF0YS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmICh0eC5kYXRhLnN1YnN0cmluZyhpLCBpICsgMikgPT09IFwiMDBcIikge1xuICAgICAgICAgICAgICAgICAgICBnYXMgKz0gY29zdHMudHhEYXRhWmVybztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eERhdGFOb256ZXJvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHguYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgYWNjZXNzTGlzdCA9IGFjY2Vzc0xpc3RpZnkodHguYWNjZXNzTGlzdCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFkZHIgaW4gYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eEFjY2Vzc0xpc3RBZGRyZXNzICsgY29zdHMudHhBY2Nlc3NMaXN0U3RvcmFnZUtleSAqIGFjY2Vzc0xpc3RbYWRkcl0uc3RvcmFnZUtleXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnYXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IE5ldHdvcmsgZm9yIHRoZSAlJW5ldHdvcmslJSBuYW1lIG9yIGNoYWluSWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20obmV0d29yaykge1xuICAgICAgICBpbmplY3RDb21tb25OZXR3b3JrcygpO1xuICAgICAgICAvLyBEZWZhdWx0IG5ldHdvcmtcbiAgICAgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE5ldHdvcmsuZnJvbShcIm1haW5uZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2Fub25pY2FsIG5hbWUgb3IgY2hhaW4gSURcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG5ldHdvcmsgPSBCaWdJbnQobmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIChuZXR3b3JrKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgY29uc3QgbmV0d29ya0Z1bmMgPSBOZXR3b3Jrcy5nZXQobmV0d29yayk7XG4gICAgICAgICAgICBpZiAobmV0d29ya0Z1bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29ya0Z1bmMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOZXR3b3JrKFwidW5rbm93blwiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVua25vd24gbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xvbmFibGUgd2l0aCBuZXR3b3JrLWxpa2UgYWJpbGl0aWVzXG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmsuY2xvbmUpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lID0gbmV0d29yay5jbG9uZSgpO1xuICAgICAgICAgICAgLy9pZiAodHlwZW9mKG5ldHdvcmsubmFtZSkgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mKG5ldHdvcmsuY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5ldHdvcmtpc2hcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAobmV0d29yay5uYW1lKSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgKG5ldHdvcmsuY2hhaW5JZCkgPT09IFwibnVtYmVyXCIsIFwiaW52YWxpZCBuZXR3b3JrIG9iamVjdCBuYW1lIG9yIGNoYWluSWRcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tID0gbmV3IE5ldHdvcmsoKG5ldHdvcmsubmFtZSksIChuZXR3b3JrLmNoYWluSWQpKTtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrLmVuc0FkZHJlc3MgfHwgbmV0d29yay5lbnNOZXR3b3JrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXN0b20uYXR0YWNoUGx1Z2luKG5ldyBFbnNQbHVnaW4obmV0d29yay5lbnNBZGRyZXNzLCBuZXR3b3JrLmVuc05ldHdvcmspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaWYgKCg8YW55Pm5ldHdvcmspLmxheWVyT25lQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgLy8gICAgY3VzdG9tLmF0dGFjaFBsdWdpbihuZXcgTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luKCg8YW55Pm5ldHdvcmspLmxheWVyT25lQ29ubmVjdGlvbikpO1xuICAgICAgICAgICAgLy99XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZWdpc3RlciAlJW5hbWVPckNoYWluSWQlJSB3aXRoIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJuc1xuICAgICAqICBhbiBpbnN0YW5jZSBvZiBhIE5ldHdvcmsgcmVwcmVzZW50aW5nIHRoYXQgY2hhaW4uXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyKG5hbWVPckNoYWluSWQsIG5ldHdvcmtGdW5jKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG5hbWVPckNoYWluSWQpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBuYW1lT3JDaGFpbklkID0gQmlnSW50KG5hbWVPckNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gTmV0d29ya3MuZ2V0KG5hbWVPckNoYWluSWQpO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgY29uZmxpY3RpbmcgbmV0d29yayBmb3IgJHtKU09OLnN0cmluZ2lmeShleGlzdGluZy5uYW1lKX1gLCBcIm5hbWVPckNoYWluSWRcIiwgbmFtZU9yQ2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgTmV0d29ya3Muc2V0KG5hbWVPckNoYWluSWQsIG5ldHdvcmtGdW5jKTtcbiAgICB9XG59XG4vLyBXZSBkb24ndCB3YW50IHRvIGJyaW5nIGluIGZvcm1hdFVuaXRzIGJlY2F1c2UgaXQgaXMgYmFja2VkIGJ5XG4vLyBGaXhlZE51bWJlciBhbmQgd2Ugd2FudCB0byBrZWVwIE5ldHdvcmtzIHRpbnkuIFRoZSB2YWx1ZXNcbi8vIGluY2x1ZGVkIGJ5IHRoZSBHYXMgU3RhdGlvbnMgYXJlIGFsc28gSUVFRSA3NTQgd2l0aCBsb3RzIG9mXG4vLyByb3VuZGluZyBpc3N1ZXMgYW5kIGV4Y2VlZCB0aGUgc3RyaWN0IGNoZWNrcyBmb3JtYXRVbml0cyBoYXMuXG5mdW5jdGlvbiBwYXJzZVVuaXRzKF92YWx1ZSwgZGVjaW1hbHMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IFN0cmluZyhfdmFsdWUpO1xuICAgIGlmICghdmFsdWUubWF0Y2goL15bMC05Ll0rJC8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBnd2VpIHZhbHVlOiAke192YWx1ZX1gKTtcbiAgICB9XG4gICAgLy8gQnJlYWsgaW50byBbIHdob2xlLCBmcmFjdGlvbiBdXG4gICAgY29uc3QgY29tcHMgPSB2YWx1ZS5zcGxpdChcIi5cIik7XG4gICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb21wcy5wdXNoKFwiXCIpO1xuICAgIH1cbiAgICAvLyBNb3JlIHRoYW4gMSBkZWNpbWFsIHBvaW50IG9yIHRvbyBtYW55IGZyYWN0aW9uYWwgcG9zaXRpb25zXG4gICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZ3dlaSB2YWx1ZTogJHtfdmFsdWV9YCk7XG4gICAgfVxuICAgIC8vIFBhZCB0aGUgZnJhY3Rpb24gdG8gOSBkZWNpbWFscGxhY2VzXG4gICAgd2hpbGUgKGNvbXBzWzFdLmxlbmd0aCA8IGRlY2ltYWxzKSB7XG4gICAgICAgIGNvbXBzWzFdICs9IFwiMFwiO1xuICAgIH1cbiAgICAvLyBUb28gbWFueSBkZWNpbWFscyBhbmQgc29tZSBub24temVybyBlbmRpbmcsIHRha2UgdGhlIGNlaWxpbmdcbiAgICBpZiAoY29tcHNbMV0ubGVuZ3RoID4gOSkge1xuICAgICAgICBsZXQgZnJhYyA9IEJpZ0ludChjb21wc1sxXS5zdWJzdHJpbmcoMCwgOSkpO1xuICAgICAgICBpZiAoIWNvbXBzWzFdLnN1YnN0cmluZyg5KS5tYXRjaCgvXjArJC8pKSB7XG4gICAgICAgICAgICBmcmFjKys7XG4gICAgICAgIH1cbiAgICAgICAgY29tcHNbMV0gPSBmcmFjLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoY29tcHNbMF0gKyBjb21wc1sxXSk7XG59XG4vLyBVc2VkIGJ5IFBvbHlnb24gdG8gdXNlIGEgZ2FzIHN0YXRpb24gZm9yIGZlZSBkYXRhXG5mdW5jdGlvbiBnZXRHYXNTdGF0aW9uUGx1Z2luKHVybCkge1xuICAgIHJldHVybiBuZXcgRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbih1cmwsIGFzeW5jIChmZXRjaEZlZURhdGEsIHByb3ZpZGVyLCByZXF1ZXN0KSA9PiB7XG4gICAgICAgIC8vIFByZXZlbnQgQ2xvdWRmbGFyZSBmcm9tIGJsb2NraW5nIG91ciByZXF1ZXN0IGluIG5vZGUuanNcbiAgICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoXCJVc2VyLUFnZW50XCIsIFwiZXRoZXJzXCIpO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBbX3Jlc3BvbnNlLCBfZmVlRGF0YV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCksIGZldGNoRmVlRGF0YSgpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gX3Jlc3BvbnNlO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHJlc3BvbnNlLmJvZHlKc29uLnN0YW5kYXJkO1xuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogX2ZlZURhdGEuZ2FzUHJpY2UsXG4gICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBwYXJzZVVuaXRzKHBheWxvYWQubWF4RmVlLCA5KSxcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogcGFyc2VVbml0cyhwYXlsb2FkLm1heFByaW9yaXR5RmVlLCA5KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZmVlRGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYGVycm9yIGVuY291bnRlcmVkIHdpdGggcG9seWdvbiBnYXMgc3RhdGlvbiAoJHtKU09OLnN0cmluZ2lmeShyZXF1ZXN0LnVybCl9KWAsIFwiU0VSVkVSX0VSUk9SXCIsIHsgcmVxdWVzdCwgcmVzcG9uc2UsIGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyBVc2VkIGJ5IE9wdGltaXNtIGZvciBhIGN1c3RvbSBwcmlvcml0eSBmZWVcbmZ1bmN0aW9uIGdldFByaW9yaXR5RmVlUGx1Z2luKG1heFByaW9yaXR5RmVlUGVyR2FzKSB7XG4gICAgcmV0dXJuIG5ldyBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luKFwiZGF0YTpcIiwgYXN5bmMgKGZldGNoRmVlRGF0YSwgcHJvdmlkZXIsIHJlcXVlc3QpID0+IHtcbiAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IGZldGNoRmVlRGF0YSgpO1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBhbHdheXMgZmFpbFxuICAgICAgICBpZiAoZmVlRGF0YS5tYXhGZWVQZXJHYXMgPT0gbnVsbCB8fCBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmZWVEYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGNvcnJlY3RlZCBiYXNlRmVlIHRvIHJlY29tcHV0ZSB0aGUgdXBkYXRlZCB2YWx1ZXNcbiAgICAgICAgY29uc3QgYmFzZUZlZSA9IGZlZURhdGEubWF4RmVlUGVyR2FzIC0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdhc1ByaWNlOiBmZWVEYXRhLmdhc1ByaWNlLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiAoYmFzZUZlZSArIG1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzXG4gICAgICAgIH07XG4gICAgfSk7XG59XG4vLyBTZWU6IGh0dHBzOi8vY2hhaW5saXN0Lm9yZ1xubGV0IGluamVjdGVkID0gZmFsc2U7XG5mdW5jdGlvbiBpbmplY3RDb21tb25OZXR3b3JrcygpIHtcbiAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbmplY3RlZCA9IHRydWU7XG4gICAgLy8vIFJlZ2lzdGVyIHBvcHVsYXIgRXRoZXJldW0gbmV0d29ya3NcbiAgICBmdW5jdGlvbiByZWdpc3RlckV0aChuYW1lLCBjaGFpbklkLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV3IE5ldHdvcmsobmFtZSwgY2hhaW5JZCk7XG4gICAgICAgICAgICAvLyBXZSB1c2UgMCB0byBkaXNhYmxlIEVOU1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5zTmV0d29yayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV0d29yay5hdHRhY2hQbHVnaW4obmV3IEVuc1BsdWdpbihudWxsLCBvcHRpb25zLmVuc05ldHdvcmspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ldHdvcmsuYXR0YWNoUGx1Z2luKG5ldyBHYXNDb3N0UGx1Z2luKCkpO1xuICAgICAgICAgICAgKG9wdGlvbnMucGx1Z2lucyB8fCBbXSkuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICAgICAgICAgICAgbmV0d29yay5hdHRhY2hQbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBuZXR3b3JrIGJ5IG5hbWUgYW5kIGNoYWluIElEXG4gICAgICAgIE5ldHdvcmsucmVnaXN0ZXIobmFtZSwgZnVuYyk7XG4gICAgICAgIE5ldHdvcmsucmVnaXN0ZXIoY2hhaW5JZCwgZnVuYyk7XG4gICAgICAgIGlmIChvcHRpb25zLmFsdE5hbWVzKSB7XG4gICAgICAgICAgICBvcHRpb25zLmFsdE5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBOZXR3b3JrLnJlZ2lzdGVyKG5hbWUsIGZ1bmMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJFdGgoXCJtYWlubmV0XCIsIDEsIHsgZW5zTmV0d29yazogMSwgYWx0TmFtZXM6IFtcImhvbWVzdGVhZFwiXSB9KTtcbiAgICByZWdpc3RlckV0aChcInJvcHN0ZW5cIiwgMywgeyBlbnNOZXR3b3JrOiAzIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwicmlua2VieVwiLCA0LCB7IGVuc05ldHdvcms6IDQgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJnb2VybGlcIiwgNSwgeyBlbnNOZXR3b3JrOiA1IH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwia292YW5cIiwgNDIsIHsgZW5zTmV0d29yazogNDIgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJzZXBvbGlhXCIsIDExMTU1MTExLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJjbGFzc2ljXCIsIDYxLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJjbGFzc2ljS290dGlcIiwgNiwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYXJiaXRydW1cIiwgNDIxNjEsIHtcbiAgICAgICAgZW5zTmV0d29yazogMSxcbiAgICB9KTtcbiAgICByZWdpc3RlckV0aChcImFyYml0cnVtLWdvZXJsaVwiLCA0MjE2MTMsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImJuYlwiLCA1NiwgeyBlbnNOZXR3b3JrOiAxIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYm5idFwiLCA5Nywge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwibGluZWFcIiwgNTkxNDQsIHsgZW5zTmV0d29yazogMSB9KTtcbiAgICByZWdpc3RlckV0aChcImxpbmVhLWdvZXJsaVwiLCA1OTE0MCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwibWF0aWNcIiwgMTM3LCB7XG4gICAgICAgIGVuc05ldHdvcms6IDEsXG4gICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgIGdldEdhc1N0YXRpb25QbHVnaW4oXCJodHRwczovXFwvZ2Fzc3RhdGlvbi5wb2x5Z29uLnRlY2hub2xvZ3kvdjJcIilcbiAgICAgICAgXVxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwibWF0aWMtbXVtYmFpXCIsIDgwMDAxLCB7XG4gICAgICAgIGFsdE5hbWVzOiBbXCJtYXRpY011bWJhaVwiLCBcIm1hdGljbXVtXCJdLFxuICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICBnZXRHYXNTdGF0aW9uUGx1Z2luKFwiaHR0cHM6L1xcL2dhc3N0YXRpb24tdGVzdG5ldC5wb2x5Z29uLnRlY2hub2xvZ3kvdjJcIilcbiAgICAgICAgXVxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwib3B0aW1pc21cIiwgMTAsIHtcbiAgICAgICAgZW5zTmV0d29yazogMSxcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgZ2V0UHJpb3JpdHlGZWVQbHVnaW4oQmlnSW50KFwiMTAwMDAwMFwiKSlcbiAgICAgICAgXVxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwib3B0aW1pc20tZ29lcmxpXCIsIDQyMCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwieGRhaVwiLCAxMDAsIHsgZW5zTmV0d29yazogMSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmsuanMubWFwIiwiaW1wb3J0IHsgYXNzZXJ0LCBpc0hleFN0cmluZyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuZnVuY3Rpb24gY29weShvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgcG9sbGluZyBzdWJzY3JpYmVyIGZvciBjb21tb24gZXZlbnRzLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9sbGluZ1N1YnNjcmliZXIocHJvdmlkZXIsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ID09PSBcImJsb2NrXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKHByb3ZpZGVyKTtcbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaW5nKGV2ZW50LCAzMikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKHByb3ZpZGVyLCBldmVudCk7XG4gICAgfVxuICAgIGFzc2VydChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBwb2xsaW5nIGV2ZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcImdldFBvbGxpbmdTdWJzY3JpYmVyXCIsIGluZm86IHsgZXZlbnQgfVxuICAgIH0pO1xufVxuLy8gQFRPRE86IHJlZmFjdG9yIHRoaXNcbi8qKlxuICogIEEgKipQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKiogcG9sbHMgYXQgYSByZWd1bGFyIGludGVydmFsIGZvciBhIGNoYW5nZVxuICogIGluIHRoZSBibG9jayBudW1iZXIuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI3BvbGxlcjtcbiAgICAjaW50ZXJ2YWw7XG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGJsb2NrIHdlIGhhdmUgc2Nhbm5lZCBmb3IgZXZlbnRzLiBUaGUgdmFsdWUgLTJcbiAgICAvLyBpbmRpY2F0ZXMgd2Ugc3RpbGwgbmVlZCB0byBmZXRjaCBhbiBpbml0aWFsIGJsb2NrIG51bWJlclxuICAgICNibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLiNpbnRlcnZhbCA9IDQwMDA7XG4gICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcG9sbGluZyBpbnRlcnZhbC5cbiAgICAgKi9cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkgeyByZXR1cm4gdGhpcy4jaW50ZXJ2YWw7IH1cbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7IHRoaXMuI2ludGVydmFsID0gdmFsdWU7IH1cbiAgICBhc3luYyAjcG9sbCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgICAgIC8vIEJvb3RzdHJhcCBwb2xsIHRvIHNldHVwIG91ciBpbml0aWFsIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyID09PSAtMikge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQFRPRE86IFB1dCBhIGNhcCBvbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgZXZlbnRzIHBlciBsb29wP1xuICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyICE9PSB0aGlzLiNibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGIgPSB0aGlzLiNibG9ja051bWJlciArIDE7IGIgPD0gYmxvY2tOdW1iZXI7IGIrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGJlZW4gc3RvcHBlZFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jcG9sbGVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNwcm92aWRlci5lbWl0KFwiYmxvY2tcIiwgYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBAVE9ETzogTWlub3IgYnVtcCwgYWRkIGFuIFwiZXJyb3JcIiBldmVudCB0byBsZXQgc3Vic2NyaWJlcnNcbiAgICAgICAgICAgIC8vICAgICAgICBrbm93IHRoaW5ncyB3ZW50IGF3cnkuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIGJlZW4gc3RvcHBlZFxuICAgICAgICBpZiAodGhpcy4jcG9sbGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwcm92aWRlci5fc2V0VGltZW91dCh0aGlzLiNwb2xsLmJpbmQodGhpcyksIHRoaXMuI2ludGVydmFsKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNwb2xsZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwcm92aWRlci5fc2V0VGltZW91dCh0aGlzLiNwb2xsLmJpbmQodGhpcyksIHRoaXMuI2ludGVydmFsKTtcbiAgICAgICAgdGhpcy4jcG9sbCgpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3BvbGxlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLl9jbGVhclRpbWVvdXQodGhpcy4jcG9sbGVyKTtcbiAgICAgICAgdGhpcy4jcG9sbGVyID0gbnVsbDtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbn1cbi8qKlxuICogIEFuICoqT25CbG9ja1N1YnNjcmliZXIqKiBjYW4gYmUgc3ViLWNsYXNzZWQsIHdpdGggYSBbW19wb2xsXV1cbiAqICBpbXBsbWVudGF0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIG9uIGV2ZXJ5IG5ldyBibG9jay5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI3BvbGw7XG4gICAgI3J1bm5pbmc7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKk9uQmxvY2tTdWJzY3JpYmVyKiogYXR0YWNoZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jcG9sbCA9IChibG9ja051bWJlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcG9sbChibG9ja051bWJlciwgdGhpcy4jcHJvdmlkZXIpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2FsbGVkIG9uIGV2ZXJ5IG5ldyBibG9jay5cbiAgICAgKi9cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViLWNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzXCIpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jcG9sbCgtMik7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uKFwiYmxvY2tcIiwgdGhpcy4jcG9sbCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbCk7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkgeyB0aGlzLnN0b3AoKTsgfVxuICAgIHJlc3VtZSgpIHsgdGhpcy5zdGFydCgpOyB9XG59XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyIGV4dGVuZHMgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICNmaWx0ZXI7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2ZpbHRlciA9IGNvcHkoZmlsdGVyKTtcbiAgICB9XG4gICAgYXN5bmMgX3BvbGwoYmxvY2tOdW1iZXIsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLiNmaWx0ZXIpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKiogd2lsbCBwb2xsIGZvciBhIGdpdmVuIHRyYW5zYWN0aW9uXG4gKiAgaGFzaCBmb3IgaXRzIHJlY2VpcHQuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyIGV4dGVuZHMgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICNoYXNoO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKiogYXR0YWNoZWQgdG9cbiAgICAgKiAgJSVwcm92aWRlciUlLCBsaXN0ZW5pbmcgZm9yICUlaGFzaCUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBoYXNoKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jaGFzaCA9IGhhc2g7XG4gICAgfVxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLiNoYXNoKTtcbiAgICAgICAgaWYgKHR4KSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMuI2hhc2gsIHR4KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogIEEgKipQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKiogd2lsbCBwb2xsIGZvciBhIGdpdmVuIGZpbHRlciBmb3IgaXRzIGxvZ3MuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI2ZpbHRlcjtcbiAgICAjcG9sbGVyO1xuICAgICNydW5uaW5nO1xuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBibG9jayB3ZSBoYXZlIHNjYW5uZWQgZm9yIGV2ZW50cy4gVGhlIHZhbHVlIC0yXG4gICAgLy8gaW5kaWNhdGVzIHdlIHN0aWxsIG5lZWQgdG8gZmV0Y2ggYW4gaW5pdGlhbCBibG9jayBudW1iZXJcbiAgICAjYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIqKiBhdHRhY2hlZCB0b1xuICAgICAqICAlJXByb3ZpZGVyJSUsIGxpc3RlbmluZyBmb3IgJSVmaWx0ZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI2ZpbHRlciA9IGNvcHkoZmlsdGVyKTtcbiAgICAgICAgdGhpcy4jcG9sbGVyID0gdGhpcy4jcG9sbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgfVxuICAgIGFzeW5jICNwb2xsKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIC8vIFRoZSBpbml0aWFsIGJsb2NrIGhhc24ndCBiZWVuIGRldGVybWluZWQgeWV0XG4gICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXIgPSBjb3B5KHRoaXMuI2ZpbHRlcik7XG4gICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSB0aGlzLiNibG9ja051bWJlciArIDE7XG4gICAgICAgIGZpbHRlci50b0Jsb2NrID0gYmxvY2tOdW1iZXI7XG4gICAgICAgIGNvbnN0IGxvZ3MgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5nZXRMb2dzKGZpbHRlcik7XG4gICAgICAgIC8vIE5vIGxvZ3MgY291bGQganVzdCBtZWFuIHRoZSBub2RlIGhhcyBub3QgaW5kZXhlZCB0aGVtIHlldCxcbiAgICAgICAgLy8gc28gd2Uga2VlcCBhIHNsaWRpbmcgd2luZG93IG9mIDYwIGJsb2NrcyB0byBrZWVwIHNjYW5uaW5nXG4gICAgICAgIGlmIChsb2dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyIDwgYmxvY2tOdW1iZXIgLSA2MCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGxvZyBvZiBsb2dzKSB7XG4gICAgICAgICAgICB0aGlzLiNwcm92aWRlci5lbWl0KHRoaXMuI2ZpbHRlciwgbG9nKTtcbiAgICAgICAgICAgIC8vIE9ubHkgYWR2YW5jZSB0aGUgYmxvY2sgbnVtYmVyIHdoZW4gbG9ncyB3ZXJlIGZvdW5kIHRvXG4gICAgICAgICAgICAvLyBhY2NvdW50IGZvciBuZXR3b3JrcyAobGlrZSBCTkIgYW5kIFBvbHlnb24pIHdoaWNoIG1heVxuICAgICAgICAgICAgLy8gc2FjcmlmaWNlIGV2ZW50IGNvbnNpc3RlbmN5IGZvciBibG9jayBldmVudCBzcGVlZFxuICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBsb2cuYmxvY2tOdW1iZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCkudGhlbigoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub24oXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgaWYgKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVyLXBvbGxpbmcuanMubWFwIiwiLyoqXG4gKiAgVGhlIGF2YWlsYWJsZSBwcm92aWRlcnMgc2hvdWxkIHN1ZmZpY2UgZm9yIG1vc3QgZGV2ZWxvcGVycyBwdXJwb3NlcyxcbiAqICBidXQgdGhlIFtbQWJzdHJhY3RQcm92aWRlcl1dIGNsYXNzIGhhcyBtYW55IGZlYXR1cmVzIHdoaWNoIGVuYWJsZVxuICogIHN1Yi1jbGFzc2luZyBpdCBmb3Igc3BlY2lmaWMgcHVycG9zZXMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlcjogU3ViY2xhc3NpbmcgUHJvdmlkZXIgIFthYnN0cmFjdC1wcm92aWRlcl1cbiAqL1xuLy8gQFRPRE9cbi8vIEV2ZW50IGNvYWxlc2NlbmNlXG4vLyAgIFdoZW4gd2UgcmVnaXN0ZXIgYW4gZXZlbnQgd2l0aCBhbiBhc3luYyB2YWx1ZSAoZS5nLiBhZGRyZXNzIGlzIGEgU2lnbmVyXG4vLyAgIG9yIEVOUyBuYW1lKSwgd2UgbmVlZCB0byBhZGQgaXQgaW1tZWlkYXRlbHkgZm9yIHRoZSBFdmVudCBBUEksIGJ1dCBhbHNvXG4vLyAgIG5lZWQgdGltZSB0byByZXNvbHZlIHRoZSBhZGRyZXNzLiBVcG9uIHJlc29sdmluZyB0aGUgYWRkcmVzcywgd2UgbmVlZCB0b1xuLy8gICBtaWdyYXRlIHRoZSBsaXN0ZW5lciB0byB0aGUgc3RhdGljIGV2ZW50LiBXZSBhbHNvIG5lZWQgdG8gbWFpbnRhaW4gYSBtYXBcbi8vICAgb2YgU2lnbmVyL0VOUyBuYW1lIHRvIGFkZHJlc3Mgc28gd2UgY2FuIHN5bmMgcmVzcG9uZCB0byBsaXN0ZW5lckNvdW50LlxuaW1wb3J0IHsgZ2V0QWRkcmVzcywgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgWmVyb0FkZHJlc3MgfSBmcm9tIFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDb250cmFjdCB9IGZyb20gXCIuLi9jb250cmFjdC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbmFtZWhhc2ggfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YUxlbmd0aCwgZGF0YVNsaWNlLCBoZXhsaWZ5LCBpc0hleFN0cmluZywgZ2V0QmlnSW50LCBnZXRCeXRlcywgZ2V0TnVtYmVyLCBpc0NhbGxFeGNlcHRpb24sIGlzRXJyb3IsIG1ha2VFcnJvciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgRmV0Y2hSZXF1ZXN0LCB0b0JlQXJyYXksIHRvUXVhbnRpdHksIGRlZmluZVByb3BlcnRpZXMsIEV2ZW50UGF5bG9hZCwgcmVzb2x2ZVByb3BlcnRpZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRW5zUmVzb2x2ZXIgfSBmcm9tIFwiLi9lbnMtcmVzb2x2ZXIuanNcIjtcbmltcG9ydCB7IGZvcm1hdEJsb2NrLCBmb3JtYXRMb2csIGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCwgZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSB9IGZyb20gXCIuL2Zvcm1hdC5qc1wiO1xuaW1wb3J0IHsgTmV0d29yayB9IGZyb20gXCIuL25ldHdvcmsuanNcIjtcbmltcG9ydCB7IGNvcHlSZXF1ZXN0LCBCbG9jaywgRmVlRGF0YSwgTG9nLCBUcmFuc2FjdGlvblJlY2VpcHQsIFRyYW5zYWN0aW9uUmVzcG9uc2UgfSBmcm9tIFwiLi9wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgUG9sbGluZ0Jsb2NrU3Vic2NyaWJlciwgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciwgUG9sbGluZ09ycGhhblN1YnNjcmliZXIsIFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIjtcbi8vIENvbnN0YW50c1xuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcbmNvbnN0IE1BWF9DQ0lQX1JFRElSRUNUUyA9IDEwO1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnRoZW4pID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gZ2V0VGFnKHByZWZpeCwgdmFsdWUpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgXCI6XCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKGssIHYpID0+IHtcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYGJpZ2ludDoke3YudG9TdHJpbmcoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnQgb2JqZWN0IGtleXNcbiAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2KTtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIGtleXMucmVkdWNlKChhY2N1bSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjdW1ba2V5XSA9IHZba2V5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfSk7XG59XG4vKipcbiAqICBBbiAqKlVubWFuYWdlZFN1YnNjcmliZXIqKiBpcyB1c2VmdWwgZm9yIGV2ZW50cyB3aGljaCBkbyBub3QgcmVxdWlyZVxuICogIGFueSBhZGRpdGlvbmFsIG1hbmFnZW1lbnQsIHN1Y2ggYXMgYGBcImRlYnVnXCJgYCB3aGljaCBvbmx5IHJlcXVpcmVzXG4gKiAgZW1pdCBpbiBzeW5jaHJvbm91cyBldmVudCBsb29wIHRyaWdnZXJlZCBjYWxscy5cbiAqL1xuZXhwb3J0IGNsYXNzIFVubWFuYWdlZFN1YnNjcmliZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBmb2YgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBVbm1hbmFnZWRTdWJzY3JpYmVyIHdpdGggJSVuYW1lJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSkgeyBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTsgfVxuICAgIHN0YXJ0KCkgeyB9XG4gICAgc3RvcCgpIHsgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkgeyB9XG4gICAgcmVzdW1lKCkgeyB9XG59XG5mdW5jdGlvbiBjb3B5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGNvbmNpc2lmeShpdGVtcykge1xuICAgIGl0ZW1zID0gQXJyYXkuZnJvbSgobmV3IFNldChpdGVtcykpLnZhbHVlcygpKTtcbiAgICBpdGVtcy5zb3J0KCk7XG4gICAgcmV0dXJuIGl0ZW1zO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uKF9ldmVudCwgcHJvdmlkZXIpIHtcbiAgICBpZiAoX2V2ZW50ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBldmVudFwiKTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIHRvcGljIGFycmF5IGluZm8gYW4gRXZlbnRGaWx0ZXJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShfZXZlbnQpKSB7XG4gICAgICAgIF9ldmVudCA9IHsgdG9waWNzOiBfZXZlbnQgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoX2V2ZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzd2l0Y2ggKF9ldmVudCkge1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgIGNhc2UgXCJuZXR3b3JrXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBfZXZlbnQsIHRhZzogX2V2ZW50IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaW5nKF9ldmVudCwgMzIpKSB7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBfZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0cmFuc2FjdGlvblwiLCB0YWc6IGdldFRhZyhcInR4XCIsIHsgaGFzaCB9KSwgaGFzaCB9O1xuICAgIH1cbiAgICBpZiAoX2V2ZW50Lm9ycGhhbikge1xuICAgICAgICBjb25zdCBldmVudCA9IF9ldmVudDtcbiAgICAgICAgLy8gQFRPRE86IFNob3VsZCBsb3dlcmNhc2UgYW5kIHdoYXRub3QgdGhpbmdzIGhlcmUgaW5zdGVhZCBvZiBjb3B5Li4uXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwib3JwaGFuXCIsIHRhZzogZ2V0VGFnKFwib3JwaGFuXCIsIGV2ZW50KSwgZmlsdGVyOiBjb3B5KGV2ZW50KSB9O1xuICAgIH1cbiAgICBpZiAoKF9ldmVudC5hZGRyZXNzIHx8IF9ldmVudC50b3BpY3MpKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gX2V2ZW50O1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgICB0b3BpY3M6ICgoZXZlbnQudG9waWNzIHx8IFtdKS5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uY2lzaWZ5KHQubWFwKCh0KSA9PiB0LnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZXZlbnQuYWRkcmVzcykge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gW107XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYWRkQWRkcmVzcyA9IChhZGRyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGFkZHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKGFkZHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goYXdhaXQgcmVzb2x2ZUFkZHJlc3MoYWRkciwgcHJvdmlkZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50LmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuYWRkcmVzcy5mb3JFYWNoKGFkZEFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkQWRkcmVzcyhldmVudC5hZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGNvbmNpc2lmeShhZGRyZXNzZXMubWFwKChhKSA9PiBhLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmaWx0ZXIsIHRhZzogZ2V0VGFnKFwiZXZlbnRcIiwgZmlsdGVyKSwgdHlwZTogXCJldmVudFwiIH07XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVua25vd24gUHJvdmlkZXJFdmVudFwiLCBcImV2ZW50XCIsIF9ldmVudCk7XG59XG5mdW5jdGlvbiBnZXRUaW1lKCkgeyByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTsgfVxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgY2FjaGVUaW1lb3V0OiAyNTAsXG4gICAgcG9sbGluZ0ludGVydmFsOiA0MDAwXG59O1xuLyoqXG4gKiAgQW4gKipBYnN0cmFjdFByb3ZpZGVyKiogcHJvdmlkZXMgYSBiYXNlIGNsYXNzIGZvciBvdGhlciBzdWItY2xhc3NlcyB0b1xuICogIGltcGxlbWVudCB0aGUgW1tQcm92aWRlcl1dIEFQSSBieSBub3JtYWxpemluZyBpbnB1dCBhcmd1bWVudHMgYW5kXG4gKiAgZm9ybWF0dGluZyBvdXRwdXQgcmVzdWx0cyBhcyB3ZWxsIGFzIHRyYWNraW5nIGV2ZW50cyBmb3IgY29uc2lzdGVudFxuICogIGJlaGF2aW91ciBvbiBhbiBldmVudHVhbGx5LWNvbnNpc3RlbnQgbmV0d29yay5cbiAqL1xuZXhwb3J0IGNsYXNzIEFic3RyYWN0UHJvdmlkZXIge1xuICAgICNzdWJzO1xuICAgICNwbHVnaW5zO1xuICAgIC8vIG51bGw9dW5wYXVzZWQsIHRydWU9cGF1c2VkK2Ryb3BXaGlsZVBhdXNlZCwgZmFsc2U9cGF1c2VkXG4gICAgI3BhdXNlZFN0YXRlO1xuICAgICNkZXN0cm95ZWQ7XG4gICAgI25ldHdvcmtQcm9taXNlO1xuICAgICNhbnlOZXR3b3JrO1xuICAgICNwZXJmb3JtQ2FjaGU7XG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGJsb2NrIG51bWJlciBpZiBydW5uaW5nIGFuIGV2ZW50IG9yIC0xIGlmIG5vIFwiYmxvY2tcIiBldmVudFxuICAgICNsYXN0QmxvY2tOdW1iZXI7XG4gICAgI25leHRUaW1lcjtcbiAgICAjdGltZXJzO1xuICAgICNkaXNhYmxlQ2NpcFJlYWQ7XG4gICAgI29wdGlvbnM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkFic3RyYWN0UHJvdmlkZXIqKiBjb25uZWN0ZWQgdG8gJSVuZXR3b3JrJSUsIG9yXG4gICAgICogIHVzZSB0aGUgdmFyaW91cyBuZXR3b3JrIGRldGVjdGlvbiBjYXBhYmlsaXRpZXMgdG8gZGlzY292ZXIgdGhlXG4gICAgICogIFtbTmV0d29ya11dIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfbmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLiNvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICBpZiAoX25ldHdvcmsgPT09IFwiYW55XCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2FueU5ldHdvcmsgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9uZXR3b3JrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gTmV0d29yay5mcm9tKF9uZXR3b3JrKTtcbiAgICAgICAgICAgIHRoaXMuI2FueU5ldHdvcmsgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKG5ldHdvcmspO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7IH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jYW55TmV0d29yayA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2xhc3RCbG9ja051bWJlciA9IC0xO1xuICAgICAgICB0aGlzLiNwZXJmb3JtQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3N1YnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3BsdWdpbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3BhdXNlZFN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI25leHRUaW1lciA9IDE7XG4gICAgICAgIHRoaXMuI3RpbWVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZGlzYWJsZUNjaXBSZWFkID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7IHJldHVybiB0aGlzLiNvcHRpb25zLnBvbGxpbmdJbnRlcnZhbDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdGhpc2BgLCB0byBhbGxvdyBhbiAqKkFic3RyYWN0UHJvdmlkZXIqKiB0byBpbXBsZW1lbnRcbiAgICAgKiAgdGhlIFtbQ29udHJhY3RSdW5uZXJdXSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZ2V0IHByb3ZpZGVyKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGFsbCB0aGUgcmVnaXN0ZXJlZCBwbHVnLWlucy5cbiAgICAgKi9cbiAgICBnZXQgcGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jcGx1Z2lucy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBdHRhY2ggYSBuZXcgcGx1Zy1pbi5cbiAgICAgKi9cbiAgICBhdHRhY2hQbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIGlmICh0aGlzLiNwbHVnaW5zLmdldChwbHVnaW4ubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlcGxhY2UgZXhpc3RpbmcgcGx1Z2luOiAke3BsdWdpbi5uYW1lfSBgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwbHVnaW5zLnNldChwbHVnaW4ubmFtZSwgcGx1Z2luLmNvbm5lY3QodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCBhIHBsdWdpbiBieSBuYW1lLlxuICAgICAqL1xuICAgIGdldFBsdWdpbihuYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jcGx1Z2lucy5nZXQobmFtZSkpIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcmV2ZW50IGFueSBDQ0lQLXJlYWQgb3BlcmF0aW9uLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgcmVxdWVzdGVkXG4gICAgICogIGluIGEgW1tjYWxsXV0gdXNpbmcgYGBlbmFibGVDY2lwUmVhZGBgLlxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlQ2NpcFJlYWQoKSB7IHJldHVybiB0aGlzLiNkaXNhYmxlQ2NpcFJlYWQ7IH1cbiAgICBzZXQgZGlzYWJsZUNjaXBSZWFkKHZhbHVlKSB7IHRoaXMuI2Rpc2FibGVDY2lwUmVhZCA9ICEhdmFsdWU7IH1cbiAgICAvLyBTaGFyZXMgbXVsdGlwbGUgaWRlbnRpY2FsIHJlcXVlc3RzIG1hZGUgZHVyaW5nIHRoZSBzYW1lIDI1MG1zXG4gICAgYXN5bmMgI3BlcmZvcm0ocmVxKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLiNvcHRpb25zLmNhY2hlVGltZW91dDtcbiAgICAgICAgLy8gQ2FjaGluZyBkaXNhYmxlZFxuICAgICAgICBpZiAodGltZW91dCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9wZXJmb3JtKHJlcSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgdGFnXG4gICAgICAgIGNvbnN0IHRhZyA9IGdldFRhZyhyZXEubWV0aG9kLCByZXEpO1xuICAgICAgICBsZXQgcGVyZm9ybSA9IHRoaXMuI3BlcmZvcm1DYWNoZS5nZXQodGFnKTtcbiAgICAgICAgaWYgKCFwZXJmb3JtKSB7XG4gICAgICAgICAgICBwZXJmb3JtID0gdGhpcy5fcGVyZm9ybShyZXEpO1xuICAgICAgICAgICAgdGhpcy4jcGVyZm9ybUNhY2hlLnNldCh0YWcsIHBlcmZvcm0pO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3BlcmZvcm1DYWNoZS5nZXQodGFnKSA9PT0gcGVyZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNwZXJmb3JtQ2FjaGUuZGVsZXRlKHRhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHBlcmZvcm07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgZGF0YSBmb3IgZXhlY3V0aW5nIHRoZSBDQ0lQLXJlYWQgb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBjY2lwUmVhZEZldGNoKHR4LCBjYWxsZGF0YSwgdXJscykge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlQ2NpcFJlYWQgfHwgdXJscy5sZW5ndGggPT09IDAgfHwgdHgudG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZGVyID0gdHgudG8udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNhbGxkYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSB1cmxzW2ldO1xuICAgICAgICAgICAgLy8gVVJMIGV4cGFuc2lvblxuICAgICAgICAgICAgY29uc3QgaHJlZiA9IHVybC5yZXBsYWNlKFwie3NlbmRlcn1cIiwgc2VuZGVyKS5yZXBsYWNlKFwie2RhdGF9XCIsIGRhdGEpO1xuICAgICAgICAgICAgLy8gSWYgbm8ge2RhdGF9IGlzIHByZXNlbnQsIHVzZSBQT1NUOyBvdGhlcndpc2UgR0VUXG4gICAgICAgICAgICAvL2NvbnN0IGpzb246IHN0cmluZyB8IG51bGwgPSAodXJsLmluZGV4T2YoXCJ7ZGF0YX1cIikgPj0gMCkgPyBudWxsOiBKU09OLnN0cmluZ2lmeSh7IGRhdGEsIHNlbmRlciB9KTtcbiAgICAgICAgICAgIC8vY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2hKc29uKHsgdXJsOiBocmVmLCBlcnJvclBhc3NUaHJvdWdoOiB0cnVlIH0sIGpzb24sICh2YWx1ZSwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIC8vICAgIHZhbHVlLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgICAgICAvLyAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAvL30pO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBGZXRjaFJlcXVlc3QoaHJlZik7XG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoXCJ7ZGF0YX1cIikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ib2R5ID0geyBkYXRhLCBzZW5kZXIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRDY2lwUmVhZEZldGNoUmVxdWVzdFwiLCByZXF1ZXN0LCBpbmRleDogaSwgdXJscyB9KTtcbiAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcInVua25vd24gZXJyb3JcIjtcbiAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzcC5ib2R5SnNvbjtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkRmV0Y2hSZXN1bHRcIiwgcmVxdWVzdCwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSByZXN1bHQubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkRmV0Y2hFcnJvclwiLCByZXF1ZXN0LCByZXN1bHQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgLy8gNHh4IGluZGljYXRlcyB0aGUgcmVzdWx0IGlzIG5vdCBwcmVzZW50OyBzdG9wXG4gICAgICAgICAgICBhc3NlcnQocmVzcC5zdGF0dXNDb2RlIDwgNDAwIHx8IHJlc3Auc3RhdHVzQ29kZSA+PSA1MDAsIGByZXNwb25zZSBub3QgZm91bmQgZHVyaW5nIENDSVAgZmV0Y2g6ICR7ZXJyb3JNZXNzYWdlfWAsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwgeyByZWFzb246IFwiNDA0X01JU1NJTkdfUkVTT1VSQ0VcIiwgdHJhbnNhY3Rpb246IHR4LCBpbmZvOiB7IHVybCwgZXJyb3JNZXNzYWdlIH0gfSk7XG4gICAgICAgICAgICAvLyA1eHggaW5kaWNhdGVzIHNlcnZlciBpc3N1ZTsgdHJ5IHRoZSBuZXh0IHVybFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlcy5wdXNoKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIENDSVAgZmV0Y2g6ICR7ZXJyb3JNZXNzYWdlcy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0pKS5qb2luKFwiLCBcIil9YCwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiNTAwX1NFUlZFUl9FUlJPUlwiLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHR4LCBpbmZvOiB7IHVybHMsIGVycm9yTWVzc2FnZXMgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIGJsb2NrIGJlZm9yZVxuICAgICAqICByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW4gYWx0ZXJuYXRlXG4gICAgICogIHN1Yi1jbGFzcyBvZiBbW0Jsb2NrXV0uXG4gICAgICovXG4gICAgX3dyYXBCbG9jayh2YWx1ZSwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrKGZvcm1hdEJsb2NrKHZhbHVlKSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSBsb2cgYmVmb3JlXG4gICAgICogIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhbiBhbHRlcm5hdGVcbiAgICAgKiAgc3ViLWNsYXNzIG9mIFtbTG9nXV0uXG4gICAgICovXG4gICAgX3dyYXBMb2codmFsdWUsIG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2coZm9ybWF0TG9nKHZhbHVlKSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSB0cmFuc2FjdGlvblxuICAgICAqICByZWNlaXB0IGJlZm9yZSByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW5cbiAgICAgKiAgYWx0ZXJuYXRlIHN1Yi1jbGFzcyBvZiBbW1RyYW5zYWN0aW9uUmVjZWlwdF1dLlxuICAgICAqL1xuICAgIF93cmFwVHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlLCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25SZWNlaXB0KGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgdHJhbnNhY3Rpb25cbiAgICAgKiAgcmVzcG9uc2UgYmVmb3JlIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhblxuICAgICAqICBhbHRlcm5hdGUgc3ViLWNsYXNzIG9mIFtbVHJhbnNhY3Rpb25SZXNwb25zZV1dLlxuICAgICAqL1xuICAgIF93cmFwVHJhbnNhY3Rpb25SZXNwb25zZSh0eCwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UoZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSh0eCksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIE5ldHdvcmssIGZvcmNpbmcgYSBuZXR3b3JrIGRldGVjdGlvbiB1c2luZyB3aGF0ZXZlclxuICAgICAqICB0ZWNobmlxdWUgdGhlIHN1Yi1jbGFzcyByZXF1aXJlcy5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzLlxuICAgICAqL1xuICAgIF9kZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwic3ViLWNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgdGhpc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiX2RldGVjdE5ldHdvcmtcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIHNob3VsZCB1c2UgdGhpcyB0byBwZXJmb3JtIGFsbCBidWlsdC1pbiBvcGVyYXRpb25zLiBBbGxcbiAgICAgKiAgbWV0aG9kcyBzYW5pdGl6ZXMgYW5kIG5vcm1hbGl6ZXMgdGhlIHZhbHVlcyBwYXNzZWQgaW50byB0aGlzLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMuXG4gICAgICovXG4gICAgYXN5bmMgX3BlcmZvcm0ocmVxKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgYHVuc3VwcG9ydGVkIG1ldGhvZDogJHtyZXEubWV0aG9kfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogcmVxLm1ldGhvZCxcbiAgICAgICAgICAgIGluZm86IHJlcVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gU3RhdGVcbiAgICBhc3luYyBnZXRCbG9ja051bWJlcigpIHtcbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBnZXROdW1iZXIoYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRCbG9ja051bWJlclwiIH0pLCBcIiVyZXNwb25zZVwiKTtcbiAgICAgICAgaWYgKHRoaXMuI2xhc3RCbG9ja051bWJlciA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIHRoZSBhZGRyZXNzIGZvciAlJWFkZHJlc3MlJSwgcmVzb2x2aW5nIEVOU1xuICAgICAqICBuYW1lcyBhbmQgW1tBZGRyZXNzYWJsZV1dIG9iamVjdHMgYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGFuXG4gICAgICogIGFkZHJlc3MuXG4gICAgICovXG4gICAgX2dldEFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFkZHJlc3MoYWRkcmVzcywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIGEgdmFsaWQgYmxvY2sgdGFnIGZvciAlJWJsb2NrVGFnJSUsIHJlc29sdmluZ1xuICAgICAqICBuZWdhdGl2ZSB2YWx1ZXMgYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGEgdmFsaWQgYmxvY2sgdGFnLlxuICAgICAqL1xuICAgIF9nZXRCbG9ja1RhZyhibG9ja1RhZykge1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibGF0ZXN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChibG9ja1RhZykge1xuICAgICAgICAgICAgY2FzZSBcImVhcmxpZXN0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiMHgwXCI7XG4gICAgICAgICAgICBjYXNlIFwibGF0ZXN0XCI6XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcInNhZmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tUYWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGJsb2NrVGFnKSkge1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGJsb2NrVGFnLCAzMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9RdWFudGl0eShibG9ja1RhZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9IGdldE51bWJlcihibG9ja1RhZywgXCJibG9ja1RhZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmIChibG9ja1RhZyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvUXVhbnRpdHkoYmxvY2tUYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI2xhc3RCbG9ja051bWJlciA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvUXVhbnRpdHkodGhpcy4jbGFzdEJsb2NrTnVtYmVyICsgYmxvY2tUYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKChiKSA9PiB0b1F1YW50aXR5KGIgKyBibG9ja1RhZykpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgYmxvY2tUYWdcIiwgXCJibG9ja1RhZ1wiLCBibG9ja1RhZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIGEgZmlsdGVyIGZvciAlJWZpbHRlciUlLCByZXNvbHZpbmcgYW55IEVOU1xuICAgICAqICBuYW1lcyBvciBbW0FkZHJlc3NhYmxlXV0gb2JqZWN0IGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhIHZhbGlkXG4gICAgICogIGZpbHRlci5cbiAgICAgKi9cbiAgICBfZ2V0RmlsdGVyKGZpbHRlcikge1xuICAgICAgICAvLyBDcmVhdGUgYSBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRvcGljc1xuICAgICAgICBjb25zdCB0b3BpY3MgPSAoZmlsdGVyLnRvcGljcyB8fCBbXSkubWFwKCh0KSA9PiB7XG4gICAgICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25jaXNpZnkodC5tYXAoKHQpID0+IHQudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJsb2NrSGFzaCA9IChcImJsb2NrSGFzaFwiIGluIGZpbHRlcikgPyBmaWx0ZXIuYmxvY2tIYXNoIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCByZXNvbHZlID0gKF9hZGRyZXNzLCBmcm9tQmxvY2ssIHRvQmxvY2spID0+IHtcbiAgICAgICAgICAgIGxldCBhZGRyZXNzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgc3dpdGNoIChfYWRkcmVzcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hZGRyZXNzWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBfYWRkcmVzcy5zb3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG9ja0hhc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUJsb2NrICE9IG51bGwgfHwgdG9CbG9jayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmlsdGVyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHt9O1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9waWNzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZpbHRlci50b3BpY3MgPSB0b3BpY3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJvbUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9IGZyb21CbG9jaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLnRvQmxvY2sgPSB0b0Jsb2NrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrSGFzaCkge1xuICAgICAgICAgICAgICAgIGZpbHRlci5ibG9ja0hhc2ggPSBibG9ja0hhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgICAgICB9O1xuICAgICAgICAvLyBBZGRyZXNzZXMgY291bGQgYmUgYXN5bmMgKEVOUyBuYW1lcyBvciBBZGRyZXNzYWJsZXMpXG4gICAgICAgIGxldCBhZGRyZXNzID0gW107XG4gICAgICAgIGlmIChmaWx0ZXIuYWRkcmVzcykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhZGRyIG9mIGZpbHRlci5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MucHVzaCh0aGlzLl9nZXRBZGRyZXNzKGFkZHIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLnB1c2godGhpcy5fZ2V0QWRkcmVzcyhmaWx0ZXIuYWRkcmVzcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBmcm9tQmxvY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChcImZyb21CbG9ja1wiIGluIGZpbHRlcikge1xuICAgICAgICAgICAgZnJvbUJsb2NrID0gdGhpcy5fZ2V0QmxvY2tUYWcoZmlsdGVyLmZyb21CbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvQmxvY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChcInRvQmxvY2tcIiBpbiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIHRvQmxvY2sgPSB0aGlzLl9nZXRCbG9ja1RhZyhmaWx0ZXIudG9CbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZHJlc3MuZmlsdGVyKChhKSA9PiAodHlwZW9mIChhKSAhPT0gXCJzdHJpbmdcIikpLmxlbmd0aCB8fFxuICAgICAgICAgICAgKGZyb21CbG9jayAhPSBudWxsICYmIHR5cGVvZiAoZnJvbUJsb2NrKSAhPT0gXCJzdHJpbmdcIikgfHxcbiAgICAgICAgICAgICh0b0Jsb2NrICE9IG51bGwgJiYgdHlwZW9mICh0b0Jsb2NrKSAhPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbUHJvbWlzZS5hbGwoYWRkcmVzcyksIGZyb21CbG9jaywgdG9CbG9ja10pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdFswXSwgcmVzdWx0WzFdLCByZXN1bHRbMl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoYWRkcmVzcywgZnJvbUJsb2NrLCB0b0Jsb2NrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb3ZsZXMgdG8gYSB0cmFuc2FjdGlvbiBmb3IgJSVyZXF1ZXN0JSUsIHJlc29sdmluZ1xuICAgICAqICBhbnkgRU5TIG5hbWVzIG9yIFtbQWRkcmVzc2FibGVdXSBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYSB2YWxpZFxuICAgICAqICB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBfZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KF9yZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjb3B5UmVxdWVzdChfcmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIFtcInRvXCIsIFwiZnJvbVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSByZXNvbHZlQWRkcmVzcyhyZXF1ZXN0W2tleV0sIHRoaXMpO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShhZGRyKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jIGZ1bmN0aW9uICgpIHsgcmVxdWVzdFtrZXldID0gYXdhaXQgYWRkcjsgfSkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0W2tleV0gPSBhZGRyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlcXVlc3QuYmxvY2tUYWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tUYWcgPSB0aGlzLl9nZXRCbG9ja1RhZyhyZXF1ZXN0LmJsb2NrVGFnKTtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UoYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyByZXF1ZXN0LmJsb2NrVGFnID0gYXdhaXQgYmxvY2tUYWc7IH0pKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ibG9ja1RhZyA9IGJsb2NrVGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAoYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIGFzeW5jIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIC8vIE5vIGV4cGxpY2l0IG5ldHdvcmsgd2FzIHNldCBhbmQgdGhpcyBpcyBvdXIgZmlyc3QgdGltZVxuICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRGV0ZWN0IHRoZSBjdXJyZW50IG5ldHdvcmsgKHNoYXJlZCB3aXRoIGFsbCBjYWxscylcbiAgICAgICAgICAgIGNvbnN0IGRldGVjdE5ldHdvcmsgPSB0aGlzLl9kZXRlY3ROZXR3b3JrKCkudGhlbigobmV0d29yaykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgbmV0d29ya1Byb21pc2Ugb24gZmFpbHVyZSwgc28gd2Ugd2lsbCB0cnkgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT09IGRldGVjdE5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBkZXRlY3ROZXR3b3JrO1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBkZXRlY3ROZXR3b3JrKS5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ldHdvcmtQcm9taXNlID0gdGhpcy4jbmV0d29ya1Byb21pc2U7XG4gICAgICAgIGNvbnN0IFtleHBlY3RlZCwgYWN0dWFsXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIG5ldHdvcmtQcm9taXNlLFxuICAgICAgICAgICAgdGhpcy5fZGV0ZWN0TmV0d29yaygpIC8vIFRoZSBhY3R1YWwgY29ubmVjdGVkIG5ldHdvcmtcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChleHBlY3RlZC5jaGFpbklkICE9PSBhY3R1YWwuY2hhaW5JZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2FueU5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgXCJhbnlcIiBuZXR3b3JrIGNhbiBjaGFuZ2UsIHNvIG5vdGlmeSBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIGFjdHVhbCwgZXhwZWN0ZWQpO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbmV0d29yayBpZiBzb21ldGhpbmcgZWxzZSBoYXNuJ3QgYWxyZWFkeSBjaGFuZ2VkIGl0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmtQcm9taXNlID09PSBuZXR3b3JrUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShhY3R1YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgZG8gbm90IGFsbG93IGNoYW5nZXMgdG8gdGhlIHVuZGVybHlpbmcgbmV0d29ya1xuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYG5ldHdvcmsgY2hhbmdlZDogJHtleHBlY3RlZC5jaGFpbklkfSA9PiAke2FjdHVhbC5jaGFpbklkfSBgLCBcIk5FVFdPUktfRVJST1JcIiwge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogXCJjaGFuZ2VkXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwZWN0ZWQuY2xvbmUoKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RmVlRGF0YSgpIHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICBjb25zdCBnZXRGZWVEYXRhRnVuYyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgX2Jsb2NrLCBnYXNQcmljZSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIF9ibG9jazogdGhpcy4jZ2V0QmxvY2soXCJsYXRlc3RcIiwgZmFsc2UpLFxuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiAoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdhc1ByaWNlID0gYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRHYXNQcmljZVwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludChnYXNQcmljZSwgXCIlcmVzcG9uc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSkoKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IG1heEZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBudWxsO1xuICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSByZWNvbW1lbmRlZCBFSVAtMTU1OSBoZXVyaXN0aWNzIGZvciBmZWUgZGF0YVxuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLl93cmFwQmxvY2soX2Jsb2NrLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIGlmIChibG9jayAmJiBibG9jay5iYXNlRmVlUGVyR2FzKSB7XG4gICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBCaWdJbnQoXCIxMDAwMDAwMDAwXCIpO1xuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhcyA9IChibG9jay5iYXNlRmVlUGVyR2FzICogQk5fMikgKyBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRmVlRGF0YShnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIENoZWNrIGZvciBhIEZlZURhdGFOZXRXb3JrUGx1Z2luXG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IG5ldHdvcmsuZ2V0UGx1Z2luKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmV0Y2hVcmxGZWVEYXRhUGx1Z2luXCIpO1xuICAgICAgICBpZiAocGx1Z2luKSB7XG4gICAgICAgICAgICBjb25zdCByZXEgPSBuZXcgRmV0Y2hSZXF1ZXN0KHBsdWdpbi51cmwpO1xuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHBsdWdpbi5wcm9jZXNzRnVuYyhnZXRGZWVEYXRhRnVuYywgdGhpcywgcmVxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmVlRGF0YShmZWVEYXRhLmdhc1ByaWNlLCBmZWVEYXRhLm1heEZlZVBlckdhcywgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IGdldEZlZURhdGFGdW5jKCk7XG4gICAgfVxuICAgIGFzeW5jIGVzdGltYXRlR2FzKF90eCkge1xuICAgICAgICBsZXQgdHggPSB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QoX3R4KTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZSh0eCkpIHtcbiAgICAgICAgICAgIHR4ID0gYXdhaXQgdHg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldEJpZ0ludChhd2FpdCB0aGlzLiNwZXJmb3JtKHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJlc3RpbWF0ZUdhc1wiLCB0cmFuc2FjdGlvbjogdHhcbiAgICAgICAgfSksIFwiJXJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICBhc3luYyAjY2FsbCh0eCwgYmxvY2tUYWcsIGF0dGVtcHQpIHtcbiAgICAgICAgYXNzZXJ0KGF0dGVtcHQgPCBNQVhfQ0NJUF9SRURJUkVDVFMsIFwiQ0NJUCByZWFkIGV4Y2VlZGVkIG1heGltdW0gcmVkaXJlY3Rpb25zXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcIlRPT19NQU5ZX1JFRElSRUNUU1wiLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4LCB7IGJsb2NrVGFnLCBlbmFibGVDY2lwUmVhZDogdHJ1ZSB9KVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhpcyBjYW1lIGluIGFzIGEgUGVyZm9ybUFjdGlvblRyYW5zYWN0aW9uLCBzbyB0by9mcm9tIGFyZSBzYWZlOyB3ZSBjYW4gY2FzdFxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGNvcHlSZXF1ZXN0KHR4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGF3YWl0IHRoaXMuX3BlcmZvcm0oeyBtZXRob2Q6IFwiY2FsbFwiLCB0cmFuc2FjdGlvbiwgYmxvY2tUYWcgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gQ0NJUCBSZWFkIE9mZmNoYWluTG9va3VwXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZUNjaXBSZWFkICYmIGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikgJiYgZXJyb3IuZGF0YSAmJiBhdHRlbXB0ID49IDAgJiYgYmxvY2tUYWcgPT09IFwibGF0ZXN0XCIgJiYgdHJhbnNhY3Rpb24udG8gIT0gbnVsbCAmJiBkYXRhU2xpY2UoZXJyb3IuZGF0YSwgMCwgNCkgPT09IFwiMHg1NTZmMTgzMFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGVycm9yLmRhdGE7XG4gICAgICAgICAgICAgICAgY29uc3QgdHhTZW5kZXIgPSBhd2FpdCByZXNvbHZlQWRkcmVzcyh0cmFuc2FjdGlvbi50bywgdGhpcyk7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIENDSVAgUmVhZCBBcmd1bWVudHNcbiAgICAgICAgICAgICAgICBsZXQgY2NpcEFyZ3M7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2NpcEFyZ3MgPSBwYXJzZU9mZmNoYWluTG9va3VwKGRhdGFTbGljZShlcnJvci5kYXRhLCA0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGVycm9yLm1lc3NhZ2UsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIkJBRF9EQVRBXCIsIHRyYW5zYWN0aW9uLCBpbmZvOiB7IGRhdGEgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHNlbmRlciBvZiB0aGUgT2ZmY2hhaW5Mb29rdXAgbWF0Y2hlcyB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICBhc3NlcnQoY2NpcEFyZ3Muc2VuZGVyLnRvTG93ZXJDYXNlKCkgPT09IHR4U2VuZGVyLnRvTG93ZXJDYXNlKCksIFwiQ0NJUCBSZWFkIHNlbmRlciBtaXNtYXRjaFwiLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiT2ZmY2hhaW5Mb29rdXAoYWRkcmVzcyxzdHJpbmdbXSxieXRlcyxieXRlczQsYnl0ZXMpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBjY2lwQXJncy5lcnJvckFyZ3NcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNjaXBSZXN1bHQgPSBhd2FpdCB0aGlzLmNjaXBSZWFkRmV0Y2godHJhbnNhY3Rpb24sIGNjaXBBcmdzLmNhbGxkYXRhLCBjY2lwQXJncy51cmxzKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQoY2NpcFJlc3VsdCAhPSBudWxsLCBcIkNDSVAgUmVhZCBmYWlsZWQgdG8gZmV0Y2ggZGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIkZFVENIX0ZBSUxFRFwiLCB0cmFuc2FjdGlvbiwgaW5mbzogeyBkYXRhOiBlcnJvci5kYXRhLCBlcnJvckFyZ3M6IGNjaXBBcmdzLmVycm9yQXJncyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIHRvOiB0eFNlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY29uY2F0KFtjY2lwQXJncy5zZWxlY3RvciwgZW5jb2RlQnl0ZXMoW2NjaXBSZXN1bHQsIGNjaXBBcmdzLmV4dHJhRGF0YV0pXSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRDY2lwUmVhZENhbGxcIiwgdHJhbnNhY3Rpb246IHR4IH0pO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI2NhbGwodHgsIGJsb2NrVGFnLCBhdHRlbXB0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZENhbGxSZXN1bHRcIiwgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4KSwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkQ2FsbEVycm9yXCIsIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCksIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAjY2hlY2tOZXR3b3JrKHByb21pc2UpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICB2YWx1ZTogcHJvbWlzZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBhc3luYyBjYWxsKF90eCkge1xuICAgICAgICBjb25zdCB7IHR4LCBibG9ja1RhZyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgdHg6IHRoaXMuX2dldFRyYW5zYWN0aW9uUmVxdWVzdChfdHgpLFxuICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKF90eC5ibG9ja1RhZylcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjaGVja05ldHdvcmsodGhpcy4jY2FsbCh0eCwgYmxvY2tUYWcsIF90eC5lbmFibGVDY2lwUmVhZCA/IDAgOiAtMSkpO1xuICAgIH1cbiAgICAvLyBBY2NvdW50XG4gICAgYXN5bmMgI2dldEFjY291bnRWYWx1ZShyZXF1ZXN0LCBfYWRkcmVzcywgX2Jsb2NrVGFnKSB7XG4gICAgICAgIGxldCBhZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhfYWRkcmVzcyk7XG4gICAgICAgIGxldCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKF9ibG9ja1RhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiAoYmxvY2tUYWcpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBbYWRkcmVzcywgYmxvY2tUYWddID0gYXdhaXQgUHJvbWlzZS5hbGwoW2FkZHJlc3MsIGJsb2NrVGFnXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NoZWNrTmV0d29yayh0aGlzLiNwZXJmb3JtKE9iamVjdC5hc3NpZ24ocmVxdWVzdCwgeyBhZGRyZXNzLCBibG9ja1RhZyB9KSkpO1xuICAgIH1cbiAgICBhc3luYyBnZXRCYWxhbmNlKGFkZHJlc3MsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBnZXRCaWdJbnQoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldEJhbGFuY2VcIiB9LCBhZGRyZXNzLCBibG9ja1RhZyksIFwiJXJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbkNvdW50KGFkZHJlc3MsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBnZXROdW1iZXIoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uQ291bnRcIiB9LCBhZGRyZXNzLCBibG9ja1RhZyksIFwiJXJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRDb2RlKGFkZHJlc3MsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRDb2RlXCIgfSwgYWRkcmVzcywgYmxvY2tUYWcpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U3RvcmFnZShhZGRyZXNzLCBfcG9zaXRpb24sIGJsb2NrVGFnKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0QmlnSW50KF9wb3NpdGlvbiwgXCJwb3NpdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldFN0b3JhZ2VcIiwgcG9zaXRpb24gfSwgYWRkcmVzcywgYmxvY2tUYWcpKTtcbiAgICB9XG4gICAgLy8gV3JpdGVcbiAgICBhc3luYyBicm9hZGNhc3RUcmFuc2FjdGlvbihzaWduZWRUeCkge1xuICAgICAgICBjb25zdCB7IGJsb2NrTnVtYmVyLCBoYXNoLCBuZXR3b3JrIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5nZXRCbG9ja051bWJlcigpLFxuICAgICAgICAgICAgaGFzaDogdGhpcy5fcGVyZm9ybSh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgc2lnbmVkVHJhbnNhY3Rpb246IHNpZ25lZFR4XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0eCA9IFRyYW5zYWN0aW9uLmZyb20oc2lnbmVkVHgpO1xuICAgICAgICBpZiAodHguaGFzaCAhPT0gaGFzaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE86IHRoZSByZXR1cm5lZCBoYXNoIGRpZCBub3QgbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBuZXR3b3JrKS5yZXBsYWNlYWJsZVRyYW5zYWN0aW9uKGJsb2NrTnVtYmVyKTtcbiAgICB9XG4gICAgYXN5bmMgI2dldEJsb2NrKGJsb2NrLCBpbmNsdWRlVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIC8vIEBUT0RPOiBBZGQgQ3VzdG9tQmxvY2tQbHVnaW4gY2hlY2tcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGJsb2NrLCAzMikpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZXJmb3JtKHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZ2V0QmxvY2tcIiwgYmxvY2tIYXNoOiBibG9jaywgaW5jbHVkZVRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJsb2NrVGFnID0gdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2spO1xuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGJsb2NrVGFnID0gYXdhaXQgYmxvY2tUYWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlcmZvcm0oe1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldEJsb2NrXCIsIGJsb2NrVGFnLCBpbmNsdWRlVHJhbnNhY3Rpb25zXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBRdWVyaWVzXG4gICAgYXN5bmMgZ2V0QmxvY2soYmxvY2ssIHByZWZldGNoVHhzKSB7XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jZ2V0QmxvY2soYmxvY2ssICEhcHJlZmV0Y2hUeHMpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwQmxvY2socGFyYW1zLCBuZXR3b3JrKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oaGFzaCkge1xuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25cIiwgaGFzaCB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVzcG9uc2UocGFyYW1zLCBuZXR3b3JrKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpIHtcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCBoYXNoIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWUgYmFja2VuZHMgZGlkIG5vdCBiYWNrZmlsbCB0aGUgZWZmZWN0aXZlR2FzUHJpY2UgaW50byBvbGQgdHJhbnNhY3Rpb25zXG4gICAgICAgIC8vIGluIHRoZSByZWNlaXB0LCBzbyB3ZSBsb29rIGl0IHVwIG1hbnVhbGx5IGFuZCBpbmplY3QgaXQuXG4gICAgICAgIGlmIChwYXJhbXMuZ2FzUHJpY2UgPT0gbnVsbCAmJiBwYXJhbXMuZWZmZWN0aXZlR2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uXCIsIGhhc2ggfSk7XG4gICAgICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlcG9ydCB0aGlzOyBjb3VsZCBub3QgZmluZCB0eCBvciBlZmZlY3RpdmVHYXNQcmljZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFtcy5lZmZlY3RpdmVHYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb25SZWNlaXB0KHBhcmFtcywgbmV0d29yayk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVzdWx0KGhhc2gpIHtcbiAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcmVzdWx0OiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uUmVzdWx0XCIsIGhhc2ggfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbiAgICB9XG4gICAgLy8gQmxvb20tZmlsdGVyIFF1ZXJpZXNcbiAgICBhc3luYyBnZXRMb2dzKF9maWx0ZXIpIHtcbiAgICAgICAgbGV0IGZpbHRlciA9IHRoaXMuX2dldEZpbHRlcihfZmlsdGVyKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShmaWx0ZXIpKSB7XG4gICAgICAgICAgICBmaWx0ZXIgPSBhd2FpdCBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldExvZ3NcIiwgZmlsdGVyIH0pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGFyYW1zLm1hcCgocCkgPT4gdGhpcy5fd3JhcExvZyhwLCBuZXR3b3JrKSk7XG4gICAgfVxuICAgIC8vIEVOU1xuICAgIF9nZXRQcm92aWRlcihjaGFpbklkKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJwcm92aWRlciBjYW5ub3QgY29ubmVjdCB0byB0YXJnZXQgbmV0d29ya1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiX2dldFByb3ZpZGVyKClcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVzb2x2ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgRW5zUmVzb2x2ZXIuZnJvbU5hbWUodGhpcywgbmFtZSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEF2YXRhcihuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gYXdhaXQgdGhpcy5nZXRSZXNvbHZlcihuYW1lKTtcbiAgICAgICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZXIuZ2V0QXZhdGFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmVOYW1lKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBhd2FpdCB0aGlzLmdldFJlc29sdmVyKG5hbWUpO1xuICAgICAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlci5nZXRBZGRyZXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGxvb2t1cEFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICBhZGRyZXNzID0gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5hbWVoYXNoKGFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCkgKyBcIi5hZGRyLnJldmVyc2VcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlbnNBZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuZ2V0RW5zQWRkcmVzcyh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGVuc0NvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGVuc0FkZHIsIFtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHJlc29sdmVyKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIlxuICAgICAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IGVuc0NvbnRyYWN0LnJlc29sdmVyKG5vZGUpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVyID09IG51bGwgfHwgcmVzb2x2ZXIgPT09IFplcm9BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlckNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KHJlc29sdmVyLCBbXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBuYW1lKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiXG4gICAgICAgICAgICBdLCB0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhd2FpdCByZXNvbHZlckNvbnRyYWN0Lm5hbWUobm9kZSk7XG4gICAgICAgICAgICAvLyBGYWlsZWQgZm9yd2FyZCByZXNvbHV0aW9uXG4gICAgICAgICAgICBjb25zdCBjaGVjayA9IGF3YWl0IHRoaXMucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICBpZiAoY2hlY2sgIT09IGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTm8gZGF0YSB3YXMgcmV0dXJuZWQgZnJvbSB0aGUgcmVzb2x2ZXJcbiAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkJBRF9EQVRBXCIpICYmIGVycm9yLnZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyByZWVydGVkXG4gICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIHdhaXRGb3JUcmFuc2FjdGlvbihoYXNoLCBfY29uZmlybXMsIHRpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgY29uZmlybXMgPSAoX2NvbmZpcm1zICE9IG51bGwpID8gX2NvbmZpcm1zIDogMTtcbiAgICAgICAgaWYgKGNvbmZpcm1zID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChhc3luYyAoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciAtIHJlY2VpcHQuYmxvY2tOdW1iZXIgKyAxID49IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMub2ZmKFwiYmxvY2tcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFRUVcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJibG9ja1wiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYoXCJibG9ja1wiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJ0aW1lb3V0XCIsIFwiVElNRU9VVFwiLCB7IHJlYXNvbjogXCJ0aW1lb3V0XCIgfSkpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdGVuZXIoYXdhaXQgdGhpcy5nZXRCbG9ja051bWJlcigpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHdhaXRGb3JCbG9jayhibG9ja1RhZykge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwibm90IGltcGxlbWVudGVkIHlldFwiLCBcIk5PVF9JTVBMRU1FTlRFRFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwid2FpdEZvckJsb2NrXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDbGVhciBhIHRpbWVyIGNyZWF0ZWQgdXNpbmcgdGhlIFtbX3NldFRpbWVvdXRdXSBtZXRob2QuXG4gICAgICovXG4gICAgX2NsZWFyVGltZW91dCh0aW1lcklkKSB7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gdGhpcy4jdGltZXJzLmdldCh0aW1lcklkKTtcbiAgICAgICAgaWYgKCF0aW1lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lci50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyLnRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiN0aW1lcnMuZGVsZXRlKHRpbWVySWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgdGltZXIgdGhhdCB3aWxsIGV4ZWN1dGUgJSVmdW5jJSUgYWZ0ZXIgYXQgbGVhc3QgJSV0aW1lb3V0JSVcbiAgICAgKiAgKGluIG1zKS4gSWYgJSV0aW1lb3V0JSUgaXMgdW5zcGVjaWZpZWQsIHRoZW4gJSVmdW5jJSUgd2lsbCBleGVjdXRlXG4gICAgICogIGluIHRoZSBuZXh0IGV2ZW50IGxvb3AuXG4gICAgICpcbiAgICAgKiAgW1BhdXNpbmddKEFic3RyYWN0UHJvdmlkZXItcGF1c2VkKSB0aGUgcHJvdmlkZXIgd2lsbCBwYXVzZSBhbnlcbiAgICAgKiAgYXNzb2NpYXRlZCB0aW1lcnMuXG4gICAgICovXG4gICAgX3NldFRpbWVvdXQoX2Z1bmMsIHRpbWVvdXQpIHtcbiAgICAgICAgaWYgKHRpbWVvdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGltZW91dCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZXJJZCA9IHRoaXMuI25leHRUaW1lcisrO1xuICAgICAgICBjb25zdCBmdW5jID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jdGltZXJzLmRlbGV0ZSh0aW1lcklkKTtcbiAgICAgICAgICAgIF9mdW5jKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy4jdGltZXJzLnNldCh0aW1lcklkLCB7IHRpbWVyOiBudWxsLCBmdW5jLCB0aW1lOiB0aW1lb3V0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmMsIHRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy4jdGltZXJzLnNldCh0aW1lcklkLCB7IHRpbWVyLCBmdW5jLCB0aW1lOiBnZXRUaW1lKCkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpbWVySWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQZXJmb3JtICUlZnVuYyUlIG9uIGVhY2ggc3Vic2NyaWJlci5cbiAgICAgKi9cbiAgICBfZm9yRWFjaFN1YnNjcmliZXIoZnVuYykge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBmdW5jKHN1Yi5zdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gY3VzdG9taXplIHN1YnNjcmlwdGlvblxuICAgICAqICBpbXBsZW1lbnRhdGlvbnMuXG4gICAgICovXG4gICAgX2dldFN1YnNjcmliZXIoc3ViKSB7XG4gICAgICAgIHN3aXRjaCAoc3ViLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICBjYXNlIFwibmV0d29ya1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5tYW5hZ2VkU3Vic2NyaWJlcihzdWIudHlwZSk7XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2tcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSBuZXcgUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcih0aGlzKTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMucG9sbGluZ0ludGVydmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICAgICAgY2FzZSBcInRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKHRoaXMsIHN1Yi5oYXNoKTtcbiAgICAgICAgICAgIGNhc2UgXCJvcnBoYW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXZlbnQ6ICR7c3ViLnR5cGV9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiBhIFtbU3Vic2NyaWJlcl1dIGZhaWxzIGFuZCBuZWVkcyB0byByZXBsYWNlIGl0c2VsZiwgdGhpc1xuICAgICAqICBtZXRob2QgbWF5IGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsIHRoaXMgaXMgdXNlZCBmb3IgcHJvdmlkZXJzIHdoZW4gdXNpbmcgdGhlXG4gICAgICogIGBgZXRoX2dldEZpbHRlckNoYW5nZXNgYCBtZXRob2QsIHdoaWNoIGNhbiByZXR1cm4gbnVsbCBpZiBzdGF0ZVxuICAgICAqICBmaWx0ZXJzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBiYWNrZW5kLCBhbGxvd2luZyB0aGUgU3Vic2NyaWJlclxuICAgICAqICB0byBzd2FwIGluIGEgW1tQb2xsaW5nRXZlbnRTdWJzY3JpYmVyXV0uXG4gICAgICovXG4gICAgX3JlY292ZXJTdWJzY3JpYmVyKG9sZFN1YiwgbmV3U3ViKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuI3N1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChzdWIuc3Vic2NyaWJlciA9PT0gb2xkU3ViKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIgPSBuZXdTdWI7XG4gICAgICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N1Yi5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdWIucGF1c2UodGhpcy4jcGF1c2VkU3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAjaGFzU3ViKGV2ZW50LCBlbWl0QXJncykge1xuICAgICAgICBsZXQgc3ViID0gYXdhaXQgZ2V0U3Vic2NyaXB0aW9uKGV2ZW50LCB0aGlzKTtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGxvZyB0aGF0IGlzIHJlbW92aW5nIGFuIGV4aXN0aW5nIGxvZzsgd2UgYWN0dWFsbHkgd2FudFxuICAgICAgICAvLyB0byBlbWl0IGFuIG9ycGhhbiBldmVudCBmb3IgdGhlIHJlbW92ZWQgbG9nXG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJldmVudFwiICYmIGVtaXRBcmdzICYmIGVtaXRBcmdzLmxlbmd0aCA+IDAgJiYgZW1pdEFyZ3NbMF0ucmVtb3ZlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3ViID0gYXdhaXQgZ2V0U3Vic2NyaXB0aW9uKHsgb3JwaGFuOiBcImRyb3AtbG9nXCIsIGxvZzogZW1pdEFyZ3NbMF0gfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3N1YnMuZ2V0KHN1Yi50YWcpIHx8IG51bGw7XG4gICAgfVxuICAgIGFzeW5jICNnZXRTdWIoZXZlbnQpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYXdhaXQgZ2V0U3Vic2NyaXB0aW9uKGV2ZW50LCB0aGlzKTtcbiAgICAgICAgLy8gUHJldmVudCB0YW1wZXJpbmcgd2l0aCBvdXIgdGFnIGluIGFueSBzdWJjbGFzcycgX2dldFN1YnNjcmliZXJcbiAgICAgICAgY29uc3QgdGFnID0gc3Vic2NyaXB0aW9uLnRhZztcbiAgICAgICAgbGV0IHN1YiA9IHRoaXMuI3N1YnMuZ2V0KHRhZyk7XG4gICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gdGhpcy5fZ2V0U3Vic2NyaWJlcihzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzc2FibGVNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICAgICAgY29uc3QgbmFtZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHN1YiA9IHsgc3Vic2NyaWJlciwgdGFnLCBhZGRyZXNzYWJsZU1hcCwgbmFtZU1hcCwgc3RhcnRlZDogZmFsc2UsIGxpc3RlbmVyczogW10gfTtcbiAgICAgICAgICAgIHRoaXMuI3N1YnMuc2V0KHRhZywgc3ViKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ViO1xuICAgIH1cbiAgICBhc3luYyBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jZ2V0U3ViKGV2ZW50KTtcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IGZhbHNlIH0pO1xuICAgICAgICBpZiAoIXN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdGFydCgpO1xuICAgICAgICAgICAgc3ViLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5wYXVzZSh0aGlzLiNwYXVzZWRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzeW5jIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2dldFN1YihldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiB0cnVlIH0pO1xuICAgICAgICBpZiAoIXN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdGFydCgpO1xuICAgICAgICAgICAgc3ViLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5wYXVzZSh0aGlzLiNwYXVzZWRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzeW5jIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jaGFzU3ViKGV2ZW50LCBhcmdzKTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90IHN1YnNjcmlwdGlvbiBvciBpZiBhIHJlY2VudCBlbWl0IHJlbW92ZWRcbiAgICAgICAgLy8gdGhlIGxhc3Qgb2YgdGhlbSAod2hpY2ggYWxzbyBkZWxldGVkIHRoZSBzdWIpIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKCFzdWIgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gc3ViLmxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMgPSBzdWIubGlzdGVuZXJzLmZpbHRlcigoeyBsaXN0ZW5lciwgb25jZSB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gbmV3IEV2ZW50UGF5bG9hZCh0aGlzLCAob25jZSA/IG51bGwgOiBsaXN0ZW5lciksIGV2ZW50KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCAuLi5hcmdzLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICByZXR1cm4gIW9uY2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY291bnQgPiAwKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdGVuZXJDb3VudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICB0b3RhbCArPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgYXN5bmMgbGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jaGFzU3ViKGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XG4gICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdWIubGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsaXN0ZW5lciB8fCBzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdGFnLCBzdGFydGVkLCBzdWJzY3JpYmVyIH0gPSBhd2FpdCB0aGlzLiNnZXRTdWIoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFt0YWcsIHsgc3RhcnRlZCwgc3Vic2NyaWJlciB9XSBvZiB0aGlzLiNzdWJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEFsaWFzIGZvciBcIm9uXCJcbiAgICBhc3luYyBhZGRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLy8gQWxpYXMgZm9yIFwib2ZmXCJcbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiB0aGlzIHByb3ZpZGVyIGhhcyBiZWVuIGRlc3Ryb3llZCB1c2luZyB0aGUgW1tkZXN0cm95XV0gbWV0aG9kLlxuICAgICAqXG4gICAgICogIE9uY2UgZGVzdHJveWVkLCBhbGwgcmVzb3VyY2VzIGFyZSByZWNsYWltZWQsIGludGVybmFsIGV2ZW50IGxvb3BzXG4gICAgICogIGFuZCB0aW1lcnMgYXJlIGNsZWFuZWQgdXAgYW5kIG5vIGZ1cnRoZXIgcmVxdWVzdHMgbWF5IGJlIHNlbnQgdG9cbiAgICAgKiAgdGhlIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGdldCBkZXN0cm95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNkZXN0cm95ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgdXNlIHRoaXMgdG8gc2h1dGRvd24gYW55IHNvY2tldHMgb3IgcmVsZWFzZSB0aGVpclxuICAgICAqICByZXNvdXJjZXMgYW5kIHJlamVjdCBhbnkgcGVuZGluZyByZXF1ZXN0cy5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBjYWxsIGBgc3VwZXIuZGVzdHJveSgpYGAuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgLy8gU3RvcCBhbGwgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIC8vIFNodXQgZG93biBhbGwgdGllbXJzXG4gICAgICAgIGZvciAoY29uc3QgdGltZXJJZCBvZiB0aGlzLiN0aW1lcnMua2V5cygpKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdoZXRoZXIgdGhlIHByb3ZpZGVyIGlzIGN1cnJlbnRseSBwYXVzZWQuXG4gICAgICpcbiAgICAgKiAgQSBwYXVzZWQgcHJvdmlkZXIgd2lsbCBub3QgZW1pdCBhbnkgZXZlbnRzLCBhbmQgZ2VuZXJhbGx5IHNob3VsZFxuICAgICAqICBub3QgbWFrZSBhbnkgcmVxdWVzdHMgdG8gdGhlIG5ldHdvcmssIGJ1dCB0aGF0IGlzIHVwIHRvIHN1Yi1jbGFzc2VzXG4gICAgICogIHRvIG1hbmFnZS5cbiAgICAgKlxuICAgICAqICBTZXR0aW5nIGBgcGF1c2VkID0gdHJ1ZWBgIGlzIGlkZW50aWNhbCB0byBjYWxsaW5nIGBgLnBhdXNlKGZhbHNlKWBgLFxuICAgICAqICB3aGljaCB3aWxsIGJ1ZmZlciBhbnkgZXZlbnRzIHRoYXQgb2NjdXIgd2hpbGUgcGF1c2VkIHVudGlsIHRoZVxuICAgICAqICBwcm92aWRlciBpcyB1bnBhdXNlZC5cbiAgICAgKi9cbiAgICBnZXQgcGF1c2VkKCkgeyByZXR1cm4gKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpOyB9XG4gICAgc2V0IHBhdXNlZChwYXVzZSkge1xuICAgICAgICBpZiAoISFwYXVzZSA9PT0gdGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGF1c2UgdGhlIHByb3ZpZGVyLiBJZiAlJWRyb3BXaGlsZVBhdXNlZCUlLCBhbnkgZXZlbnRzIHRoYXQgb2NjdXJcbiAgICAgKiAgd2hpbGUgcGF1c2VkIGFyZSBkcm9wcGVkLCBvdGhlcndpc2UgYWxsIGV2ZW50cyB3aWxsIGJlIGVtaXR0ZWQgb25jZVxuICAgICAqICB0aGUgcHJvdmlkZXIgaXMgdW5wYXVzZWQuXG4gICAgICovXG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuI2xhc3RCbG9ja051bWJlciA9IC0xO1xuICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlID09ICEhZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNhbm5vdCBjaGFuZ2UgcGF1c2UgdHlwZTsgcmVzdW1lIGZpcnN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicGF1c2VcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZm9yRWFjaFN1YnNjcmliZXIoKHMpID0+IHMucGF1c2UoZHJvcFdoaWxlUGF1c2VkKSk7XG4gICAgICAgIHRoaXMuI3BhdXNlZFN0YXRlID0gISFkcm9wV2hpbGVQYXVzZWQ7XG4gICAgICAgIGZvciAoY29uc3QgdGltZXIgb2YgdGhpcy4jdGltZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgdGltZXJcbiAgICAgICAgICAgIGlmICh0aW1lci50aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lci50aW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1haW5pbmcgdGltZSBuZWVkZWQgZm9yIHdoZW4gd2UgYmVjb21lIHVucGF1c2VkXG4gICAgICAgICAgICB0aW1lci50aW1lID0gZ2V0VGltZSgpIC0gdGltZXIudGltZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzdW1lIHRoZSBwcm92aWRlci5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZm9yRWFjaFN1YnNjcmliZXIoKHMpID0+IHMucmVzdW1lKCkpO1xuICAgICAgICB0aGlzLiNwYXVzZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgdGltZXIgb2YgdGhpcy4jdGltZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAvLyBSZW1haW5pbmcgdGltZSB3aGVuIHdlIHdlcmUgcGF1c2VkXG4gICAgICAgICAgICBsZXQgdGltZW91dCA9IHRpbWVyLnRpbWU7XG4gICAgICAgICAgICBpZiAodGltZW91dCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0IHRpbWUgKGluIGNhdXNlIHBhdXNlZCwgc28gd2UgY29uIGNvbXB1dGUgcmVtYWluaW5mIHRpbWUpXG4gICAgICAgICAgICB0aW1lci50aW1lID0gZ2V0VGltZSgpO1xuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHRpbWVyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRpbWVyLmZ1bmMsIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gX3BhcnNlU3RyaW5nKHJlc3VsdCwgc3RhcnQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBieXRlcyA9IF9wYXJzZUJ5dGVzKHJlc3VsdCwgc3RhcnQpO1xuICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBfcGFyc2VCeXRlcyhyZXN1bHQsIHN0YXJ0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBnZXROdW1iZXIoZGF0YVNsaWNlKHJlc3VsdCwgc3RhcnQsIHN0YXJ0ICsgMzIpKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZ2V0TnVtYmVyKGRhdGFTbGljZShyZXN1bHQsIG9mZnNldCwgb2Zmc2V0ICsgMzIpKTtcbiAgICAgICAgcmV0dXJuIGRhdGFTbGljZShyZXN1bHQsIG9mZnNldCArIDMyLCBvZmZzZXQgKyAzMiArIGxlbmd0aCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBudW1QYWQodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0b0JlQXJyYXkodmFsdWUpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJuYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgcGFkZGVkLnNldChyZXN1bHQsIDMyIC0gcmVzdWx0Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHBhZGRlZDtcbn1cbmZ1bmN0aW9uIGJ5dGVzUGFkKHZhbHVlKSB7XG4gICAgaWYgKCh2YWx1ZS5sZW5ndGggJSAzMikgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwodmFsdWUubGVuZ3RoIC8gMzIpICogMzIpO1xuICAgIHJlc3VsdC5zZXQodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBlbXB0eSA9IG5ldyBVaW50OEFycmF5KFtdKTtcbi8vIEFCSSBFbmNvZGVzIGEgc2VyaWVzIG9mIChieXRlcywgYnl0ZXMsIC4uLilcbmZ1bmN0aW9uIGVuY29kZUJ5dGVzKGRhdGFzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGJ5dGVDb3VudCA9IDA7XG4gICAgLy8gQWRkIHBsYWNlLWhvbGRlcnMgZm9yIHBvaW50ZXJzIGFzIHdlIGFkZCBpdGVtc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZW1wdHkpO1xuICAgICAgICBieXRlQ291bnQgKz0gMzI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKGRhdGFzW2ldKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBieXRlcyBvZmZzZXRcbiAgICAgICAgcmVzdWx0W2ldID0gbnVtUGFkKGJ5dGVDb3VudCk7XG4gICAgICAgIC8vIFRoZSBsZW5ndGggYW5kIHBhZGRlZCB2YWx1ZSBvZiBkYXRhXG4gICAgICAgIHJlc3VsdC5wdXNoKG51bVBhZChkYXRhLmxlbmd0aCkpO1xuICAgICAgICByZXN1bHQucHVzaChieXRlc1BhZChkYXRhKSk7XG4gICAgICAgIGJ5dGVDb3VudCArPSAzMiArIE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIDMyKSAqIDMyO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0KHJlc3VsdCk7XG59XG5jb25zdCB6ZXJvcyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG5mdW5jdGlvbiBwYXJzZU9mZmNoYWluTG9va3VwKGRhdGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHNlbmRlcjogXCJcIiwgdXJsczogW10sIGNhbGxkYXRhOiBcIlwiLCBzZWxlY3RvcjogXCJcIiwgZXh0cmFEYXRhOiBcIlwiLCBlcnJvckFyZ3M6IFtdXG4gICAgfTtcbiAgICBhc3NlcnQoZGF0YUxlbmd0aChkYXRhKSA+PSA1ICogMzIsIFwiaW5zdWZmaWNpZW50IE9mZmNoYWluTG9va3VwIGRhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgIHJlYXNvbjogXCJpbnN1ZmZpY2llbnQgT2ZmY2hhaW5Mb29rdXAgZGF0YVwiXG4gICAgfSk7XG4gICAgY29uc3Qgc2VuZGVyID0gZGF0YVNsaWNlKGRhdGEsIDAsIDMyKTtcbiAgICBhc3NlcnQoZGF0YVNsaWNlKHNlbmRlciwgMCwgMTIpID09PSBkYXRhU2xpY2UoemVyb3MsIDAsIDEyKSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHNlbmRlclwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgc2VuZGVyXCJcbiAgICB9KTtcbiAgICByZXN1bHQuc2VuZGVyID0gZGF0YVNsaWNlKHNlbmRlciwgMTIpO1xuICAgIC8vIFJlYWQgdGhlIFVSTHMgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB1cmxzID0gW107XG4gICAgICAgIGNvbnN0IHVybHNPZmZzZXQgPSBnZXROdW1iZXIoZGF0YVNsaWNlKGRhdGEsIDMyLCA2NCkpO1xuICAgICAgICBjb25zdCB1cmxzTGVuZ3RoID0gZ2V0TnVtYmVyKGRhdGFTbGljZShkYXRhLCB1cmxzT2Zmc2V0LCB1cmxzT2Zmc2V0ICsgMzIpKTtcbiAgICAgICAgY29uc3QgdXJsc0RhdGEgPSBkYXRhU2xpY2UoZGF0YSwgdXJsc09mZnNldCArIDMyKTtcbiAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCB1cmxzTGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IF9wYXJzZVN0cmluZyh1cmxzRGF0YSwgdSAqIDMyKTtcbiAgICAgICAgICAgIGlmICh1cmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFib3J0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJscy5wdXNoKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnVybHMgPSB1cmxzO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgdXJsc1wiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHVybHNcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBDQ0lQIGNhbGxkYXRhIHRvIGZvcndhcmRcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjYWxsZGF0YSA9IF9wYXJzZUJ5dGVzKGRhdGEsIDY0KTtcbiAgICAgICAgaWYgKGNhbGxkYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFib3J0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5jYWxsZGF0YSA9IGNhbGxkYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGRhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBjYWxsZGF0YVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIGNhbGxiYWNrU2VsZWN0b3IgKGJ5dGVzNClcbiAgICBhc3NlcnQoZGF0YVNsaWNlKGRhdGEsIDEwMCwgMTI4KSA9PT0gZGF0YVNsaWNlKHplcm9zLCAwLCAyOCksIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBjYWxsYmFhY2tTZWxlY3RvclwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGJhYWNrU2VsZWN0b3JcIlxuICAgIH0pO1xuICAgIHJlc3VsdC5zZWxlY3RvciA9IGRhdGFTbGljZShkYXRhLCA5NiwgMTAwKTtcbiAgICAvLyBHZXQgdGhlIGV4dHJhIGRhdGEgdG8gc2VuZCBiYWNrIHRvIHRoZSBjb250cmFjdCBhcyBjb250ZXh0XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXh0cmFEYXRhID0gX3BhcnNlQnl0ZXMoZGF0YSwgMTI4KTtcbiAgICAgICAgaWYgKGV4dHJhRGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuZXh0cmFEYXRhID0gZXh0cmFEYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgZXh0cmFEYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgZXh0cmFEYXRhXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3VsdC5lcnJvckFyZ3MgPSBcInNlbmRlcix1cmxzLGNhbGxkYXRhLHNlbGVjdG9yLGV4dHJhRGF0YVwiLnNwbGl0KC8sLykubWFwKChrKSA9PiByZXN1bHRba10pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1wcm92aWRlci5qcy5tYXAiLCIvKipcbiAqICBHZW5lcmFsbHkgdGhlIFtbV2FsbGV0XV0gYW5kIFtbSnNvblJwY1NpZ25lcl1dIGFuZCB0aGVpciBzdWItY2xhc3Nlc1xuICogIGFyZSBzdWZmaWNlbnQgZm9yIG1vc3QgZGV2ZWxvcGVycywgYnV0IHRoaXMgaXMgcHJvdmlkZWQgdG9cbiAqICBmYXNjaWxpdGF0ZSBtb3JlIGNvbXBsZXggU2lnbmVycy5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXNpZ25lcjogU3ViY2xhc3NpbmcgU2lnbmVyIFthYnN0cmFjdC1zaWduZXJdXG4gKi9cbmltcG9ydCB7IHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIHJlc29sdmVQcm9wZXJ0aWVzLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb3B5UmVxdWVzdCB9IGZyb20gXCIuL3Byb3ZpZGVyLmpzXCI7XG5mdW5jdGlvbiBjaGVja1Byb3ZpZGVyKHNpZ25lciwgb3BlcmF0aW9uKSB7XG4gICAgaWYgKHNpZ25lci5wcm92aWRlcikge1xuICAgICAgICByZXR1cm4gc2lnbmVyLnByb3ZpZGVyO1xuICAgIH1cbiAgICBhc3NlcnQoZmFsc2UsIFwibWlzc2luZyBwcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbiB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBvcHVsYXRlKHNpZ25lciwgdHgpIHtcbiAgICBsZXQgcG9wID0gY29weVJlcXVlc3QodHgpO1xuICAgIGlmIChwb3AudG8gIT0gbnVsbCkge1xuICAgICAgICBwb3AudG8gPSByZXNvbHZlQWRkcmVzcyhwb3AudG8sIHNpZ25lcik7XG4gICAgfVxuICAgIGlmIChwb3AuZnJvbSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSBwb3AuZnJvbTtcbiAgICAgICAgcG9wLmZyb20gPSBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBzaWduZXIuZ2V0QWRkcmVzcygpLFxuICAgICAgICAgICAgcmVzb2x2ZUFkZHJlc3MoZnJvbSwgc2lnbmVyKVxuICAgICAgICBdKS50aGVuKChbYWRkcmVzcywgZnJvbV0pID0+IHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gZnJvbS50b0xvd2VyQ2FzZSgpLCBcInRyYW5zYWN0aW9uIGZyb20gbWlzbWF0Y2hcIiwgXCJ0eC5mcm9tXCIsIGZyb20pO1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9wLmZyb20gPSBzaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMocG9wKTtcbn1cbi8qKlxuICogIEFuICoqQWJzdHJhY3RTaWduZXIqKiBpbmNsdWRlcyBtb3N0IG9mIHRlaCBmdW5jdGlvbmFsaXR5IHJlcXVpcmVkXG4gKiAgdG8gZ2V0IGEgW1tTaWduZXJdXSB3b3JraW5nIGFzIGV4cGVjdGVkLCBidXQgcmVxdWlyZXMgYSBmZXdcbiAqICBTaWduZXItc3BlY2lmaWMgbWV0aG9kcyBiZSBvdmVycmlkZGVuLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEFic3RyYWN0U2lnbmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIHRoaXMgc2lnbmVyIGlzIGNvbm5lY3RlZCB0by5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBTaWduZXIgY29ubmVjdGVkIHRvICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHJvdmlkZXI6IChwcm92aWRlciB8fCBudWxsKSB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Tm9uY2UoYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvdmlkZXIodGhpcywgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIpLmdldFRyYW5zYWN0aW9uQ291bnQoYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCksIGJsb2NrVGFnKTtcbiAgICB9XG4gICAgYXN5bmMgcG9wdWxhdGVDYWxsKHR4KSB7XG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHBvcHVsYXRlKHRoaXMsIHR4KTtcbiAgICAgICAgcmV0dXJuIHBvcDtcbiAgICB9XG4gICAgYXN5bmMgcG9wdWxhdGVUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGNoZWNrUHJvdmlkZXIodGhpcywgXCJwb3B1bGF0ZVRyYW5zYWN0aW9uXCIpO1xuICAgICAgICBjb25zdCBwb3AgPSBhd2FpdCBwb3B1bGF0ZSh0aGlzLCB0eCk7XG4gICAgICAgIGlmIChwb3Aubm9uY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgcG9wLm5vbmNlID0gYXdhaXQgdGhpcy5nZXROb25jZShcInBlbmRpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcC5nYXNMaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb3AuZ2FzTGltaXQgPSBhd2FpdCB0aGlzLmVzdGltYXRlR2FzKHBvcCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9wdWxhdGUgdGhlIGNoYWluIElEXG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCAodGhpcy5wcm92aWRlcikuZ2V0TmV0d29yaygpO1xuICAgICAgICBpZiAocG9wLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IGdldEJpZ0ludChwb3AuY2hhaW5JZCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChjaGFpbklkID09PSBuZXR3b3JrLmNoYWluSWQsIFwidHJhbnNhY3Rpb24gY2hhaW5JZCBtaXNtYXRjaFwiLCBcInR4LmNoYWluSWRcIiwgdHguY2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3AuY2hhaW5JZCA9IG5ldHdvcmsuY2hhaW5JZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3QgYWxsb3cgbWl4aW5nIHByZS1laXAtMTU1OSBhbmQgZWlwLTE1NTkgcHJvcGVydGllc1xuICAgICAgICBjb25zdCBoYXNFaXAxNTU5ID0gKHBvcC5tYXhGZWVQZXJHYXMgIT0gbnVsbCB8fCBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCk7XG4gICAgICAgIGlmIChwb3AuZ2FzUHJpY2UgIT0gbnVsbCAmJiAocG9wLnR5cGUgPT09IDIgfHwgaGFzRWlwMTU1OSkpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImVpcC0xNTU5IHRyYW5zYWN0aW9uIGRvIG5vdCBzdXBwb3J0IGdhc1ByaWNlXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChwb3AudHlwZSA9PT0gMCB8fCBwb3AudHlwZSA9PT0gMSkgJiYgaGFzRWlwMTU1OSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwicHJlLWVpcC0xNTU5IHRyYW5zYWN0aW9uIGRvIG5vdCBzdXBwb3J0IG1heEZlZVBlckdhcy9tYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHBvcC50eXBlID09PSAyIHx8IHBvcC50eXBlID09IG51bGwpICYmIChwb3AubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpKSB7XG4gICAgICAgICAgICAvLyBGdWxseS1mb3JtZWQgRUlQLTE1NTkgdHJhbnNhY3Rpb24gKHNraXAgZ2V0RmVlRGF0YSlcbiAgICAgICAgICAgIHBvcC50eXBlID0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3AudHlwZSA9PT0gMCB8fCBwb3AudHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgLy8gRXhwbGljaXQgTGVnYWN5IG9yIEVJUC0yOTMwIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGdldCBmZWUgZGF0YSB0byBkZXRlcm1pbmUgdGhpbmdzXG4gICAgICAgICAgICBjb25zdCBmZWVEYXRhID0gYXdhaXQgcHJvdmlkZXIuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgYXNzZXJ0KGZlZURhdGEuZ2FzUHJpY2UgIT0gbnVsbCwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgZ2FzUHJpY2VcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRHYXNQcmljZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZ2FzUHJpY2VcbiAgICAgICAgICAgIGlmIChwb3AuZ2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBvcC5nYXNQcmljZSA9IGZlZURhdGEuZ2FzUHJpY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGdldCBmZWUgZGF0YSB0byBkZXRlcm1pbmUgdGhpbmdzXG4gICAgICAgICAgICBjb25zdCBmZWVEYXRhID0gYXdhaXQgcHJvdmlkZXIuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgaWYgKHBvcC50eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGF1dG8tZGV0ZWN0IHRoZSBpbnRlbmRlZCB0eXBlIG9mIHRoaXMgdHJhbnNhY3Rpb24uLi5cbiAgICAgICAgICAgICAgICBpZiAoZmVlRGF0YS5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5ldHdvcmsgc3VwcG9ydHMgRUlQLTE1NTkhXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZ3JhZGUgdHJhbnNhY3Rpb24gZnJvbSBudWxsIHRvIGVpcC0xNTU5XG4gICAgICAgICAgICAgICAgICAgIHBvcC50eXBlID0gMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2luZyBsZWdhY3kgZ2FzUHJpY2UgcHJvcGVydHkgb24gYW4gZWlwLTE1NTkgbmV0d29yayxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBnYXNQcmljZSBhcyBib3RoIGZlZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXNQcmljZSA9IHBvcC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwb3AuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4RmVlUGVyR2FzID0gZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBnYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3AubWF4RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZlZURhdGEuZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGRvZXNuJ3Qgc3VwcG9ydCBFSVAtMTU1OS4uLlxuICAgICAgICAgICAgICAgICAgICAvLyAuLi5idXQgdGhleSBhcmUgdHJ5aW5nIHRvIHVzZSBFSVAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCghaGFzRWlwMTU1OSwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRUlQLTE1NTlcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9wLmdhc1ByaWNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5nYXNQcmljZSA9IGZlZURhdGEuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBzZXQgdW50eXBlZCB0cmFuc2FjdGlvbiB0byBsZWdhY3lcbiAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IE1heWJlIHRoaXMgc2hvbGQgYWxsb3cgdHlwZSAxP1xuICAgICAgICAgICAgICAgICAgICBwb3AudHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXRGZWVEYXRhIGhhcyBmYWlsZWQgdXMuXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJmYWlsZWQgdG8gZ2V0IGNvbnNpc3RlbnQgZmVlIGRhdGFcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25lci5nZXRGZWVEYXRhXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocG9wLnR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHVzaW5nIEVJUC0xNTU5XG4gICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgIGlmIChwb3AubWF4RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wLm1heEZlZVBlckdhcyA9IGZlZURhdGEubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9AVE9PRDogRG9uJ3QgYXdhaXQgYWxsIG92ZXIgdGhlIHBsYWNlOyBzYXZlIHRoZW0gdXAgZm9yXG4gICAgICAgIC8vIHRoZSBlbmQgZm9yIGJldHRlciBiYXRjaGluZ1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMocG9wKTtcbiAgICB9XG4gICAgYXN5bmMgZXN0aW1hdGVHYXModHgpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvdmlkZXIodGhpcywgXCJlc3RpbWF0ZUdhc1wiKS5lc3RpbWF0ZUdhcyhhd2FpdCB0aGlzLnBvcHVsYXRlQ2FsbCh0eCkpO1xuICAgIH1cbiAgICBhc3luYyBjYWxsKHR4KSB7XG4gICAgICAgIHJldHVybiBjaGVja1Byb3ZpZGVyKHRoaXMsIFwiY2FsbFwiKS5jYWxsKGF3YWl0IHRoaXMucG9wdWxhdGVDYWxsKHR4KSk7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmVOYW1lKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBjaGVja1Byb3ZpZGVyKHRoaXMsIFwicmVzb2x2ZU5hbWVcIik7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gY2hlY2tQcm92aWRlcih0aGlzLCBcInNlbmRUcmFuc2FjdGlvblwiKTtcbiAgICAgICAgY29uc3QgcG9wID0gYXdhaXQgdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgZGVsZXRlIHBvcC5mcm9tO1xuICAgICAgICBjb25zdCB0eE9iaiA9IFRyYW5zYWN0aW9uLmZyb20ocG9wKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmJyb2FkY2FzdFRyYW5zYWN0aW9uKGF3YWl0IHRoaXMuc2lnblRyYW5zYWN0aW9uKHR4T2JqKSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKlZvaWRTaWduZXIqKiBpcyBhIGNsYXNzIGRlaXNnbmVkIHRvIGFsbG93IGFuIGFkZHJlc3MgdG8gYmUgdXNlZFxuICogIGluIGFueSBBUEkgd2hpY2ggYWNjZXB0cyBhIFNpZ25lciwgYnV0IGZvciB3aGljaCB0aGVyZSBhcmUgbm9cbiAqICBjcmVkZW50aWFscyBhdmFpbGFibGUgdG8gcGVyZm9ybSBhbnkgYWN0dWFsIHNpZ25pbmcuXG4gKlxuICogIFRoaXMgZm9yIGV4YW1wbGUgYWxsb3cgaW1wZXJzb25hdGluZyBhbiBhY2NvdW50IGZvciB0aGUgcHVycG9zZSBvZlxuICogIHN0YXRpYyBjYWxscyBvciBlc3RpbWF0aW5nIGdhcywgYnV0IGRvZXMgbm90IGFsbG93IHNlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICovXG5leHBvcnQgY2xhc3MgVm9pZFNpZ25lciBleHRlbmRzIEFic3RyYWN0U2lnbmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHNpZ25lciBhZGRyZXNzLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipWb2lkU2lnbmVyKiogd2l0aCAlJWFkZHJlc3MlJSBhdHRhY2hlZCB0b1xuICAgICAqICAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWRkcmVzcyB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWRkcmVzcygpIHsgcmV0dXJuIHRoaXMuYWRkcmVzczsgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWb2lkU2lnbmVyKHRoaXMuYWRkcmVzcywgcHJvdmlkZXIpO1xuICAgIH1cbiAgICAjdGhyb3dVbnN1cHBvcnRlZChzdWZmaXgsIG9wZXJhdGlvbikge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIGBWb2lkU2lnbmVyIGNhbm5vdCBzaWduICR7c3VmZml4fWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgdGhpcy4jdGhyb3dVbnN1cHBvcnRlZChcInRyYW5zYWN0aW9uc1wiLCBcInNpZ25UcmFuc2FjdGlvblwiKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0aGlzLiN0aHJvd1Vuc3VwcG9ydGVkKFwibWVzc2FnZXNcIiwgXCJzaWduTWVzc2FnZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLiN0aHJvd1Vuc3VwcG9ydGVkKFwidHlwZWQtZGF0YVwiLCBcInNpZ25UeXBlZERhdGFcIik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3Qtc2lnbmVyLmpzLm1hcCIsImltcG9ydCB7IGlzRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFBvbGxpbmdFdmVudFN1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIjtcbmZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59XG4vKipcbiAqICBTb21lIGJhY2tlbmRzIHN1cHBvcnQgc3Vic2NyaWJpbmcgdG8gZXZlbnRzIHVzaW5nIGEgRmlsdGVyIElELlxuICpcbiAqICBXaGVuIHN1YnNjcmliaW5nIHdpdGggdGhpcyB0ZWNobmlxdWUsIHRoZSBub2RlIGlzc3VlcyBhIHVuaXF1ZVxuICogIC8vRmlsdGVyIElELy8uIEF0IHRoaXMgcG9pbnQgdGhlIG5vZGUgZGVkaWNhdGVzIHJlc291cmNlcyB0b1xuICogIHRoZSBmaWx0ZXIsIHNvIHRoYXQgcGVyaW9kaWMgY2FsbHMgdG8gZm9sbG93IHVwIG9uIHRoZSAvL0ZpbHRlciBJRC8vXG4gKiAgd2lsbCByZWNlaXZlIGFueSBldmVudHMgc2luY2UgdGhlIGxhc3QgY2FsbC5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlcklkU3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNmaWx0ZXJJZFByb21pc2U7XG4gICAgI3BvbGxlcjtcbiAgICAjcnVubmluZztcbiAgICAjbmV0d29yaztcbiAgICAjaGF1bHQ7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiB3aGljaCB3aWxsIHVzZWQgW1tfc3Vic2NyaWJlXV1cbiAgICAgKiAgYW5kIFtbX2VtaXRSZXN1bHRzXV0gdG8gc2V0dXAgdGhlIHN1YnNjcmlwdGlvbiBhbmQgcHJvdmlkZSB0aGUgZXZlbnRcbiAgICAgKiAgdG8gdGhlICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jbmV0d29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuI2hhdWx0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzIHRvIGJlZ2luIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICovXG4gICAgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgaGFuZGxlIHRoZSBldmVudHMuXG4gICAgICovXG4gICAgX2VtaXRSZXN1bHRzKHByb3ZpZGVyLCByZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzIGhhbmRsZSByZWNvdmVyeSBvbiBlcnJvcnMuXG4gICAgICovXG4gICAgX3JlY292ZXIocHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIGFzeW5jICNwb2xsKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBpZiAodGhpcy4jZmlsdGVySWRQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSB0aGlzLl9zdWJzY3JpYmUodGhpcy4jcHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBGaWx0ZXIgSURcbiAgICAgICAgICAgIGxldCBmaWx0ZXJJZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZpbHRlcklkID0gYXdhaXQgdGhpcy4jZmlsdGVySWRQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiKSB8fCBlcnJvci5vcGVyYXRpb24gIT09IFwiZXRoX25ld0ZpbHRlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgRmlsdGVyIElEOyBkb3duZ3JhZGUgdG9cbiAgICAgICAgICAgIC8vIHBvbGxpbmdcbiAgICAgICAgICAgIGlmIChmaWx0ZXJJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZmlsdGVySWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLiNwcm92aWRlci5fcmVjb3ZlclN1YnNjcmliZXIodGhpcywgdGhpcy5fcmVjb3Zlcih0aGlzLiNwcm92aWRlcikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuI25ldHdvcmspIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrID0gbmV0d29yaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrLmNoYWluSWQgIT09IG5ldHdvcmsuY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoYWlkIGNoYW5nZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jaGF1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5zZW5kKFwiZXRoX2dldEZpbHRlckNoYW5nZXNcIiwgW2ZpbHRlcklkXSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9lbWl0UmVzdWx0cyh0aGlzLiNwcm92aWRlciwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQFRPRE9cIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xuICAgIH1cbiAgICAjdGVhcmRvd24oKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcklkUHJvbWlzZSA9IHRoaXMuI2ZpbHRlcklkUHJvbWlzZTtcbiAgICAgICAgaWYgKGZpbHRlcklkUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy4jZmlsdGVySWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgIGZpbHRlcklkUHJvbWlzZS50aGVuKChmaWx0ZXJJZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLnNlbmQoXCJldGhfdW5pbnN0YWxsRmlsdGVyXCIsIFtmaWx0ZXJJZF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuI3BvbGwoLTIpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2hhdWx0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jdGVhcmRvd24oKTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI3RlYXJkb3duKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgcmVzdW1lKCkgeyB0aGlzLnN0YXJ0KCk7IH1cbn1cbi8qKlxuICogIEEgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiBmb3IgcmVjZWl2aW5nIGNvbnRyYWN0IGV2ZW50cy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlcklkRXZlbnRTdWJzY3JpYmVyIGV4dGVuZHMgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICAjZXZlbnQ7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJVxuICAgICAqICBsaXN0ZW5pbmcgZm9yICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2V2ZW50ID0gY29weShmaWx0ZXIpO1xuICAgIH1cbiAgICBfcmVjb3Zlcihwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdFdmVudFN1YnNjcmliZXIocHJvdmlkZXIsIHRoaXMuI2V2ZW50KTtcbiAgICB9XG4gICAgYXN5bmMgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICBjb25zdCBmaWx0ZXJJZCA9IGF3YWl0IHByb3ZpZGVyLnNlbmQoXCJldGhfbmV3RmlsdGVyXCIsIFt0aGlzLiNldmVudF0pO1xuICAgICAgICByZXR1cm4gZmlsdGVySWQ7XG4gICAgfVxuICAgIGFzeW5jIF9lbWl0UmVzdWx0cyhwcm92aWRlciwgcmVzdWx0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMuI2V2ZW50LCBwcm92aWRlci5fd3JhcExvZyhyZXN1bHQsIHByb3ZpZGVyLl9uZXR3b3JrKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqICBBICoqRmlsdGVySWRTdWJzY3JpYmVyKiogZm9yIHJlY2VpdmluZyBwZW5kaW5nIHRyYW5zYWN0aW9ucyBldmVudHMuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyIGV4dGVuZHMgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICBhc3luYyBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5zZW5kKFwiZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlclwiLCBbXSk7XG4gICAgfVxuICAgIGFzeW5jIF9lbWl0UmVzdWx0cyhwcm92aWRlciwgcmVzdWx0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KFwicGVuZGluZ1wiLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlci1maWx0ZXJpZC5qcy5tYXAiLCIvKipcbiAqICBPbmUgb2YgdGhlIG1vc3QgY29tbW9uIHdheXMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgYmxvY2tjaGFpbiBpc1xuICogIGJ5IGEgbm9kZSBydW5uaW5nIGEgSlNPTi1SUEMgaW50ZXJmYWNlIHdoaWNoIGNhbiBiZSBjb25uZWN0ZWQgdG8sXG4gKiAgYmFzZWQgb24gdGhlIHRyYW5zcG9ydCwgdXNpbmc6XG4gKlxuICogIC0gSFRUUCBvciBIVFRQUyAtIFtbSnNvblJwY1Byb3ZpZGVyXV1cbiAqICAtIFdlYlNvY2tldCAtIFtbV2ViU29ja2V0UHJvdmlkZXJdXVxuICogIC0gSVBDIC0gW1tJcGNTb2NrZXRQcm92aWRlcl1dXG4gKlxuICogQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2pzb25ycGM6SlNPTi1SUEMgUHJvdmlkZXIgIFthYm91dC1qc29ucnBjUHJvdmlkZXJdXG4gKi9cbi8vIEBUT0RPOlxuLy8gLSBBZGQgdGhlIGJhdGNoaW5nIEFQSVxuLy8gaHR0cHM6Ly9wbGF5Z3JvdW5kLm9wZW4tcnBjLm9yZy8/c2NoZW1hVXJsPWh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9ldGhlcmV1bS9ldGgxLjAtYXBpcy9hc3NlbWJsZWQtc3BlYy9vcGVucnBjLmpzb24mdWlTY2hlbWElNUJhcHBCYXIlNUQlNUJ1aTpzcGxpdFZpZXclNUQ9dHJ1ZSZ1aVNjaGVtYSU1QmFwcEJhciU1RCU1QnVpOmlucHV0JTVEPWZhbHNlJnVpU2NoZW1hJTVCYXBwQmFyJTVEJTVCdWk6ZXhhbXBsZXNEcm9wZG93biU1RD1mYWxzZVxuaW1wb3J0IHsgQWJpQ29kZXIgfSBmcm9tIFwiLi4vYWJpL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzLCByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZERhdGFFbmNvZGVyIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIHRvUXVhbnRpdHksIHRvVXRmOEJ5dGVzLCBtYWtlRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIEZldGNoUmVxdWVzdCwgcmVzb2x2ZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEFic3RyYWN0UHJvdmlkZXIsIFVubWFuYWdlZFN1YnNjcmliZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RTaWduZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1zaWduZXIuanNcIjtcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XG5pbXBvcnQgeyBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlciwgRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciB9IGZyb20gXCIuL3N1YnNjcmliZXItZmlsdGVyaWQuanNcIjtcbmltcG9ydCB7IFBvbGxpbmdFdmVudFN1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIjtcbmNvbnN0IFByaW1pdGl2ZSA9IFwiYmlnaW50LGJvb2xlYW4sZnVuY3Rpb24sbnVtYmVyLHN0cmluZyxzeW1ib2xcIi5zcGxpdCgvLC9nKTtcbi8vY29uc3QgTWV0aG9kcyA9IFwiZ2V0QWRkcmVzcyx0aGVuXCIuc3BsaXQoLywvZyk7XG5mdW5jdGlvbiBkZWVwQ29weSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IFByaW1pdGl2ZS5pbmRleE9mKHR5cGVvZiAodmFsdWUpKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLy8gS2VlcCBhbnkgQWRkcmVzc2FibGVcbiAgICBpZiAodHlwZW9mICh2YWx1ZS5nZXRBZGRyZXNzKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUubWFwKGRlZXBDb3B5KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLnJlZHVjZSgoYWNjdW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgYWNjdW1ba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBzaG91bGQgbm90IGhhcHBlbjogJHt2YWx1ZX0gKCR7dHlwZW9mICh2YWx1ZSl9KWApO1xufVxuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7IH0pO1xufVxuZnVuY3Rpb24gZ2V0TG93ZXJDYXNlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBpc1BvbGxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnBvbGxpbmdJbnRlcnZhbCkgPT09IFwibnVtYmVyXCIpO1xufVxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgcG9sbGluZzogZmFsc2UsXG4gICAgc3RhdGljTmV0d29yazogbnVsbCxcbiAgICBiYXRjaFN0YWxsVGltZTogMTAsXG4gICAgYmF0Y2hNYXhTaXplOiAoMSA8PCAyMCksXG4gICAgYmF0Y2hNYXhDb3VudDogMTAwLFxuICAgIGNhY2hlVGltZW91dDogMjUwLFxuICAgIHBvbGxpbmdJbnRlcnZhbDogNDAwMFxufTtcbi8vIEBUT0RPOiBVbmNoZWNrZWQgU2lnbmVyc1xuZXhwb3J0IGNsYXNzIEpzb25ScGNTaWduZXIgZXh0ZW5kcyBBYnN0cmFjdFNpZ25lciB7XG4gICAgYWRkcmVzcztcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgYWRkcmVzcykge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWRkcmVzcyB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY2Fubm90IHJlY29ubmVjdCBKc29uUnBjU2lnbmVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzaWduZXIuY29ubmVjdFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRyZXNzO1xuICAgIH1cbiAgICAvLyBKU09OLVJQQyB3aWxsIGF1dG9tYXRpYWxseSBmaWxsIGluIG5vbmNlLCBldGMuIHNvIHdlIGp1c3QgY2hlY2sgZnJvbVxuICAgIGFzeW5jIHBvcHVsYXRlVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9wdWxhdGVDYWxsKHR4KTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBqdXN0IHRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBhZnRlciBzZW50LCB3aGljaCBpcyB3aGF0XG4gICAgLy8gdGhlIGJhcmUgSlNPTi1SUEMgQVBJIGRvZXM7XG4gICAgYXN5bmMgc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKF90eCkge1xuICAgICAgICBjb25zdCB0eCA9IGRlZXBDb3B5KF90eCk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZnJvbSBtYXRjaGVzIHRoZSBzZW5kZXJcbiAgICAgICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgICAgIGNvbnN0IF9mcm9tID0gdHguZnJvbTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3MoX2Zyb20sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZyb20gIT0gbnVsbCAmJiBmcm9tLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIF90eCk7XG4gICAgICAgICAgICAgICAgdHguZnJvbSA9IGZyb207XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSB0aGlzLmFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIEpTT04tUlBDIGZvciBldGhfc2VuZFRyYW5zYWN0aW9uIHVzZXMgOTAwMDAgZ2FzOyBpZiB0aGUgdXNlclxuICAgICAgICAvLyB3aXNoZXMgdG8gdXNlIHRoaXMsIGl0IGlzIGVhc3kgdG8gc3BlY2lmeSBleHBsaWNpdGx5LCBvdGhlcndpc2VcbiAgICAgICAgLy8gd2UgbG9vayBpdCB1cCBmb3IgdGhlbS5cbiAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0eC5nYXNMaW1pdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXMoeyAuLi50eCwgZnJvbTogdGhpcy5hZGRyZXNzIH0pO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGFkZHJlc3MgbWF5IGJlIGFuIEVOUyBuYW1lIG9yIEFkZHJlc3NhYmxlXG4gICAgICAgIGlmICh0eC50byAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBfdG8gPSB0eC50bztcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0eC50byA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKF90bywgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXYWl0IHVudGlsIGFsbCBvZiBvdXIgcHJvcGVydGllcyBhcmUgZmlsbGVkIGluXG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZXhUeCA9IHRoaXMucHJvdmlkZXIuZ2V0UnBjVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiLCBbaGV4VHhdKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIC8vIFRoaXMgY2Fubm90IGJlIG1pbmVkIGFueSBlYXJsaWVyIHRoYW4gYW55IHJlY2VudCBibG9ja1xuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgLy8gU2VuZCB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgSlNPTi1SUEMgb25seSBwcm92aWRlcyBhbmQgb3BhcXVlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgICAgLy8gZm9yIGEgcmVzcG9uc2UsIGFuZCB3ZSBuZWVkIHRoZSBhY3R1YWwgdHJhbnNhY3Rpb24sIHNvIHdlIHBvbGxcbiAgICAgICAgLy8gZm9yIGl0OyBpdCBzaG91bGQgc2hvdyB1cCB2ZXJ5IHF1aWNrbHlcbiAgICAgICAgcmV0dXJuIGF3YWl0IChuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0cyA9IFsxMDAwLCAxMDBdO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tUeCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgZ2V0dGluZyB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24oaGFzaCk7XG4gICAgICAgICAgICAgICAgaWYgKHR4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0eC5yZXBsYWNlYWJsZVRyYW5zYWN0aW9uKGJsb2NrTnVtYmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2FpdCBhbm90aGVyIDQgc2Vjb25kc1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIuX3NldFRpbWVvdXQoKCkgPT4geyBjaGVja1R4KCk7IH0sIHRpbWVvdXRzLnBvcCgpIHx8IDQwMDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNoZWNrVHgoKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24oX3R4KSB7XG4gICAgICAgIGNvbnN0IHR4ID0gZGVlcENvcHkoX3R4KTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBmcm9tIG1hdGNoZXMgdGhlIHNlbmRlclxuICAgICAgICBpZiAodHguZnJvbSkge1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHR4LmZyb20sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJvbSAhPSBudWxsICYmIGZyb20udG9Mb3dlckNhc2UoKSA9PT0gdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgX3R4KTtcbiAgICAgICAgICAgIHR4LmZyb20gPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHguZnJvbSA9IHRoaXMuYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZXhUeCA9IHRoaXMucHJvdmlkZXIuZ2V0UnBjVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UcmFuc2FjdGlvblwiLCBbaGV4VHhdKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UoX21lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgodHlwZW9mIChfbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gdG9VdGY4Qnl0ZXMoX21lc3NhZ2UpIDogX21lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfc2lnblwiLCBbXG4gICAgICAgICAgICBoZXhsaWZ5KG1lc3NhZ2UpLCB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkZWVwQ29weShfdmFsdWUpO1xuICAgICAgICAvLyBQb3B1bGF0ZSBhbnkgRU5TIG5hbWVzIChpbi1wbGFjZSlcbiAgICAgICAgY29uc3QgcG9wdWxhdGVkID0gYXdhaXQgVHlwZWREYXRhRW5jb2Rlci5yZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFkZHJlc3MgIT0gbnVsbCwgXCJUeXBlZERhdGEgZG9lcyBub3Qgc3VwcG9ydCBudWxsIGFkZHJlc3NcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblR5cGVkRGF0YV92NFwiLCBbXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KFR5cGVkRGF0YUVuY29kZXIuZ2V0UGF5bG9hZChwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgcG9wdWxhdGVkLnZhbHVlKSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIHVubG9jayhwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfdW5sb2NrQWNjb3VudFwiLCBbXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgcGFzc3dvcmQsIG51bGxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvSlNPTi1SUEMjZXRoX3NpZ25cbiAgICBhc3luYyBfbGVnYWN5U2lnbk1lc3NhZ2UoX21lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgodHlwZW9mIChfbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gdG9VdGY4Qnl0ZXMoX21lc3NhZ2UpIDogX21lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25cIiwgW1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIGhleGxpZnkobWVzc2FnZSlcbiAgICAgICAgXSk7XG4gICAgfVxufVxuLyoqXG4gKiAgVGhlIEpzb25ScGNBcGlQcm92aWRlciBpcyBhbiBhYnN0cmFjdCBjbGFzcyBhbmQgKipNVVNUKiogYmVcbiAqICBzdWItY2xhc3NlZC5cbiAqXG4gKiAgSXQgcHJvdmlkZXMgdGhlIGJhc2UgZm9yIGFsbCBKU09OLVJQQy1iYXNlZCBQcm92aWRlciBpbnRlcmFjdGlvbi5cbiAqXG4gKiAgU3ViLWNsYXNzaW5nIE5vdGVzOlxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBvdmVycmlkZSBfc2VuZFxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBjYWxsIHRoZSBgX3N0YXJ0KClgIG1ldGhvZCBvbmNlIGNvbm5lY3RlZFxuICovXG5leHBvcnQgY2xhc3MgSnNvblJwY0FwaVByb3ZpZGVyIGV4dGVuZHMgQWJzdHJhY3RQcm92aWRlciB7XG4gICAgI29wdGlvbnM7XG4gICAgLy8gVGhlIG5leHQgSUQgdG8gdXNlIGZvciB0aGUgSlNPTi1SUEMgSUQgZmllbGRcbiAgICAjbmV4dElkO1xuICAgIC8vIFBheWxvYWRzIGFyZSBxdWV1ZWQgYW5kIHRyaWdnZXJlZCBpbiBiYXRjaGVzIHVzaW5nIHRoZSBkcmFpblRpbWVyXG4gICAgI3BheWxvYWRzO1xuICAgICNkcmFpblRpbWVyO1xuICAgICNub3RSZWFkeTtcbiAgICAjbmV0d29yaztcbiAgICAjc2NoZWR1bGVEcmFpbigpIHtcbiAgICAgICAgaWYgKHRoaXMuI2RyYWluVGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgdXNpbmcgYmF0Y2hpbmcsIG5vIGhhcmQgaW4gc2VuZGluZyBpdCBpbW1laWRhdGVseVxuICAgICAgICBjb25zdCBzdGFsbFRpbWUgPSAodGhpcy5fZ2V0T3B0aW9uKFwiYmF0Y2hNYXhDb3VudFwiKSA9PT0gMSkgPyAwIDogdGhpcy5fZ2V0T3B0aW9uKFwiYmF0Y2hTdGFsbFRpbWVcIik7XG4gICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZHMgPSB0aGlzLiNwYXlsb2FkcztcbiAgICAgICAgICAgIHRoaXMuI3BheWxvYWRzID0gW107XG4gICAgICAgICAgICB3aGlsZSAocGF5bG9hZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHBheWxvYWQgYmF0Y2hlcyB0aGF0IHNhdGlzZnkgb3VyIGJhdGNoIGNvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBbKHBheWxvYWRzLnNoaWZ0KCkpXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocGF5bG9hZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXRjaC5sZW5ndGggPT09IHRoaXMuI29wdGlvbnMuYmF0Y2hNYXhDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmF0Y2gucHVzaCgocGF5bG9hZHMuc2hpZnQoKSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IEpTT04uc3RyaW5naWZ5KGJhdGNoLm1hcCgocCkgPT4gcC5wYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPiB0aGlzLiNvcHRpb25zLmJhdGNoTWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZHMudW5zaGlmdCgoYmF0Y2gucG9wKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHJlc3VsdCB0byBlYWNoIHBheWxvYWRcbiAgICAgICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gKChiYXRjaC5sZW5ndGggPT09IDEpID8gYmF0Y2hbMF0ucGF5bG9hZCA6IGJhdGNoLm1hcCgocCkgPT4gcC5wYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRScGNQYXlsb2FkXCIsIHBheWxvYWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9zZW5kKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY1Jlc3VsdFwiLCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHJlc3VsdHMgaW4gYmF0Y2ggb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyByZXNvbHZlLCByZWplY3QsIHBheWxvYWQgfSBvZiBiYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwicHJvdmlkZXIgZGVzdHJveWVkOyBjYW5jZWxsZWQgcmVxdWVzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogcGF5bG9hZC5tZXRob2QgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbWF0Y2hpbmcgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHJlc3VsdC5maWx0ZXIoKHIpID0+IChyLmlkID09PSBwYXlsb2FkLmlkKSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gcmVzdWx0OyB0aGUgbm9kZSBmYWlsZWQgdXMgaW4gdW5leHBlY3RlZCB3YXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3AgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG1ha2VFcnJvcihcIm1pc3NpbmcgcmVzcG9uc2UgZm9yIHJlcXVlc3RcIiwgXCJCQURfREFUQVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LCBpbmZvOiB7IHBheWxvYWQgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlc3BvbnNlIGlzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiByZXNwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aGlzLmdldFJwY0Vycm9yKHBheWxvYWQsIHJlc3ApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBnb29kOyBzZW5kIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3AucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNFcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyByZWplY3QgfSBvZiBiYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBhdWdtZW50IHRoZSBlcnJvciB3aXRoIHRoZSBwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHN0YWxsVGltZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuI25leHRJZCA9IDE7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIHRoaXMuI3BheWxvYWRzID0gW107XG4gICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLiNuZXR3b3JrID0gbnVsbDtcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IHJlc29sdmUgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUgPSBfcmVzb2x2ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4jbm90UmVhZHkgPSB7IHByb21pc2UsIHJlc29sdmUgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgYW55IHN0YXRpYyBuZXR3b3JrIGlzIGNvbXBhdGJpbGUgd2l0aCB0aGUgcHJvdmlkZWQgbmV0d3Jva1xuICAgICAgICBjb25zdCBzdGF0aWNOZXR3b3JrID0gdGhpcy5fZ2V0T3B0aW9uKFwic3RhdGljTmV0d29ya1wiKTtcbiAgICAgICAgaWYgKHN0YXRpY05ldHdvcmspIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG5ldHdvcmsgPT0gbnVsbCB8fCBzdGF0aWNOZXR3b3JrLm1hdGNoZXMobmV0d29yayksIFwic3RhdGljTmV0d29yayBNVVNUIG1hdGNoIG5ldHdvcmsgb2JqZWN0XCIsIFwib3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBzdGF0aWNOZXR3b3JrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIG9wdGlvbiAlJWtleSUlLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzIGNhbiB1c2UgdGhpcyB0byBpbnF1aXJlIGFib3V0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBfZ2V0T3B0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jb3B0aW9uc1trZXldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0cyB0aGUgW1tOZXR3b3JrXV0gdGhpcyBwcm92aWRlciBoYXMgY29tbWl0dGVkIHRvLiBPbiBlYWNoIGNhbGwsIHRoZSBuZXR3b3JrXG4gICAgICogIGlzIGRldGVjdGVkLCBhbmQgaWYgaXQgaGFzIGNoYW5nZWQsIHRoZSBjYWxsIHdpbGwgcmVqZWN0LlxuICAgICAqL1xuICAgIGdldCBfbmV0d29yaygpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuI25ldHdvcmssIFwibmV0d29yayBpcyBub3QgYXZhaWxhYmxlIHlldFwiLCBcIk5FVFdPUktfRVJST1JcIik7XG4gICAgICAgIHJldHVybiB0aGlzLiNuZXR3b3JrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG5vbi1ub3JtYWxpemVkIHZhbHVlIGJ5IHBlcmZvcm1pbmcgJSVyZXElJS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBtb2RpZnkgYmVoYXZpb3Igb2YgYWN0aW9ucyxcbiAgICAgKiAgYW5kIHNob3VsZCBnZW5lcmFsbHkgY2FsbCBgYHN1cGVyLl9wZXJmb3JtYGAgYXMgYSBmYWxsYmFjay5cbiAgICAgKi9cbiAgICBhc3luYyBfcGVyZm9ybShyZXEpIHtcbiAgICAgICAgLy8gTGVnYWN5IG5ldHdvcmtzIGRvIG5vdCBsaWtlIHRoZSB0eXBlIGZpZWxkIGJlaW5nIHBhc3NlZCBhbG9uZyAod2hpY2hcbiAgICAgICAgLy8gaXMgZmFpciksIHNvIHdlIGRlbGV0ZSB0eXBlIGlmIGl0IGlzIDAgYW5kIGEgbm9uLUVJUC0xNTU5IG5ldHdvcmtcbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09IFwiY2FsbFwiIHx8IHJlcS5tZXRob2QgPT09IFwiZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAgICAgbGV0IHR4ID0gcmVxLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgaWYgKHR4ICYmIHR4LnR5cGUgIT0gbnVsbCAmJiBnZXRCaWdJbnQodHgudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gRUlQLTE1NTkgcHJvcGVydGllcywgaXQgbWlnaHQgYmUgbm9uLUVJUC1hNTU5XG4gICAgICAgICAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyA9PSBudWxsICYmIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHRoaXMuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmVlRGF0YS5tYXhGZWVQZXJHYXMgPT0gbnVsbCAmJiBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBrbm93IGFib3V0IEVJUC0xNTU5IChhbmQgaGVuY2UgdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IE9iamVjdC5hc3NpZ24oe30sIHJlcSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCwgeyB0eXBlOiB1bmRlZmluZWQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmdldFJwY1JlcXVlc3QocmVxKTtcbiAgICAgICAgaWYgKHJlcXVlc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZChyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX3BlcmZvcm0ocmVxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzOyBpdCBkZXRlY3RzIHRoZSAqYWN0dWFsKiBuZXR3b3JrIHRoYXRcbiAgICAgKiAgd2UgYXJlICoqY3VycmVudGx5KiogY29ubmVjdGVkIHRvLlxuICAgICAqXG4gICAgICogIEtlZXAgaW4gbWluZCB0aGF0IFtbc2VuZF1dIG1heSBvbmx5IGJlIHVzZWQgb25jZSBbW3JlYWR5XV0sIG90aGVyd2lzZSB0aGVcbiAgICAgKiAgX3NlbmQgcHJpbWl0aXZlIG11c3QgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIF9kZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gdGhpcy5fZ2V0T3B0aW9uKFwic3RhdGljTmV0d29ya1wiKTtcbiAgICAgICAgaWYgKG5ldHdvcmspIHtcbiAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGFyZSByZWFkeSwgdXNlIGBgc2VuZGBgLCB3aGljaCBlbmFibGVkIHJlcXVlc3RzIHRvIGJlIGJhdGNoZWRcbiAgICAgICAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBOZXR3b3JrLmZyb20oZ2V0QmlnSW50KGF3YWl0IHRoaXMuc2VuZChcImV0aF9jaGFpbklkXCIsIFtdKSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGFyZSBub3QgcmVhZHkgeWV0OyB1c2UgdGhlIHByaW1pdGl2ZSBfc2VuZFxuICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuI25leHRJZCsrLCBtZXRob2Q6IFwiZXRoX2NoYWluSWRcIiwgcGFyYW1zOiBbXSwganNvbnJwYzogXCIyLjBcIlxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kUnBjUGF5bG9hZFwiLCBwYXlsb2FkIH0pO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gKGF3YWl0IHRoaXMuX3NlbmQocGF5bG9hZCkpWzBdO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY0Vycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY1Jlc3VsdFwiLCByZXN1bHQgfSk7XG4gICAgICAgIGlmIChcInJlc3VsdFwiIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIE5ldHdvcmsuZnJvbShnZXRCaWdJbnQocmVzdWx0LnJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IHRoaXMuZ2V0UnBjRXJyb3IocGF5bG9hZCwgcmVzdWx0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqTVVTVCoqIGNhbGwgdGhpcy4gVW50aWwgW1tfc3RhcnRdXSBoYXMgYmVlbiBjYWxsZWQsIG5vIGNhbGxzXG4gICAgICogIHdpbGwgYmUgcGFzc2VkIHRvIFtbX3NlbmRdXSBmcm9tIFtbc2VuZF1dLiBJZiBpdCBpcyBvdmVycmlkZGVuLCB0aGVuXG4gICAgICogIGBgc3VwZXIuX3N0YXJ0KClgYCAqKk1VU1QqKiBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiAgQ2FsbGluZyBpdCBtdWx0aXBsZSB0aW1lcyBpcyBzYWZlIGFuZCBoYXMgbm8gZWZmZWN0LlxuICAgICAqL1xuICAgIF9zdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI25vdFJlYWR5ID09IG51bGwgfHwgdGhpcy4jbm90UmVhZHkucmVzb2x2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbm90UmVhZHkucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLiNub3RSZWFkeSA9IG51bGw7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBCb290c3RyYXAgdGhlIG5ldHdvcmtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLiNuZXR3b3JrID09IG51bGwgJiYgIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IGF3YWl0IHRoaXMuX2RldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJKc29uUnBjUHJvdmlkZXIgZmFpbGVkIHRvIGRldGVjdCBuZXR3b3JrIGFuZCBjYW5ub3Qgc3RhcnQgdXA7IHJldHJ5IGluIDFzIChwZXJoYXBzIHRoZSBVUkwgaXMgd3Jvbmcgb3IgdGhlIG5vZGUgaXMgbm90IHN0YXJ0ZWQpXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBtYWtlRXJyb3IoXCJmYWlsZWQgdG8gYm9vdHN0cmFwIG5ldHdvcmsgZGV0ZWN0aW9uXCIsIFwiTkVUV09SS19FUlJPUlwiLCB7IGV2ZW50OiBcImluaXRpYWwtbmV0d29yay1kaXNjb3ZlcnlcIiwgaW5mbzogeyBlcnJvciB9IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RhbGwoMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgZGlzcGF0Y2hpbmcgcmVxdWVzdHNcbiAgICAgICAgICAgIHRoaXMuI3NjaGVkdWxlRHJhaW4oKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhlIFtbX3N0YXJ0XV0gaGFzIGJlZW4gY2FsbGVkLiBUaGlzIGNhbiBiZSB1c2VkIGluXG4gICAgICogIHN1Yi1jbGFzc2VzIHRvIGRlZmVyIHNlbmRpbmcgZGF0YSB1bnRpbCB0aGUgY29ubmVjdGlvbiBoYXMgYmVlblxuICAgICAqICBlc3RhYmxpc2hlZC5cbiAgICAgKi9cbiAgICBhc3luYyBfd2FpdFVudGlsUmVhZHkoKSB7XG4gICAgICAgIGlmICh0aGlzLiNub3RSZWFkeSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI25vdFJlYWR5LnByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBTdWJzY3JpYmVyIHRoYXQgd2lsbCBtYW5hZ2UgdGhlICUlc3ViJSUuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gbW9kaWZ5IHRoZSBiZWhhdmlvciBvZlxuICAgICAqICBzdWJzY3JpcHRpb24gbWFuYWdlbWVudC5cbiAgICAgKi9cbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcbiAgICAgICAgLy8gUGVuZGluZyBGaWx0ZXJzIGFyZW4ndCBhdmFpbGJsZSB2aWEgcG9sbGluZ1xuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcImV2ZW50XCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRPcHRpb24oXCJwb2xsaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPcnBoYW5lZCBMb2dzIGFyZSBoYW5kbGVkIGF1dG9tYXRpY2FsbHksIGJ5IHRoZSBmaWx0ZXIsIHNpbmNlXG4gICAgICAgIC8vIGxvZ3Mgd2l0aCByZW1vdmVkIGFyZSBlbWl0dGVkIGJ5IGl0XG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJvcnBoYW5cIiAmJiBzdWIuZmlsdGVyLm9ycGhhbiA9PT0gXCJkcm9wLWxvZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVubWFuYWdlZFN1YnNjcmliZXIoXCJvcnBoYW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9nZXRTdWJzY3JpYmVyKHN1Yik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgb25seSBpZiB0aGUgW1tfc3RhcnRdXSBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICovXG4gICAgZ2V0IHJlYWR5KCkgeyByZXR1cm4gdGhpcy4jbm90UmVhZHkgPT0gbnVsbDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zICUldHglJSBhcyBhIG5vcm1hbGl6ZWQgSlNPTi1SUEMgdHJhbnNhY3Rpb24gcmVxdWVzdCxcbiAgICAgKiAgd2hpY2ggaGFzIGFsbCB2YWx1ZXMgaGV4bGlmaWVkIGFuZCBhbnkgbnVtZXJpYyB2YWx1ZXMgY29udmVydGVkXG4gICAgICogIHRvIFF1YW50aXR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBnZXRScGNUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgLy8gSlNPTi1SUEMgbm93IHJlcXVpcmVzIG51bWVyaWMgdmFsdWVzIHRvIGJlIFwicXVhbnRpdHlcIiB2YWx1ZXNcbiAgICAgICAgW1wiY2hhaW5JZFwiLCBcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJ0eXBlXCIsIFwibWF4RmVlUGVyR2FzXCIsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJub25jZVwiLCBcInZhbHVlXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR4W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkc3RLZXkgPSBrZXk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImdhc0xpbWl0XCIpIHtcbiAgICAgICAgICAgICAgICBkc3RLZXkgPSBcImdhc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2RzdEtleV0gPSB0b1F1YW50aXR5KGdldEJpZ0ludCh0eFtrZXldLCBgdHguJHtrZXl9YCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGFkZHJlc3NlcyBhbmQgZGF0YSBhcmUgbG93ZXJjYXNlXG4gICAgICAgIFtcImZyb21cIiwgXCJ0b1wiLCBcImRhdGFcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBoZXhsaWZ5KHR4W2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBhY2Nlc3MgbGlzdCBvYmplY3RcbiAgICAgICAgaWYgKHR4LmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdFtcImFjY2Vzc0xpc3RcIl0gPSBhY2Nlc3NMaXN0aWZ5KHR4LmFjY2Vzc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSByZXF1ZXN0IG1ldGhvZCBhbmQgYXJndW1lbnRzIHJlcXVpcmVkIHRvIHBlcmZvcm1cbiAgICAgKiAgJSVyZXElJS5cbiAgICAgKi9cbiAgICBnZXRScGNSZXF1ZXN0KHJlcSkge1xuICAgICAgICBzd2l0Y2ggKHJlcS5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjaGFpbklkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9jaGFpbklkXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2Jsb2NrTnVtYmVyXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2dhc1ByaWNlXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmFsYW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0VHJhbnNhY3Rpb25Db3VudFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0Q29kZVwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0U3RvcmFnZUF0XCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCIweFwiICsgcmVxLnBvc2l0aW9uLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuYmxvY2tUYWdcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiYnJvYWRjYXN0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLnNpZ25lZFRyYW5zYWN0aW9uXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcbiAgICAgICAgICAgICAgICBpZiAoXCJibG9ja1RhZ1wiIGluIHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmJsb2NrVGFnLCAhIXJlcS5pbmNsdWRlVHJhbnNhY3Rpb25zXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImJsb2NrSGFzaFwiIGluIHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRCbG9ja0J5SGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5ibG9ja0hhc2gsICEhcmVxLmluY2x1ZGVUcmFuc2FjdGlvbnNdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmhhc2hdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmhhc2hdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLmdldFJwY1RyYW5zYWN0aW9uKHJlcS50cmFuc2FjdGlvbiksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2VzdGltYXRlR2FzXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLmdldFJwY1RyYW5zYWN0aW9uKHJlcS50cmFuc2FjdGlvbildXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5maWx0ZXIgJiYgcmVxLmZpbHRlci5hZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVxLmZpbHRlci5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmZpbHRlci5hZGRyZXNzID0gcmVxLmZpbHRlci5hZGRyZXNzLm1hcChnZXRMb3dlckNhc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmZpbHRlci5hZGRyZXNzID0gZ2V0TG93ZXJDYXNlKHJlcS5maWx0ZXIuYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9nZXRMb2dzXCIsIGFyZ3M6IFtyZXEuZmlsdGVyXSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhbiBldGhlcnMtc3R5bGUgRXJyb3IgZm9yIHRoZSBnaXZlbiBKU09OLVJQQyBlcnJvclxuICAgICAqICAlJXBheWxvYWQlJSwgY29hbGVzY2luZyB0aGUgdmFyaW91cyBzdHJpbmdzIGFuZCBlcnJvciBzaGFwZXNcbiAgICAgKiAgdGhhdCBkaWZmZXJlbnQgbm9kZXMgcmV0dXJuLCBjb2VyY2luZyB0aGVtIGludG8gYSBtYWNoaW5lLXJlYWRhYmxlXG4gICAgICogIHN0YW5kYXJkaXplZCBlcnJvci5cbiAgICAgKi9cbiAgICBnZXRScGNFcnJvcihwYXlsb2FkLCBfZXJyb3IpIHtcbiAgICAgICAgY29uc3QgeyBtZXRob2QgfSA9IHBheWxvYWQ7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IF9lcnJvcjtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJldGhfZXN0aW1hdGVHYXNcIiAmJiBlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgaWYgKCFtc2cubWF0Y2goL3JldmVydC9pKSAmJiBtc2cubWF0Y2goL2luc3VmZmljaWVudCBmdW5kcy9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHNcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogKHBheWxvYWQucGFyYW1zWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgaW5mbzogeyBwYXlsb2FkLCBlcnJvciB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJldGhfY2FsbFwiIHx8IG1ldGhvZCA9PT0gXCJldGhfZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3BlbHVua0RhdGEoZXJyb3IpO1xuICAgICAgICAgICAgY29uc3QgZSA9IEFiaUNvZGVyLmdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKChtZXRob2QgPT09IFwiZXRoX2NhbGxcIikgPyBcImNhbGxcIiA6IFwiZXN0aW1hdGVHYXNcIiwgKHBheWxvYWQucGFyYW1zWzBdKSwgKHJlc3VsdCA/IHJlc3VsdC5kYXRhIDogbnVsbCkpO1xuICAgICAgICAgICAgZS5pbmZvID0geyBlcnJvciwgcGF5bG9hZCB9O1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBlc3RpbWF0ZUdhcyBhbmQgY2FsbCBjYW4gcmV0dXJuIGFyYml0cmFyeSBjb250cmFjdC1kZWZpbmVkIHRleHQsIHNvIG5vdyB3ZVxuICAgICAgICAvLyB3ZSBjYW4gcHJvY2VzcyB0ZXh0IHNhZmVseS5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KHNwZWx1bmtNZXNzYWdlKGVycm9yKSk7XG4gICAgICAgIGlmICh0eXBlb2YgKGVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIGVycm9yLm1lc3NhZ2UubWF0Y2goL3VzZXIgZGVuaWVkfGV0aGVycy11c2VyLWRlbmllZC9pKSkge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uTWFwID0ge1xuICAgICAgICAgICAgICAgIGV0aF9zaWduOiBcInNpZ25NZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgcGVyc29uYWxfc2lnbjogXCJzaWduTWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgIGV0aF9zaWduVHlwZWREYXRhX3Y0OiBcInNpZ25UeXBlZERhdGFcIixcbiAgICAgICAgICAgICAgICBldGhfc2lnblRyYW5zYWN0aW9uOiBcInNpZ25UcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIGV0aF9zZW5kVHJhbnNhY3Rpb246IFwic2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZXRoX3JlcXVlc3RBY2NvdW50czogXCJyZXF1ZXN0QWNjZXNzXCIsXG4gICAgICAgICAgICAgICAgd2FsbGV0X3JlcXVlc3RBY2NvdW50czogXCJyZXF1ZXN0QWNjZXNzXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihgdXNlciByZWplY3RlZCBhY3Rpb25gLCBcIkFDVElPTl9SRUpFQ1RFRFwiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAoYWN0aW9uTWFwW21ldGhvZF0gfHwgXCJ1bmtub3duXCIpLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogXCJyZWplY3RlZFwiLFxuICAgICAgICAgICAgICAgIGluZm86IHsgcGF5bG9hZCwgZXJyb3IgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIgfHwgbWV0aG9kID09PSBcImV0aF9zZW5kVHJhbnNhY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSAocGF5bG9hZC5wYXJhbXNbMF0pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL2luc3VmZmljaWVudCBmdW5kc3xiYXNlIGZlZSBleGNlZWRzIGdhcyBsaW1pdC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGludHJpbnNpYyB0cmFuc2FjdGlvbiBjb3N0XCIsIFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL25vbmNlL2kpICYmIG1lc3NhZ2UubWF0Y2goL3RvbyBsb3cvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsIFwiTk9OQ0VfRVhQSVJFRFwiLCB7IHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBcInJlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkXCJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9yZXBsYWNlbWVudCB0cmFuc2FjdGlvbi9pKSAmJiBtZXNzYWdlLm1hdGNoKC91bmRlcnByaWNlZC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJyZXBsYWNlbWVudCBmZWUgdG9vIGxvd1wiLCBcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCIsIHsgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9vbmx5IHJlcGxheS1wcm90ZWN0ZWQvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwibGVnYWN5IHByZS1laXAtMTU1IHRyYW5zYWN0aW9ucyBub3Qgc3VwcG9ydGVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBtZXRob2QsIGluZm86IHsgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfSB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHVuc3VwcG9ydGVkID0gISFtZXNzYWdlLm1hdGNoKC90aGUgbWV0aG9kIC4qIGRvZXMgbm90IGV4aXN0L2kpO1xuICAgICAgICBpZiAoIXVuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IuZGV0YWlscyAmJiBlcnJvci5kZXRhaWxzLnN0YXJ0c1dpdGgoXCJVbmF1dGhvcml6ZWQgbWV0aG9kOlwiKSkge1xuICAgICAgICAgICAgICAgIHVuc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodW5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJ1bnN1cHBvcnRlZCBvcGVyYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogcGF5bG9hZC5tZXRob2QsIGluZm86IHsgZXJyb3IsIHBheWxvYWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcImNvdWxkIG5vdCBjb2FsZXNjZSBlcnJvclwiLCBcIlVOS05PV05fRVJST1JcIiwgeyBlcnJvciwgcGF5bG9hZCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlcXVlc3RzIHRoZSAlJW1ldGhvZCUlIHdpdGggJSVwYXJhbXMlJSB2aWEgdGhlIEpTT04tUlBDIHByb3RvY29sXG4gICAgICogIG92ZXIgdGhlIHVuZGVybHlpbmcgY2hhbm5lbC4gVGhpcyBjYW4gYmUgdXNlZCB0byBjYWxsIG1ldGhvZHNcbiAgICAgKiAgb24gdGhlIGJhY2tlbmQgdGhhdCBkbyBub3QgaGF2ZSBhIGhpZ2gtbGV2ZWwgQVBJIHdpdGhpbiB0aGUgUHJvdmlkZXJcbiAgICAgKiAgQVBJLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIHF1ZXVlcyByZXF1ZXN0cyBhY2NvcmRpbmcgdG8gdGhlIGJhdGNoIGNvbnN0cmFpbnRzXG4gICAgICogIGluIHRoZSBvcHRpb25zLCBhc3NpZ25zIHRoZSByZXF1ZXN0IGEgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogICoqRG8gTk9UIG92ZXJyaWRlKiogdGhpcyBtZXRob2QgaW4gc3ViLWNsYXNzZXM7IGluc3RlYWRcbiAgICAgKiAgb3ZlcnJpZGUgW1tfc2VuZF1dIG9yIGZvcmNlIHRoZSBvcHRpb25zIHZhbHVlcyBpbiB0aGVcbiAgICAgKiAgY2FsbCB0byB0aGUgY29uc3RydWN0b3IgdG8gbW9kaWZ5IHRoaXMgbWV0aG9kJ3MgYmVoYXZpb3IuXG4gICAgICovXG4gICAgc2VuZChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICAvLyBAVE9ETzogY2FjaGUgY2hhaW5JZD8/IHB1cmdlIG9uIHN3aXRjaF9uZXR3b3Jrc1xuICAgICAgICAvLyBXZSBoYXZlIGJlZW4gZGVzdHJveWVkOyBubyBvcGVyYXRpb25zIGFyZSBzdXBwb3J0ZWQgYW55bW9yZVxuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChtYWtlRXJyb3IoXCJwcm92aWRlciBkZXN0cm95ZWQ7IGNhbmNlbGxlZCByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBtZXRob2QgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy4jbmV4dElkKys7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNwYXlsb2Fkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByZXNvbHZlLCByZWplY3QsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogeyBtZXRob2QsIHBhcmFtcywgaWQsIGpzb25ycGM6IFwiMi4wXCIgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBub3QgYSBwZW5kaW5nIGRyYWluVGltZXIsIHNldCBvbmVcbiAgICAgICAgdGhpcy4jc2NoZWR1bGVEcmFpbigpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBbW1NpZ25lcl1dIGFjY291bnQgZm9yICAlJWFkZHJlc3MlJSBtYW5hZ2VkIGJ5XG4gICAgICogIHRoZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUlYWRkcmVzcyUlIGlzIGEgbnVtYmVyLCBpdCBpcyB1c2VkIGFzIGFuIGluZGV4IGluIHRoZVxuICAgICAqICB0aGUgYWNjb3VudHMgZnJvbSBbW2xpc3RBY2NvdW50c11dLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIG9ubHkgYmUgdXNlZCBvbiBjbGllbnRzIHdoaWNoIG1hbmFnZSBhY2NvdW50cyAoc3VjaCBhc1xuICAgICAqICBHZXRoIHdpdGggaW1wb3J0ZWQgYWNjb3VudCBvciBNZXRhTWFzaykuXG4gICAgICpcbiAgICAgKiAgVGhyb3dzIGlmIHRoZSBhY2NvdW50IGRvZXNuJ3QgZXhpc3QuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U2lnbmVyKGFkZHJlc3MpIHtcbiAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWNjb3VudHNQcm9taXNlID0gdGhpcy5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKTtcbiAgICAgICAgLy8gQWNjb3VudCBpbmRleFxuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSAoYXdhaXQgYWNjb3VudHNQcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzID49IGFjY291bnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHN1Y2ggYWNjb3VudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgSnNvblJwY1NpZ25lcih0aGlzLCBhY2NvdW50c1thZGRyZXNzXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhY2NvdW50cyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBhY2NvdW50czogYWNjb3VudHNQcm9taXNlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBY2NvdW50IGFkZHJlc3NcbiAgICAgICAgYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGZvciAoY29uc3QgYWNjb3VudCBvZiBhY2NvdW50cykge1xuICAgICAgICAgICAgaWYgKGdldEFkZHJlc3MoYWNjb3VudCkgPT09IGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEpzb25ScGNTaWduZXIodGhpcywgYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhY2NvdW50XCIpO1xuICAgIH1cbiAgICBhc3luYyBsaXN0QWNjb3VudHMoKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKTtcbiAgICAgICAgcmV0dXJuIGFjY291bnRzLm1hcCgoYSkgPT4gbmV3IEpzb25ScGNTaWduZXIodGhpcywgYSkpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvLyBTdG9wIHByb2Nlc3NpbmcgcmVxdWVzdHNcbiAgICAgICAgaWYgKHRoaXMuI2RyYWluVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNkcmFpblRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbmNlbCBhbGwgcGVuZGluZyByZXF1ZXN0c1xuICAgICAgICBmb3IgKGNvbnN0IHsgcGF5bG9hZCwgcmVqZWN0IH0gb2YgdGhpcy4jcGF5bG9hZHMpIHtcbiAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJwcm92aWRlciBkZXN0cm95ZWQ7IGNhbmNlbGxlZCByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBwYXlsb2FkLm1ldGhvZCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcGF5bG9hZHMgPSBbXTtcbiAgICAgICAgLy8gUGFyZW50IGNsZWFuLXVwXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vLyBAVE9ETzogcmVtb3ZlIHRoaXMgaW4gdjcsIGl0IGlzIG5vdCBleHBvcnRlZCBiZWNhdXNlIHRoaXMgZnVuY3Rpb25hbGl0eVxuLy8gaXMgZXhwb3NlZCBpbiB0aGUgSnNvblJwY0FwaVByb3ZpZGVyIGJ5IHNldHRpbmcgcG9sbGluZyB0byB0cnVlLiBJdCBzaG91bGRcbi8vIGJlIHNhZmUgdG8gcmVtb3ZlIHJlZ2FyZGxlc3MsIGJlY2F1c2UgaXQgaXNuJ3QgcmVhY2hhYmxlLCBidXQganVzdCBpbiBjYXNlLlxuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKi9cbmV4cG9ydCBjbGFzcyBKc29uUnBjQXBpUG9sbGluZ1Byb3ZpZGVyIGV4dGVuZHMgSnNvblJwY0FwaVByb3ZpZGVyIHtcbiAgICAjcG9sbGluZ0ludGVydmFsO1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuI3BvbGxpbmdJbnRlcnZhbCA9IDQwMDA7XG4gICAgfVxuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gc3VwZXIuX2dldFN1YnNjcmliZXIoc3ViKTtcbiAgICAgICAgaWYgKGlzUG9sbGFibGUoc3Vic2NyaWJlcikpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIucG9sbGluZ0ludGVydmFsID0gdGhpcy4jcG9sbGluZ0ludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHBvbGxpbmcgaW50ZXJ2YWwgKGRlZmF1bHQ6IDQwMDAgbXMpXG4gICAgICovXG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI3BvbGxpbmdJbnRlcnZhbDsgfVxuICAgIHNldCBwb2xsaW5nSW50ZXJ2YWwodmFsdWUpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50ZXJ2YWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcG9sbGluZ0ludGVydmFsID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzdWIpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1BvbGxhYmxlKHN1YikpIHtcbiAgICAgICAgICAgICAgICBzdWIucG9sbGluZ0ludGVydmFsID0gdGhpcy4jcG9sbGluZ0ludGVydmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqICBUaGUgSnNvblJwY1Byb3ZpZGVyIGlzIG9uZSBvZiB0aGUgbW9zdCBjb21tb24gUHJvdmlkZXJzLFxuICogIHdoaWNoIHBlcmZvcm1zIGFsbCBvcGVyYXRpb25zIG92ZXIgSFRUUCAob3IgSFRUUFMpIHJlcXVlc3RzLlxuICpcbiAqICBFdmVudHMgYXJlIHByb2Nlc3NlZCBieSBwb2xsaW5nIHRoZSBiYWNrZW5kIGZvciB0aGUgY3VycmVudCBibG9ja1xuICogIG51bWJlcjsgd2hlbiBpdCBhZHZhbmNlcywgYWxsIGJsb2NrLWJhc2UgZXZlbnRzIGFyZSB0aGVuIGNoZWNrZWRcbiAqICBmb3IgdXBkYXRlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEpzb25ScGNQcm92aWRlciBleHRlbmRzIEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIge1xuICAgICNjb25uZWN0O1xuICAgIGNvbnN0cnVjdG9yKHVybCwgbmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICBpZiAodXJsID09IG51bGwpIHtcbiAgICAgICAgICAgIHVybCA9IFwiaHR0cDovXFwvbG9jYWxob3N0Ojg1NDVcIjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCA9IG5ldyBGZXRjaFJlcXVlc3QodXJsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QgPSB1cmwuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0Q29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Nvbm5lY3QuY2xvbmUoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICAvLyBBbGwgcmVxdWVzdHMgYXJlIG92ZXIgSFRUUCwgc28gd2UgY2FuIGp1c3Qgc3RhcnQgaGFuZGxpbmcgcmVxdWVzdHNcbiAgICAgICAgLy8gV2UgZG8gdGhpcyBoZXJlIHJhdGhlciB0aGFuIHRoZSBjb25zdHJ1Y3RvciBzbyB0aGF0IHdlIGRvbid0IHNlbmQgYW55XG4gICAgICAgIC8vIHJlcXVlc3RzIHRvIHRoZSBuZXR3b3JrIChpLmUuIGV0aF9jaGFpbklkKSB1bnRpbCB3ZSBhYnNvbHV0ZWx5IGhhdmUgdG8uXG4gICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5zZW5kKG1ldGhvZCwgcGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgX3NlbmQocGF5bG9hZCkge1xuICAgICAgICAvLyBDb25maWd1cmUgYSBQT1NUIGNvbm5lY3Rpb24gZm9yIHRoZSByZXF1ZXN0ZWQgbWV0aG9kXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgIHJlcXVlc3QuYm9keSA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgICAgICByZXF1ZXN0LnNldEhlYWRlcihcImNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgIHJlc3BvbnNlLmFzc2VydE9rKCk7XG4gICAgICAgIGxldCByZXNwID0gcmVzcG9uc2UuYm9keUpzb247XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXNwKSkge1xuICAgICAgICAgICAgcmVzcCA9IFtyZXNwXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcDtcbiAgICB9XG59XG5mdW5jdGlvbiBzcGVsdW5rRGF0YSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBUaGVzZSAqYXJlKiB0aGUgZHJvaWRzIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLm1lc3NhZ2UubWF0Y2goL3JldmVydC9pKSAmJiBpc0hleFN0cmluZyh2YWx1ZS5kYXRhKSkge1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiB2YWx1ZS5tZXNzYWdlLCBkYXRhOiB2YWx1ZS5kYXRhIH07XG4gICAgfVxuICAgIC8vIFNwZWx1bmsgZnVydGhlci4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3BlbHVua0RhdGEodmFsdWVba2V5XSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gTWlnaHQgYmUgYSBKU09OIHN0cmluZyB3ZSBjYW4gZnVydGhlciBkZXNjZW5kLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlbHVua0RhdGEoSlNPTi5wYXJzZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gX3NwZWx1bmtNZXNzYWdlKHZhbHVlLCByZXN1bHQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFRoZXNlICphcmUqIHRoZSBkcm9pZHMgd2UncmUgbG9va2luZyBmb3IuXG4gICAgaWYgKHR5cGVvZiAodmFsdWUubWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUubWVzc2FnZSk7XG4gICAgfVxuICAgIC8vIFNwZWx1bmsgZnVydGhlci4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgX3NwZWx1bmtNZXNzYWdlKHZhbHVlW2tleV0sIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTWlnaHQgYmUgYSBKU09OIHN0cmluZyB3ZSBjYW4gZnVydGhlciBkZXNjZW5kLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gX3NwZWx1bmtNZXNzYWdlKEpTT04ucGFyc2UodmFsdWUpLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxufVxuZnVuY3Rpb24gc3BlbHVua01lc3NhZ2UodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBfc3BlbHVua01lc3NhZ2UodmFsdWUsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWpzb25ycGMuanMubWFwIiwiaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1qc29ucnBjLmpzXCI7XG47XG4vKipcbiAqICBBICoqQnJvd3NlclByb3ZpZGVyKiogaXMgaW50ZW5kZWQgdG8gd3JhcCBhbiBpbmplY3RlZCBwcm92aWRlciB3aGljaFxuICogIGFkaGVyZXMgdG8gdGhlIFtbbGluay1laXAtMTE5M11dIHN0YW5kYXJkLCB3aGljaCBtb3N0IChpZiBub3QgYWxsKVxuICogIGN1cnJlbnRseSBkby5cbiAqL1xuZXhwb3J0IGNsYXNzIEJyb3dzZXJQcm92aWRlciBleHRlbmRzIEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIge1xuICAgICNyZXF1ZXN0O1xuICAgIC8qKlxuICAgICAqICBDb25ubmVjdCB0byB0aGUgJSVldGhlcmV1bSUlIHByb3ZpZGVyLCBvcHRpb25hbGx5IGZvcmNpbmcgdGhlXG4gICAgICogICUlbmV0d29yayUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGV0aGVyZXVtLCBuZXR3b3JrKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIHsgYmF0Y2hNYXhDb3VudDogMSB9KTtcbiAgICAgICAgdGhpcy4jcmVxdWVzdCA9IGFzeW5jIChtZXRob2QsIHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHsgbWV0aG9kLCBwYXJhbXMgfTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRFaXAxMTkzUmVxdWVzdFwiLCBwYXlsb2FkIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldGhlcmV1bS5yZXF1ZXN0KHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFaXAxMTkzUmVzdWx0XCIsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSBlLmNvZGU7XG4gICAgICAgICAgICAgICAgZXJyb3IuZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgICAgICAgICBlcnJvci5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlRWlwMTE5M0Vycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5zZW5kKG1ldGhvZCwgcGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgX3NlbmQocGF5bG9hZCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCghQXJyYXkuaXNBcnJheShwYXlsb2FkKSwgXCJFSVAtMTE5MyBkb2VzIG5vdCBzdXBwb3J0IGJhdGNoIHJlcXVlc3RcIiwgXCJwYXlsb2FkXCIsIHBheWxvYWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jcmVxdWVzdChwYXlsb2FkLm1ldGhvZCwgcGF5bG9hZC5wYXJhbXMgfHwgW10pO1xuICAgICAgICAgICAgcmV0dXJuIFt7IGlkOiBwYXlsb2FkLmlkLCByZXN1bHQgfV07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICBpZDogcGF5bG9hZC5pZCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHsgY29kZTogZS5jb2RlLCBkYXRhOiBlLmRhdGEsIG1lc3NhZ2U6IGUubWVzc2FnZSB9XG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UnBjRXJyb3IocGF5bG9hZCwgZXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG4gICAgICAgIC8vIEVJUC0xMTkzIGdpdmVzIHVzIHNvbWUgbWFjaGluZS1yZWFkYWJsZSBlcnJvciBjb2Rlcywgc28gcmV3cml0ZVxuICAgICAgICAvLyB0aGVtIGludG8gXG4gICAgICAgIHN3aXRjaCAoZXJyb3IuZXJyb3IuY29kZSB8fCAtMSkge1xuICAgICAgICAgICAgY2FzZSA0MDAxOlxuICAgICAgICAgICAgICAgIGVycm9yLmVycm9yLm1lc3NhZ2UgPSBgZXRoZXJzLXVzZXItZGVuaWVkOiAke2Vycm9yLmVycm9yLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDIwMDpcbiAgICAgICAgICAgICAgICBlcnJvci5lcnJvci5tZXNzYWdlID0gYGV0aGVycy11bnN1cHBvcnRlZDogJHtlcnJvci5lcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldFJwY0Vycm9yKHBheWxvYWQsIGVycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIGBgdHJ1ZWBgIGlmIHRoZSBwcm92aWRlciBtYW5hZ2VzIHRoZSAlJWFkZHJlc3MlJS5cbiAgICAgKi9cbiAgICBhc3luYyBoYXNTaWduZXIoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSk7XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFjY291bnRzLmxlbmd0aCA+IGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBhY2NvdW50cy5maWx0ZXIoKGEpID0+IChhLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MpKS5sZW5ndGggIT09IDA7XG4gICAgfVxuICAgIGFzeW5jIGdldFNpZ25lcihhZGRyZXNzKSB7XG4gICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuaGFzU2lnbmVyKGFkZHJlc3MpKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvL2NvbnN0IHJlc3AgPSBcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNyZXF1ZXN0KFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiLCBbXSk7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJFU1BcIiwgcmVzcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZXJyb3IucGF5bG9hZDtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmdldFJwY0Vycm9yKHBheWxvYWQsIHsgaWQ6IHBheWxvYWQuaWQsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5nZXRTaWduZXIoYWRkcmVzcyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItYnJvd3Nlci5qcy5tYXAiLCJpbXBvcnQgeyBKc29uUnBjU2lnbmVyIH0gZnJvbSBcImV0aGVyc1wiO1xuaW1wb3J0IHsgQnJvd3NlclByb3ZpZGVyIH0gZnJvbSBcImV0aGVyc1wiO1xuXG5leHBvcnQgY29uc3QgcHJvdmlkZXIgPSBuZXcgQnJvd3NlclByb3ZpZGVyKHdpbmRvdy5ldGhlcmV1bSk7XG5cbi8vIGV4cG9ydCBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcblxubGV0IHNpZ25lcjogSnNvblJwY1NpZ25lcjtcbmxldCBzaWduZXJQcm9taXNlOiBQcm9taXNlPEpzb25ScGNTaWduZXI+O1xuXG4vLyBQcm9tcHQgdXNlciB0byBlbmFibGUgdGhlaXIgd2FsbGV0LCBpZiBub3QgYWxyZWFkeSBlbmFibGVkOlxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNpZ25lcigpIHtcbiAgaWYgKHNpZ25lcilcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNpZ25lcik7XG4gIGlmIChzaWduZXJQcm9taXNlKSB7XG4gICAgcmV0dXJuIHNpZ25lclByb21pc2U7XG4gIH1cbiAgc2lnbmVyUHJvbWlzZSA9IG5ldyBQcm9taXNlKGFzeW5jIChyZXMpID0+IHtcbiAgICBhd2FpdCB3aW5kb3cuZXRoZXJldW0uZW5hYmxlKCk7XG4gICAgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XG4gICAgcmVzKHNpZ25lcik7XG4gIH0pO1xuXG4gIHJldHVybiBzaWduZXJQcm9taXNlO1xufVxuIiwiZXhwb3J0IGludGVyZmFjZSBBY3RpdmF0aW9uRnVuY3Rpb24ge1xuICBpZDogbnVtYmVyO1xuICBjb250ZXh0OiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIG11bHRpcGxpZXI6IEJpZ0ludDtcbiAgd2VpZ2h0SW5XYXR0OiBCaWdJbnQ7XG59XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gIGFjdGl2YXRpbmc6IHN0cmluZztcbiAgYmFsYW5jZTogc3RyaW5nO1xuICBzZWxlY3RlZEZ1bmN0aW9uSWQ6IG51bWJlcjtcbiAgYWN0aXZhdGlvbkZ1bmN0aW9uczogQWN0aXZhdGlvbkZ1bmN0aW9uW107XG59XG5cblxuXG5leHBvcnQgZnVuY3Rpb24gUGFuZWwoe1xuICBhY3RpdmF0aW5nLFxuICBhY3RpdmF0aW9uRnVuY3Rpb25zLFxuICBzZWxlY3RlZEZ1bmN0aW9uSWQsXG4gIGJhbGFuY2UsXG59OiBQcm9wcykge1xuICBjb25zb2xlLmxvZyhhY3RpdmF0aW9uRnVuY3Rpb25zLCBzZWxlY3RlZEZ1bmN0aW9uSWQpO1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT17YWN0aXZhdGluZyA9PT0gXCJ1bmFjdGl2YXRlZFwiID8gXCJvcGFjaXR5LTEwMFwiIDogXCJvcGFjaXR5LTBcIn1cbiAgICAgID5cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgIHthY3RpdmF0aW9uRnVuY3Rpb25zW3NlbGVjdGVkRnVuY3Rpb25JZF0uY29udGV4dH1cbiAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICB7YWN0aXZhdGlvbkZ1bmN0aW9uc1tzZWxlY3RlZEZ1bmN0aW9uSWRdLmRlc2NyaXB0aW9ufVxuICAgICAgICAgIDxiciAvPlxuICAgICAgICAgIDxiciAvPlxuICAgICAgICAgIFJld2FyZDp7XCIgXCJ9XG4gICAgICAgICAge1N0cmluZyhcbiAgICAgICAgICAgIChhY3RpdmF0aW9uRnVuY3Rpb25zW3NlbGVjdGVkRnVuY3Rpb25JZF0ubXVsdGlwbGllciBhcyBiaWdpbnQpICpcbiAgICAgICAgICAgICAgKGFjdGl2YXRpb25GdW5jdGlvbnNbc2VsZWN0ZWRGdW5jdGlvbklkXS53ZWlnaHRJbldhdHQgYXMgYmlnaW50KSxcbiAgICAgICAgICApfXtcIiBcIn1cbiAgICAgICAgICBWZXJpZmljYXRpb24gV0FUVFxuICAgICAgICA8L3A+XG4gICAgICA8L2Rpdj5cbiAgICAgIHthY3RpdmF0aW5nID09PSBcImFjdGl2YXRpbmdcIiAmJiAoXG4gICAgICAgIDxpbWdcbiAgICAgICAgICBzcmM9XCIuL2Fzc2V0cy9sb2FkaW5nLnBuZ1wiXG4gICAgICAgICAgYWx0PVwiTG9hZGluZy4uLlwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwiYWJzb2x1dGUgdG9wLTE2IHctMjAgaC0yMFwiXG4gICAgICAgIC8+XG4gICAgICApfVxuICAgICAge2FjdGl2YXRpbmcgPT09IFwiYWN0aXZhdGVkXCIgJiYgPGRpdj5hY3RpdmF0ZWQgJHtiYWxhbmNlfSBXQVRUUzwvZGl2Pn1cbiAgICA8Lz5cbiAgKTtcbn1cbiIsImV4cG9ydCBjb25zdCBjb250cmFjdEFCSTogYW55W10gPSBbXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJfcG9DXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiLFxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiYWN0aXZhdGlvbkZ1bmN0aW9uSWRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJBY3RpdmF0aW9uRnVuY3Rpb25BcHByb3ZlZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgfSxcbiAge1xuICAgIGFub255bW91czogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcImFjdGl2YXRpb25GdW5jdGlvbklkXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiZGV2ZWxvcGVyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgbmFtZTogXCJjb250ZXh0XCIsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJBY3RpdmF0aW9uRnVuY3Rpb25SZWdpc3RlcmVkXCIsXG4gICAgdHlwZTogXCJldmVudFwiLFxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiYWRkclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBuYW1lOiBcIkRlYnVnQWRkcmVzc1wiLFxuICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcImFjdGl2YXRpb25GdW5jdGlvbklkXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwiYWN0aXZhdGVcIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBuYW1lOiBcImFjdGl2YXRpb25GdW5jdGlvbnNcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiaXNzdWVyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgbmFtZTogXCJhcHByb3ZlZFwiLFxuICAgICAgICB0eXBlOiBcImJvb2xcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJlbnVtIE5ld2NvaW5FbmNvZGVyLldhdHRUeXBlXCIsXG4gICAgICAgIG5hbWU6IFwid2F0dFR5cGVcIixcbiAgICAgICAgdHlwZTogXCJ1aW50OFwiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJtdWx0aXBsaWVyXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICAgICAgbmFtZTogXCJjb250ZXh0SWRcIixcbiAgICAgICAgdHlwZTogXCJieXRlczMyXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIG5hbWU6IFwiY29udGV4dFwiLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBuYW1lOiBcImRlc2NyaXB0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcImFkZHJzc1wiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwid2VpZ2h0SW5XYXR0XCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgbmFtZTogXCJpc0FzeW5jXCIsXG4gICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiYWN0aXZhdGlvbkZ1bmN0aW9uSWRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJhcHByb3ZlQWN0aXZhdGlvbkZ1bmN0aW9uXCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJhY3RpdmF0aW9uRnVuY3Rpb25JZFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBuYW1lOiBcImNhbk1pbnRcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcImdldEFwcHJvdmVkQWN0aXZhdGlvbkZ1bmN0aW9uc1wiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICBuYW1lOiBcImlzc3VlclwiLFxuICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgbmFtZTogXCJhcHByb3ZlZFwiLFxuICAgICAgICAgICAgdHlwZTogXCJib29sXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiZW51bSBOZXdjb2luRW5jb2Rlci5XYXR0VHlwZVwiLFxuICAgICAgICAgICAgbmFtZTogXCJ3YXR0VHlwZVwiLFxuICAgICAgICAgICAgdHlwZTogXCJ1aW50OFwiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgIG5hbWU6IFwibXVsdGlwbGllclwiLFxuICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgICAgICAgbmFtZTogXCJjb250ZXh0SWRcIixcbiAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgbmFtZTogXCJjb250ZXh0XCIsXG4gICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgbmFtZTogXCJkZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICBuYW1lOiBcImFkZHJzc1wiLFxuICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgbmFtZTogXCJ3ZWlnaHRJbldhdHRcIixcbiAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgICAgIG5hbWU6IFwiaXNBc3luY1wiLFxuICAgICAgICAgICAgdHlwZTogXCJib29sXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInN0cnVjdCBOZXdjb2luRW5jb2Rlci5BY3RpdmF0aW9uRnVuY3Rpb25bXVwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInR1cGxlW11cIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLFxuICAgICAgICBuYW1lOiBcImNvbmRpdGlvbk1ldFwiLFxuICAgICAgICB0eXBlOiBcImJvb2xcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiYWN0aXZhdGlvbkZ1bmN0aW9uSWRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJvcmFjbGVSZXNwb25zZVwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcIm93bmVyXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJwb0NcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJjb250cmFjdCBFbmVyZ3lNaW50ZXJNb2NrXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJlbnVtIE5ld2NvaW5FbmNvZGVyLldhdHRUeXBlXCIsXG4gICAgICAgIG5hbWU6IFwiX3dhdHRUeXBlXCIsXG4gICAgICAgIHR5cGU6IFwidWludDhcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX211bHRpcGxpZXJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgICBuYW1lOiBcIl9jb250ZXh0SWRcIixcbiAgICAgICAgdHlwZTogXCJieXRlczMyXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIG5hbWU6IFwiX2NvbnRleHRcIixcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgbmFtZTogXCJfZGVzY3JpcHRpb25cIixcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiX2FkZHJzc1wiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX3dlaWdodEluV2F0dFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgIG5hbWU6IFwiX2lzQXN5bmNcIixcbiAgICAgICAgdHlwZTogXCJib29sXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJyZWdpc3RlckFjdGl2YXRpb25GdW5jdGlvblwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG5dO1xuIiwiaW1wb3J0IHsgZXRoZXJzLCBCYXNlQ29udHJhY3QsIFRyYW5zYWN0aW9uUmVzcG9uc2UgfSBmcm9tIFwiZXRoZXJzXCI7XG5pbXBvcnQgeyBwcm92aWRlciB9IGZyb20gXCIuLi9ldGhlcnNQcm92aWRlclwiO1xuaW1wb3J0IHsgY29udHJhY3RBQkkgfSBmcm9tIFwiLi9hYmlcIjtcbmltcG9ydCB7IEFjdGl2YXRpb25GdW5jdGlvbiB9IGZyb20gXCIuLi8uLi9jb21wb25lbnRzL1BhbmVsXCI7XG5cbmNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IFwiMHg4NDM4N2UzYWQwNjJENjgzQkZjN2VEMkVlYWYyQzMwQjI3QmQzZDA1XCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW5jb2RlckNvbnRyYWN0IGV4dGVuZHMgQmFzZUNvbnRyYWN0IHtcbiAgYWN0aXZhdGUoaWQ6IG51bWJlcik6IFByb21pc2U8VHJhbnNhY3Rpb25SZXNwb25zZT47XG4gIGdldEFwcHJvdmVkQWN0aXZhdGlvbkZ1bmN0aW9ucygpOiBQcm9taXNlPEFjdGl2YXRpb25GdW5jdGlvbltdPjtcbn1cblxuZXhwb3J0IGNvbnN0IGVuY29kZXJDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoXG4gIGNvbnRyYWN0QWRkcmVzcyxcbiAgY29udHJhY3RBQkksXG4gIHByb3ZpZGVyLFxuKTtcblxuZXhwb3J0IGNvbnN0IGVuY29kZXJDb250cmFjdEZhY3RvcnkgPSAoYWRkcmVzczogc3RyaW5nKSA9PiBuZXcgZXRoZXJzLkNvbnRyYWN0KFxuICBhZGRyZXNzIHx8IGNvbnRyYWN0QWRkcmVzcyxcbiAgY29udHJhY3RBQkksXG4gIHByb3ZpZGVyLFxuKTtcblxuLy8gZW5jb2RlckNvbnRyYWN0LmNvbm5lY3Qoc2lnbmVyKTtcbiIsImV4cG9ydCBjb25zdCBjb250cmFjdEFCSTogYW55W10gPSBbXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiLFxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICAgICAgbmFtZTogXCJpZFwiLFxuICAgICAgICB0eXBlOiBcImJ5dGVzMzJcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBuYW1lOiBcIkNoYWlubGlua0NhbmNlbGxlZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgfSxcbiAge1xuICAgIGFub255bW91czogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJieXRlczMyXCIsXG4gICAgICAgIG5hbWU6IFwiaWRcIixcbiAgICAgICAgdHlwZTogXCJieXRlczMyXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJDaGFpbmxpbmtGdWxmaWxsZWRcIixcbiAgICB0eXBlOiBcImV2ZW50XCIsXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgICBuYW1lOiBcImlkXCIsXG4gICAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwiQ2hhaW5saW5rUmVxdWVzdGVkXCIsXG4gICAgdHlwZTogXCJldmVudFwiLFxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJmcm9tXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJ0b1wiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBuYW1lOiBcIk93bmVyc2hpcFRyYW5zZmVyUmVxdWVzdGVkXCIsXG4gICAgdHlwZTogXCJldmVudFwiLFxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJmcm9tXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJ0b1wiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBuYW1lOiBcIk93bmVyc2hpcFRyYW5zZmVycmVkXCIsXG4gICAgdHlwZTogXCJldmVudFwiLFxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJyZXF1ZXN0ZXJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJSZXF1ZXN0RnVsZmlsbGVkXCIsXG4gICAgdHlwZTogXCJldmVudFwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcImFjY2VwdE93bmVyc2hpcFwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX2FjdGl2YXRpb25GdW5jdGlvbklkXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwiYWN0aXZhdGVcIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgICBuYW1lOiBcInJlcXVlc3RJZFwiLFxuICAgICAgICB0eXBlOiBcImJ5dGVzMzJcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgIG5hbWU6IFwiZGF0YVwiLFxuICAgICAgICB0eXBlOiBcImJvb2xcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBuYW1lOiBcImZ1bGZpbGxcIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJnZXRGZWVJbkh1bmRyZWR0aHNPZkxpbmtcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcImdldEpvYklkXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwiZ2V0T3JhY2xlQWRkcmVzc1wiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwib3duZXJcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwicGFzc3BvcnRIb2xkZXJzXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImJvb2xcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJyZXF1ZXN0XCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJieXRlczMyXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJyZXF1ZXN0ZXJzXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJyZXNwb25zZVwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJib29sXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJfZmVlSW5IdW5kcmVkdGhzT2ZMaW5rXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwic2V0RmVlSW5IdW5kcmVkdGhzT2ZMaW5rXCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJfZmVlSW5KdWVsc1wiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBuYW1lOiBcInNldEZlZUluSnVlbHNcIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIG5hbWU6IFwiX2pvYklkXCIsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJzZXRKb2JJZFwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiX29yYWNsZUFkZHJlc3NcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJzZXRPcmFjbGVBZGRyZXNzXCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJ0b1wiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBuYW1lOiBcInRyYW5zZmVyT3duZXJzaGlwXCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwid2l0aGRyYXdMaW5rXCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG5dO1xuIiwiaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSBcImV0aGVyc1wiO1xuaW1wb3J0IHsgcHJvdmlkZXIgfSBmcm9tIFwiLi4vZXRoZXJzUHJvdmlkZXJcIjtcbmltcG9ydCB7IGNvbnRyYWN0QUJJIH0gZnJvbSBcIi4vYWJpXCI7XG5pbXBvcnQgeyBCYXNlQ29udHJhY3QgfSBmcm9tIFwiZXRoZXJzXCI7XG5cbmNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IFwiMHhmMTkyRWU1YTlmQjlBRTNBOGRlZTc5NjY5Q0ZkMkJBOEM4NDQxZDljXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3VpbGRHaXRjb2luUGFzc3BvcnRDb250cmFjdCBleHRlbmRzIEJhc2VDb250cmFjdCB7XG4gIHJlcXVlc3QoKTogUHJvbWlzZTx2b2lkPjtcbn1cblxuZXhwb3J0IGNvbnN0IGd1aWxkQUZDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoXG4gIGNvbnRyYWN0QWRkcmVzcyxcbiAgY29udHJhY3RBQkksXG4gIHByb3ZpZGVyLFxuKTtcblxuXG5leHBvcnQgY29uc3QgZ3VpbGRBRkNvbnRyYWN0RmFjdG9yeSA9IChhZGRyZXNzOiBzdHJpbmcpID0+IG5ldyBldGhlcnMuQ29udHJhY3QoXG4gIGFkZHJlc3MgfHwgY29udHJhY3RBZGRyZXNzLFxuICBjb250cmFjdEFCSSxcbiAgcHJvdmlkZXIsXG4pO1xuXG4vLyBnZXRTaWduZXIoKS50aGVuKChzaWduZXIpID0+IGd1aWxkQUZDb250cmFjdC5jb25uZWN0KHNpZ25lcikpO1xuXG5cbiIsImV4cG9ydCBjb25zdCBjb250cmFjdEFCSTogYW55W10gPSBbXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJhY2NvdW50XCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQ4XCIsXG4gICAgICAgIG5hbWU6IFwiaWRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50OFwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwiYmFsYW5jZU9mRW5lcmd5XCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcImFjY291bnRcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJiYWxhbmNlT2ZXYXR0c1wiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJhY2NvdW50XCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQ4XCIsXG4gICAgICAgIG5hbWU6IFwiaWRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50OFwiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJhbW91bnRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJtaW50XCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDhcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50OFwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwibmV1cmFsVG9rZW5CYWxhbmNlc1wiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJ3YXR0QmFsYW5jZXNcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuXTtcbiIsImltcG9ydCB7IGV0aGVycywgQmFzZUNvbnRyYWN0LCBCaWdOdW1iZXJpc2ggfSBmcm9tIFwiZXRoZXJzXCI7XG5pbXBvcnQgeyBwcm92aWRlciB9IGZyb20gXCIuLi9ldGhlcnNQcm92aWRlclwiO1xuaW1wb3J0IHsgY29udHJhY3RBQkkgfSBmcm9tIFwiLi9hYmlcIjtcblxuY29uc3QgY29udHJhY3RBZGRyZXNzID0gXCIweGYyNzJGZTYyZUVkQ0JDZjcyMjFEODQ1MWE2OGE4NWMzQUY0ZkFjRmVcIjtcblxuZXhwb3J0IGludGVyZmFjZSBXYXR0c0NvbnRyYWN0IGV4dGVuZHMgQmFzZUNvbnRyYWN0IHtcbiAgcmVxdWVzdCgpOiBQcm9taXNlPHZvaWQ+O1xuICBiYWxhbmNlT2ZXYXR0cyhhZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPEJpZ051bWJlcmlzaD47XG59XG5cbmV4cG9ydCBjb25zdCB3YXR0c0NvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChcbiAgY29udHJhY3RBZGRyZXNzLFxuICBjb250cmFjdEFCSSxcbiAgcHJvdmlkZXIsXG4pO1xuXG5cbmV4cG9ydCBjb25zdCB3YXR0c0NvbnRyYWN0RmFjdG9yeSA9IChhZGRyZXNzOiBzdHJpbmcpID0+IG5ldyBldGhlcnMuQ29udHJhY3QoXG4gIGFkZHJlc3MgfHwgY29udHJhY3RBZGRyZXNzLFxuICBjb250cmFjdEFCSSxcbiAgcHJvdmlkZXIsXG4pO1xuXG4vLyBnZXRTaWduZXIoKS50aGVuKChzaWduZXIpID0+IHdhdHRzQ29udHJhY3QuY29ubmVjdChzaWduZXIpKTtcblxuIiwiLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYXdtbGVlci91c2UtYXN5bmMtbWVtby9ibG9iL21hc3Rlci9zcmMvaW5kZXgudHNcblxuaW1wb3J0IHtEZXBlbmRlbmN5TGlzdCwgdXNlRWZmZWN0LCB1c2VTdGF0ZX0gZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBc3luY01lbW88VD4oZmFjdG9yeTogKCkgPT4gUHJvbWlzZTxUPiB8IHVuZGVmaW5lZCB8IG51bGwsIGRlcHM6IERlcGVuZGVuY3lMaXN0KTogVCB8IHVuZGVmaW5lZFxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFzeW5jTWVtbzxUPihmYWN0b3J5OiAoKSA9PiBQcm9taXNlPFQ+IHwgdW5kZWZpbmVkIHwgbnVsbCwgZGVwczogRGVwZW5kZW5jeUxpc3QsIGluaXRpYWw6IFQpOiBUXG5leHBvcnQgZnVuY3Rpb24gdXNlQXN5bmNNZW1vPFQ+KGZhY3Rvcnk6ICgpID0+IFByb21pc2U8VD4gfCB1bmRlZmluZWQgfCBudWxsLCBkZXBzOiBEZXBlbmRlbmN5TGlzdCwgaW5pdGlhbD86IFQpIHtcbiAgY29uc3QgW3ZhbCwgc2V0VmFsXSA9IHVzZVN0YXRlPFQgfCB1bmRlZmluZWQ+KGluaXRpYWwpXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGNhbmNlbCA9IGZhbHNlXG4gICAgY29uc3QgcHJvbWlzZSA9IGZhY3RvcnkoKVxuICAgIGlmIChwcm9taXNlID09PSB1bmRlZmluZWQgfHwgcHJvbWlzZSA9PT0gbnVsbCkgcmV0dXJuXG4gICAgcHJvbWlzZS50aGVuKCh2YWwpID0+IHtcbiAgICAgIGlmICghY2FuY2VsKSB7XG4gICAgICAgIHNldFZhbCh2YWwpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FuY2VsID0gdHJ1ZVxuICAgIH1cbiAgfSwgZGVwcylcbiAgcmV0dXJuIHZhbFxufSIsIlxuaW1wb3J0IHsgQ29tcGF0aWJsZUNvbnRyYWN0LCBDb250cmFjdFR5cGUsIGNvbnRyYWN0VHlwZXMgfSBmcm9tIFwiLi4vY29udHJhY3RzXCI7XG5pbXBvcnQgeyBFbmNvZGVyQ29udHJhY3QsIGVuY29kZXJDb250cmFjdCB9IGZyb20gXCIuLi9jb250cmFjdHMvRW5jb2RlckNvbnRyYWN0L2NvbnRyYWN0XCI7XG5pbXBvcnQgeyBnZXRTaWduZXIgfSBmcm9tIFwiLi4vY29udHJhY3RzL2V0aGVyc1Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBHdWlsZEdpdGNvaW5QYXNzcG9ydENvbnRyYWN0LCBndWlsZEFGQ29udHJhY3QgfSBmcm9tIFwiLi4vY29udHJhY3RzL2d1aWxkQUZDb250cmFjdC9jb250cmFjdFwiO1xuaW1wb3J0IHsgV2F0dHNDb250cmFjdCwgd2F0dHNDb250cmFjdCB9IGZyb20gXCIuLi9jb250cmFjdHMvd2F0dHNDb250cmFjdC9jb250cmFjdFwiO1xuaW1wb3J0IHsgdXNlQXN5bmNNZW1vIH0gZnJvbSBcIi4uL3V0aWxzL3VzZUFzeW5jTWVtb1wiO1xuaW1wb3J0IHsgUHJvcHNXaXRoQ2hpbGRyZW4gfSBmcm9tIFwicmVhY3RcIjtcblxuXG50eXBlIEJ1dHRvblByb3BzID0gUmVhY3QuRGV0YWlsZWRIVE1MUHJvcHM8UmVhY3QuQnV0dG9uSFRNTEF0dHJpYnV0ZXM8SFRNTEJ1dHRvbkVsZW1lbnQ+LCBIVE1MQnV0dG9uRWxlbWVudD5cblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgYWN0aXZhdGluZzogc3RyaW5nO1xuICBzZXRBY3RpdmF0aW5nOiAoYWN0aXZhdGluZzogc3RyaW5nKSA9PiB2b2lkO1xuICAvLyBiYWxhbmNlOiBzdHJpbmc7XG4gIHNldEJhbGFuY2U6IChiYWxhbmNlOiBzdHJpbmcpID0+IHZvaWQ7XG4gIHNlbGVjdGVkRnVuY3Rpb25JZD86IG51bWJlcjtcbiAgcmVuZGVyPzogKHByb3BzOiBCdXR0b25Qcm9wcykgPT4gSlNYLkVsZW1lbnRcbiAgY29udHJhY3RUeXBlPzogQ29udHJhY3RUeXBlXG4gIGNvbnRyYWN0QWRkcmVzcz86IHN0cmluZ1xufVxuXG50eXBlIEFjdGl2YXRlUGFyYW1zID0geyBcbiAgc2VsZWN0ZWRGdW5jdGlvbklkOiBudW1iZXIsIFxuICBjb250cmFjdFR5cGU6IENvbnRyYWN0VHlwZSwgXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLCBcbiAgcGFyYW1zOiBhbnlbXSBcbn07XG5cbmV4cG9ydCBjb25zdCB1c2VCdXR0b24gPSAoe1xuICBzZXRBY3RpdmF0aW5nLFxuICBzZXRCYWxhbmNlLFxuICBzZWxlY3RlZEZ1bmN0aW9uSWQ6IF9zZWxlY3RlZEZ1bmN0aW9uSWQsXG4gIGNvbnRyYWN0VHlwZTogX2NvbnRyYWN0VHlwZSxcbiAgY29udHJhY3RBZGRyZXNzOiBfY29udHJhY3RBZGRyZXNzXG59OiBQcm9wcykgPT4ge1xuICBjb25zdCBhY3RpdmF0ZSA9IGFzeW5jIChhcmdzPzogQWN0aXZhdGVQYXJhbXMpID0+IHtcbiAgY29uc3Qgc2lnbmVyID0gYXdhaXQgZ2V0U2lnbmVyKCk7XG5cbiAgICBsZXQge1xuICAgICAgc2VsZWN0ZWRGdW5jdGlvbklkLCBcbiAgICAgIGNvbnRyYWN0VHlwZSwgXG4gICAgICBjb250cmFjdEFkZHJlc3MsIFxuICAgICAgLy8gcGFyYW1zIFxuICAgIH0gPSBhcmdzIHx8IHt9O1xuXG4gICAgY29udHJhY3RUeXBlID0gY29udHJhY3RUeXBlIHx8IF9jb250cmFjdFR5cGUgfHwgXCJndWlsZEFGQ29udHJhY3RcIjtcbiAgICBjb250cmFjdEFkZHJlc3MgPSBjb250cmFjdEFkZHJlc3MgfHwgX2NvbnRyYWN0QWRkcmVzcyB8fCBcIlwiO1xuICAgIGNvbnN0IHNmaWQgPSB0eXBlb2Ygc2VsZWN0ZWRGdW5jdGlvbklkICE9IFwidW5kZWZpbmVkXCIgPyBzZWxlY3RlZEZ1bmN0aW9uSWQgOiBfc2VsZWN0ZWRGdW5jdGlvbklkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGd1aWxkQ29udHJhY3RXaXRoU2lnbmVyID0gZ3VpbGRBRkNvbnRyYWN0LmNvbm5lY3QoXG4gICAgICAgIHNpZ25lciEsXG4gICAgICApIGFzIEd1aWxkR2l0Y29pblBhc3Nwb3J0Q29udHJhY3Q7XG5cbiAgICAgIGF3YWl0IGd1aWxkQ29udHJhY3RXaXRoU2lnbmVyLnJlcXVlc3QoKTtcblxuICAgICAgLy8gV2FpdGluZyBmb3IgMyBzZWNvbmRzIGFmdGVyIHRoZSByZXF1ZXN0IGJlZm9yZSBjYWxsaW5nIGFjdGl2YXRlXG4gICAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlbmNvZGVyQ29udHJhY3RXaXRoU2lnbmVyID0gZW5jb2RlckNvbnRyYWN0LmNvbm5lY3QoXG4gICAgICAgICAgICBzaWduZXIhLFxuICAgICAgICAgICkgYXMgRW5jb2RlckNvbnRyYWN0O1xuXG4gICAgICAgICAgLy8gQWN0aXZhdGluZyB3aXRoIHBhcmFtZXRlciAwXG4gICAgICAgICAgY29uc3QgdHggPVxuICAgICAgICAgICAgYXdhaXQgZW5jb2RlckNvbnRyYWN0V2l0aFNpZ25lci5hY3RpdmF0ZShzZmlkISk7XG5cbiAgICAgICAgICAvLyBXYWl0aW5nIGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgbWluZWRcbiAgICAgICAgICBhd2FpdCB0eC53YWl0KCk7XG5cbiAgICAgICAgICAvLyBDaGVjayB0aGUgYmFsYW5jZU9mV2F0dHNcbiAgICAgICAgICBjaGVja0JhbGFuY2UoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZHVyaW5nIGFjdGl2YXRpb246IFwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSwgNjAwMDApOyAvLyA2MDAwMG1zID0gNjBzXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coXCJFcnJvciBkdXJpbmcgcmVxdWVzdDogXCIsIGUpO1xuICAgIH1cbiAgICBzZXRBY3RpdmF0aW5nKFwiYWN0aXZhdGluZ1wiKTtcblxuICAgIC8vIGNvbnRyYWN0VHlwZSA9IGNvbnRyYWN0VHlwZSB8fCBfY29udHJhY3RUeXBlIHx8IFwiZ3VpbGRBRkNvbnRyYWN0XCI7XG4gICAgLy8gY29udHJhY3RBZGRyZXNzID0gY29udHJhY3RBZGRyZXNzIHx8IF9jb250cmFjdEFkZHJlc3MgfHwgXCJcIjtcbiAgICAvLyBjb25zdCBzZmlkID0gc2VsZWN0ZWRGdW5jdGlvbklkIHx8IF9zZWxlY3RlZEZ1bmN0aW9uSWQ7XG4gICAgLy8gaWYoc2ZpZCA9PSB1bmRlZmluZWQpXG4gICAgLy8gICByZXR1cm4gY29uc29sZS53YXJuKFwiTm8gZnVuY3Rpb24gaWQgcHJvdmlkZWRcIik7XG5cbiAgICAvLyBjb25zdCB7IGZhY3RvcnksIGFjdGl2YXRpb25NZXRob2QgfSA9IGNvbnRyYWN0VHlwZXNbY29udHJhY3RUeXBlXTtcbiAgICAvLyBjb25zdCBjb250cmFjdCA9IGZhY3RvcnkoY29udHJhY3RBZGRyZXNzKVxuXG4gICAgLy8gdHJ5IHtcbiAgICAvLyAgIGNvbnN0IGNvbnRyYWN0V2l0aFNpZ25lciA9IGNvbnRyYWN0LmNvbm5lY3QoXG4gICAgLy8gICAgIHNpZ25lciEsXG4gICAgLy8gICApIGFzIENvbXBhdGlibGVDb250cmFjdDtcblxuICAgIC8vICAgLy8gY29uc3QgY29udHJhY3RXaXRoU2lnbmVyID0gY29udHJhY3RXaXRoU2lnbmVyLmNvbm5lY3QoXG4gICAgLy8gICAvLyAgIHNpZ25lciEsXG4gICAgLy8gICAvLyApIGFzIENvbXBhdGlibGVDb250cmFjdDtcblxuICAgIC8vICAgLy9AdHMtaWdub3JlXG4gICAgLy8gICBhd2FpdCBjb250cmFjdFdpdGhTaWduZXIucmVxdWVzdCgpOyBcblxuICAgIC8vICAgLy8gV2FpdGluZyBmb3IgMyBzZWNvbmRzIGFmdGVyIHRoZSByZXF1ZXN0IGJlZm9yZSBjYWxsaW5nIGFjdGl2YXRlXG4gICAgLy8gICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAvLyAgICAgdHJ5IHtcblxuICAgIC8vICAgICAgIC8vIEFjdGl2YXRpbmcgd2l0aCBwYXJhbWV0ZXIgMFxuICAgIC8vICAgICAgIGNvbnN0IHR4ID1cbiAgICAvLyAgICAgICAgIGF3YWl0IGNvbnRyYWN0V2l0aFNpZ25lclthY3RpdmF0aW9uTWV0aG9kXShzZWxlY3RlZEZ1bmN0aW9uSWQpO1xuXG4gICAgLy8gICAgICAgLy8gV2FpdGluZyBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIG1pbmVkXG4gICAgLy8gICAgICAgYXdhaXQgdHgud2FpdCgpO1xuXG4gICAgLy8gICAgICAgLy8gQ2hlY2sgdGhlIGJhbGFuY2VPZldhdHRzXG4gICAgLy8gICAgICAgY2hlY2tCYWxhbmNlKCk7XG4gICAgLy8gICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGR1cmluZyBhY3RpdmF0aW9uOiBcIiwgZSk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH0sIDYwMDAwKTsgLy8gNjAwMDBtcyA9IDYwc1xuICAgIC8vIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZHVyaW5nIHJlcXVlc3Q6IFwiLCBlKTtcbiAgICAvLyB9XG4gICAgLy8gc2V0QWN0aXZhdGluZyhcImFjdGl2YXRpbmdcIik7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gdG8gY2hlY2sgdGhlIGJhbGFuY2Ugb2YgV2F0dHNcbiAgY29uc3QgY2hlY2tCYWxhbmNlID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHNpZ25lciA9IHVzZUFzeW5jTWVtbyhnZXRTaWduZXIsIFtdKTtcblxuICAgIGNvbnN0IHdhdHRzQ29udHJhY3RXaXRoU2lnbmVyID0gd2F0dHNDb250cmFjdC5jb25uZWN0KFxuICAgICAgc2lnbmVyISxcbiAgICApIGFzIFdhdHRzQ29udHJhY3Q7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCBzaWduZXIhLmdldEFkZHJlc3MoKTtcbiAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCB3YXR0c0NvbnRyYWN0V2l0aFNpZ25lci5iYWxhbmNlT2ZXYXR0cyhhZGRyZXNzKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiQmFsYW5jZSBvZiBXYXR0czogXCIsIGJhbGFuY2UudG9TdHJpbmcoKSk7XG4gICAgICBzZXRCYWxhbmNlKGJhbGFuY2UudG9TdHJpbmcoKSk7XG4gICAgICBzZXRBY3RpdmF0aW5nKFwiYWN0aXZhdGVkXCIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZmV0Y2hpbmcgYmFsYW5jZTogXCIsIGUpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGFjdGl2YXRlXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQnV0dG9uKHtcbiAgYWN0aXZhdGluZyxcbiAgc2V0QWN0aXZhdGluZyxcbiAgc2V0QmFsYW5jZSxcbiAgc2VsZWN0ZWRGdW5jdGlvbklkLFxuICByZW5kZXIsXG59OiBQcm9wcykge1xuICBjb25zdCBzaWduZXIgPSB1c2VBc3luY01lbW8oZ2V0U2lnbmVyLCBbXSk7XG5cbiAgY29uc3QgeyBhY3RpdmF0ZSB9ID0gdXNlQnV0dG9uKHtcbiAgICBhY3RpdmF0aW5nLFxuICAgIHNldEFjdGl2YXRpbmcsXG4gICAgc2V0QmFsYW5jZSxcbiAgICBzZWxlY3RlZEZ1bmN0aW9uSWQsXG4gIH0pO1xuXG4gIGNvbnN0IEJ1dHRvbkNvbXAgPSByZW5kZXIgfHwgKChwcm9wczogQnV0dG9uUHJvcHMpID0+IDxidXR0b24gey4uLnByb3BzfSAvPik7XG5cbiAgaWYgKCFzaWduZXIpXG4gICAgcmV0dXJuIDw+V2FpdC4uLjwvPjtcblxuICByZXR1cm4gKFxuICAgIDxCdXR0b25Db21wXG4gICAgICBvbkNsaWNrPXsoKSA9PiBhY3RpdmF0ZSgpfVxuICAgICAgY2xhc3NOYW1lPXtgcHktMiBweC00IHRleHQtd2hpdGUgcm91bmRlZC1mdWxsIHctNDAgJHthY3RpdmF0aW5nID09PSBcImFjdGl2YXRpbmdcIiA/IFwiYmctZ3JheS00MDBcIiA6IFwiYmctYmxhY2tcIlxuICAgICAgICB9YH1cbiAgICAgIGRpc2FibGVkPXthY3RpdmF0aW5nID09PSBcImFjdGl2YXRpbmdcIn1cbiAgICA+XG4gICAgICB7YWN0aXZhdGluZyA9PT0gXCJhY3RpdmF0aW5nXCIgPyBcIkFjdGl2YXRpbmdcIiA6IFwiQWN0aXZhdGVcIn1cbiAgICA8L0J1dHRvbkNvbXA+XG4gICk7XG59XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBBY3RpdmF0aW9uRnVuY3Rpb24gfSBmcm9tIFwiLi9QYW5lbFwiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICBhY3RpdmF0aW9uRnVuY3Rpb25zOiBBY3RpdmF0aW9uRnVuY3Rpb25bXTtcbiAgc2VsZWN0ZWRGdW5jdGlvbklkOiBudW1iZXI7XG4gIHNldFNlbGVjdGVkRnVuY3Rpb25JZDogKGlkOiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmZ1bmN0aW9uIERyb3Bkb3duKHtcbiAgYWN0aXZhdGlvbkZ1bmN0aW9ucyxcbiAgc2V0U2VsZWN0ZWRGdW5jdGlvbklkLFxuICBzZWxlY3RlZEZ1bmN0aW9uSWQsXG59OiBQcm9wcykge1xuICAvLyBIYW5kbGUgZHJvcGRvd24gY2hhbmdlXG4gIGNvbnN0IGhhbmRsZUNoYW5nZSA9IChldmVudDogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTFNlbGVjdEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgdmFsdWVBc051bWJlciA9IE51bWJlcihldmVudC50YXJnZXQudmFsdWUpO1xuICAgIHNldFNlbGVjdGVkRnVuY3Rpb25JZCh2YWx1ZUFzTnVtYmVyKTtcbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKHNlbGVjdGVkRnVuY3Rpb25JZCk7XG4gIH0sIFtzZWxlY3RlZEZ1bmN0aW9uSWRdKTtcblxuICByZXR1cm4gKFxuICAgIDxzZWxlY3RcbiAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9XG4gICAgICB2YWx1ZT17c2VsZWN0ZWRGdW5jdGlvbklkfVxuICAgICAgY2xhc3NOYW1lPXtgcHktMiBweC00IHRleHQteHMgdGV4dC1ibGFjayByb3VuZGVkLWZ1bGwgdy00MCBib3JkZXIgYm9yZGVyLWJsYWNrICR7IXNlbGVjdGVkRnVuY3Rpb25JZCA/IFwiYmctd2hpdGVcIiA6IFwiYmctZ3JheS0yMDBcIlxuICAgICAgICB9YH1cbiAgICA+XG4gICAgICA8b3B0aW9uIHZhbHVlPVwiXCIgZGlzYWJsZWQ+XG4gICAgICAgIFNlbGVjdCBhbiBhY3RpdmF0aW9uIGZ1bmN0aW9uXG4gICAgICA8L29wdGlvbj5cbiAgICAgIHthY3RpdmF0aW9uRnVuY3Rpb25zLm1hcCgoZnVuYywgaW5kZXgpID0+IChcbiAgICAgICAgPG9wdGlvbiBrZXk9e2Z1bmMuaWR9IHZhbHVlPXtpbmRleH0+XG4gICAgICAgICAge2Z1bmMuY29udGV4dH0ge2Z1bmMuaWR9XG4gICAgICAgIDwvb3B0aW9uPlxuICAgICAgKSl9XG4gICAgPC9zZWxlY3Q+XG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IERyb3Bkb3duO1xuIiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZ2V0U2lnbmVyIH0gZnJvbSBcIi4vY29udHJhY3RzL2V0aGVyc1Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBBY3RpdmF0aW9uRnVuY3Rpb24sIFBhbmVsIH0gZnJvbSBcIi4vY29tcG9uZW50cy9QYW5lbFwiO1xuaW1wb3J0IEJ1dHRvbiwgeyB1c2VCdXR0b24gfSBmcm9tIFwiLi9jb21wb25lbnRzL0J1dHRvbi50c3hcIjtcbmltcG9ydCBEcm9wZG93biBmcm9tIFwiLi9jb21wb25lbnRzL0Ryb3Bkb3duXCI7XG5pbXBvcnQge1xuICBFbmNvZGVyQ29udHJhY3QsXG4gIGVuY29kZXJDb250cmFjdCxcbn0gZnJvbSBcIi4vY29udHJhY3RzL0VuY29kZXJDb250cmFjdC9jb250cmFjdFwiO1xuaW1wb3J0IHsgdXNlQXN5bmNNZW1vIH0gZnJvbSBcIi4vdXRpbHMvdXNlQXN5bmNNZW1vXCI7XG5cbmV4cG9ydCB7IHVzZUJ1dHRvbiB9O1xuXG5leHBvcnQgY29uc3QgdXNlQWN0aXZhdGlvbkZ1bmN0aW9ucyA9IChjb250cmFjdEFkZHJlc3M/OiBzdHJpbmcsIGF1dG9jb25uZWN0PzogYm9vbGVhbikgPT4ge1xuICBjb25zdCBbYWN0aXZhdGluZywgc2V0QWN0aXZhdGluZ10gPSB1c2VTdGF0ZShcInVuYWN0aXZhdGVkXCIpO1xuICBjb25zdCBbYmFsYW5jZSwgc2V0QmFsYW5jZV0gPSB1c2VTdGF0ZShcIjBcIik7XG4gIGNvbnN0IFtzZWxlY3RlZEZ1bmN0aW9uSWQsIHNldFNlbGVjdGVkRnVuY3Rpb25JZF0gPSB1c2VTdGF0ZSgwKTtcblxuICAvLyBjb25zdCBbYWN0aXZhdGlvbkZ1bmN0aW9ucywgc2V0QWN0aXZhdGlvbkZ1bmN0aW9uc10gPSB1c2VTdGF0ZTxcbiAgLy8gICBBY3RpdmF0aW9uRnVuY3Rpb25bXVxuICAvLyA+KFtdKTtcbiAgY29uc3QgW2RvQ29ubmVjdCwgc2V0RG9Db25uZWN0XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzQ29ubmVjdGluZywgc2V0SXNDb25uZWN0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzQ29ubmVjdGVkLCBzZXRJc0Nvbm5lY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cblxuICBjb25zdCBjb25uZWN0ID0gKCkgPT4gc2V0RG9Db25uZWN0KHRydWUpO1xuXG4gIGNvbnN0IHNpZ25lciA9IHVzZUFzeW5jTWVtbyhhc3luYyAoKSA9PiB7XG4gICAgaWYoIShkb0Nvbm5lY3QgfHwgYXV0b2Nvbm5lY3QpKVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgc2V0SXNDb25uZWN0aW5nKHRydWUpO1xuICAgIGNvbnN0IHNpID0gYXdhaXQgZ2V0U2lnbmVyKCk7XG4gICAgc2V0SXNDb25uZWN0aW5nKGZhbHNlKTtcbiAgICBzZXRJc0Nvbm5lY3RlZCghIXNpKVxuICAgIFxuICAgIHJldHVybiBzaTtcbiAgfSwgW2RvQ29ubmVjdCwgYXV0b2Nvbm5lY3RdKTtcblxuICBjb25zdCBfYWN0aXZhdGlvbkZ1bmN0aW9ucyA9IHVzZUFzeW5jTWVtbyhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFzaWduZXIpXG4gICAgICByZXR1cm47XG5cbiAgICBjb25zdCBlbmNvZGVyQ29udHJhY3RXaXRoU2lnbmVyID0gZW5jb2RlckNvbnRyYWN0LmNvbm5lY3QoXG4gICAgICBzaWduZXIsXG4gICAgKSBhcyBFbmNvZGVyQ29udHJhY3Q7XG4gICAgY29uc3QgcHJveHlPYmplY3QgPVxuICAgICAgYXdhaXQgZW5jb2RlckNvbnRyYWN0V2l0aFNpZ25lci5nZXRBcHByb3ZlZEFjdGl2YXRpb25GdW5jdGlvbnMoKTtcbiAgICBjb25zb2xlLmxvZyhwcm94eU9iamVjdCk7XG4gICAgcmV0dXJuIHByb3h5T2JqZWN0IGFzIEFjdGl2YXRpb25GdW5jdGlvbltdO1xuICAgIC8vIHNldEFjdGl2YXRpb25GdW5jdGlvbnMocHJveHlPYmplY3QgYXMgQWN0aXZhdGlvbkZ1bmN0aW9uW10pO1xuICB9LCBbc2lnbmVyLCBjb250cmFjdEFkZHJlc3NdLCBbXSBhcyBBY3RpdmF0aW9uRnVuY3Rpb25bXSk7XG5cbiAgY29uc3QgYWN0aXZhdGlvbkZ1bmN0aW9ucyA9IF9hY3RpdmF0aW9uRnVuY3Rpb25zIHx8IFtdO1xuXG4gIGNvbnN0IGRyb3BEb3duID0gPERyb3Bkb3duXG4gICAgc2VsZWN0ZWRGdW5jdGlvbklkPXtzZWxlY3RlZEZ1bmN0aW9uSWR9XG4gICAgc2V0U2VsZWN0ZWRGdW5jdGlvbklkPXtzZXRTZWxlY3RlZEZ1bmN0aW9uSWR9XG4gICAgYWN0aXZhdGlvbkZ1bmN0aW9ucz17YWN0aXZhdGlvbkZ1bmN0aW9uc31cbiAgLz5cblxuICBjb25zdCBwYW5lbCA9IDxQYW5lbFxuICAgIGFjdGl2YXRpbmc9e2FjdGl2YXRpbmd9XG4gICAgYWN0aXZhdGlvbkZ1bmN0aW9ucz17YWN0aXZhdGlvbkZ1bmN0aW9uc31cbiAgICBzZWxlY3RlZEZ1bmN0aW9uSWQ9e3NlbGVjdGVkRnVuY3Rpb25JZH1cbiAgICBiYWxhbmNlPXtiYWxhbmNlfVxuICAvPlxuXG4gIGNvbnN0IGJ1dHRvblBhcmFtcyA9IHtcbiAgICBhY3RpdmF0aW5nLFxuICAgIHNldEFjdGl2YXRpbmcsXG4gICAgYmFsYW5jZSxcbiAgICBzZXRCYWxhbmNlLFxuICAgIHNlbGVjdGVkRnVuY3Rpb25JZFxuICB9O1xuXG4gIGNvbnN0IGJ1dHRvbiA9IDxCdXR0b25cbiAgICB7Li4uYnV0dG9uUGFyYW1zfVxuICAvLyBhY3RpdmF0aW5nPXthY3RpdmF0aW5nfVxuICAvLyBzZXRBY3RpdmF0aW5nPXtzZXRBY3RpdmF0aW5nfVxuICAvLyBiYWxhbmNlPXtiYWxhbmNlfVxuICAvLyBzZXRCYWxhbmNlPXtzZXRCYWxhbmNlfVxuICAvLyBzZWxlY3RlZEZ1bmN0aW9uSWQ9e3NlbGVjdGVkRnVuY3Rpb25JZH1cbiAgLz5cblxuICBjb25zdCB7IGFjdGl2YXRlIH0gPSB1c2VCdXR0b24oYnV0dG9uUGFyYW1zKTtcblxuICByZXR1cm4ge1xuICAgIGFjdGl2YXRlLFxuICAgIGFjdGl2YXRpb25GdW5jdGlvbnMsXG4gICAgc2V0QWN0aXZhdGluZyxcbiAgICBhY3RpdmF0aW5nLFxuICAgIHNlbGVjdGVkRnVuY3Rpb25JZCxcbiAgICBzZXRTZWxlY3RlZEZ1bmN0aW9uSWQsXG4gICAgYmFsYW5jZSxcbiAgICBzZXRCYWxhbmNlLFxuXG4gICAgYnV0dG9uLFxuICAgIHBhbmVsLFxuICAgIGRyb3BEb3duLFxuXG4gICAgY29ubmVjdCxcbiAgICBpc0Nvbm5lY3RpbmcsXG4gICAgaXNDb25uZWN0ZWQsXG4gICAgc2lnbmVyXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFwcCgpIHtcbiAgY29uc3Qge1xuICAgIGFjdGl2YXRpb25GdW5jdGlvbnMsXG4gICAgc2V0QWN0aXZhdGluZyxcbiAgICBhY3RpdmF0aW5nLFxuICAgIHNlbGVjdGVkRnVuY3Rpb25JZCxcbiAgICBzZXRTZWxlY3RlZEZ1bmN0aW9uSWQsXG4gICAgYmFsYW5jZSxcbiAgICBzZXRCYWxhbmNlLFxuICAgIGNvbm5lY3QsXG4gICAgYnV0dG9uLFxuICAgIHBhbmVsLFxuICAgIGRyb3BEb3duLFxuICAgIGlzQ29ubmVjdGVkXG4gIH0gPSB1c2VBY3RpdmF0aW9uRnVuY3Rpb25zKFwiMHg4NDM4N2UzYWQwNjJENjgzQkZjN2VEMkVlYWYyQzMwQjI3QmQzZDA1XCIpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJtaW4taC1zY3JlZW4gZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXJcIj5cblxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSBmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gcGwtMiBwci0yIHB0LTggcGItOCBib3JkZXIgYm9yZGVyLWJsYWNrIHctNjQgaC05NlwiPlxuICAgIHshaXNDb25uZWN0ZWQgJiYgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBjb25uZWN0KCl9PmNvbm5lY3Q8L2J1dHRvbj59XG48YnIgLz48YnIgLz5cbiAgICAgICAge2FjdGl2YXRpb25GdW5jdGlvbnMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgPD5cbiAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgIHthY3RpdmF0aW5nICE9IFwiYWN0aXZhdGluZ1wiICYmIChcbiAgICAgICAgICAgICAgICBkcm9wRG93blxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICB7cGFuZWx9XG4gICAgICAgICAgICAgIHtidXR0b259XG4gICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIHsvKiB7YWN0aXZhdGluZyAhPSBcImFjdGl2YXRpbmdcIiAmJiAoXG4gICAgICAgICAgICAgIDxEcm9wZG93blxuICAgICAgICAgICAgICAgIHNlbGVjdGVkRnVuY3Rpb25JZD17c2VsZWN0ZWRGdW5jdGlvbklkfVxuICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkRnVuY3Rpb25JZD17c2V0U2VsZWN0ZWRGdW5jdGlvbklkfVxuICAgICAgICAgICAgICAgIGFjdGl2YXRpb25GdW5jdGlvbnM9e2FjdGl2YXRpb25GdW5jdGlvbnN9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAgPFBhbmVsXG4gICAgICAgICAgICAgIGFjdGl2YXRpbmc9e2FjdGl2YXRpbmd9XG4gICAgICAgICAgICAgIGFjdGl2YXRpb25GdW5jdGlvbnM9e2FjdGl2YXRpb25GdW5jdGlvbnN9XG4gICAgICAgICAgICAgIHNlbGVjdGVkRnVuY3Rpb25JZD17c2VsZWN0ZWRGdW5jdGlvbklkfVxuICAgICAgICAgICAgICBiYWxhbmNlPXtiYWxhbmNlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgYWN0aXZhdGluZz17YWN0aXZhdGluZ31cbiAgICAgICAgICAgICAgc2V0QWN0aXZhdGluZz17c2V0QWN0aXZhdGluZ31cbiAgICAgICAgICAgICAgYmFsYW5jZT17YmFsYW5jZX1cbiAgICAgICAgICAgICAgc2V0QmFsYW5jZT17c2V0QmFsYW5jZX1cbiAgICAgICAgICAgICAgc2VsZWN0ZWRGdW5jdGlvbklkPXtzZWxlY3RlZEZ1bmN0aW9uSWR9XG4gICAgICAgICAgICAvPiAqL31cbiAgICAgICAgICA8Lz5cblxuXG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IEFjdGl2YXRpb25CeUNvbnRyYWN0QWRkcmVzcyA9IEFwcDsiXSwibmFtZXMiOlsiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaGFzT3duUHJvcGVydHkiLCJwcm9wSXNFbnVtZXJhYmxlIiwidG9PYmplY3QiLCJ2YWwiLCJzaG91bGRVc2VOYXRpdmUiLCJ0ZXN0MSIsInRlc3QyIiwiaSIsIm9yZGVyMiIsIm4iLCJ0ZXN0MyIsImxldHRlciIsIm9iamVjdEFzc2lnbiIsInRhcmdldCIsInNvdXJjZSIsImZyb20iLCJ0byIsInN5bWJvbHMiLCJzIiwia2V5IiwicmVxdWlyZSQkMCIsImYiLCJyZXF1aXJlJCQxIiwiZyIsInJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uX21pbiIsImgiLCJtIiwicCIsInEiLCJjIiwiYSIsImsiLCJiIiwiZCIsImUiLCJsIiwiUmVhY3QiLCJfYXNzaWduIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJleHBvcnRzIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9CTE9DS19UWVBFIiwiUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUiLCJSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIiwiUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUiLCJSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUiLCJzeW1ib2xGb3IiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwibWF5YmVJdGVyYXRvciIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3MiLCJfa2V5MiIsInByaW50V2FybmluZyIsImxldmVsIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSIsInN0YWNrIiwiYXJnc1dpdGhGb3JtYXQiLCJpdGVtIiwiZW5hYmxlU2NvcGVBUEkiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiZ2V0V3JhcHBlZE5hbWUiLCJvdXRlclR5cGUiLCJpbm5lclR5cGUiLCJ3cmFwcGVyTmFtZSIsImZ1bmN0aW9uTmFtZSIsImdldENvbnRleHROYW1lIiwiZ2V0Q29tcG9uZW50TmFtZSIsImNvbnRleHQiLCJwcm92aWRlciIsImxhenlDb21wb25lbnQiLCJwYXlsb2FkIiwiaW5pdCIsImRpc2FibGVkRGVwdGgiLCJwcmV2TG9nIiwicHJldkluZm8iLCJwcmV2V2FybiIsInByZXZFcnJvciIsInByZXZHcm91cCIsInByZXZHcm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImRpc2FibGVkTG9nIiwiZGlzYWJsZUxvZ3MiLCJwcm9wcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsIm5hbWUiLCJvd25lckZuIiwieCIsIm1hdGNoIiwicmVlbnRyeSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJQb3NzaWJseVdlYWtNYXAiLCJkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lIiwiZm4iLCJjb25zdHJ1Y3QiLCJmcmFtZSIsImNvbnRyb2wiLCJwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiRmFrZSIsInNhbXBsZSIsInNhbXBsZUxpbmVzIiwiY29udHJvbExpbmVzIiwiX2ZyYW1lIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJwcm90b3R5cGUiLCJkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCIsImVsZW1lbnQiLCJvd25lciIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwidHlwZVNwZWNOYW1lIiwiZXJyb3IkMSIsImVyciIsImV4IiwiUmVhY3RDdXJyZW50T3duZXIiLCJSRVNFUlZFRF9QUk9QUyIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJoYXNWYWxpZEtleSIsIndhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZCIsInNlbGYiLCJkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlciIsImRpc3BsYXlOYW1lIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJyZWYiLCJqc3hERVYiLCJtYXliZUtleSIsInByb3BOYW1lIiwiZGVmYXVsdFByb3BzIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsImluZm8iLCJwYXJlbnROYW1lIiwidmFsaWRhdGVFeHBsaWNpdEtleSIsImN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJjaGlsZE93bmVyIiwidmFsaWRhdGVDaGlsZEtleXMiLCJub2RlIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiaXRlcmF0b3IiLCJzdGVwIiwidmFsaWRhdGVQcm9wVHlwZXMiLCJwcm9wVHlwZXMiLCJfbmFtZSIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJqc3hXaXRoVmFsaWRhdGlvblN0YXRpYyIsImpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyIsImpzeCIsImpzeHMiLCJqc3hSdW50aW1lTW9kdWxlIiwidmVyc2lvbiIsImNoZWNrVHlwZSIsInZhbHVlIiwidHlwZXMiLCJ0IiwicmVzb2x2ZVByb3BlcnRpZXMiLCJhY2N1bSIsInYiLCJpbmRleCIsImRlZmluZVByb3BlcnRpZXMiLCJzdHJpbmdpZnkiLCJIRVgiLCJyZXN1bHQiLCJpc0Vycm9yIiwiY29kZSIsImlzQ2FsbEV4Y2VwdGlvbiIsIm1ha2VFcnJvciIsIm1lc3NhZ2UiLCJzaG9ydE1lc3NhZ2UiLCJkZXRhaWxzIiwiYXNzZXJ0IiwiY2hlY2siLCJhc3NlcnRBcmd1bWVudCIsImFzc2VydEFyZ3VtZW50Q291bnQiLCJjb3VudCIsImV4cGVjdGVkQ291bnQiLCJfbm9ybWFsaXplRm9ybXMiLCJmb3JtIiwiZXhwZWN0ZWQiLCJhc3NlcnROb3JtYWxpemUiLCJhc3NlcnRQcml2YXRlIiwiZ2l2ZW5HdWFyZCIsImd1YXJkIiwiY2xhc3NOYW1lIiwibWV0aG9kIiwib3BlcmF0aW9uIiwiX2dldEJ5dGVzIiwiY29weSIsIm9mZnNldCIsImdldEJ5dGVzIiwiZ2V0Qnl0ZXNDb3B5IiwiaXNIZXhTdHJpbmciLCJsZW5ndGgiLCJpc0J5dGVzTGlrZSIsIkhleENoYXJhY3RlcnMiLCJoZXhsaWZ5IiwiZGF0YSIsImJ5dGVzIiwiY29uY2F0IiwiZGF0YXMiLCJkYXRhTGVuZ3RoIiwiZGF0YVNsaWNlIiwic3RhcnQiLCJlbmQiLCJ6ZXJvUGFkIiwibGVmdCIsInplcm9QYWRWYWx1ZSIsInplcm9QYWRCeXRlcyIsIkJOXzAiLCJCTl8xIiwibWF4VmFsdWUiLCJmcm9tVHdvcyIsIl92YWx1ZSIsIl93aWR0aCIsImdldFVpbnQiLCJ3aWR0aCIsImdldE51bWJlciIsIm1hc2siLCJ0b1R3b3MiLCJnZXRCaWdJbnQiLCJsaW1pdCIsIl9iaXRzIiwiYml0cyIsIk5pYmJsZXMiLCJ0b0JpZ0ludCIsInRvTnVtYmVyIiwidG9CZUhleCIsInRvQmVBcnJheSIsImhleCIsInRvUXVhbnRpdHkiLCJBbHBoYWJldCIsIkJOXzU4IiwiZW5jb2RlQmFzZTU4IiwiZGVjb2RlQmFzZTY0IiwidGV4dERhdGEiLCJlbmNvZGVCYXNlNjQiLCJfZGF0YSIsIkV2ZW50UGF5bG9hZCIsImVtaXR0ZXIiLCJsaXN0ZW5lciIsImZpbHRlciIsIl9fcHVibGljRmllbGQiLCJfX3ByaXZhdGVBZGQiLCJfbGlzdGVuZXIiLCJfX3ByaXZhdGVTZXQiLCJfX3ByaXZhdGVHZXQiLCJlcnJvckZ1bmMiLCJyZWFzb24iLCJvdXRwdXQiLCJiYWRDb2RlcG9pbnQiLCJpZ25vcmVGdW5jIiwicmVwbGFjZUZ1bmMiLCJVdGY4RXJyb3JGdW5jcyIsImdldFV0ZjhDb2RlUG9pbnRzIiwiX2J5dGVzIiwib25FcnJvciIsImV4dHJhTGVuZ3RoIiwib3ZlcmxvbmdNYXNrIiwicmVzIiwiaiIsIm5leHRDaGFyIiwidG9VdGY4Qnl0ZXMiLCJzdHIiLCJjMiIsInBhaXIiLCJfdG9VdGY4U3RyaW5nIiwiY29kZVBvaW50cyIsImNvZGVQb2ludCIsInRvVXRmOFN0cmluZyIsImNyZWF0ZUdldFVybCIsIm9wdGlvbnMiLCJnZXRVcmwiLCJyZXEiLCJfc2lnbmFsIiwicHJvdG9jb2wiLCJzaWduYWwiLCJjb250cm9sbGVyIiwicmVzcCIsImhlYWRlcnMiLCJyZXNwQm9keSIsImJvZHkiLCJNQVhfQVRURU1QVFMiLCJTTE9UX0lOVEVSVkFMIiwiZGVmYXVsdEdldFVybEZ1bmMiLCJyZURhdGEiLCJyZUlwZnMiLCJsb2NrZWQiLCJkYXRhR2F0ZXdheUZ1bmMiLCJ1cmwiLCJGZXRjaFJlc3BvbnNlIiwidW5wZXJjZW50IiwiRmV0Y2hSZXF1ZXN0IiwiZ2V0SXBmc0dhdGV3YXlGdW5jIiwiYmFzZVVybCIsImdhdGV3YXlJcGZzIiwiR2F0ZXdheXMiLCJmZXRjaFNpZ25hbHMiLCJGZXRjaENhbmNlbFNpZ25hbCIsInJlcXVlc3QiLCJfbGlzdGVuZXJzIiwiX2NhbmNlbGxlZCIsImNoZWNrU2lnbmFsIiwiX0ZldGNoUmVxdWVzdCIsIl9zZW5kIiwiX2FsbG93SW5zZWN1cmUiLCJfZ3ppcCIsIl9oZWFkZXJzIiwiX21ldGhvZCIsIl90aW1lb3V0IiwiX3VybCIsIl9ib2R5IiwiX2JvZHlUeXBlIiwiX2NyZWRzIiwiX3ByZWZsaWdodCIsIl9wcm9jZXNzIiwiX3JldHJ5IiwiX3Rocm90dGxlIiwiX2dldFVybEZ1bmMiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwidGltZW91dCIsInByZWZsaWdodCIsInByb2Nlc3MiLCJyZXRyeSIsInBhcmFtcyIsIl9fcHJpdmF0ZU1ldGhvZCIsInNlbmRfZm4iLCJnZXRUaW1lIiwiY3VycmVudCIsImNsb25lIiwic2NoZW1lIiwiZnVuYyIsImF0dGVtcHQiLCJleHBpcmVzIiwiZGVsYXkiLCJfcmVxdWVzdCIsIl9yZXNwb25zZSIsIndhaXQiLCJyZXNwb25zZSIsIl9hIiwicmV0cnlBZnRlciIsIl9iIiwiX2MiLCJfRmV0Y2hSZXNwb25zZSIsInN0YXR1c0NvZGUiLCJzdGF0dXNNZXNzYWdlIiwiX3N0YXR1c0NvZGUiLCJfc3RhdHVzTWVzc2FnZSIsIl9lcnJvciIsInN0YWxsIiwiYWxsIiwicmVzb2x2ZSIsImhleGxpZnlCeXRlIiwidW5hcnJheWlmeUludGVnZXIiLCJfZGVjb2RlQ2hpbGRyZW4iLCJjaGlsZE9mZnNldCIsImRlY29kZWQiLCJfZGVjb2RlIiwiY2hlY2tPZmZzZXQiLCJsZW5ndGhMZW5ndGgiLCJkZWNvZGVSbHAiLCJhcnJheWlmeUludGVnZXIiLCJfZW5jb2RlIiwibmliYmxlcyIsImVuY29kZVJscCIsIldvcmRTaXplIiwiUGFkZGluZyIsInBhc3NQcm9wZXJ0aWVzIiwiX2d1YXJkIiwidGhyb3dFcnJvciIsIndyYXBwZWQiLCJfUmVzdWx0IiwiaXRlbXMiLCJuYW1lcyIsIndyYXAiLCJfbmFtZXMiLCJuYW1lQ291bnRzIiwicHJvcCIsInJlY2VpdmVyIiwiY2FsbGJhY2siLCJ0aGlzQXJnIiwiUmVzdWx0IiwiZ2V0VmFsdWUiLCJDb2RlciIsImxvY2FsTmFtZSIsImR5bmFtaWMiLCJXcml0ZXIiLCJfd3JpdGVEYXRhIiwiX2RhdGFMZW5ndGgiLCJ3cml0ZXIiLCJ3cml0ZURhdGFfZm4iLCJwYWRkaW5nT2Zmc2V0IiwiX1JlYWRlciIsImFsbG93TG9vc2UiLCJfcGVla0J5dGVzIiwiX29mZnNldCIsImxvb3NlIiwicGVla0J5dGVzX2ZuIiwiYWxpZ25lZExlbmd0aCIsIlJlYWRlciIsIm51bWJlciIsImxlbmd0aHMiLCJoYXNoIiwiZXhpc3RzIiwiaW5zdGFuY2UiLCJjaGVja0ZpbmlzaGVkIiwib3V0IiwibWluIiwiY3J5cHRvIiwidThhIiwidTMyIiwiYXJyIiwiY3JlYXRlVmlldyIsInJvdHIiLCJ3b3JkIiwic2hpZnQiLCJpc0xFIiwidXRmOFRvQnl0ZXMiLCJ0b0J5dGVzIiwiY29uY2F0Qnl0ZXMiLCJhcnJheXMiLCJyIiwic3VtIiwicGFkIiwiSGFzaCIsIndyYXBDb25zdHJ1Y3RvciIsImhhc2hDb25zIiwiaGFzaEMiLCJtc2ciLCJ0bXAiLCJyYW5kb21CeXRlcyIsImJ5dGVzTGVuZ3RoIiwiSE1BQyIsIl9rZXkiLCJhc3NlcnRIYXNoIiwiYmxvY2tMZW4iLCJidWYiLCJhc3NlcnRFeGlzdHMiLCJhc3NlcnRCeXRlcyIsIm9IYXNoIiwiaUhhc2giLCJmaW5pc2hlZCIsImRlc3Ryb3llZCIsIm91dHB1dExlbiIsImhtYWMiLCJzZXRCaWdVaW50NjQiLCJ2aWV3IiwiYnl0ZU9mZnNldCIsIl8zMm4iLCJfdTMyX21heCIsIndoIiwid2wiLCJTSEEyIiwicGFkT2Zmc2V0IiwiYnVmZmVyIiwibGVuIiwicG9zIiwidGFrZSIsImRhdGFWaWV3Iiwib3ZpZXciLCJvdXRMZW4iLCJzdGF0ZSIsIkNoaSIsIk1haiIsIlNIQTI1Nl9LIiwiSVYiLCJTSEEyNTZfVyIsIlNIQTI1NiIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiVzE1IiwiVzIiLCJzMCIsInMxIiwic2lnbWExIiwiVDEiLCJUMiIsInNoYTI1NiIsIlUzMl9NQVNLNjQiLCJmcm9tQmlnIiwibGUiLCJzcGxpdCIsImxzdCIsIkFoIiwiQWwiLCJyb3RsU0giLCJyb3RsU0wiLCJyb3RsQkgiLCJyb3RsQkwiLCJTSEEzX1BJIiwiU0hBM19ST1RMIiwiX1NIQTNfSU9UQSIsIl8wbiIsIl8xbiIsIl8ybiIsIl83biIsIl8yNTZuIiwiXzB4NzFuIiwicm91bmQiLCJSIiwieSIsIlNIQTNfSU9UQV9IIiwiU0hBM19JT1RBX0wiLCJyb3RsSCIsInJvdGxMIiwia2VjY2FrUCIsInJvdW5kcyIsImlkeDEiLCJpZHgwIiwiQjAiLCJCMSIsIlRoIiwiVGwiLCJjdXJIIiwiY3VyTCIsIlBJIiwiS2VjY2FrIiwic3VmZml4IiwiZW5hYmxlWE9GIiwiYnVmZmVyT3V0IiwiZ2VuIiwia2VjY2FrXzI1NiIsIl9rZWNjYWsyNTYiLCJfX2tlY2NhazI1NiIsImtlY2NhazI1NiIsImhleGVzIiwiXyIsImJ5dGVzVG9IZXgiLCJudW1iZXJUb0hleFVucGFkZGVkIiwibnVtIiwiaGV4VG9OdW1iZXIiLCJoZXhUb0J5dGVzIiwiYXJyYXkiLCJoZXhCeXRlIiwiYnl0ZSIsImJ5dGVzVG9OdW1iZXJCRSIsImJ5dGVzVG9OdW1iZXJMRSIsIm51bWJlclRvQnl0ZXNCRSIsIm51bWJlclRvQnl0ZXNMRSIsIm51bWJlclRvVmFyQnl0ZXNCRSIsImVuc3VyZUJ5dGVzIiwidGl0bGUiLCJleHBlY3RlZExlbmd0aCIsImVxdWFsQnl0ZXMiLCJiMSIsImIyIiwiYml0TGVuIiwiYml0R2V0IiwiYml0U2V0IiwiYml0TWFzayIsInU4biIsInU4ZnIiLCJjcmVhdGVIbWFjRHJiZyIsImhhc2hMZW4iLCJxQnl0ZUxlbiIsImhtYWNGbiIsInJlc2V0IiwicmVzZWVkIiwic2VlZCIsInNsIiwicHJlZCIsInZhbGlkYXRvckZucyIsInZhbGlkYXRlT2JqZWN0IiwidmFsaWRhdG9ycyIsIm9wdFZhbGlkYXRvcnMiLCJjaGVja0ZpZWxkIiwiZmllbGROYW1lIiwiaXNPcHRpb25hbCIsImNoZWNrVmFsIiwiXzNuIiwiXzRuIiwiXzVuIiwiXzhuIiwibW9kIiwicG93IiwicG93ZXIiLCJtb2R1bG8iLCJwb3cyIiwiaW52ZXJ0IiwidSIsInRvbmVsbGlTaGFua3MiLCJQIiwibGVnZW5kcmVDIiwiUSIsIlMiLCJaIiwicDFkaXY0IiwiRnAiLCJyb290IiwiUTFkaXYyIiwidDIiLCJnZSIsIkZwU3FydCIsImMxIiwibjIiLCJudiIsIkZJRUxEX0ZJRUxEUyIsInZhbGlkYXRlRmllbGQiLCJmaWVsZCIsImluaXRpYWwiLCJvcHRzIiwibWFwIiwiRnBQb3ciLCJGcEludmVydEJhdGNoIiwibnVtcyIsImxhc3RNdWx0aXBsaWVkIiwiYWNjIiwiaW52ZXJ0ZWQiLCJuTGVuZ3RoIiwibkJpdExlbmd0aCIsIl9uQml0TGVuZ3RoIiwibkJ5dGVMZW5ndGgiLCJGaWVsZCIsIk9SREVSIiwicmVkZWYiLCJCSVRTIiwiQllURVMiLCJzcXJ0UCIsImxocyIsInJocyIsImdldEZpZWxkQnl0ZXNMZW5ndGgiLCJmaWVsZE9yZGVyIiwiYml0TGVuZ3RoIiwiZ2V0TWluSGFzaExlbmd0aCIsIm1hcEhhc2hUb0ZpZWxkIiwiZmllbGRMZW4iLCJtaW5MZW4iLCJyZWR1Y2VkIiwid05BRiIsImNvbnN0VGltZU5lZ2F0ZSIsImNvbmRpdGlvbiIsIm5lZyIsIlciLCJ3aW5kb3dzIiwid2luZG93U2l6ZSIsImVsbSIsInBvaW50cyIsImJhc2UiLCJ3aW5kb3ciLCJwcmVjb21wdXRlcyIsIm1heE51bWJlciIsInNoaWZ0QnkiLCJ3Yml0cyIsIm9mZnNldDEiLCJvZmZzZXQyIiwiY29uZDEiLCJjb25kMiIsInByZWNvbXB1dGVzTWFwIiwidHJhbnNmb3JtIiwiY29tcCIsInZhbGlkYXRlQmFzaWMiLCJjdXJ2ZSIsInZhbGlkYXRlUG9pbnRPcHRzIiwidXQudmFsaWRhdGVPYmplY3QiLCJlbmRvIiwiYjJuIiwiaDJiIiwidXQiLCJERVIiLCJzQnl0ZXMiLCJyQnl0ZXNMZWZ0Iiwic2lnIiwic2xpY2UiLCJzaGwiLCJyaGwiLCJybCIsIndlaWVyc3RyYXNzUG9pbnRzIiwiQ1VSVkUiLCJwb2ludCIsIl9pc0NvbXByZXNzZWQiLCJ1dC5jb25jYXRCeXRlcyIsImZyb21CeXRlcyIsInRhaWwiLCJ3ZWllcnN0cmFzc0VxdWF0aW9uIiwieDIiLCJ4MyIsImlzV2l0aGluQ3VydmVPcmRlciIsImFzc2VydEdFIiwibm9ybVByaXZhdGVLZXlUb1NjYWxhciIsIndyYXBQcml2YXRlS2V5IiwidXQuYnl0ZXNUb0hleCIsInV0LmJ5dGVzVG9OdW1iZXJCRSIsIm1vZC5tb2QiLCJwb2ludFByZWNvbXB1dGVzIiwiYXNzZXJ0UHJqUG9pbnQiLCJvdGhlciIsIlBvaW50IiwicHgiLCJweSIsInB6IiwiaXMwIiwidG9JbnYiLCJwcml2YXRlS2V5IiwicmlnaHQiLCJYMSIsIlkxIiwiWjEiLCJYMiIsIlkyIiwiWjIiLCJVMSIsIlUyIiwiYjMiLCJYMyIsIlkzIiwiWjMiLCJ0MCIsInQxIiwidDMiLCJ0NCIsInQ1Iiwid25hZiIsIkkiLCJrMW5lZyIsImsxIiwiazJuZWciLCJrMiIsImsxcCIsImsycCIsInNjYWxhciIsImZha2UiLCJmMXAiLCJmMnAiLCJtdWwiLCJpeiIsInoiLCJheCIsImF5IiwienoiLCJjb2ZhY3RvciIsImlzVG9yc2lvbkZyZWUiLCJjbGVhckNvZmFjdG9yIiwiaXNDb21wcmVzc2VkIiwidmFsaWRhdGVPcHRzIiwid2VpZXJzdHJhc3MiLCJjdXJ2ZURlZiIsIkNVUlZFX09SREVSIiwiY29tcHJlc3NlZExlbiIsInVuY29tcHJlc3NlZExlbiIsImlzVmFsaWRGaWVsZEVsZW1lbnQiLCJtb2ROIiwiaW52TiIsIm1vZC5pbnZlcnQiLCJjYXQiLCJoZWFkIiwieTIiLCJpc1lPZGQiLCJudW1Ub05CeXRlU3RyIiwidXQubnVtYmVyVG9CeXRlc0JFIiwiaXNCaWdnZXJUaGFuSGFsZk9yZGVyIiwiSEFMRiIsIm5vcm1hbGl6ZVMiLCJzbGNOdW0iLCJTaWduYXR1cmUiLCJyZWNvdmVyeSIsIm1zZ0hhc2giLCJyZWMiLCJiaXRzMmludF9tb2ROIiwicmFkaiIsImlyIiwidTEiLCJ1MiIsInV0LmhleFRvQnl0ZXMiLCJ1dGlscyIsIm1vZC5nZXRNaW5IYXNoTGVuZ3RoIiwibW9kLm1hcEhhc2hUb0ZpZWxkIiwiZ2V0UHVibGljS2V5IiwiaXNQcm9iUHViIiwiZ2V0U2hhcmVkU2VjcmV0IiwicHJpdmF0ZUEiLCJwdWJsaWNCIiwiYml0czJpbnQiLCJkZWx0YSIsIk9SREVSX01BU0siLCJ1dC5iaXRNYXNrIiwiaW50Mm9jdGV0cyIsInByZXBTaWciLCJkZWZhdWx0U2lnT3B0cyIsImxvd1MiLCJwcmVoYXNoIiwiZW50IiwiaDFpbnQiLCJzZWVkQXJncyIsImsyc2lnIiwia0J5dGVzIiwiaWsiLCJub3JtUyIsImRlZmF1bHRWZXJPcHRzIiwic2lnbiIsInByaXZLZXkiLCJ1dC5jcmVhdGVIbWFjRHJiZyIsInZlcmlmeSIsInNpZ25hdHVyZSIsInB1YmxpY0tleSIsInNnIiwiX3NpZyIsImRlckVycm9yIiwiaXMiLCJnZXRIYXNoIiwibXNncyIsImNyZWF0ZUN1cnZlIiwiZGVmSGFzaCIsImNyZWF0ZSIsInNlY3AyNTZrMVAiLCJzZWNwMjU2azFOIiwiZGl2TmVhcmVzdCIsInNxcnRNb2QiLCJfNm4iLCJfMTFuIiwiXzIybiIsIl8yM24iLCJfNDRuIiwiXzg4biIsImI2IiwiYjkiLCJiMTEiLCJiMjIiLCJiNDQiLCJiODgiLCJiMTc2IiwiYjIyMCIsImIyMjMiLCJzZWNwMjU2azEiLCJhMSIsImEyIiwiUE9XXzJfMTI4IiwiWmVyb0FkZHJlc3MiLCJaZXJvSGFzaCIsIkJOXzIiLCJCTl8yNyIsIkJOXzI4IiwiQk5fMzUiLCJ0b1VpbnQyNTYiLCJfU2lnbmF0dXJlIiwiX3IiLCJfcyIsIl92IiwiX25ldHdvcmtWIiwieVBhcml0eUFuZFMiLCJuZXR3b3JrViIsImJ2IiwiY2hhaW5JZCIsImFzc2VydEVycm9yIiwieVBhcml0eSIsIl9TaWduaW5nS2V5IiwiX3ByaXZhdGVLZXkiLCJkaWdlc3QiLCJwdWJLZXkiLCJjb21wcmVzc2VkIiwicHViIiwic2VjcFNpZyIsInAwIiwicDEiLCJwdWIwIiwicHViMSIsIlNpZ25pbmdLZXkiLCJCTl8zNiIsImdldENoZWNrc3VtQWRkcmVzcyIsImFkZHJlc3MiLCJjaGFycyIsImV4cGFuZGVkIiwiaGFzaGVkIiwiaWJhbkxvb2t1cCIsInNhZmVEaWdpdHMiLCJpYmFuQ2hlY2tzdW0iLCJibG9jayIsImNoZWNrc3VtIiwiQmFzZTM2IiwiZnJvbUJhc2UzNiIsImdldEFkZHJlc3MiLCJnZXRDcmVhdGVBZGRyZXNzIiwidHgiLCJub25jZUhleCIsImlzQWRkcmVzc2FibGUiLCJjaGVja0FkZHJlc3MiLCJwcm9taXNlIiwicmVzb2x2ZUFkZHJlc3MiLCJyZXNvbHZlciIsIl9nYXVyZCIsInNpZ25lZCIsIlR5cGVkIiwic2l6ZSIsIl90eXBlZFN5bWJvbCIsIl9UeXBlZCIsImdhdXJkIiwiX29wdGlvbnMiLCJBZGRyZXNzQ29kZXIiLCJyZWFkZXIiLCJBbm9ueW1vdXNDb2RlciIsImNvZGVyIiwicGFjayIsImNvZGVycyIsImFycmF5VmFsdWVzIiwidW5pcXVlIiwic3RhdGljV3JpdGVyIiwiZHluYW1pY1dyaXRlciIsInVwZGF0ZUZ1bmNzIiwiZHluYW1pY09mZnNldCIsInVwZGF0ZUZ1bmMiLCJiYXNlT2Zmc2V0IiwidW5wYWNrIiwiYmFzZVJlYWRlciIsIm9mZnNldFJlYWRlciIsIkFycmF5Q29kZXIiLCJkZWZhdWx0Q2hpbGQiLCJCb29sZWFuQ29kZXIiLCJEeW5hbWljQnl0ZXNDb2RlciIsIkJ5dGVzQ29kZXIiLCJGaXhlZEJ5dGVzQ29kZXIiLCJFbXB0eSIsIk51bGxDb2RlciIsIkJOX01BWF9VSU5UMjU2IiwiTnVtYmVyQ29kZXIiLCJtYXhVaW50VmFsdWUiLCJib3VuZHMiLCJTdHJpbmdDb2RlciIsIlR1cGxlQ29kZXIiLCJ1bmlxdWVOYW1lcyIsImlkIiwiQ09NUFJFU1NFRCQxIiwiRkVOQ0VEIiwiTlNNX01BWCIsImRlY29kZV9hcml0aG1ldGljIiwidTE2Iiwic3ltYm9sX2NvdW50IiwidG90YWwiLCJza2lwIiwicG9zX3BheWxvYWQiLCJyZWFkX3dpZHRoIiwicmVhZF9idWZmZXIiLCJyZWFkX2JpdCIsIk4iLCJGVUxMIiwiUVJUUiIsIk1BU0siLCJyZWdpc3RlciIsImxvdyIsInJhbmdlIiwibWlkIiwicmVhZF9wYXlsb2FkIiwicmVhZF9jb21wcmVzc2VkX3BheWxvYWQiLCJ1bnNhZmVfYXRvYiIsImxvb2t1cCIsInJldCIsImNhcnJ5IiwicmVhZF9kZWx0YXMiLCJuZXh0IiwicmVhZF9zb3J0ZWQiLCJwcmV2IiwicmVhZF9zb3J0ZWRfYXJyYXlzIiwicmVhZF9hcnJheV93aGlsZSIsInJlYWRfbWFwcGVkIiwidyIsInJlYWRfbGluZWFyX3RhYmxlIiwicmVhZF9yZXBsYWNlbWVudF90YWJsZSIsInJlYWRfdHJhbnNwb3NlZCIsImR4IiwiZHkiLCJ2TiIsInlzIiwial9keSIsInJlYWRfdHJpZSIsInNvcnRlZCIsImV4cGFuZCIsImRlY29kZSIsImNwcyIsInNhdmVkIiwiYnIiLCJjcCIsImhleF9jcCIsInF1b3RlX2NwIiwiZXhwbG9kZV9jcCIsInN0cl9mcm9tX2NwcyIsImNvbXBhcmVfYXJyYXlzIiwiQ09NUFJFU1NFRCIsIlMwIiwiTDAiLCJWMCIsIlQwIiwiTF9DT1VOVCIsIlZfQ09VTlQiLCJUX0NPVU5UIiwiTl9DT1VOVCIsIlNfQ09VTlQiLCJTMSIsIkwxIiwiVjEiLCJ1bnBhY2tfY2MiLCJwYWNrZWQiLCJ1bnBhY2tfY3AiLCJTSElGVEVEX1JBTksiLCJFWENMVVNJT05TIiwiREVDT01QIiwiUkVDT01QIiwiaW5pdCQxIiwiYnVja2V0IiwiaXNfaGFuZ3VsIiwiY29tcG9zZV9wYWlyIiwicmVjb21wIiwiZGVjb21wb3NlZCIsImNoZWNrX29yZGVyIiwiYWRkIiwiY2MiLCJzX2luZGV4IiwibF9pbmRleCIsInZfaW5kZXgiLCJ0X2luZGV4IiwibWFwcGVkIiwicHJldl9jYyIsImNvbXBvc2VkX2Zyb21fZGVjb21wb3NlZCIsInByZXZfY3AiLCJjb21wb3NlZCIsIm5mZCIsIm5mYyIsIkhZUEhFTiIsIlNUT1BfQ0giLCJGRTBGIiwiVU5JUVVFX1BIIiwiQXJyYXlfZnJvbSIsImdyb3VwX2hhc19jcCIsIkVtb2ppIiwiTUFQUEVEIiwiSUdOT1JFRCIsIkNNIiwiTlNNIiwiRVNDQVBFIiwiR1JPVVBTIiwiV0hPTEVfVkFMSUQiLCJXSE9MRV9NQVAiLCJWQUxJRCIsIkVNT0pJX0xJU1QiLCJFTU9KSV9ST09UIiwicmVhZF9zb3J0ZWRfYXJyYXkiLCJyZWFkX3NvcnRlZF9zZXQiLCJjaHVua3MiLCJ1bnJlc3RyaWN0ZWQiLCJyZWFkX2NodW5rZWQiLCJNIiwid2hvbGVzIiwiViIsInJlY3MiLCJncyIsInVuaW9uIiwiY29tcGxlbWVudCIsIm11bHRpIiwiYWRkX3RvX3VuaW9uIiwicXVvdGVkX2NwIiwic2hvdWxkX2VzY2FwZSIsImJpZGlfcXEiLCJzYWZlX3N0cl9mcm9tX2NwcyIsImNoZWNrX2xhYmVsX2V4dGVuc2lvbiIsImNoZWNrX2xlYWRpbmdfdW5kZXJzY29yZSIsImNoZWNrX2ZlbmNlZCIsImVycm9yX3BsYWNlbWVudCIsImxhc3QiLCJxdW90ZXIiLCJpc19jb21iaW5pbmdfbWFyayIsImVuc19ub3JtYWxpemUiLCJmbGF0dGVuIiwiZmlsdGVyX2ZlMGYiLCJuZiIsImVmIiwibGFiZWwiLCJpbnB1dCIsInRva2VucyIsInRva2Vuc19mcm9tX3N0ciIsInRva2VuX2NvdW50Iiwibm9ybSIsImRldGVybWluZV9ncm91cCIsImNoZWNrX2dyb3VwIiwiY2hlY2tfd2hvbGUiLCJncm91cCIsIm1ha2VyIiwic2hhcmVkIiwid2hvbGUiLCJzZXQiLCJncm91cHMiLCJlcnJvcl9ncm91cF9tZW1iZXIiLCJlcnJvcl9kaXNhbGxvd2VkIiwicXVvdGVkIiwiZ2ciLCJ3aGVyZSIsImVtb2ppIiwiY29uc3VtZV9lbW9qaV9yZXZlcnNlZCIsImVhdGVuIiwiWmVyb3MiLCJjaGVja0NvbXBvbmVudCIsImVuc05hbWVTcGxpdCIsImVuc05vcm1hbGl6ZSIsImNvbXBzIiwibmFtZWhhc2giLCJkbnNFbmNvZGUiLCJhY2Nlc3NTZXRpZnkiLCJhZGRyIiwic3RvcmFnZUtleXMiLCJzdG9yYWdlS2V5IiwiYWNjZXNzTGlzdGlmeSIsImNvbXB1dGVBZGRyZXNzIiwicHVia2V5IiwicmVjb3ZlckFkZHJlc3MiLCJCTl9NQVhfVUlOVCIsImhhbmRsZUFkZHJlc3MiLCJoYW5kbGVBY2Nlc3NMaXN0IiwicGFyYW0iLCJoYW5kbGVOdW1iZXIiLCJoYW5kbGVVaW50IiwiZm9ybWF0TnVtYmVyIiwiZm9ybWF0QWNjZXNzTGlzdCIsIl9wYXJzZUxlZ2FjeSIsImZpZWxkcyIsIl9zZXJpYWxpemVMZWdhY3kiLCJsZWdhY3kiLCJfcGFyc2VFaXBTaWduYXR1cmUiLCJfcGFyc2VFaXAxNTU5IiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJtYXhGZWVQZXJHYXMiLCJfc2VyaWFsaXplRWlwMTU1OSIsIl9wYXJzZUVpcDI5MzAiLCJfc2VyaWFsaXplRWlwMjkzMCIsIl9UcmFuc2FjdGlvbiIsIl90eXBlIiwiX3RvIiwiX25vbmNlIiwiX2dhc0xpbWl0IiwiX2dhc1ByaWNlIiwiX21heFByaW9yaXR5RmVlUGVyR2FzIiwiX21heEZlZVBlckdhcyIsIl9jaGFpbklkIiwiX2FjY2Vzc0xpc3QiLCJoYXNHYXNQcmljZSIsImhhc0ZlZSIsImhhc0FjY2Vzc0xpc3QiLCJUcmFuc2FjdGlvbiIsInBhZGRpbmciLCJCTl9fMSIsImhleFBhZFJpZ2h0IiwiaGV4VHJ1ZSIsImhleEZhbHNlIiwiZG9tYWluRmllbGRUeXBlcyIsImRvbWFpbkZpZWxkTmFtZXMiLCJjaGVja1N0cmluZyIsImRvbWFpbkNoZWNrcyIsImdldEJhc2VFbmNvZGVyIiwiYm91bmRzVXBwZXIiLCJib3VuZHNMb3dlciIsImVuY29kZVR5cGUiLCJfVHlwZWREYXRhRW5jb2RlciIsIl9nZXRFbmNvZGVyIiwiX3R5cGVzIiwiX2Z1bGxUeXBlcyIsIl9lbmNvZGVyQ2FjaGUiLCJsaW5rcyIsInBhcmVudHMiLCJzdWJ0eXBlcyIsImJhc2VUeXBlIiwicHJpbWFyeVR5cGVzIiwiY2hlY2tDaXJjdWxhciIsImZvdW5kIiwic3VidHlwZSIsInN0IiwiZW5jb2RlciIsImdldEVuY29kZXJfZm4iLCJkb21haW4iLCJkb21haW5GaWVsZHMiLCJyZXNvbHZlTmFtZSIsImVuc0NhY2hlIiwiZG9tYWluVmFsdWVzIiwiZG9tYWluVHlwZXMiLCJ0eXBlc1dpdGhEb21haW4iLCJzdWJFbmNvZGVyIiwiZW5jb2RlZFR5cGUiLCJUeXBlZERhdGFFbmNvZGVyIiwic2V0aWZ5IiwiX2t3VmlzaWJEZXBsb3kiLCJLd1Zpc2liRGVwbG95IiwiX2t3VmlzaWIiLCJLd1Zpc2liIiwiX2t3VHlwZXMiLCJLd1R5cGVzIiwiX2t3TW9kaWZpZXJzIiwiS3dNb2RpZmllcnMiLCJfa3dPdGhlciIsIl9rZXl3b3JkcyIsIktleXdvcmRzIiwiU2ltcGxlVG9rZW5zIiwicmVnZXhXaGl0ZXNwYWNlUHJlZml4IiwicmVnZXhOdW1iZXJQcmVmaXgiLCJyZWdleElkUHJlZml4IiwicmVnZXhJZCIsInJlZ2V4VHlwZSIsIl9Ub2tlblN0cmluZyIsIl9zdWJUb2tlblN0cmluZyIsIl90b2tlbnMiLCJhbGxvd2VkIiwidG9wIiwic3ViVG9rZW5TdHJpbmdfZm4iLCJsaW5rIiwiX19wcml2YXRlV3JhcHBlciIsInRva2VuIiwiVG9rZW5TdHJpbmciLCJsZXgiLCJ0ZXh0IiwiYnJhY2tldHMiLCJjb21tYXMiLCJjdXIiLCJhbGxvd1NpbmdsZSIsImluY2x1ZGVkIiwiY29uc3VtZU5hbWUiLCJrZXl3b3JkIiwiY29uc3VtZUtleXdvcmRzIiwia2V5d29yZHMiLCJjb25zdW1lTXV0YWJpbGl0eSIsIm1vZGlmaWVycyIsImNvbnN1bWVQYXJhbXMiLCJhbGxvd0luZGV4ZWQiLCJQYXJhbVR5cGUiLCJjb25zdW1lR2FzIiwiY29uc3VtZUVvaSIsInJlZ2V4QXJyYXlUeXBlIiwidmVyaWZ5QmFzaWNUeXBlIiwiaW50ZXJuYWwiLCJQYXJhbVR5cGVJbnRlcm5hbCIsIkVycm9yRnJhZ21lbnRJbnRlcm5hbCIsIkV2ZW50RnJhZ21lbnRJbnRlcm5hbCIsIkNvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCIsIkZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCIsIkZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCIsIlN0cnVjdEZyYWdtZW50SW50ZXJuYWwiLCJfUGFyYW1UeXBlIiwiaW5kZXhlZCIsImNvbXBvbmVudHMiLCJhcnJheUxlbmd0aCIsImFycmF5Q2hpbGRyZW4iLCJfd2Fsa0FzeW5jIiwiX3RoaXMiLCJwcm9taXNlcyIsIndhbGtBc3luY19mbiIsIm9iaiIsImJyYWNrZXQiLCJhcnJheU1hdGNoIiwic2V0VmFsdWUiLCJjaGlsZFR5cGUiLCJGcmFnbWVudCIsImlucHV0cyIsIkNvbnN0cnVjdG9yRnJhZ21lbnQiLCJFcnJvckZyYWdtZW50IiwiRXZlbnRGcmFnbWVudCIsIkZhbGxiYWNrRnJhZ21lbnQiLCJGdW5jdGlvbkZyYWdtZW50IiwiU3RydWN0RnJhZ21lbnQiLCJOYW1lZEZyYWdtZW50Iiwiam9pblBhcmFtcyIsImFub255bW91cyIsInBheWFibGUiLCJnYXMiLCJzdGF0ZU11dGFiaWxpdHkiLCJlcnJvck9iaiIsInRvcElzVmFsaWQiLCJtdXRhYmlsaXR5Iiwib3V0cHV0cyIsIm8iLCJQYW5pY1JlYXNvbnMiLCJwYXJhbVR5cGVCeXRlcyIsInBhcmFtVHlwZU51bWJlciIsImRlZmF1bHRDb2RlciIsImdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uIiwiYWN0aW9uIiwiYWJpQ29kZXIiLCJpbnZvY2F0aW9uIiwicmV2ZXJ0IiwidHJhbnNhY3Rpb24iLCJfQWJpQ29kZXIiLCJfZ2V0Q29kZXIiLCJnZXRDb2Rlcl9mbiIsIkFiaUNvZGVyIiwiTG9nRGVzY3JpcHRpb24iLCJ0b3BpYyIsIlRyYW5zYWN0aW9uRGVzY3JpcHRpb24iLCJzZWxlY3RvciIsIkVycm9yRGVzY3JpcHRpb24iLCJJbmRleGVkIiwiQnVpbHRpbkVycm9ycyIsIl9JbnRlcmZhY2UiLCJmcmFnbWVudHMiLCJfZ2V0RnVuY3Rpb24iLCJfZ2V0RXZlbnQiLCJfZXJyb3JzIiwiX2V2ZW50cyIsIl9mdW5jdGlvbnMiLCJfYWJpQ29kZXIiLCJhYmkiLCJmcmFncyIsImZhbGxiYWNrIiwicmVjZWl2ZSIsIm1pbmltYWwiLCJnZXRGdW5jdGlvbl9mbiIsImdldEV2ZW50X2ZuIiwibWF0Y2hpbmciLCJtYXRjaFN0ciIsImN1c3RvbVByZWZpeCIsInBhcnNlZCIsInRvcGljcyIsImVuY29kZVRvcGljIiwiZGF0YVR5cGVzIiwiZGF0YVZhbHVlcyIsImV2ZW50VG9waWMiLCJub25JbmRleGVkIiwicmVzdWx0SW5kZXhlZCIsInJlc3VsdE5vbkluZGV4ZWQiLCJub25JbmRleGVkSW5kZXgiLCJpbmRleGVkSW5kZXgiLCJsb2ciLCJoZXhEYXRhIiwiZm9yY2VVbmlxdWUiLCJsYXN0VmFsdWUiLCJ2YWx1ZUxlbmd0aCIsImFsbG93T3B0aW9ucyIsImxhc3RBcmciLCJJbnRlcmZhY2UiLCJ0b0pzb24iLCJGZWVEYXRhIiwiZ2FzUHJpY2UiLCJjb3B5UmVxdWVzdCIsImJpZ0ludEtleXMiLCJudW1iZXJLZXlzIiwiQmxvY2siLCJfdHJhbnNhY3Rpb25zIiwiVHJhbnNhY3Rpb25SZXNwb25zZSIsInR4cyIsImJhc2VGZWVQZXJHYXMiLCJkaWZmaWN1bHR5IiwiZXh0cmFEYXRhIiwiZ2FzTGltaXQiLCJnYXNVc2VkIiwibWluZXIiLCJub25jZSIsInBhcmVudEhhc2giLCJ0aW1lc3RhbXAiLCJ0cmFuc2FjdGlvbnMiLCJpbmRleE9ySGFzaCIsImNyZWF0ZU9ycGhhbmVkQmxvY2tGaWx0ZXIiLCJMb2ciLCJibG9ja0hhc2giLCJibG9ja051bWJlciIsInJlbW92ZWQiLCJ0cmFuc2FjdGlvbkhhc2giLCJ0cmFuc2FjdGlvbkluZGV4IiwicmVjZWlwdCIsImNyZWF0ZVJlbW92ZWRMb2dGaWx0ZXIiLCJUcmFuc2FjdGlvblJlY2VpcHQiLCJfbG9ncyIsImNvbnRyYWN0QWRkcmVzcyIsImxvZ3NCbG9vbSIsImxvZ3MiLCJzdGF0dXMiLCJjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIiLCJjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlciIsIl9UcmFuc2FjdGlvblJlc3BvbnNlIiwiX3N0YXJ0QmxvY2siLCJhY2Nlc3NMaXN0IiwiX2NvbmZpcm1zIiwiY29uZmlybXMiLCJzdGFydEJsb2NrIiwibmV4dFNjYW4iLCJzdG9wU2Nhbm5pbmciLCJjaGVja1JlcGxhY2VtZW50IiwibWluZWQiLCJjaGVja1JlY2VpcHQiLCJyZWplY3QiLCJjYW5jZWxsZXJzIiwiY2FuY2VsIiwidGltZXIiLCJ0eExpc3RlbmVyIiwicmVwbGFjZUxpc3RlbmVyIiwiRXZlbnRMb2ciLCJpZmFjZSIsIlVuZGVjb2RlZEV2ZW50TG9nIiwiQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQiLCJfaWZhY2UiLCJDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UiLCJDb250cmFjdFVua25vd25FdmVudFBheWxvYWQiLCJjb250cmFjdCIsIkNvbnRyYWN0RXZlbnRQYXlsb2FkIiwiX2xvZyIsImNhbkNhbGwiLCJjYW5Fc3RpbWF0ZSIsImNhblJlc29sdmUiLCJjYW5TZW5kIiwiZ2V0UmVzb2x2ZXIiLCJQcmVwYXJlZFRvcGljRmlsdGVyIiwiX2ZpbHRlciIsInJ1bm5lciIsImdldFJ1bm5lciIsInJlc29sdmVkQXJncyIsImZlYXR1cmUiLCJnZXRQcm92aWRlciIsImNvcHlPdmVycmlkZXMiLCJhcmciLCJfb3ZlcnJpZGVzIiwib3ZlcnJpZGVzIiwicmVzb2x2ZUFyZ3MiLCJfcnVubmVyIiwiYnVpbGRXcmFwcGVkRmFsbGJhY2siLCJwb3B1bGF0ZVRyYW5zYWN0aW9uIiwibm9WYWx1ZSIsIm5vRGF0YSIsInN0YXRpY0NhbGwiLCJzZW5kIiwiZXN0aW1hdGVHYXMiLCJidWlsZFdyYXBwZWRNZXRob2QiLCJnZXRGcmFnbWVudCIsInN0YXRpY0NhbGxSZXN1bHQiLCJidWlsZFdyYXBwZWRFdmVudCIsImludGVybmFsVmFsdWVzIiwic2V0SW50ZXJuYWwiLCJnZXRJbnRlcm5hbCIsImlzRGVmZXJyZWQiLCJnZXRTdWJJbmZvIiwiZXZlbnQiLCJ0b3BpY0hhc2hpZnkiLCJ0YWciLCJoYXNTdWIiLCJzdWJzIiwiZ2V0U3ViIiwic3ViIiwiZm91bmRGcmFnbWVudCIsIl9mb3VuZEZyYWdtZW50IiwiZW1pdCIsInN0YXJ0aW5nIiwic3RhcnRlZCIsImxhc3RFbWl0IiwiX2VtaXQiLCJwYXlsb2FkRnVuYyIsIm9uY2UiLCJwYXNzQXJncyIsInJlc3VsdFByb21pc2UiLCJfQmFzZUNvbnRyYWN0IiwiX2RlcGxveVR4IiwiYWRkclByb21pc2UiLCJkZXBsb3lUeCIsImZpbHRlcnMiLCJjaGVja0NvZGUiLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwibGlzdGVuZXJzIiwic3RvcCIsIkN1c3RvbUNvbnRyYWN0IiwiQmFzZUNvbnRyYWN0IiwiX0NvbnRyYWN0QmFzZSIsIkNvbnRyYWN0IiwiZ2V0SXBmc0xpbmsiLCJNdWx0aWNvaW5Qcm92aWRlclBsdWdpbiIsInByb2l2ZGVyIiwiY29pblR5cGUiLCJtYXRjaGVySXBmcyIsIm1hdGNoZXJzIiwiX0Vuc1Jlc29sdmVyIiwiX2ZldGNoIiwiX3N1cHBvcnRzMjU0NCIsIl9yZXNvbHZlciIsImZldGNoX2ZuIiwiZXRoQ29pblR5cGUiLCJjb2luUGx1Z2luIiwicGx1Z2luIiwiaXBmcyIsInN3YXJtIiwibGlua2FnZSIsImF2YXRhciIsInRva2VuSWQiLCJ0b2tlbk93bmVyIiwiYmFsYW5jZSIsIm1ldGFkYXRhVXJsIiwibWV0YWRhdGEiLCJpbWFnZVVybCIsIm5ldHdvcmsiLCJlbnNQbHVnaW4iLCJjdXJyZW50TmFtZSIsIl9nZXRSZXNvbHZlciIsImdldFJlc29sdmVyX2ZuIiwiZnVuY05hbWUiLCJlbnNBZGRyIiwiRW5zUmVzb2x2ZXIiLCJhbGxvd051bGwiLCJudWxsVmFsdWUiLCJhcnJheU9mIiwiYWx0TmFtZXMiLCJzcmNLZXkiLCJhbHRLZXkiLCJmb3JtYXRCb29sZWFuIiwiZm9ybWF0RGF0YSIsImZvcm1hdEhhc2giLCJfZm9ybWF0TG9nIiwiZm9ybWF0TG9nIiwiX2Zvcm1hdEJsb2NrIiwiZm9ybWF0QmxvY2siLCJmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlIiwiX2Zvcm1hdFJlY2VpcHRMb2ciLCJmb3JtYXRSZWNlaXB0TG9nIiwiX2Zvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCIsImZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCIsIkVuc0FkZHJlc3MiLCJOZXR3b3JrUGx1Z2luIiwiR2FzQ29zdFBsdWdpbiIsImVmZmVjdGl2ZUJsb2NrIiwiY29zdHMiLCJudWxsaXNoIiwiRW5zUGx1Z2luIiwidGFyZ2V0TmV0d29yayIsIkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4iLCJwcm9jZXNzRnVuYyIsIl9wcm9jZXNzRnVuYyIsIk5ldHdvcmtzIiwiX05ldHdvcmsiLCJfcGx1Z2lucyIsImJhc2VuYW1lIiwiaW5qZWN0Q29tbW9uTmV0d29ya3MiLCJuZXR3b3JrRnVuYyIsImN1c3RvbSIsIm5hbWVPckNoYWluSWQiLCJleGlzdGluZyIsIk5ldHdvcmsiLCJwYXJzZVVuaXRzIiwiZGVjaW1hbHMiLCJmcmFjIiwiZ2V0R2FzU3RhdGlvblBsdWdpbiIsImZldGNoRmVlRGF0YSIsIl9mZWVEYXRhIiwiZ2V0UHJpb3JpdHlGZWVQbHVnaW4iLCJmZWVEYXRhIiwiYmFzZUZlZSIsImluamVjdGVkIiwicmVnaXN0ZXJFdGgiLCJQb2xsaW5nQmxvY2tTdWJzY3JpYmVyIiwiX3BvbGwiLCJfcHJvdmlkZXIiLCJfcG9sbGVyIiwiX2ludGVydmFsIiwiX2Jsb2NrTnVtYmVyIiwicG9sbF9mbiIsImRyb3BXaGlsZVBhdXNlZCIsIk9uQmxvY2tTdWJzY3JpYmVyIiwiX3J1bm5pbmciLCJQb2xsaW5nT3JwaGFuU3Vic2NyaWJlciIsIlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIiLCJfaGFzaCIsIlBvbGxpbmdFdmVudFN1YnNjcmliZXIiLCJNQVhfQ0NJUF9SRURJUkVDVFMiLCJpc1Byb21pc2UiLCJnZXRUYWciLCJVbm1hbmFnZWRTdWJzY3JpYmVyIiwiY29uY2lzaWZ5IiwiZ2V0U3Vic2NyaXB0aW9uIiwiX2V2ZW50IiwiYWRkcmVzc2VzIiwiYWRkQWRkcmVzcyIsImRlZmF1bHRPcHRpb25zIiwiQWJzdHJhY3RQcm92aWRlciIsIl9uZXR3b3JrIiwiX3BlcmZvcm0iLCJfY2FsbCIsIl9jaGVja05ldHdvcmsiLCJfZ2V0QWNjb3VudFZhbHVlIiwiX2dldEJsb2NrIiwiX2hhc1N1YiIsIl9nZXRTdWIiLCJfc3VicyIsIl9wYXVzZWRTdGF0ZSIsIl9kZXN0cm95ZWQiLCJfbmV0d29ya1Byb21pc2UiLCJfYW55TmV0d29yayIsIl9wZXJmb3JtQ2FjaGUiLCJfbGFzdEJsb2NrTnVtYmVyIiwiX25leHRUaW1lciIsIl90aW1lcnMiLCJfZGlzYWJsZUNjaXBSZWFkIiwiY2FsbGRhdGEiLCJ1cmxzIiwic2VuZGVyIiwiZXJyb3JNZXNzYWdlcyIsImhyZWYiLCJlcnJvck1lc3NhZ2UiLCJwZXJmb3JtX2ZuIiwiYmxvY2tUYWciLCJfYWRkcmVzcyIsImRldGVjdE5ldHdvcmsiLCJuZXR3b3JrUHJvbWlzZSIsImFjdHVhbCIsImdldEZlZURhdGFGdW5jIiwiX2Jsb2NrIiwiZ2V0QmxvY2tfZm4iLCJfdHgiLCJjaGVja05ldHdvcmtfZm4iLCJjYWxsX2ZuIiwiZ2V0QWNjb3VudFZhbHVlX2ZuIiwiX3Bvc2l0aW9uIiwicG9zaXRpb24iLCJzaWduZWRUeCIsInByZWZldGNoVHhzIiwidGltZXJJZCIsIl9mdW5jIiwic3Vic2NyaWJlciIsIm9sZFN1YiIsIm5ld1N1YiIsImdldFN1Yl9mbiIsImhhc1N1Yl9mbiIsInBhdXNlIiwicGVyZm9ybSIsInR4U2VuZGVyIiwiY2NpcEFyZ3MiLCJwYXJzZU9mZmNoYWluTG9va3VwIiwiY2NpcFJlc3VsdCIsImVuY29kZUJ5dGVzIiwiX2Jsb2NrVGFnIiwiaW5jbHVkZVRyYW5zYWN0aW9ucyIsImVtaXRBcmdzIiwic3Vic2NyaXB0aW9uIiwiX3BhcnNlU3RyaW5nIiwiX3BhcnNlQnl0ZXMiLCJudW1QYWQiLCJwYWRkZWQiLCJieXRlc1BhZCIsImVtcHR5IiwiYnl0ZUNvdW50IiwiemVyb3MiLCJ1cmxzT2Zmc2V0IiwidXJsc0xlbmd0aCIsInVybHNEYXRhIiwiY2hlY2tQcm92aWRlciIsInNpZ25lciIsInBvcHVsYXRlIiwicG9wIiwiQWJzdHJhY3RTaWduZXIiLCJoYXNFaXAxNTU5IiwidHhPYmoiLCJGaWx0ZXJJZFN1YnNjcmliZXIiLCJfdGVhcmRvd24iLCJfZmlsdGVySWRQcm9taXNlIiwiX2hhdWx0IiwidGVhcmRvd25fZm4iLCJmaWx0ZXJJZCIsImZpbHRlcklkUHJvbWlzZSIsIkZpbHRlcklkRXZlbnRTdWJzY3JpYmVyIiwicmVzdWx0cyIsIkZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIiLCJQcmltaXRpdmUiLCJkZWVwQ29weSIsImR1cmF0aW9uIiwiZ2V0TG93ZXJDYXNlIiwiaXNQb2xsYWJsZSIsIkpzb25ScGNTaWduZXIiLCJfZnJvbSIsImhleFR4IiwidGltZW91dHMiLCJjaGVja1R4IiwiX21lc3NhZ2UiLCJwb3B1bGF0ZWQiLCJKc29uUnBjQXBpUHJvdmlkZXIiLCJfc2NoZWR1bGVEcmFpbiIsIl9uZXh0SWQiLCJfcGF5bG9hZHMiLCJfZHJhaW5UaW1lciIsIl9ub3RSZWFkeSIsIl9yZXNvbHZlIiwic3RhdGljTmV0d29yayIsInNjaGVkdWxlRHJhaW5fZm4iLCJkc3RLZXkiLCJzcGVsdW5rRGF0YSIsInNwZWx1bmtNZXNzYWdlIiwidW5zdXBwb3J0ZWQiLCJhY2NvdW50c1Byb21pc2UiLCJhY2NvdW50cyIsImFjY291bnQiLCJzdGFsbFRpbWUiLCJwYXlsb2FkcyIsImJhdGNoIiwiSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciIsIl9wb2xsaW5nSW50ZXJ2YWwiLCJfc3BlbHVua01lc3NhZ2UiLCJCcm93c2VyUHJvdmlkZXIiLCJldGhlcmV1bSIsInNpZ25lclByb21pc2UiLCJnZXRTaWduZXIiLCJQYW5lbCIsImFjdGl2YXRpbmciLCJhY3RpdmF0aW9uRnVuY3Rpb25zIiwic2VsZWN0ZWRGdW5jdGlvbklkIiwiY29udHJhY3RBQkkiLCJlbmNvZGVyQ29udHJhY3QiLCJldGhlcnMuQ29udHJhY3QiLCJndWlsZEFGQ29udHJhY3QiLCJ3YXR0c0NvbnRyYWN0IiwidXNlQXN5bmNNZW1vIiwiZmFjdG9yeSIsImRlcHMiLCJzZXRWYWwiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUJ1dHRvbiIsInNldEFjdGl2YXRpbmciLCJzZXRCYWxhbmNlIiwiX3NlbGVjdGVkRnVuY3Rpb25JZCIsIl9jb250cmFjdFR5cGUiLCJfY29udHJhY3RBZGRyZXNzIiwiYWN0aXZhdGUiLCJjb250cmFjdFR5cGUiLCJzZmlkIiwiY2hlY2tCYWxhbmNlIiwid2F0dHNDb250cmFjdFdpdGhTaWduZXIiLCJCdXR0b24iLCJyZW5kZXIiLCJCdXR0b25Db21wIiwiRHJvcGRvd24iLCJzZXRTZWxlY3RlZEZ1bmN0aW9uSWQiLCJoYW5kbGVDaGFuZ2UiLCJ2YWx1ZUFzTnVtYmVyIiwidXNlQWN0aXZhdGlvbkZ1bmN0aW9ucyIsImF1dG9jb25uZWN0IiwiZG9Db25uZWN0Iiwic2V0RG9Db25uZWN0IiwiaXNDb25uZWN0aW5nIiwic2V0SXNDb25uZWN0aW5nIiwiaXNDb25uZWN0ZWQiLCJzZXRJc0Nvbm5lY3RlZCIsImNvbm5lY3QiLCJzaSIsInByb3h5T2JqZWN0IiwiZHJvcERvd24iLCJwYW5lbCIsImJ1dHRvblBhcmFtcyIsImJ1dHRvbiIsIkFwcCIsIkFjdGl2YXRpb25CeUNvbnRyYWN0QWRkcmVzcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVFBLE1BQUlBLElBQXdCLE9BQU8sdUJBQy9CQyxJQUFpQixPQUFPLFVBQVUsZ0JBQ2xDQyxJQUFtQixPQUFPLFVBQVU7QUFFeEMsV0FBU0MsRUFBU0MsR0FBSztBQUN0QixRQUFJQSxLQUFRO0FBQ1gsWUFBTSxJQUFJLFVBQVUsdURBQXVEO0FBRzVFLFdBQU8sT0FBT0EsQ0FBRztBQUFBLEVBQ2pCO0FBRUQsV0FBU0MsSUFBa0I7QUFDMUIsUUFBSTtBQUNILFVBQUksQ0FBQyxPQUFPO0FBQ1gsZUFBTztBQU1SLFVBQUlDLElBQVEsSUFBSSxPQUFPLEtBQUs7QUFFNUIsVUFEQUEsRUFBTSxDQUFDLElBQUksTUFDUCxPQUFPLG9CQUFvQkEsQ0FBSyxFQUFFLENBQUMsTUFBTTtBQUM1QyxlQUFPO0FBS1IsZUFESUMsSUFBUSxDQUFBLEdBQ0hDLElBQUksR0FBR0EsSUFBSSxJQUFJQTtBQUN2QixRQUFBRCxFQUFNLE1BQU0sT0FBTyxhQUFhQyxDQUFDLENBQUMsSUFBSUE7QUFFdkMsVUFBSUMsSUFBUyxPQUFPLG9CQUFvQkYsQ0FBSyxFQUFFLElBQUksU0FBVUcsR0FBRztBQUMvRCxlQUFPSCxFQUFNRyxDQUFDO0FBQUEsTUFDakIsQ0FBRztBQUNELFVBQUlELEVBQU8sS0FBSyxFQUFFLE1BQU07QUFDdkIsZUFBTztBQUlSLFVBQUlFLElBQVEsQ0FBQTtBQUlaLGFBSEEs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O0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxLQUFLQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxLQUFLQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJbkMsT0FBTyxNQUFNQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxNQUFNQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxNQUFNQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxNQUFNQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxNQUFNQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxNQUFNQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxNQUFNQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxNQUFNQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxNQUFNQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxNQUFNQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxNQUFNQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLEdBQUc7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdkMsT0FBTyxJQUFJQSxHQUFHO0FBQUUsV0FBTzNNLEVBQUUyTSxHQUFHLElBQUk7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLENBQUM7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLENBQUM7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLENBQUM7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLENBQUM7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLENBQUM7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLENBQUM7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLENBQUM7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLENBQUM7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxPQUFPQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLENBQUM7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBT3BMLEVBQUVvTCxHQUFHLEVBQUU7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRQSxHQUFHO0FBQUUsV0FBTyxJQUFJNHRCLEdBQU1MLElBQVEsV0FBV3Z0QixDQUFDO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSTdELE9BQU8sS0FBS0EsR0FBRztBQUFFLFdBQU8sSUFBSTR0QixHQUFNTCxJQUFRLFFBQVEsQ0FBQyxDQUFDdnRCLENBQUM7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJekQsT0FBTyxNQUFNQSxHQUFHO0FBQUUsV0FBTyxJQUFJNHRCLEdBQU1MLElBQVEsU0FBU3Z0QixDQUFDO0FB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O0FBQUEsTUFDQTtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxNQUNBO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxNQUNBO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUTtBQUFBLE1BQ047QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sU0FBUyxDQUFDO0FBQUEsSUFDVixpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxNQUNQO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUSxDQUFDO0FBQUEsSUFDVCxNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsTUFDUDtBQUFBLFFBQ0UsWUFBWTtBQUFBLFVBQ1Y7QUFBQSxZQUNFLGNBQWM7QUFBQSxZQUNkLE1BQU07QUFBQSxZQUNOLE1BQU07QUFBQSxVQUNSO0FBQUEsVUFDQTtBQUFBLFlBQ0UsY0FBYztBQUFBLFlBQ2QsTUFBTTtBQUFBLFlBQ04sTUFBTTtBQUFBLFVBQ1I7QUFBQSxVQUNBO0FBQUEsWUFDRSxjQUFjO0FBQUEsWUFDZCxNQUFNO0FBQUEsWUFDTixNQUFNO0FBQUEsVUFDUjtBQUFBLFVBQ0E7QUFBQSxZQUNFLGNBQWM7QUFBQSxZQUNkLE1BQU07QUFBQSxZQUNOLE1BQU07QUFBQSxVQUNSO0FBQUEsVUFDQTtBQUFBLFlBQ0UsY0FBYztBQUFBLFlBQ2QsTUFBTTtBQUFBLFlBQ04sTUFBTTtBQUFBLFVBQ1I7QUFBQSxVQUNBO0FBQUEsWUFDRSxjQUFjO0FBQUEsWUFDZCxNQUFNO0FBQUEsWUFDTixNQUFNO0FBQUEsVUFDUjtBQUFBLFVBQ0E7QUFBQSxZQUNFLGNBQWM7QUFBQSxZQUNkLE1BQU07QUFBQSxZQUNOLE1BQU07QUFBQSxVQUNSO0FBQUEsVUFDQTtBQUFBLFlBQ0UsY0FBYztBQUFBLFlBQ2QsTUFBTTtBQUFBLFlBQ04sTUFBTTtBQUFBLFVBQ1I7QUFBQSxVQUNBO0FBQUEsWUFDRSxjQUFjO0FBQUEsWUFDZCxNQUFNO0FBQUEsWUFDTixNQUFNO0FBQUEsVUFDUjtBQUFBLFVBQ0E7QUFBQSxZQUNFLGNBQWM7QUFBQSxZQUNkLE1BQU07QUFBQSxZQUNOLE1BQU07QUFBQSxVQUNSO0FBQUEsUUFDRjtBQUFBLFFBQ0EsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sU0FBUyxDQUFDO0FBQUEsSUFDVixpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVEsQ0FBQztBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ04sU0FBUztBQUFBLE1BQ1A7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxRQUFRLENBQUM7QUFBQSxJQUNULE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxNQUNQO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUTtBQUFBLE1BQ047QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxNQUNBO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxNQUNBO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsTUFDUDtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUNGLEdDMVVNL1UsS0FBa0IsOENBT1hnVixLQUFrQixJQUFJQztBQUFBQSxFQUNqQ2pWO0FBQUFBLEVBQ0ErVTtBQUFBQSxFQUNBL25EO0FBQ0YsR0NoQmErbkQsS0FBcUI7QUFBQSxFQUNoQztBQUFBLElBQ0UsUUFBUSxDQUFDO0FBQUEsSUFDVCxpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFdBQVc7QUFBQSxJQUNYLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxTQUFTO0FBQUEsUUFDVCxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsV0FBVztBQUFBLElBQ1gsUUFBUTtBQUFBLE1BQ047QUFBQSxRQUNFLFNBQVM7QUFBQSxRQUNULGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxXQUFXO0FBQUEsSUFDWCxRQUFRO0FBQUEsTUFDTjtBQUFBLFFBQ0UsU0FBUztBQUFBLFFBQ1QsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFDTixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFdBQVc7QUFBQSxJQUNYLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxTQUFTO0FBQUEsUUFDVCxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFLFNBQVM7QUFBQSxRQUNULGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxXQUFXO0FBQUEsSUFDWCxRQUFRO0FBQUEsTUFDTjtBQUFBLFFBQ0UsU0FBUztBQUFBLFFBQ1QsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxNQUNBO0FBQUEsUUFDRSxTQUFTO0FBQUEsUUFDVCxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsV0FBVztBQUFBLElBQ1gsUUFBUTtBQUFBLE1BQ047QUFBQSxRQUNFLFNBQVM7QUFBQSxRQUNULGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxRQUFRLENBQUM7QUFBQSxJQUNULE1BQU07QUFBQSxJQUNOLFNBQVMsQ0FBQztBQUFBLElBQ1YsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxRQUFRO0FBQUEsTUFDTjtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFDTixTQUFTLENBQUM7QUFBQSxJQUNWLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUTtBQUFBLE1BQ047QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFDTixTQUFTLENBQUM7QUFBQSxJQUNWLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUSxDQUFDO0FBQUEsSUFDVCxNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsTUFDUDtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVEsQ0FBQztBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ04sU0FBUztBQUFBLE1BQ1A7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxRQUFRLENBQUM7QUFBQSxJQUNULE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxNQUNQO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUSxDQUFDO0FBQUEsSUFDVCxNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsTUFDUDtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxNQUNQO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUSxDQUFDO0FBQUEsSUFDVCxNQUFNO0FBQUEsSUFDTixTQUFTLENBQUM7QUFBQSxJQUNWLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUTtBQUFBLE1BQ047QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sU0FBUztBQUFBLE1BQ1A7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxRQUFRLENBQUM7QUFBQSxJQUNULE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxNQUNQO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUTtBQUFBLE1BQ047QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sU0FBUyxDQUFDO0FBQUEsSUFDVixpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLFNBQVMsQ0FBQztBQUFBLElBQ1YsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxRQUFRO0FBQUEsTUFDTjtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFDTixTQUFTLENBQUM7QUFBQSxJQUNWLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUTtBQUFBLE1BQ047QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sU0FBUyxDQUFDO0FBQUEsSUFDVixpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLFNBQVMsQ0FBQztBQUFBLElBQ1YsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxRQUFRLENBQUM7QUFBQSxJQUNULE1BQU07QUFBQSxJQUNOLFNBQVMsQ0FBQztBQUFBLElBQ1YsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFDRixHQ3ZUTS9VLEtBQWtCLDhDQU1Ya1YsS0FBa0IsSUFBSUQ7QUFBQUEsRUFDakNqVjtBQUFBQSxFQUNBK1U7QUFBQUEsRUFDQS9uRDtBQUNGLEdDZmErbkQsS0FBcUI7QUFBQSxFQUNoQztBQUFBLElBQ0UsUUFBUTtBQUFBLE1BQ047QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsTUFDUDtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxNQUNQO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUTtBQUFBLE1BQ047QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxNQUNBO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLFNBQVMsQ0FBQztBQUFBLElBQ1YsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxRQUFRO0FBQUEsTUFDTjtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxNQUNBO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxNQUNQO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUTtBQUFBLE1BQ047QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sU0FBUztBQUFBLE1BQ1A7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFDRixHQzFHTS9VLEtBQWtCLDhDQU9YbVYsS0FBZ0IsSUFBSUY7QUFBQUEsRUFDL0JqVjtBQUFBLEVBQ0ErVTtBQUFBLEVBQ0EvbkQ7QUFDRjtBQ1RnQixTQUFBb29ELEdBQWdCQyxHQUE4Q0MsR0FBc0J0a0MsR0FBYTtBQUMvRyxRQUFNLENBQUNqcEIsR0FBS3d0RCxDQUFNLElBQUlDLEdBQXdCeGtDLENBQU87QUFDckQsU0FBQXlrQyxHQUFVLE1BQU07QUFDZCxRQUFJdFUsSUFBUztBQUNiLFVBQU0vZSxJQUFVaXpCO0FBQ1osUUFBeUJqekIsS0FBWTtBQUNqQyxhQUFBQSxFQUFBLEtBQUssQ0FBQ3I2QixNQUFRO0FBQ3BCLFFBQUtvNUMsS0FDSG9VLEVBQU94dEQsQ0FBRztBQUFBLE1BQ1osQ0FDRCxHQUNNLE1BQU07QUFDRixRQUFBbzVDLElBQUE7QUFBQSxNQUFBO0FBQUEsS0FFVm1VLENBQUksR0FDQXZ0RDtBQUNUO0FDUU8sTUFBTTJ0RCxLQUFZLENBQUM7QUFBQSxFQUN4QixlQUFBQztBQUFBLEVBQ0EsWUFBQUM7QUFBQSxFQUNBLG9CQUFvQkM7QUFBQSxFQUNwQixjQUFjQztBQUFBLEVBQ2QsaUJBQWlCQztBQUNuQixNQUFhO0FBQ0wsUUFBQUMsSUFBVyxPQUFPbnFELE1BQTBCO0FBQzVDLFVBQUF3bEQsSUFBUyxNQUFNcUQ7QUFFZixRQUFBO0FBQUEsTUFDRixvQkFBQUk7QUFBQSxNQUNBLGNBQUFtQjtBQUFBLE1BQ0EsaUJBQUFqVztBQUFBO0FBQUEsSUFBQSxJQUVFbjBDLEtBQVEsQ0FBQTtBQUVaLElBQUFvcUQsSUFBZUEsS0FBZ0JILEtBQWlCLG1CQUNoRDlWLElBQWtCQSxLQUFtQitWLEtBQW9CO0FBQ3pELFVBQU1HLElBQU8sT0FBT3BCLElBQXNCLE1BQWNBLElBQXFCZTtBQUV6RSxRQUFBO0FBS0YsWUFKZ0NYLEdBQWdCO0FBQUEsUUFDOUM3RDtBQUFBLE1BQUEsRUFHNEIsV0FHOUIsV0FBVyxZQUFZO0FBQ2pCLFlBQUE7QUFVRixpQkFIRSxNQU5nQzJELEdBQWdCO0FBQUEsWUFDaEQzRDtBQUFBLFVBQUEsRUFLZ0MsU0FBUzZFLENBQUssR0FHdkMsUUFHSUM7aUJBQ05yc0QsR0FBRztBQUNGLGtCQUFBLElBQUksNkJBQTZCQSxDQUFDO0FBQUEsUUFDNUM7QUFBQSxTQUNDLEdBQUs7QUFBQSxhQUNEQSxHQUFHO0FBQ0YsY0FBQSxJQUFJLDBCQUEwQkEsQ0FBQztBQUFBLElBQ3pDO0FBQ0EsSUFBQTZyRCxFQUFjLFlBQVk7QUFBQSxFQUFBLEdBK0N0QlEsSUFBZSxZQUFZO0FBQy9CLFVBQU05RSxJQUFTK0QsR0FBYVYsSUFBVyxDQUFFLENBQUEsR0FFbkMwQixJQUEwQmpCLEdBQWM7QUFBQSxNQUM1QzlEO0FBQUEsSUFBQTtBQUVFLFFBQUE7QUFDSSxZQUFBbHdCLElBQVUsTUFBTWt3QixFQUFRLGNBQ3hCOUosSUFBVSxNQUFNNk8sRUFBd0IsZUFBZWoxQixDQUFPO0FBQ3BFLGNBQVEsSUFBSSxzQkFBc0JvbUIsRUFBUSxTQUFVLENBQUEsR0FDekNxTyxFQUFBck8sRUFBUSxVQUFVLEdBQzdCb08sRUFBYyxXQUFXO0FBQUEsYUFDbEI3ckQsR0FBRztBQUNGLGNBQUEsSUFBSSw0QkFBNEJBLENBQUM7QUFBQSxJQUMzQztBQUFBLEVBQUE7QUFHSyxTQUFBO0FBQUEsSUFDTCxVQUFBa3NEO0FBQUEsRUFBQTtBQUVKO0FBRUEsU0FBd0JLLEdBQU87QUFBQSxFQUM3QixZQUFBekI7QUFBQSxFQUNBLGVBQUFlO0FBQUEsRUFDQSxZQUFBQztBQUFBLEVBQ0Esb0JBQUFkO0FBQUEsRUFDQSxRQUFBd0I7QUFDRixHQUFVO0FBQ1IsUUFBTWpGLElBQVMrRCxHQUFhVixJQUFXLENBQUUsQ0FBQSxHQUVuQyxFQUFFLFVBQUFzQixFQUFTLElBQUlOLEdBQVU7QUFBQSxJQUM3QixZQUFBZDtBQUFBLElBQ0EsZUFBQWU7QUFBQSxJQUNBLFlBQUFDO0FBQUEsSUFDQSxvQkFBQWQ7QUFBQSxFQUFBLENBQ0QsR0FFS3lCLElBQWFELE1BQVcsQ0FBQ3hvRCxNQUF3QndHLGdCQUFBQSxFQUFBQSxJQUFBLFVBQUEsRUFBUSxHQUFHeEcsRUFBTyxDQUFBO0FBRXpFLFNBQUt1akQsSUFJSC84QyxnQkFBQUEsRUFBQTtBQUFBLElBQUNpaUQ7QUFBQSxJQUFBO0FBQUEsTUFDQyxTQUFTLE1BQU1QLEVBQVM7QUFBQSxNQUN4QixXQUFXLDBDQUEwQ3BCLE1BQWUsZUFBZSxnQkFBZ0IsVUFDakc7QUFBQSxNQUNGLFVBQVVBLE1BQWU7QUFBQSxNQUV4QixVQUFBQSxNQUFlLGVBQWUsZUFBZTtBQUFBLElBQUE7QUFBQSxFQUFBLHdDQVR2QyxVQUFPLFVBQUEsQ0FBQTtBQVlwQjtBQzVLQSxTQUFTNEIsR0FBUztBQUFBLEVBQ2hCLHFCQUFBM0I7QUFBQSxFQUNBLHVCQUFBNEI7QUFBQSxFQUNBLG9CQUFBM0I7QUFDRixHQUFVO0FBRUYsUUFBQTRCLElBQWUsQ0FBQ3ZTLE1BQWdEO0FBQ3BFLFVBQU13UyxJQUFnQixPQUFPeFMsRUFBTSxPQUFPLEtBQUs7QUFDL0MsSUFBQXNTLEVBQXNCRSxDQUFhO0FBQUEsRUFBQTtBQUdyQyxTQUFBbEIsR0FBVSxNQUFNO0FBQ2QsWUFBUSxJQUFJWCxDQUFrQjtBQUFBLEVBQUEsR0FDN0IsQ0FBQ0EsQ0FBa0IsQ0FBQyxHQUdyQnZnRCxnQkFBQUEsRUFBQTtBQUFBLElBQUM7QUFBQSxJQUFBO0FBQUEsTUFDQyxVQUFVbWlEO0FBQUEsTUFDVixPQUFPNUI7QUFBQSxNQUNQLFdBQVcsc0VBQXVFQSxJQUFrQyxnQkFBYixVQUNyRztBQUFBLE1BRUYsVUFBQTtBQUFBLFFBQUF4Z0QsZ0JBQUFBLE1BQUMsVUFBTyxFQUFBLE9BQU0sSUFBRyxVQUFRLElBQUMsVUFFMUIsaUNBQUE7QUFBQSxRQUNDdWdELEVBQW9CLElBQUksQ0FBQy8wQyxHQUFNN0ssTUFDN0JWLGdCQUFBQSxPQUFBLFVBQUEsRUFBcUIsT0FBT1UsR0FDMUIsVUFBQTtBQUFBLFVBQUs2SyxFQUFBO0FBQUEsVUFBUTtBQUFBLFVBQUVBLEVBQUs7QUFBQSxRQUFBLEtBRFZBLEVBQUssRUFFbEIsQ0FDRDtBQUFBLE1BQUE7QUFBQSxJQUFBO0FBQUEsRUFBQTtBQUdQO0FDNUJhLE1BQUE4MkMsS0FBeUIsQ0FBQzVXLEdBQTBCNlcsTUFBMEI7QUFDekYsUUFBTSxDQUFDakMsR0FBWWUsQ0FBYSxJQUFJSCxHQUFTLGFBQWEsR0FDcEQsQ0FBQ2pPLEdBQVNxTyxDQUFVLElBQUlKLEdBQVMsR0FBRyxHQUNwQyxDQUFDVixHQUFvQjJCLENBQXFCLElBQUlqQixHQUFTLENBQUMsR0FLeEQsQ0FBQ3NCLEdBQVdDLENBQVksSUFBSXZCLEdBQVMsRUFBSyxHQUMxQyxDQUFDd0IsR0FBY0MsQ0FBZSxJQUFJekIsR0FBUyxFQUFLLEdBQ2hELENBQUMwQixHQUFhQyxDQUFjLElBQUkzQixHQUFTLEVBQUssR0FHOUM0QixJQUFVLE1BQU1MLEVBQWEsRUFBSSxHQUVqQzFGLElBQVMrRCxHQUFhLFlBQVk7QUFDdEMsUUFBRyxFQUFFMEIsS0FBYUQ7QUFDaEIsYUFBTyxRQUFRO0FBRWpCLElBQUFJLEVBQWdCLEVBQUk7QUFDZCxVQUFBSSxJQUFLLE1BQU0zQztBQUNqQixXQUFBdUMsRUFBZ0IsRUFBSyxHQUNORSxFQUFBLENBQUMsQ0FBQ0UsQ0FBRSxHQUVaQTtBQUFBLEVBQUEsR0FDTixDQUFDUCxHQUFXRCxDQUFXLENBQUMsR0FnQnJCaEMsSUFkdUJPLEdBQWEsWUFBWTtBQUNwRCxRQUFJLENBQUMvRDtBQUNIO0FBS0ksVUFBQWlHLElBQ0osTUFKZ0N0QyxHQUFnQjtBQUFBLE1BQ2hEM0Q7QUFBQSxJQUFBLEVBR2dDO0FBQ2xDLG1CQUFRLElBQUlpRyxDQUFXLEdBQ2hCQTtBQUFBLEtBRU4sQ0FBQ2pHLEdBQVFyUixDQUFlLEdBQUcsQ0FBMEIsQ0FBQSxLQUVKLElBRTlDdVgsSUFBV2pqRCxnQkFBQUEsRUFBQTtBQUFBLElBQUNraUQ7QUFBQSxJQUFBO0FBQUEsTUFDaEIsb0JBQUExQjtBQUFBLE1BQ0EsdUJBQUEyQjtBQUFBLE1BQ0EscUJBQUE1QjtBQUFBLElBQUE7QUFBQSxFQUFBLEdBR0kyQyxJQUFRbGpELGdCQUFBQSxFQUFBO0FBQUEsSUFBQ3FnRDtBQUFBLElBQUE7QUFBQSxNQUNiLFlBQUFDO0FBQUEsTUFDQSxxQkFBQUM7QUFBQSxNQUNBLG9CQUFBQztBQUFBLE1BQ0EsU0FBQXZOO0FBQUEsSUFBQTtBQUFBLEVBQUEsR0FHSWtRLElBQWU7QUFBQSxJQUNuQixZQUFBN0M7QUFBQSxJQUNBLGVBQUFlO0FBQUEsSUFDQSxTQUFBcE87QUFBQSxJQUNBLFlBQUFxTztBQUFBLElBQ0Esb0JBQUFkO0FBQUEsRUFBQSxHQUdJNEMsSUFBU3BqRCxnQkFBQUEsRUFBQTtBQUFBLElBQUMraEQ7QUFBQSxJQUFBO0FBQUEsTUFDYixHQUFHb0I7QUFBQSxJQUFBO0FBQUEsRUFBQSxHQVFBLEVBQUUsVUFBQXpCLEVBQUEsSUFBYU4sR0FBVStCLENBQVk7QUFFcEMsU0FBQTtBQUFBLElBQ0wsVUFBQXpCO0FBQUEsSUFDQSxxQkFBQW5CO0FBQUEsSUFDQSxlQUFBYztBQUFBLElBQ0EsWUFBQWY7QUFBQSxJQUNBLG9CQUFBRTtBQUFBLElBQ0EsdUJBQUEyQjtBQUFBLElBQ0EsU0FBQWxQO0FBQUEsSUFDQSxZQUFBcU87QUFBQSxJQUVBLFFBQUE4QjtBQUFBLElBQ0EsT0FBQUY7QUFBQSxJQUNBLFVBQUFEO0FBQUEsSUFFQSxTQUFBSDtBQUFBLElBQ0EsY0FBQUo7QUFBQSxJQUNBLGFBQUFFO0FBQUEsSUFDQSxRQUFBN0Y7QUFBQSxFQUFBO0FBRUo7QUFFQSxTQUF3QnNHLEtBQU07QUFDdEIsUUFBQTtBQUFBLElBQ0oscUJBQUE5QztBQUFBLElBQ0EsZUFBQWM7QUFBQSxJQUNBLFlBQUFmO0FBQUEsSUFDQSxvQkFBQUU7QUFBQSxJQUNBLHVCQUFBMkI7QUFBQSxJQUNBLFNBQUFsUDtBQUFBLElBQ0EsWUFBQXFPO0FBQUEsSUFDQSxTQUFBd0I7QUFBQSxJQUNBLFFBQUFNO0FBQUEsSUFDQSxPQUFBRjtBQUFBLElBQ0EsVUFBQUQ7QUFBQSxJQUNBLGFBQUFMO0FBQUEsRUFBQSxJQUNFTixHQUF1Qiw0Q0FBNEM7QUFFdkUsK0JBQ0csT0FBSSxFQUFBLFdBQVUsaURBRWIsVUFBQ3JpRCxnQkFBQUEsRUFBQSxLQUFBLE9BQUEsRUFBSSxXQUFVLHlHQUNoQixVQUFBO0FBQUEsSUFBQSxDQUFDMmlELEtBQWdCNWlELGdCQUFBQSxNQUFBLFVBQUEsRUFBTyxTQUFTLE1BQU04aUQsS0FBVyxVQUFPLFdBQUE7QUFBQSwwQkFDN0QsTUFBRyxFQUFBO0FBQUEsMEJBQUcsTUFBRyxFQUFBO0FBQUEsSUFDRHZDLEVBQW9CLFNBQVMsS0FDNUJ2Z0QsZ0JBQUFBLE1BQUE2a0MsRUFBQUEsVUFBQSxFQUNFLFVBQ0c1a0MsZ0JBQUFBLEVBQUEsS0FBQTRrQyxZQUFBLEVBQUEsVUFBQTtBQUFBLE1BQUF5YixLQUFjLGdCQUNiMkM7QUFBQSxNQUVEQztBQUFBLE1BQ0FFO0FBQUEsSUFBQSxFQUFBLENBQ0gsRUFxQkYsQ0FBQTtBQUFBLEVBQUEsRUFJSixDQUFBLEVBQ0YsQ0FBQTtBQUVKO0FBRU8sTUFBTUUsS0FBOEJEOyIsInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLDYyLDYzLDY0LDY1LDY2LDY3LDY4LDY5LDcwLDcxLDcyLDczXX0=
