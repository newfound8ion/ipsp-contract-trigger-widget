var Ef = Object.defineProperty;
var vf = (r, t, e) => t in r ? Ef(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;
var A = (r, t, e) => (vf(r, typeof t != "symbol" ? t + "" : t, e), e), Po = (r, t, e) => {
  if (!t.has(r))
    throw TypeError("Cannot " + e);
};
var l = (r, t, e) => (Po(r, t, "read from private field"), e ? e.call(r) : t.get(r)), b = (r, t, e) => {
  if (t.has(r))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(r) : t.set(r, e);
}, d = (r, t, e, n) => (Po(r, t, "write to private field"), n ? n.call(r, e) : t.set(r, e), e);
var Cs = (r, t, e, n) => ({
  set _(s) {
    d(r, t, s, e);
  },
  get _() {
    return l(r, t, n);
  }
}), O = (r, t, e) => (Po(r, t, "access private method"), e);
import gu, { useState as Un, useEffect as yu } from "react";
var Vo = { exports: {} }, gr = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var No, ec;
function mu() {
  if (ec)
    return No;
  ec = 1;
  var r = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, e = Object.prototype.propertyIsEnumerable;
  function n(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function s() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var o = {}, a = 0; a < 10; a++)
        o["_" + String.fromCharCode(a)] = a;
      var c = Object.getOwnPropertyNames(o).map(function(f) {
        return o[f];
      });
      if (c.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(f) {
        u[f] = f;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return No = s() ? Object.assign : function(i, o) {
    for (var a, c = n(i), u, f = 1; f < arguments.length; f++) {
      a = Object(arguments[f]);
      for (var h in a)
        t.call(a, h) && (c[h] = a[h]);
      if (r) {
        u = r(a);
        for (var g = 0; g < u.length; g++)
          e.call(a, u[g]) && (c[u[g]] = a[u[g]]);
      }
    }
    return c;
  }, No;
}
/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nc;
function xf() {
  if (nc)
    return gr;
  nc = 1, mu();
  var r = gu, t = 60103;
  if (gr.Fragment = 60107, typeof Symbol == "function" && Symbol.for) {
    var e = Symbol.for;
    t = e("react.element"), gr.Fragment = e("react.fragment");
  }
  var n = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = Object.prototype.hasOwnProperty, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(a, c, u) {
    var f, h = {}, g = null, w = null;
    u !== void 0 && (g = "" + u), c.key !== void 0 && (g = "" + c.key), c.ref !== void 0 && (w = c.ref);
    for (f in c)
      s.call(c, f) && !i.hasOwnProperty(f) && (h[f] = c[f]);
    if (a && a.defaultProps)
      for (f in c = a.defaultProps, c)
        h[f] === void 0 && (h[f] = c[f]);
    return { $$typeof: t, type: a, key: g, ref: w, props: h, _owner: n.current };
  }
  return gr.jsx = o, gr.jsxs = o, gr;
}
var Co = {};
/** @license React v17.0.2
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rc;
function Pf() {
  return rc || (rc = 1, function(r) {
    process.env.NODE_ENV !== "production" && function() {
      var t = gu, e = mu(), n = 60103, s = 60106;
      r.Fragment = 60107;
      var i = 60108, o = 60114, a = 60109, c = 60110, u = 60112, f = 60113, h = 60120, g = 60115, w = 60116, E = 60121, m = 60122, x = 60117, v = 60129, B = 60131;
      if (typeof Symbol == "function" && Symbol.for) {
        var T = Symbol.for;
        n = T("react.element"), s = T("react.portal"), r.Fragment = T("react.fragment"), i = T("react.strict_mode"), o = T("react.profiler"), a = T("react.provider"), c = T("react.context"), u = T("react.forward_ref"), f = T("react.suspense"), h = T("react.suspense_list"), g = T("react.memo"), w = T("react.lazy"), E = T("react.block"), m = T("react.server.block"), x = T("react.fundamental"), T("react.scope"), T("react.opaque.id"), v = T("react.debug_trace_mode"), T("react.offscreen"), B = T("react.legacy_hidden");
      }
      var H = typeof Symbol == "function" && Symbol.iterator, G = "@@iterator";
      function U(p) {
        if (p === null || typeof p != "object")
          return null;
        var N = H && p[H] || p[G];
        return typeof N == "function" ? N : null;
      }
      var D = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function S(p) {
        {
          for (var N = arguments.length, I = new Array(N > 1 ? N - 1 : 0), Q = 1; Q < N; Q++)
            I[Q - 1] = arguments[Q];
          nt("error", p, I);
        }
      }
      function nt(p, N, I) {
        {
          var Q = D.ReactDebugCurrentFrame, tt = Q.getStackAddendum();
          tt !== "" && (N += "%s", I = I.concat([tt]));
          var et = I.map(function(j) {
            return "" + j;
          });
          et.unshift("Warning: " + N), Function.prototype.apply.call(console[p], console, et);
        }
      }
      var Y = !1;
      function K(p) {
        return !!(typeof p == "string" || typeof p == "function" || p === r.Fragment || p === o || p === v || p === i || p === f || p === h || p === B || Y || typeof p == "object" && p !== null && (p.$$typeof === w || p.$$typeof === g || p.$$typeof === a || p.$$typeof === c || p.$$typeof === u || p.$$typeof === x || p.$$typeof === E || p[0] === m));
      }
      function Ot(p, N, I) {
        var Q = N.displayName || N.name || "";
        return p.displayName || (Q !== "" ? I + "(" + Q + ")" : I);
      }
      function bt(p) {
        return p.displayName || "Context";
      }
      function ht(p) {
        if (p == null)
          return null;
        if (typeof p.tag == "number" && S("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof p == "function")
          return p.displayName || p.name || null;
        if (typeof p == "string")
          return p;
        switch (p) {
          case r.Fragment:
            return "Fragment";
          case s:
            return "Portal";
          case o:
            return "Profiler";
          case i:
            return "StrictMode";
          case f:
            return "Suspense";
          case h:
            return "SuspenseList";
        }
        if (typeof p == "object")
          switch (p.$$typeof) {
            case c:
              var N = p;
              return bt(N) + ".Consumer";
            case a:
              var I = p;
              return bt(I._context) + ".Provider";
            case u:
              return Ot(p, p.render, "ForwardRef");
            case g:
              return ht(p.type);
            case E:
              return ht(p._render);
            case w: {
              var Q = p, tt = Q._payload, et = Q._init;
              try {
                return ht(et(tt));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var C = 0, k, _, $, Z, ct, Et, vt;
      function ce() {
      }
      ce.__reactDisabledLog = !0;
      function Ee() {
        {
          if (C === 0) {
            k = console.log, _ = console.info, $ = console.warn, Z = console.error, ct = console.group, Et = console.groupCollapsed, vt = console.groupEnd;
            var p = {
              configurable: !0,
              enumerable: !0,
              value: ce,
              writable: !0
            };
            Object.defineProperties(console, {
              info: p,
              log: p,
              warn: p,
              error: p,
              group: p,
              groupCollapsed: p,
              groupEnd: p
            });
          }
          C++;
        }
      }
      function on() {
        {
          if (C--, C === 0) {
            var p = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: e({}, p, {
                value: k
              }),
              info: e({}, p, {
                value: _
              }),
              warn: e({}, p, {
                value: $
              }),
              error: e({}, p, {
                value: Z
              }),
              group: e({}, p, {
                value: ct
              }),
              groupCollapsed: e({}, p, {
                value: Et
              }),
              groupEnd: e({}, p, {
                value: vt
              })
            });
          }
          C < 0 && S("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var Se = D.ReactCurrentDispatcher, Zt;
      function an(p, N, I) {
        {
          if (Zt === void 0)
            try {
              throw Error();
            } catch (tt) {
              var Q = tt.stack.trim().match(/\n( *(at )?)/);
              Zt = Q && Q[1] || "";
            }
          return `
` + Zt + p;
        }
      }
      var ue = !1, le;
      {
        var mi = typeof WeakMap == "function" ? WeakMap : Map;
        le = new mi();
      }
      function Ue(p, N) {
        if (!p || ue)
          return "";
        {
          var I = le.get(p);
          if (I !== void 0)
            return I;
        }
        var Q;
        ue = !0;
        var tt = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var et;
        et = Se.current, Se.current = null, Ee();
        try {
          if (N) {
            var j = function() {
              throw Error();
            };
            if (Object.defineProperty(j.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(j, []);
              } catch (Fe) {
                Q = Fe;
              }
              Reflect.construct(p, [], j);
            } else {
              try {
                j.call();
              } catch (Fe) {
                Q = Fe;
              }
              p.call(j.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Fe) {
              Q = Fe;
            }
            p();
          }
        } catch (Fe) {
          if (Fe && Q && typeof Fe.stack == "string") {
            for (var J = Fe.stack.split(`
`), It = Q.stack.split(`
`), ut = J.length - 1, ft = It.length - 1; ut >= 1 && ft >= 0 && J[ut] !== It[ft]; )
              ft--;
            for (; ut >= 1 && ft >= 0; ut--, ft--)
              if (J[ut] !== It[ft]) {
                if (ut !== 1 || ft !== 1)
                  do
                    if (ut--, ft--, ft < 0 || J[ut] !== It[ft]) {
                      var De = `
` + J[ut].replace(" at new ", " at ");
                      return typeof p == "function" && le.set(p, De), De;
                    }
                  while (ut >= 1 && ft >= 0);
                break;
              }
          }
        } finally {
          ue = !1, Se.current = et, on(), Error.prepareStackTrace = tt;
        }
        var pr = p ? p.displayName || p.name : "", tc = pr ? an(pr) : "";
        return typeof p == "function" && le.set(p, tc), tc;
      }
      function Ft(p, N, I) {
        return Ue(p, !1);
      }
      function cn(p) {
        var N = p.prototype;
        return !!(N && N.isReactComponent);
      }
      function Sn(p, N, I) {
        if (p == null)
          return "";
        if (typeof p == "function")
          return Ue(p, cn(p));
        if (typeof p == "string")
          return an(p);
        switch (p) {
          case f:
            return an("Suspense");
          case h:
            return an("SuspenseList");
        }
        if (typeof p == "object")
          switch (p.$$typeof) {
            case u:
              return Ft(p.render);
            case g:
              return Sn(p.type, N, I);
            case E:
              return Ft(p._render);
            case w: {
              var Q = p, tt = Q._payload, et = Q._init;
              try {
                return Sn(et(tt), N, I);
              } catch {
              }
            }
          }
        return "";
      }
      var Ps = {}, ja = D.ReactDebugCurrentFrame;
      function wi(p) {
        if (p) {
          var N = p._owner, I = Sn(p.type, p._source, N ? N.type : null);
          ja.setExtraStackFrame(I);
        } else
          ja.setExtraStackFrame(null);
      }
      function rf(p, N, I, Q, tt) {
        {
          var et = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var j in p)
            if (et(p, j)) {
              var J = void 0;
              try {
                if (typeof p[j] != "function") {
                  var It = Error((Q || "React class") + ": " + I + " type `" + j + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof p[j] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw It.name = "Invariant Violation", It;
                }
                J = p[j](N, j, Q, I, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ut) {
                J = ut;
              }
              J && !(J instanceof Error) && (wi(tt), S("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Q || "React class", I, j, typeof J), wi(null)), J instanceof Error && !(J.message in Ps) && (Ps[J.message] = !0, wi(tt), S("Failed %s type: %s", I, J.message), wi(null));
            }
        }
      }
      var Ns = D.ReactCurrentOwner, Ao = Object.prototype.hasOwnProperty, sf = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, za, Ka, bo;
      bo = {};
      function of(p) {
        if (Ao.call(p, "ref")) {
          var N = Object.getOwnPropertyDescriptor(p, "ref").get;
          if (N && N.isReactWarning)
            return !1;
        }
        return p.ref !== void 0;
      }
      function af(p) {
        if (Ao.call(p, "key")) {
          var N = Object.getOwnPropertyDescriptor(p, "key").get;
          if (N && N.isReactWarning)
            return !1;
        }
        return p.key !== void 0;
      }
      function cf(p, N) {
        if (typeof p.ref == "string" && Ns.current && N && Ns.current.stateNode !== N) {
          var I = ht(Ns.current.type);
          bo[I] || (S('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', ht(Ns.current.type), p.ref), bo[I] = !0);
        }
      }
      function uf(p, N) {
        {
          var I = function() {
            za || (za = !0, S("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", N));
          };
          I.isReactWarning = !0, Object.defineProperty(p, "key", {
            get: I,
            configurable: !0
          });
        }
      }
      function lf(p, N) {
        {
          var I = function() {
            Ka || (Ka = !0, S("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", N));
          };
          I.isReactWarning = !0, Object.defineProperty(p, "ref", {
            get: I,
            configurable: !0
          });
        }
      }
      var ff = function(p, N, I, Q, tt, et, j) {
        var J = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: n,
          // Built-in properties that belong on the element
          type: p,
          key: N,
          ref: I,
          props: j,
          // Record the component responsible for creating this element.
          _owner: et
        };
        return J._store = {}, Object.defineProperty(J._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(J, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Q
        }), Object.defineProperty(J, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: tt
        }), Object.freeze && (Object.freeze(J.props), Object.freeze(J)), J;
      };
      function hf(p, N, I, Q, tt) {
        {
          var et, j = {}, J = null, It = null;
          I !== void 0 && (J = "" + I), af(N) && (J = "" + N.key), of(N) && (It = N.ref, cf(N, tt));
          for (et in N)
            Ao.call(N, et) && !sf.hasOwnProperty(et) && (j[et] = N[et]);
          if (p && p.defaultProps) {
            var ut = p.defaultProps;
            for (et in ut)
              j[et] === void 0 && (j[et] = ut[et]);
          }
          if (J || It) {
            var ft = typeof p == "function" ? p.displayName || p.name || "Unknown" : p;
            J && uf(j, ft), It && lf(j, ft);
          }
          return ff(p, J, It, tt, Q, Ns.current, j);
        }
      }
      var Eo = D.ReactCurrentOwner, Wa = D.ReactDebugCurrentFrame;
      function dr(p) {
        if (p) {
          var N = p._owner, I = Sn(p.type, p._source, N ? N.type : null);
          Wa.setExtraStackFrame(I);
        } else
          Wa.setExtraStackFrame(null);
      }
      var vo;
      vo = !1;
      function xo(p) {
        return typeof p == "object" && p !== null && p.$$typeof === n;
      }
      function Ya() {
        {
          if (Eo.current) {
            var p = ht(Eo.current.type);
            if (p)
              return `

Check the render method of \`` + p + "`.";
          }
          return "";
        }
      }
      function df(p) {
        {
          if (p !== void 0) {
            var N = p.fileName.replace(/^.*[\\\/]/, ""), I = p.lineNumber;
            return `

Check your code at ` + N + ":" + I + ".";
          }
          return "";
        }
      }
      var Za = {};
      function pf(p) {
        {
          var N = Ya();
          if (!N) {
            var I = typeof p == "string" ? p : p.displayName || p.name;
            I && (N = `

Check the top-level render call using <` + I + ">.");
          }
          return N;
        }
      }
      function Xa(p, N) {
        {
          if (!p._store || p._store.validated || p.key != null)
            return;
          p._store.validated = !0;
          var I = pf(N);
          if (Za[I])
            return;
          Za[I] = !0;
          var Q = "";
          p && p._owner && p._owner !== Eo.current && (Q = " It was passed a child from " + ht(p._owner.type) + "."), dr(p), S('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', I, Q), dr(null);
        }
      }
      function qa(p, N) {
        {
          if (typeof p != "object")
            return;
          if (Array.isArray(p))
            for (var I = 0; I < p.length; I++) {
              var Q = p[I];
              xo(Q) && Xa(Q, N);
            }
          else if (xo(p))
            p._store && (p._store.validated = !0);
          else if (p) {
            var tt = U(p);
            if (typeof tt == "function" && tt !== p.entries)
              for (var et = tt.call(p), j; !(j = et.next()).done; )
                xo(j.value) && Xa(j.value, N);
          }
        }
      }
      function gf(p) {
        {
          var N = p.type;
          if (N == null || typeof N == "string")
            return;
          var I;
          if (typeof N == "function")
            I = N.propTypes;
          else if (typeof N == "object" && (N.$$typeof === u || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          N.$$typeof === g))
            I = N.propTypes;
          else
            return;
          if (I) {
            var Q = ht(N);
            rf(I, p.props, "prop", Q, p);
          } else if (N.PropTypes !== void 0 && !vo) {
            vo = !0;
            var tt = ht(N);
            S("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", tt || "Unknown");
          }
          typeof N.getDefaultProps == "function" && !N.getDefaultProps.isReactClassApproved && S("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function yf(p) {
        {
          for (var N = Object.keys(p.props), I = 0; I < N.length; I++) {
            var Q = N[I];
            if (Q !== "children" && Q !== "key") {
              dr(p), S("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Q), dr(null);
              break;
            }
          }
          p.ref !== null && (dr(p), S("Invalid attribute `ref` supplied to `React.Fragment`."), dr(null));
        }
      }
      function $a(p, N, I, Q, tt, et) {
        {
          var j = K(p);
          if (!j) {
            var J = "";
            (p === void 0 || typeof p == "object" && p !== null && Object.keys(p).length === 0) && (J += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
            var It = df(tt);
            It ? J += It : J += Ya();
            var ut;
            p === null ? ut = "null" : Array.isArray(p) ? ut = "array" : p !== void 0 && p.$$typeof === n ? (ut = "<" + (ht(p.type) || "Unknown") + " />", J = " Did you accidentally export a JSX literal instead of a component?") : ut = typeof p, S("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", ut, J);
          }
          var ft = hf(p, N, I, tt, et);
          if (ft == null)
            return ft;
          if (j) {
            var De = N.children;
            if (De !== void 0)
              if (Q)
                if (Array.isArray(De)) {
                  for (var pr = 0; pr < De.length; pr++)
                    qa(De[pr], p);
                  Object.freeze && Object.freeze(De);
                } else
                  S("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
              else
                qa(De, p);
          }
          return p === r.Fragment ? yf(ft) : gf(ft), ft;
        }
      }
      function mf(p, N, I) {
        return $a(p, N, I, !0);
      }
      function wf(p, N, I) {
        return $a(p, N, I, !1);
      }
      var Af = wf, bf = mf;
      r.jsx = Af, r.jsxs = bf;
    }();
  }(Co)), Co;
}
process.env.NODE_ENV === "production" ? Vo.exports = xf() : Vo.exports = Pf();
var q = Vo.exports;
const Nf = "6.9.0";
function Cf(r, t, e) {
  const n = t.split("|").map((i) => i.trim());
  for (let i = 0; i < n.length; i++)
    switch (t) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof r === t)
          return;
    }
  const s = new Error(`invalid value for type ${t}`);
  throw s.code = "INVALID_ARGUMENT", s.argument = `value.${e}`, s.value = r, s;
}
async function Rt(r) {
  const t = Object.keys(r);
  return (await Promise.all(t.map((n) => Promise.resolve(r[n])))).reduce((n, s, i) => (n[t[i]] = s, n), {});
}
function M(r, t, e) {
  for (let n in t) {
    let s = t[n];
    const i = e ? e[n] : null;
    i && Cf(s, i, n), Object.defineProperty(r, n, { enumerable: !0, value: s, writable: !1 });
  }
}
function vr(r) {
  if (r == null)
    return "null";
  if (Array.isArray(r))
    return "[ " + r.map(vr).join(", ") + " ]";
  if (r instanceof Uint8Array) {
    const t = "0123456789abcdef";
    let e = "0x";
    for (let n = 0; n < r.length; n++)
      e += t[r[n] >> 4], e += t[r[n] & 15];
    return e;
  }
  if (typeof r == "object" && typeof r.toJSON == "function")
    return vr(r.toJSON());
  switch (typeof r) {
    case "boolean":
    case "symbol":
      return r.toString();
    case "bigint":
      return BigInt(r).toString();
    case "number":
      return r.toString();
    case "string":
      return JSON.stringify(r);
    case "object": {
      const t = Object.keys(r);
      return t.sort(), "{ " + t.map((e) => `${vr(e)}: ${vr(r[e])}`).join(", ") + " }";
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function oe(r, t) {
  return r && r.code === t;
}
function ba(r) {
  return oe(r, "CALL_EXCEPTION");
}
function dt(r, t, e) {
  let n = r;
  {
    const i = [];
    if (e) {
      if ("message" in e || "code" in e || "name" in e)
        throw new Error(`value will overwrite populated values: ${vr(e)}`);
      for (const o in e) {
        if (o === "shortMessage")
          continue;
        const a = e[o];
        i.push(o + "=" + vr(a));
      }
    }
    i.push(`code=${t}`), i.push(`version=${Nf}`), i.length && (r += " (" + i.join(", ") + ")");
  }
  let s;
  switch (t) {
    case "INVALID_ARGUMENT":
      s = new TypeError(r);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      s = new RangeError(r);
      break;
    default:
      s = new Error(r);
  }
  return M(s, { code: t }), e && Object.assign(s, e), s.shortMessage == null && M(s, { shortMessage: n }), s;
}
function P(r, t, e, n) {
  if (!r)
    throw dt(t, e, n);
}
function y(r, t, e, n) {
  P(r, t, "INVALID_ARGUMENT", { argument: e, value: n });
}
function wu(r, t, e) {
  e == null && (e = ""), e && (e = ": " + e), P(r >= t, "missing arguemnt" + e, "MISSING_ARGUMENT", {
    count: r,
    expectedCount: t
  }), P(r <= t, "too many arguemnts" + e, "UNEXPECTED_ARGUMENT", {
    count: r,
    expectedCount: t
  });
}
const Tf = ["NFD", "NFC", "NFKD", "NFKC"].reduce((r, t) => {
  try {
    if ("test".normalize(t) !== "test")
      throw new Error("bad");
    if (t === "NFD") {
      const e = String.fromCharCode(233).normalize("NFD"), n = String.fromCharCode(101, 769);
      if (e !== n)
        throw new Error("broken");
    }
    r.push(t);
  } catch {
  }
  return r;
}, []);
function Of(r) {
  P(Tf.indexOf(r) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form: r }
  });
}
function so(r, t, e) {
  if (e == null && (e = ""), r !== t) {
    let n = e, s = "new";
    e && (n += ".", s += " " + e), P(!1, `private constructor; use ${n}from* methods`, "UNSUPPORTED_OPERATION", {
      operation: s
    });
  }
}
function Au(r, t, e) {
  if (r instanceof Uint8Array)
    return e ? new Uint8Array(r) : r;
  if (typeof r == "string" && r.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
    const n = new Uint8Array((r.length - 2) / 2);
    let s = 2;
    for (let i = 0; i < n.length; i++)
      n[i] = parseInt(r.substring(s, s + 2), 16), s += 2;
    return n;
  }
  y(!1, "invalid BytesLike value", t || "value", r);
}
function X(r, t) {
  return Au(r, t, !1);
}
function Ht(r, t) {
  return Au(r, t, !0);
}
function ot(r, t) {
  return !(typeof r != "string" || !r.match(/^0x[0-9A-Fa-f]*$/) || typeof t == "number" && r.length !== 2 + 2 * t || t === !0 && r.length % 2 !== 0);
}
function If(r) {
  return ot(r, !0) || r instanceof Uint8Array;
}
const sc = "0123456789abcdef";
function F(r) {
  const t = X(r);
  let e = "0x";
  for (let n = 0; n < t.length; n++) {
    const s = t[n];
    e += sc[(s & 240) >> 4] + sc[s & 15];
  }
  return e;
}
function pt(r) {
  return "0x" + r.map((t) => F(t).substring(2)).join("");
}
function Ir(r) {
  return ot(r, !0) ? (r.length - 2) / 2 : X(r).length;
}
function at(r, t, e) {
  const n = X(r);
  return e != null && e > n.length && P(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
    buffer: n,
    length: n.length,
    offset: e
  }), F(n.slice(t ?? 0, e ?? n.length));
}
function bu(r, t, e) {
  const n = X(r);
  P(t >= n.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(n),
    length: t,
    offset: t + 1
  });
  const s = new Uint8Array(t);
  return s.fill(0), e ? s.set(n, t - n.length) : s.set(n, 0), F(s);
}
function ar(r, t) {
  return bu(r, t, !0);
}
function Bf(r, t) {
  return bu(r, t, !1);
}
const io = BigInt(0), me = BigInt(1), xr = 9007199254740991;
function Rf(r, t) {
  const e = oo(r, "value"), n = BigInt(V(t, "width"));
  if (P(e >> n === io, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: r
  }), e >> n - me) {
    const s = (me << n) - me;
    return -((~e & s) + me);
  }
  return e;
}
function Eu(r, t) {
  let e = L(r, "value");
  const n = BigInt(V(t, "width")), s = me << n - me;
  if (e < io) {
    e = -e, P(e <= s, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: r
    });
    const i = (me << n) - me;
    return (~e & i) + me;
  } else
    P(e < s, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: r
    });
  return e;
}
function Is(r, t) {
  const e = oo(r, "value"), n = BigInt(V(t, "bits"));
  return e & (me << n) - me;
}
function L(r, t) {
  switch (typeof r) {
    case "bigint":
      return r;
    case "number":
      return y(Number.isInteger(r), "underflow", t || "value", r), y(r >= -xr && r <= xr, "overflow", t || "value", r), BigInt(r);
    case "string":
      try {
        if (r === "")
          throw new Error("empty string");
        return r[0] === "-" && r[1] !== "-" ? -BigInt(r.substring(1)) : BigInt(r);
      } catch (e) {
        y(!1, `invalid BigNumberish string: ${e.message}`, t || "value", r);
      }
  }
  y(!1, "invalid BigNumberish value", t || "value", r);
}
function oo(r, t) {
  const e = L(r, t);
  return P(e >= io, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value: r
  }), e;
}
const ic = "0123456789abcdef";
function Ea(r) {
  if (r instanceof Uint8Array) {
    let t = "0x0";
    for (const e of r)
      t += ic[e >> 4], t += ic[e & 15];
    return BigInt(t);
  }
  return L(r);
}
function V(r, t) {
  switch (typeof r) {
    case "bigint":
      return y(r >= -xr && r <= xr, "overflow", t || "value", r), Number(r);
    case "number":
      return y(Number.isInteger(r), "underflow", t || "value", r), y(r >= -xr && r <= xr, "overflow", t || "value", r), r;
    case "string":
      try {
        if (r === "")
          throw new Error("empty string");
        return V(BigInt(r), t);
      } catch (e) {
        y(!1, `invalid numeric string: ${e.message}`, t || "value", r);
      }
  }
  y(!1, "invalid numeric value", t || "value", r);
}
function kf(r) {
  return V(Ea(r));
}
function Bn(r, t) {
  let n = oo(r, "value").toString(16);
  if (t == null)
    n.length % 2 && (n = "0" + n);
  else {
    const s = V(t, "width");
    for (P(s * 2 >= n.length, `value exceeds width (${s} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: r
    }); n.length < s * 2; )
      n = "0" + n;
  }
  return "0x" + n;
}
function Yt(r) {
  const t = oo(r, "value");
  if (t === io)
    return new Uint8Array([]);
  let e = t.toString(16);
  e.length % 2 && (e = "0" + e);
  const n = new Uint8Array(e.length / 2);
  for (let s = 0; s < n.length; s++) {
    const i = s * 2;
    n[s] = parseInt(e.substring(i, i + 2), 16);
  }
  return n;
}
function Pr(r) {
  let t = F(If(r) ? r : Yt(r)).substring(2);
  for (; t.startsWith("0"); )
    t = t.substring(1);
  return t === "" && (t = "0"), "0x" + t;
}
const Sf = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
BigInt(0);
const oc = BigInt(58);
function Uf(r) {
  let t = Ea(X(r)), e = "";
  for (; t; )
    e = Sf[Number(t % oc)] + e, t /= oc;
  return e;
}
function Df(r) {
  r = atob(r);
  const t = new Uint8Array(r.length);
  for (let e = 0; e < r.length; e++)
    t[e] = r.charCodeAt(e);
  return X(t);
}
function Ff(r) {
  const t = X(r);
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += String.fromCharCode(t[n]);
  return btoa(e);
}
var Rr;
class vu {
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(t, e, n) {
    /**
     *  The event filter.
     */
    A(this, "filter");
    /**
     *  The **EventEmitterable**.
     */
    A(this, "emitter");
    b(this, Rr, void 0);
    d(this, Rr, e), M(this, { emitter: t, filter: n });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    l(this, Rr) != null && await this.emitter.off(this.filter, l(this, Rr));
  }
}
Rr = new WeakMap();
function Lf(r, t, e, n, s) {
  y(!1, `invalid codepoint at offset ${t}; ${r}`, "bytes", e);
}
function xu(r, t, e, n, s) {
  if (r === "BAD_PREFIX" || r === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o = t + 1; o < e.length && e[o] >> 6 === 2; o++)
      i++;
    return i;
  }
  return r === "OVERRUN" ? e.length - t - 1 : 0;
}
function Mf(r, t, e, n, s) {
  return r === "OVERLONG" ? (y(typeof s == "number", "invalid bad code point for replacement", "badCodepoint", s), n.push(s), 0) : (n.push(65533), xu(r, t, e));
}
const Gf = Object.freeze({
  error: Lf,
  ignore: xu,
  replace: Mf
});
function Qf(r, t) {
  t == null && (t = Gf.error);
  const e = X(r, "bytes"), n = [];
  let s = 0;
  for (; s < e.length; ) {
    const i = e[s++];
    if (!(i >> 7)) {
      n.push(i);
      continue;
    }
    let o = null, a = null;
    if ((i & 224) === 192)
      o = 1, a = 127;
    else if ((i & 240) === 224)
      o = 2, a = 2047;
    else if ((i & 248) === 240)
      o = 3, a = 65535;
    else {
      (i & 192) === 128 ? s += t("UNEXPECTED_CONTINUE", s - 1, e, n) : s += t("BAD_PREFIX", s - 1, e, n);
      continue;
    }
    if (s - 1 + o >= e.length) {
      s += t("OVERRUN", s - 1, e, n);
      continue;
    }
    let c = i & (1 << 8 - o - 1) - 1;
    for (let u = 0; u < o; u++) {
      let f = e[s];
      if ((f & 192) != 128) {
        s += t("MISSING_CONTINUE", s, e, n), c = null;
        break;
      }
      c = c << 6 | f & 63, s++;
    }
    if (c !== null) {
      if (c > 1114111) {
        s += t("OUT_OF_RANGE", s - 1 - o, e, n, c);
        continue;
      }
      if (c >= 55296 && c <= 57343) {
        s += t("UTF16_SURROGATE", s - 1 - o, e, n, c);
        continue;
      }
      if (c <= a) {
        s += t("OVERLONG", s - 1 - o, e, n, c);
        continue;
      }
      n.push(c);
    }
  }
  return n;
}
function en(r, t) {
  t != null && (Of(t), r = r.normalize(t));
  let e = [];
  for (let n = 0; n < r.length; n++) {
    const s = r.charCodeAt(n);
    if (s < 128)
      e.push(s);
    else if (s < 2048)
      e.push(s >> 6 | 192), e.push(s & 63 | 128);
    else if ((s & 64512) == 55296) {
      n++;
      const i = r.charCodeAt(n);
      y(n < r.length && (i & 64512) === 56320, "invalid surrogate pair", "str", r);
      const o = 65536 + ((s & 1023) << 10) + (i & 1023);
      e.push(o >> 18 | 240), e.push(o >> 12 & 63 | 128), e.push(o >> 6 & 63 | 128), e.push(o & 63 | 128);
    } else
      e.push(s >> 12 | 224), e.push(s >> 6 & 63 | 128), e.push(s & 63 | 128);
  }
  return new Uint8Array(e);
}
function Hf(r) {
  return r.map((t) => t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10 & 1023) + 55296, (t & 1023) + 56320))).join("");
}
function va(r, t) {
  return Hf(Qf(r, t));
}
function Pu(r) {
  async function t(e, n) {
    const s = e.url.split(":")[0].toLowerCase();
    P(s === "http" || s === "https", `unsupported protocol ${s}`, "UNSUPPORTED_OPERATION", {
      info: { protocol: s },
      operation: "request"
    }), P(s === "https" || !e.credentials || e.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let i;
    if (n) {
      const h = new AbortController();
      i = h.signal, n.addListener(() => {
        h.abort();
      });
    }
    const o = {
      method: e.method,
      headers: new Headers(Array.from(e)),
      body: e.body || void 0,
      signal: i
    }, a = await fetch(e.url, o), c = {};
    a.headers.forEach((h, g) => {
      c[g.toLowerCase()] = h;
    });
    const u = await a.arrayBuffer(), f = u == null ? null : new Uint8Array(u);
    return {
      statusCode: a.status,
      statusMessage: a.statusText,
      headers: c,
      body: f
    };
  }
  return t;
}
const _f = 12, Vf = 250;
let ac = Pu();
const Jf = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), jf = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let To = !1;
async function Nu(r, t) {
  try {
    const e = r.match(Jf);
    if (!e)
      throw new Error("invalid data");
    return new On(200, "OK", {
      "content-type": e[1] || "text/plain"
    }, e[2] ? Df(e[3]) : Kf(e[3]));
  } catch {
    return new On(599, "BAD REQUEST (invalid data: URI)", {}, null, new Rn(r));
  }
}
function Cu(r) {
  async function t(e, n) {
    try {
      const s = e.match(jf);
      if (!s)
        throw new Error("invalid link");
      return new Rn(`${r}${s[2]}`);
    } catch {
      return new On(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new Rn(e));
    }
  }
  return t;
}
const Ai = {
  data: Nu,
  ipfs: Cu("https://gateway.ipfs.io/ipfs/")
}, Tu = /* @__PURE__ */ new WeakMap();
var Qn, dn;
class zf {
  constructor(t) {
    b(this, Qn, void 0);
    b(this, dn, void 0);
    d(this, Qn, []), d(this, dn, !1), Tu.set(t, () => {
      if (!l(this, dn)) {
        d(this, dn, !0);
        for (const e of l(this, Qn))
          setTimeout(() => {
            e();
          }, 0);
        d(this, Qn, []);
      }
    });
  }
  addListener(t) {
    P(!l(this, dn), "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    }), l(this, Qn).push(t);
  }
  get cancelled() {
    return l(this, dn);
  }
  checkSignal() {
    P(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
Qn = new WeakMap(), dn = new WeakMap();
function bi(r) {
  if (r == null)
    throw new Error("missing signal; should not happen");
  return r.checkSignal(), r;
}
var kr, Sr, de, Qe, Ur, Dr, gt, jt, He, Hn, _n, Vn, xe, _e, pn, Jn, Bs;
const Zi = class Zi {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(t) {
    b(this, Jn);
    b(this, kr, void 0);
    b(this, Sr, void 0);
    b(this, de, void 0);
    b(this, Qe, void 0);
    b(this, Ur, void 0);
    b(this, Dr, void 0);
    b(this, gt, void 0);
    b(this, jt, void 0);
    b(this, He, void 0);
    // Hooks
    b(this, Hn, void 0);
    b(this, _n, void 0);
    b(this, Vn, void 0);
    b(this, xe, void 0);
    b(this, _e, void 0);
    b(this, pn, void 0);
    d(this, Dr, String(t)), d(this, kr, !1), d(this, Sr, !0), d(this, de, {}), d(this, Qe, ""), d(this, Ur, 3e5), d(this, _e, {
      slotInterval: Vf,
      maxAttempts: _f
    }), d(this, pn, null);
  }
  /**
   *  The fetch URL to request.
   */
  get url() {
    return l(this, Dr);
  }
  set url(t) {
    d(this, Dr, String(t));
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    return l(this, gt) == null ? null : new Uint8Array(l(this, gt));
  }
  set body(t) {
    if (t == null)
      d(this, gt, void 0), d(this, jt, void 0);
    else if (typeof t == "string")
      d(this, gt, en(t)), d(this, jt, "text/plain");
    else if (t instanceof Uint8Array)
      d(this, gt, t), d(this, jt, "application/octet-stream");
    else if (typeof t == "object")
      d(this, gt, en(JSON.stringify(t))), d(this, jt, "application/json");
    else
      throw new Error("invalid body");
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return l(this, gt) != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    return l(this, Qe) ? l(this, Qe) : this.hasBody() ? "POST" : "GET";
  }
  set method(t) {
    t == null && (t = ""), d(this, Qe, String(t).toUpperCase());
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const t = Object.assign({}, l(this, de));
    return l(this, He) && (t.authorization = `Basic ${Ff(en(l(this, He)))}`), this.allowGzip && (t["accept-encoding"] = "gzip"), t["content-type"] == null && l(this, jt) && (t["content-type"] = l(this, jt)), this.body && (t["content-length"] = String(this.body.length)), t;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(t) {
    return this.headers[t.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(t, e) {
    l(this, de)[String(t).toLowerCase()] = String(e);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    d(this, de, {});
  }
  [Symbol.iterator]() {
    const t = this.headers, e = Object.keys(t);
    let n = 0;
    return {
      next: () => {
        if (n < e.length) {
          const s = e[n++];
          return {
            value: [s, t[s]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return l(this, He) || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(t, e) {
    y(!t.match(/:/), "invalid basic authentication username", "username", "[REDACTED]"), d(this, He, `${t}:${e}`);
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return l(this, Sr);
  }
  set allowGzip(t) {
    d(this, Sr, !!t);
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!l(this, kr);
  }
  set allowInsecureAuthentication(t) {
    d(this, kr, !!t);
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return l(this, Ur);
  }
  set timeout(t) {
    y(t >= 0, "timeout must be non-zero", "timeout", t), d(this, Ur, t);
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return l(this, Hn) || null;
  }
  set preflightFunc(t) {
    d(this, Hn, t);
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return l(this, _n) || null;
  }
  set processFunc(t) {
    d(this, _n, t);
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return l(this, Vn) || null;
  }
  set retryFunc(t) {
    d(this, Vn, t);
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return l(this, pn) || ac;
  }
  set getUrlFunc(t) {
    d(this, pn, t);
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${l(this, gt) ? F(l(this, gt)) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(t) {
    t.slotInterval != null && (l(this, _e).slotInterval = t.slotInterval), t.maxAttempts != null && (l(this, _e).maxAttempts = t.maxAttempts);
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    return P(l(this, xe) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" }), d(this, xe, new zf(this)), O(this, Jn, Bs).call(this, 0, cc() + this.timeout, 0, this, new On(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    P(l(this, xe) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const t = Tu.get(this);
    if (!t)
      throw new Error("missing signal; should not happen");
    t();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(t) {
    const e = this.url.split(":")[0].toLowerCase(), n = t.split(":")[0].toLowerCase();
    P(this.method === "GET" && (e !== "https" || n !== "http") && t.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(t)})`
    });
    const s = new Zi(t);
    return s.method = "GET", s.allowGzip = this.allowGzip, s.timeout = this.timeout, d(s, de, Object.assign({}, l(this, de))), l(this, gt) && d(s, gt, new Uint8Array(l(this, gt))), d(s, jt, l(this, jt)), s;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const t = new Zi(this.url);
    return d(t, Qe, l(this, Qe)), l(this, gt) && d(t, gt, l(this, gt)), d(t, jt, l(this, jt)), d(t, de, Object.assign({}, l(this, de))), d(t, He, l(this, He)), this.allowGzip && (t.allowGzip = !0), t.timeout = this.timeout, this.allowInsecureAuthentication && (t.allowInsecureAuthentication = !0), d(t, Hn, l(this, Hn)), d(t, _n, l(this, _n)), d(t, Vn, l(this, Vn)), d(t, pn, l(this, pn)), t;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    To = !0;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(t) {
    return Ai[t.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(t, e) {
    if (t = t.toLowerCase(), t === "http" || t === "https")
      throw new Error(`cannot intercept ${t}; use registerGetUrl`);
    if (To)
      throw new Error("gateways locked");
    Ai[t] = e;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(t) {
    if (To)
      throw new Error("gateways locked");
    ac = t;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(t) {
    return Pu();
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return Nu;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(t) {
    return Cu(t);
  }
};
kr = new WeakMap(), Sr = new WeakMap(), de = new WeakMap(), Qe = new WeakMap(), Ur = new WeakMap(), Dr = new WeakMap(), gt = new WeakMap(), jt = new WeakMap(), He = new WeakMap(), Hn = new WeakMap(), _n = new WeakMap(), Vn = new WeakMap(), xe = new WeakMap(), _e = new WeakMap(), pn = new WeakMap(), Jn = new WeakSet(), Bs = async function(t, e, n, s, i) {
  var f, h, g;
  if (t >= l(this, _e).maxAttempts)
    return i.makeServerError("exceeded maximum retry limit");
  P(cc() <= e, "timeout", "TIMEOUT", {
    operation: "request.send",
    reason: "timeout",
    request: s
  }), n > 0 && await Wf(n);
  let o = this.clone();
  const a = (o.url.split(":")[0] || "").toLowerCase();
  if (a in Ai) {
    const w = await Ai[a](o.url, bi(l(s, xe)));
    if (w instanceof On) {
      let E = w;
      if (this.processFunc) {
        bi(l(s, xe));
        try {
          E = await this.processFunc(o, E);
        } catch (m) {
          (m.throttle == null || typeof m.stall != "number") && E.makeServerError("error in post-processing function", m).assertOk();
        }
      }
      return E;
    }
    o = w;
  }
  this.preflightFunc && (o = await this.preflightFunc(o));
  const c = await this.getUrlFunc(o, bi(l(s, xe)));
  let u = new On(c.statusCode, c.statusMessage, c.headers, c.body, s);
  if (u.statusCode === 301 || u.statusCode === 302) {
    try {
      const w = u.headers.location || "";
      return O(f = o.redirect(w), Jn, Bs).call(f, t + 1, e, 0, s, u);
    } catch {
    }
    return u;
  } else if (u.statusCode === 429 && (this.retryFunc == null || await this.retryFunc(o, u, t))) {
    const w = u.headers["retry-after"];
    let E = l(this, _e).slotInterval * Math.trunc(Math.random() * Math.pow(2, t));
    return typeof w == "string" && w.match(/^[1-9][0-9]*$/) && (E = parseInt(w)), O(h = o.clone(), Jn, Bs).call(h, t + 1, e, E, s, u);
  }
  if (this.processFunc) {
    bi(l(s, xe));
    try {
      u = await this.processFunc(o, u);
    } catch (w) {
      (w.throttle == null || typeof w.stall != "number") && u.makeServerError("error in post-processing function", w).assertOk();
      let E = l(this, _e).slotInterval * Math.trunc(Math.random() * Math.pow(2, t));
      return w.stall >= 0 && (E = w.stall), O(g = o.clone(), Jn, Bs).call(g, t + 1, e, E, s, u);
    }
  }
  return u;
};
let Rn = Zi;
var Zs, Xs, qs, pe, Fr, jn;
const _a = class _a {
  constructor(t, e, n, s, i) {
    b(this, Zs, void 0);
    b(this, Xs, void 0);
    b(this, qs, void 0);
    b(this, pe, void 0);
    b(this, Fr, void 0);
    b(this, jn, void 0);
    d(this, Zs, t), d(this, Xs, e), d(this, qs, Object.keys(n).reduce((o, a) => (o[a.toLowerCase()] = String(n[a]), o), {})), d(this, pe, s == null ? null : new Uint8Array(s)), d(this, Fr, i || null), d(this, jn, { message: "" });
  }
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${l(this, pe) ? F(l(this, pe)) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return l(this, Zs);
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return l(this, Xs);
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, l(this, qs));
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return l(this, pe) == null ? null : new Uint8Array(l(this, pe));
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return l(this, pe) == null ? "" : va(l(this, pe));
    } catch {
      P(!1, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch {
      P(!1, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const t = this.headers, e = Object.keys(t);
    let n = 0;
    return {
      next: () => {
        if (n < e.length) {
          const s = e[n++];
          return {
            value: [s, t[s]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(t, e) {
    let n;
    t ? n = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${t})` : (t = `${this.statusCode} ${this.statusMessage}`, n = `CLIENT ESCALATED SERVER ERROR (${t})`);
    const s = new _a(599, n, this.headers, this.body, l(this, Fr) || void 0);
    return d(s, jn, { message: t, error: e }), s;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(t, e) {
    e == null ? e = -1 : y(Number.isInteger(e) && e >= 0, "invalid stall timeout", "stall", e);
    const n = new Error(t || "throttling requests");
    throw M(n, { stall: e, throttle: !0 }), n;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(t) {
    return this.headers[t.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return l(this, pe) != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return l(this, Fr);
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return l(this, jn).message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok())
      return;
    let { message: t, error: e } = l(this, jn);
    t === "" && (t = `server response ${this.statusCode} ${this.statusMessage}`), P(!1, t, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error: e
    });
  }
};
Zs = new WeakMap(), Xs = new WeakMap(), qs = new WeakMap(), pe = new WeakMap(), Fr = new WeakMap(), jn = new WeakMap();
let On = _a;
function cc() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function Kf(r) {
  return en(r.replace(/%([0-9a-f][0-9a-f])/gi, (t, e) => String.fromCharCode(parseInt(e, 16))));
}
function Wf(r) {
  return new Promise((t) => setTimeout(t, r));
}
function Yf(r) {
  let t = r.toString(16);
  for (; t.length < 2; )
    t = "0" + t;
  return "0x" + t;
}
function uc(r, t, e) {
  let n = 0;
  for (let s = 0; s < e; s++)
    n = n * 256 + r[t + s];
  return n;
}
function lc(r, t, e, n) {
  const s = [];
  for (; e < t + 1 + n; ) {
    const i = Ou(r, e);
    s.push(i.result), e += i.consumed, P(e <= t + 1 + n, "child data too short", "BUFFER_OVERRUN", {
      buffer: r,
      length: n,
      offset: t
    });
  }
  return { consumed: 1 + n, result: s };
}
function Ou(r, t) {
  P(r.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: r,
    length: 0,
    offset: 1
  });
  const e = (n) => {
    P(n <= r.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: r,
      length: r.length,
      offset: n
    });
  };
  if (r[t] >= 248) {
    const n = r[t] - 247;
    e(t + 1 + n);
    const s = uc(r, t + 1, n);
    return e(t + 1 + n + s), lc(r, t, t + 1 + n, n + s);
  } else if (r[t] >= 192) {
    const n = r[t] - 192;
    return e(t + 1 + n), lc(r, t, t + 1, n);
  } else if (r[t] >= 184) {
    const n = r[t] - 183;
    e(t + 1 + n);
    const s = uc(r, t + 1, n);
    e(t + 1 + n + s);
    const i = F(r.slice(t + 1 + n, t + 1 + n + s));
    return { consumed: 1 + n + s, result: i };
  } else if (r[t] >= 128) {
    const n = r[t] - 128;
    e(t + 1 + n);
    const s = F(r.slice(t + 1, t + 1 + n));
    return { consumed: 1 + n, result: s };
  }
  return { consumed: 1, result: Yf(r[t]) };
}
function xa(r) {
  const t = X(r, "data"), e = Ou(t, 0);
  return y(e.consumed === t.length, "unexpected junk after rlp payload", "data", r), e.result;
}
function fc(r) {
  const t = [];
  for (; r; )
    t.unshift(r & 255), r >>= 8;
  return t;
}
function Iu(r) {
  if (Array.isArray(r)) {
    let n = [];
    if (r.forEach(function(i) {
      n = n.concat(Iu(i));
    }), n.length <= 55)
      return n.unshift(192 + n.length), n;
    const s = fc(n.length);
    return s.unshift(247 + s.length), s.concat(n);
  }
  const t = Array.prototype.slice.call(X(r, "object"));
  if (t.length === 1 && t[0] <= 127)
    return t;
  if (t.length <= 55)
    return t.unshift(128 + t.length), t;
  const e = fc(t.length);
  return e.unshift(183 + e.length), e.concat(t);
}
const hc = "0123456789abcdef";
function Gs(r) {
  let t = "0x";
  for (const e of Iu(r))
    t += hc[e >> 4], t += hc[e & 15];
  return t;
}
const St = 32, Jo = new Uint8Array(St), Zf = ["then"], Ei = {};
function Ts(r, t) {
  const e = new Error(`deferred error during ABI decoding triggered accessing ${r}`);
  throw e.error = t, e;
}
var gn;
const Ls = class Ls extends Array {
  /**
   *  @private
   */
  constructor(...e) {
    const n = e[0];
    let s = e[1], i = (e[2] || []).slice(), o = !0;
    n !== Ei && (s = e, i = [], o = !1);
    super(s.length);
    b(this, gn, void 0);
    s.forEach((c, u) => {
      this[u] = c;
    });
    const a = i.reduce((c, u) => (typeof u == "string" && c.set(u, (c.get(u) || 0) + 1), c), /* @__PURE__ */ new Map());
    if (d(this, gn, Object.freeze(s.map((c, u) => {
      const f = i[u];
      return f != null && a.get(f) === 1 ? f : null;
    }))), !!o)
      return Object.freeze(this), new Proxy(this, {
        get: (c, u, f) => {
          if (typeof u == "string") {
            if (u.match(/^[0-9]+$/)) {
              const g = V(u, "%index");
              if (g < 0 || g >= this.length)
                throw new RangeError("out of result range");
              const w = c[g];
              return w instanceof Error && Ts(`index ${g}`, w), w;
            }
            if (Zf.indexOf(u) >= 0)
              return Reflect.get(c, u, f);
            const h = c[u];
            if (h instanceof Function)
              return function(...g) {
                return h.apply(this === f ? c : this, g);
              };
            if (!(u in c))
              return c.getValue.apply(this === f ? c : this, [u]);
          }
          return Reflect.get(c, u, f);
        }
      });
  }
  /**
   *  Returns the Result as a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray() {
    const e = [];
    return this.forEach((n, s) => {
      n instanceof Error && Ts(`index ${s}`, n), e.push(n);
    }), e;
  }
  /**
   *  Returns the Result as an Object with each name-value pair.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject() {
    return l(this, gn).reduce((e, n, s) => (P(n != null, "value at index ${ index } unnamed", "UNSUPPORTED_OPERATION", {
      operation: "toObject()"
    }), n in e || (e[n] = this.getValue(n)), e), {});
  }
  /**
   *  @_ignore
   */
  slice(e, n) {
    e == null && (e = 0), e < 0 && (e += this.length, e < 0 && (e = 0)), n == null && (n = this.length), n < 0 && (n += this.length, n < 0 && (n = 0)), n > this.length && (n = this.length);
    const s = [], i = [];
    for (let o = e; o < n; o++)
      s.push(this[o]), i.push(l(this, gn)[o]);
    return new Ls(Ei, s, i);
  }
  /**
   *  @_ignore
   */
  filter(e, n) {
    const s = [], i = [];
    for (let o = 0; o < this.length; o++) {
      const a = this[o];
      a instanceof Error && Ts(`index ${o}`, a), e.call(n, a, o, this) && (s.push(a), i.push(l(this, gn)[o]));
    }
    return new Ls(Ei, s, i);
  }
  /**
   *  @_ignore
   */
  map(e, n) {
    const s = [];
    for (let i = 0; i < this.length; i++) {
      const o = this[i];
      o instanceof Error && Ts(`index ${i}`, o), s.push(e.call(n, o, i, this));
    }
    return s;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(e) {
    const n = l(this, gn).indexOf(e);
    if (n === -1)
      return;
    const s = this[n];
    return s instanceof Error && Ts(`property ${JSON.stringify(e)}`, s.error), s;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(e, n) {
    return new Ls(Ei, e, n);
  }
};
gn = new WeakMap();
let Mi = Ls;
function dc(r) {
  let t = Yt(r);
  return P(t.length <= St, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: t, length: St, offset: t.length }), t.length !== St && (t = Ht(pt([Jo.slice(t.length % St), t]))), t;
}
class sn {
  constructor(t, e, n, s) {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    A(this, "name");
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    A(this, "type");
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    A(this, "localName");
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    A(this, "dynamic");
    M(this, { name: t, type: e, localName: n, dynamic: s }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(t, e) {
    y(!1, t, this.localName, e);
  }
}
var Ve, zn, Lr, Ii;
class jo {
  constructor() {
    b(this, Lr);
    // An array of WordSize lengthed objects to concatenation
    b(this, Ve, void 0);
    b(this, zn, void 0);
    d(this, Ve, []), d(this, zn, 0);
  }
  get data() {
    return pt(l(this, Ve));
  }
  get length() {
    return l(this, zn);
  }
  appendWriter(t) {
    return O(this, Lr, Ii).call(this, Ht(t.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(t) {
    let e = Ht(t);
    const n = e.length % St;
    return n && (e = Ht(pt([e, Jo.slice(n)]))), O(this, Lr, Ii).call(this, e);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(t) {
    return O(this, Lr, Ii).call(this, dc(t));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const t = l(this, Ve).length;
    return l(this, Ve).push(Jo), d(this, zn, l(this, zn) + St), (e) => {
      l(this, Ve)[t] = dc(e);
    };
  }
}
Ve = new WeakMap(), zn = new WeakMap(), Lr = new WeakSet(), Ii = function(t) {
  return l(this, Ve).push(t), d(this, zn, l(this, zn) + t.length), t.length;
};
var zt, te, Xi, Bu;
const Va = class Va {
  constructor(t, e) {
    b(this, Xi);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    A(this, "allowLoose");
    b(this, zt, void 0);
    b(this, te, void 0);
    M(this, { allowLoose: !!e }), d(this, zt, Ht(t)), d(this, te, 0);
  }
  get data() {
    return F(l(this, zt));
  }
  get dataLength() {
    return l(this, zt).length;
  }
  get consumed() {
    return l(this, te);
  }
  get bytes() {
    return new Uint8Array(l(this, zt));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(t) {
    return new Va(l(this, zt).slice(l(this, te) + t), this.allowLoose);
  }
  // Read bytes
  readBytes(t, e) {
    let n = O(this, Xi, Bu).call(this, 0, t, !!e);
    return d(this, te, l(this, te) + n.length), n.slice(0, t);
  }
  // Read a numeric values
  readValue() {
    return Ea(this.readBytes(St));
  }
  readIndex() {
    return kf(this.readBytes(St));
  }
};
zt = new WeakMap(), te = new WeakMap(), Xi = new WeakSet(), Bu = function(t, e, n) {
  let s = Math.ceil(e / St) * St;
  return l(this, te) + s > l(this, zt).length && (this.allowLoose && n && l(this, te) + e <= l(this, zt).length ? s = e : P(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
    buffer: Ht(l(this, zt)),
    length: l(this, zt).length,
    offset: l(this, te) + s
  })), l(this, zt).slice(l(this, te), l(this, te) + s);
};
let zo = Va;
function Gi(r) {
  if (!Number.isSafeInteger(r) || r < 0)
    throw new Error(`Wrong positive integer: ${r}`);
}
function Pa(r, ...t) {
  if (!(r instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(r.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${r.length}`);
}
function Xf(r) {
  if (typeof r != "function" || typeof r.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Gi(r.outputLen), Gi(r.blockLen);
}
function ms(r, t = !0) {
  if (r.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && r.finished)
    throw new Error("Hash#digest() has already been called");
}
function Ru(r, t) {
  Pa(r);
  const e = t.outputLen;
  if (r.length < e)
    throw new Error(`digestInto() expects output buffer of length at least ${e}`);
}
const Oo = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ku = (r) => r instanceof Uint8Array, qf = (r) => new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4)), Io = (r) => new DataView(r.buffer, r.byteOffset, r.byteLength), ve = (r, t) => r << 32 - t | r >>> t, $f = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!$f)
  throw new Error("Non little-endian hardware is not supported");
function th(r) {
  if (typeof r != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof r}`);
  return new Uint8Array(new TextEncoder().encode(r));
}
function ao(r) {
  if (typeof r == "string" && (r = th(r)), !ku(r))
    throw new Error(`expected Uint8Array, got ${typeof r}`);
  return r;
}
function eh(...r) {
  const t = new Uint8Array(r.reduce((n, s) => n + s.length, 0));
  let e = 0;
  return r.forEach((n) => {
    if (!ku(n))
      throw new Error("Uint8Array expected");
    t.set(n, e), e += n.length;
  }), t;
}
class Na {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function Su(r) {
  const t = (n) => r().update(ao(n)).digest(), e = r();
  return t.outputLen = e.outputLen, t.blockLen = e.blockLen, t.create = () => r(), t;
}
function nh(r = 32) {
  if (Oo && typeof Oo.getRandomValues == "function")
    return Oo.getRandomValues(new Uint8Array(r));
  throw new Error("crypto.getRandomValues must be defined");
}
class Uu extends Na {
  constructor(t, e) {
    super(), this.finished = !1, this.destroyed = !1, Xf(t);
    const n = ao(e);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const s = this.blockLen, i = new Uint8Array(s);
    i.set(n.length > s ? t.create().update(n).digest() : n);
    for (let o = 0; o < i.length; o++)
      i[o] ^= 54;
    this.iHash.update(i), this.oHash = t.create();
    for (let o = 0; o < i.length; o++)
      i[o] ^= 106;
    this.oHash.update(i), i.fill(0);
  }
  update(t) {
    return ms(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    ms(this), Pa(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: e, iHash: n, finished: s, destroyed: i, blockLen: o, outputLen: a } = this;
    return t = t, t.finished = s, t.destroyed = i, t.blockLen = o, t.outputLen = a, t.oHash = e._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const Du = (r, t, e) => new Uu(r, t).update(e).digest();
Du.create = (r, t) => new Uu(r, t);
function rh(r, t, e, n) {
  if (typeof r.setBigUint64 == "function")
    return r.setBigUint64(t, e, n);
  const s = BigInt(32), i = BigInt(4294967295), o = Number(e >> s & i), a = Number(e & i), c = n ? 4 : 0, u = n ? 0 : 4;
  r.setUint32(t + c, o, n), r.setUint32(t + u, a, n);
}
class sh extends Na {
  constructor(t, e, n, s) {
    super(), this.blockLen = t, this.outputLen = e, this.padOffset = n, this.isLE = s, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = Io(this.buffer);
  }
  update(t) {
    ms(this);
    const { view: e, buffer: n, blockLen: s } = this;
    t = ao(t);
    const i = t.length;
    for (let o = 0; o < i; ) {
      const a = Math.min(s - this.pos, i - o);
      if (a === s) {
        const c = Io(t);
        for (; s <= i - o; o += s)
          this.process(c, o);
        continue;
      }
      n.set(t.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === s && (this.process(e, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    ms(this), Ru(t, this), this.finished = !0;
    const { buffer: e, view: n, blockLen: s, isLE: i } = this;
    let { pos: o } = this;
    e[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > s - o && (this.process(n, 0), o = 0);
    for (let h = o; h < s; h++)
      e[h] = 0;
    rh(n, s - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const a = Io(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, f = this.get();
    if (u > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let h = 0; h < u; h++)
      a.setUint32(4 * h, f[h], i);
  }
  digest() {
    const { buffer: t, outputLen: e } = this;
    this.digestInto(t);
    const n = t.slice(0, e);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: e, buffer: n, length: s, finished: i, destroyed: o, pos: a } = this;
    return t.length = s, t.pos = a, t.finished = i, t.destroyed = o, s % e && t.buffer.set(n), t;
  }
}
const ih = (r, t, e) => r & t ^ ~r & e, oh = (r, t, e) => r & t ^ r & e ^ t & e, ah = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), un = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), ln = /* @__PURE__ */ new Uint32Array(64);
class ch extends sh {
  constructor() {
    super(64, 32, 8, !1), this.A = un[0] | 0, this.B = un[1] | 0, this.C = un[2] | 0, this.D = un[3] | 0, this.E = un[4] | 0, this.F = un[5] | 0, this.G = un[6] | 0, this.H = un[7] | 0;
  }
  get() {
    const { A: t, B: e, C: n, D: s, E: i, F: o, G: a, H: c } = this;
    return [t, e, n, s, i, o, a, c];
  }
  // prettier-ignore
  set(t, e, n, s, i, o, a, c) {
    this.A = t | 0, this.B = e | 0, this.C = n | 0, this.D = s | 0, this.E = i | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, e) {
    for (let h = 0; h < 16; h++, e += 4)
      ln[h] = t.getUint32(e, !1);
    for (let h = 16; h < 64; h++) {
      const g = ln[h - 15], w = ln[h - 2], E = ve(g, 7) ^ ve(g, 18) ^ g >>> 3, m = ve(w, 17) ^ ve(w, 19) ^ w >>> 10;
      ln[h] = m + ln[h - 7] + E + ln[h - 16] | 0;
    }
    let { A: n, B: s, C: i, D: o, E: a, F: c, G: u, H: f } = this;
    for (let h = 0; h < 64; h++) {
      const g = ve(a, 6) ^ ve(a, 11) ^ ve(a, 25), w = f + g + ih(a, c, u) + ah[h] + ln[h] | 0, m = (ve(n, 2) ^ ve(n, 13) ^ ve(n, 22)) + oh(n, s, i) | 0;
      f = u, u = c, c = a, a = o + w | 0, o = i, i = s, s = n, n = w + m | 0;
    }
    n = n + this.A | 0, s = s + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, f = f + this.H | 0, this.set(n, s, i, o, a, c, u, f);
  }
  roundClean() {
    ln.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const uh = /* @__PURE__ */ Su(() => new ch()), vi = /* @__PURE__ */ BigInt(2 ** 32 - 1), pc = /* @__PURE__ */ BigInt(32);
function lh(r, t = !1) {
  return t ? { h: Number(r & vi), l: Number(r >> pc & vi) } : { h: Number(r >> pc & vi) | 0, l: Number(r & vi) | 0 };
}
function fh(r, t = !1) {
  let e = new Uint32Array(r.length), n = new Uint32Array(r.length);
  for (let s = 0; s < r.length; s++) {
    const { h: i, l: o } = lh(r[s], t);
    [e[s], n[s]] = [i, o];
  }
  return [e, n];
}
const hh = (r, t, e) => r << e | t >>> 32 - e, dh = (r, t, e) => t << e | r >>> 32 - e, ph = (r, t, e) => t << e - 32 | r >>> 64 - e, gh = (r, t, e) => r << e - 32 | t >>> 64 - e, [Fu, Lu, Mu] = [[], [], []], yh = /* @__PURE__ */ BigInt(0), Os = /* @__PURE__ */ BigInt(1), mh = /* @__PURE__ */ BigInt(2), wh = /* @__PURE__ */ BigInt(7), Ah = /* @__PURE__ */ BigInt(256), bh = /* @__PURE__ */ BigInt(113);
for (let r = 0, t = Os, e = 1, n = 0; r < 24; r++) {
  [e, n] = [n, (2 * e + 3 * n) % 5], Fu.push(2 * (5 * n + e)), Lu.push((r + 1) * (r + 2) / 2 % 64);
  let s = yh;
  for (let i = 0; i < 7; i++)
    t = (t << Os ^ (t >> wh) * bh) % Ah, t & mh && (s ^= Os << (Os << /* @__PURE__ */ BigInt(i)) - Os);
  Mu.push(s);
}
const [Eh, vh] = /* @__PURE__ */ fh(Mu, !0), gc = (r, t, e) => e > 32 ? ph(r, t, e) : hh(r, t, e), yc = (r, t, e) => e > 32 ? gh(r, t, e) : dh(r, t, e);
function xh(r, t = 24) {
  const e = new Uint32Array(10);
  for (let n = 24 - t; n < 24; n++) {
    for (let o = 0; o < 10; o++)
      e[o] = r[o] ^ r[o + 10] ^ r[o + 20] ^ r[o + 30] ^ r[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10, c = (o + 2) % 10, u = e[c], f = e[c + 1], h = gc(u, f, 1) ^ e[a], g = yc(u, f, 1) ^ e[a + 1];
      for (let w = 0; w < 50; w += 10)
        r[o + w] ^= h, r[o + w + 1] ^= g;
    }
    let s = r[2], i = r[3];
    for (let o = 0; o < 24; o++) {
      const a = Lu[o], c = gc(s, i, a), u = yc(s, i, a), f = Fu[o];
      s = r[f], i = r[f + 1], r[f] = c, r[f + 1] = u;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++)
        e[a] = r[o + a];
      for (let a = 0; a < 10; a++)
        r[o + a] ^= ~e[(a + 2) % 10] & e[(a + 4) % 10];
    }
    r[0] ^= Eh[n], r[1] ^= vh[n];
  }
  e.fill(0);
}
class Ca extends Na {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, e, n, s = !1, i = 24) {
    if (super(), this.blockLen = t, this.suffix = e, this.outputLen = n, this.enableXOF = s, this.rounds = i, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, Gi(n), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = qf(this.state);
  }
  keccak() {
    xh(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    ms(this);
    const { blockLen: e, state: n } = this;
    t = ao(t);
    const s = t.length;
    for (let i = 0; i < s; ) {
      const o = Math.min(e - this.pos, s - i);
      for (let a = 0; a < o; a++)
        n[this.pos++] ^= t[i++];
      this.pos === e && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: e, pos: n, blockLen: s } = this;
    t[n] ^= e, e & 128 && n === s - 1 && this.keccak(), t[s - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    ms(this, !1), Pa(t), this.finish();
    const e = this.state, { blockLen: n } = this;
    for (let s = 0, i = t.length; s < i; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, i - s);
      t.set(e.subarray(this.posOut, this.posOut + o), s), this.posOut += o, s += o;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return Gi(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (Ru(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: e, suffix: n, outputLen: s, rounds: i, enableXOF: o } = this;
    return t || (t = new Ca(e, n, s, o, i)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = i, t.suffix = n, t.outputLen = s, t.enableXOF = o, t.destroyed = this.destroyed, t;
  }
}
const Ph = (r, t, e) => Su(() => new Ca(t, r, e)), Nh = /* @__PURE__ */ Ph(1, 136, 256 / 8);
let Gu = !1;
const Qu = function(r) {
  return Nh(r);
};
let Hu = Qu;
function it(r) {
  const t = X(r, "data");
  return F(Hu(t));
}
it._ = Qu;
it.lock = function() {
  Gu = !0;
};
it.register = function(r) {
  if (Gu)
    throw new TypeError("keccak256 is locked");
  Hu = r;
};
Object.freeze(it);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _u = BigInt(0), co = BigInt(1), Ch = BigInt(2), uo = (r) => r instanceof Uint8Array, Th = /* @__PURE__ */ Array.from({ length: 256 }, (r, t) => t.toString(16).padStart(2, "0"));
function ws(r) {
  if (!uo(r))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let e = 0; e < r.length; e++)
    t += Th[r[e]];
  return t;
}
function Vu(r) {
  const t = r.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function Ta(r) {
  if (typeof r != "string")
    throw new Error("hex string expected, got " + typeof r);
  return BigInt(r === "" ? "0" : `0x${r}`);
}
function As(r) {
  if (typeof r != "string")
    throw new Error("hex string expected, got " + typeof r);
  const t = r.length;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const e = new Uint8Array(t / 2);
  for (let n = 0; n < e.length; n++) {
    const s = n * 2, i = r.slice(s, s + 2), o = Number.parseInt(i, 16);
    if (Number.isNaN(o) || o < 0)
      throw new Error("Invalid byte sequence");
    e[n] = o;
  }
  return e;
}
function ir(r) {
  return Ta(ws(r));
}
function Oa(r) {
  if (!uo(r))
    throw new Error("Uint8Array expected");
  return Ta(ws(Uint8Array.from(r).reverse()));
}
function bs(r, t) {
  return As(r.toString(16).padStart(t * 2, "0"));
}
function Ia(r, t) {
  return bs(r, t).reverse();
}
function Oh(r) {
  return As(Vu(r));
}
function he(r, t, e) {
  let n;
  if (typeof t == "string")
    try {
      n = As(t);
    } catch (i) {
      throw new Error(`${r} must be valid hex string, got "${t}". Cause: ${i}`);
    }
  else if (uo(t))
    n = Uint8Array.from(t);
  else
    throw new Error(`${r} must be hex string or Uint8Array`);
  const s = n.length;
  if (typeof e == "number" && s !== e)
    throw new Error(`${r} expected ${e} bytes, got ${s}`);
  return n;
}
function Qs(...r) {
  const t = new Uint8Array(r.reduce((n, s) => n + s.length, 0));
  let e = 0;
  return r.forEach((n) => {
    if (!uo(n))
      throw new Error("Uint8Array expected");
    t.set(n, e), e += n.length;
  }), t;
}
function Ih(r, t) {
  if (r.length !== t.length)
    return !1;
  for (let e = 0; e < r.length; e++)
    if (r[e] !== t[e])
      return !1;
  return !0;
}
function Bh(r) {
  if (typeof r != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof r}`);
  return new Uint8Array(new TextEncoder().encode(r));
}
function Rh(r) {
  let t;
  for (t = 0; r > _u; r >>= co, t += 1)
    ;
  return t;
}
function kh(r, t) {
  return r >> BigInt(t) & co;
}
const Sh = (r, t, e) => r | (e ? co : _u) << BigInt(t), Ba = (r) => (Ch << BigInt(r - 1)) - co, Bo = (r) => new Uint8Array(r), mc = (r) => Uint8Array.from(r);
function Ju(r, t, e) {
  if (typeof r != "number" || r < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof e != "function")
    throw new Error("hmacFn must be a function");
  let n = Bo(r), s = Bo(r), i = 0;
  const o = () => {
    n.fill(1), s.fill(0), i = 0;
  }, a = (...h) => e(s, n, ...h), c = (h = Bo()) => {
    s = a(mc([0]), h), n = a(), h.length !== 0 && (s = a(mc([1]), h), n = a());
  }, u = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let h = 0;
    const g = [];
    for (; h < t; ) {
      n = a();
      const w = n.slice();
      g.push(w), h += n.length;
    }
    return Qs(...g);
  };
  return (h, g) => {
    o(), c(h);
    let w;
    for (; !(w = g(u())); )
      c();
    return o(), w;
  };
}
const Uh = {
  bigint: (r) => typeof r == "bigint",
  function: (r) => typeof r == "function",
  boolean: (r) => typeof r == "boolean",
  string: (r) => typeof r == "string",
  stringOrUint8Array: (r) => typeof r == "string" || r instanceof Uint8Array,
  isSafeInteger: (r) => Number.isSafeInteger(r),
  array: (r) => Array.isArray(r),
  field: (r, t) => t.Fp.isValid(r),
  hash: (r) => typeof r == "function" && Number.isSafeInteger(r.outputLen)
};
function di(r, t, e = {}) {
  const n = (s, i, o) => {
    const a = Uh[i];
    if (typeof a != "function")
      throw new Error(`Invalid validator "${i}", expected function`);
    const c = r[s];
    if (!(o && c === void 0) && !a(c, r))
      throw new Error(`Invalid param ${String(s)}=${c} (${typeof c}), expected ${i}`);
  };
  for (const [s, i] of Object.entries(t))
    n(s, i, !1);
  for (const [s, i] of Object.entries(e))
    n(s, i, !0);
  return r;
}
const Dh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: kh,
  bitLen: Rh,
  bitMask: Ba,
  bitSet: Sh,
  bytesToHex: ws,
  bytesToNumberBE: ir,
  bytesToNumberLE: Oa,
  concatBytes: Qs,
  createHmacDrbg: Ju,
  ensureBytes: he,
  equalBytes: Ih,
  hexToBytes: As,
  hexToNumber: Ta,
  numberToBytesBE: bs,
  numberToBytesLE: Ia,
  numberToHexUnpadded: Vu,
  numberToVarBytesBE: Oh,
  utf8ToBytes: Bh,
  validateObject: di
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const yt = BigInt(0), lt = BigInt(1), Dn = BigInt(2), Fh = BigInt(3), Ko = BigInt(4), wc = BigInt(5), Ac = BigInt(8);
BigInt(9);
BigInt(16);
function Mt(r, t) {
  const e = r % t;
  return e >= yt ? e : t + e;
}
function Lh(r, t, e) {
  if (e <= yt || t < yt)
    throw new Error("Expected power/modulo > 0");
  if (e === lt)
    return yt;
  let n = lt;
  for (; t > yt; )
    t & lt && (n = n * r % e), r = r * r % e, t >>= lt;
  return n;
}
function Xt(r, t, e) {
  let n = r;
  for (; t-- > yt; )
    n *= n, n %= e;
  return n;
}
function Wo(r, t) {
  if (r === yt || t <= yt)
    throw new Error(`invert: expected positive integers, got n=${r} mod=${t}`);
  let e = Mt(r, t), n = t, s = yt, i = lt;
  for (; e !== yt; ) {
    const a = n / e, c = n % e, u = s - i * a;
    n = e, e = c, s = i, i = u;
  }
  if (n !== lt)
    throw new Error("invert: does not exist");
  return Mt(s, t);
}
function Mh(r) {
  const t = (r - lt) / Dn;
  let e, n, s;
  for (e = r - lt, n = 0; e % Dn === yt; e /= Dn, n++)
    ;
  for (s = Dn; s < r && Lh(s, t, r) !== r - lt; s++)
    ;
  if (n === 1) {
    const o = (r + lt) / Ko;
    return function(c, u) {
      const f = c.pow(u, o);
      if (!c.eql(c.sqr(f), u))
        throw new Error("Cannot find square root");
      return f;
    };
  }
  const i = (e + lt) / Dn;
  return function(a, c) {
    if (a.pow(c, t) === a.neg(a.ONE))
      throw new Error("Cannot find square root");
    let u = n, f = a.pow(a.mul(a.ONE, s), e), h = a.pow(c, i), g = a.pow(c, e);
    for (; !a.eql(g, a.ONE); ) {
      if (a.eql(g, a.ZERO))
        return a.ZERO;
      let w = 1;
      for (let m = a.sqr(g); w < u && !a.eql(m, a.ONE); w++)
        m = a.sqr(m);
      const E = a.pow(f, lt << BigInt(u - w - 1));
      f = a.sqr(E), h = a.mul(h, E), g = a.mul(g, f), u = w;
    }
    return h;
  };
}
function Gh(r) {
  if (r % Ko === Fh) {
    const t = (r + lt) / Ko;
    return function(n, s) {
      const i = n.pow(s, t);
      if (!n.eql(n.sqr(i), s))
        throw new Error("Cannot find square root");
      return i;
    };
  }
  if (r % Ac === wc) {
    const t = (r - wc) / Ac;
    return function(n, s) {
      const i = n.mul(s, Dn), o = n.pow(i, t), a = n.mul(s, o), c = n.mul(n.mul(a, Dn), o), u = n.mul(a, n.sub(c, n.ONE));
      if (!n.eql(n.sqr(u), s))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  return Mh(r);
}
const Qh = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Hh(r) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, e = Qh.reduce((n, s) => (n[s] = "function", n), t);
  return di(r, e);
}
function _h(r, t, e) {
  if (e < yt)
    throw new Error("Expected power > 0");
  if (e === yt)
    return r.ONE;
  if (e === lt)
    return t;
  let n = r.ONE, s = t;
  for (; e > yt; )
    e & lt && (n = r.mul(n, s)), s = r.sqr(s), e >>= lt;
  return n;
}
function Vh(r, t) {
  const e = new Array(t.length), n = t.reduce((i, o, a) => r.is0(o) ? i : (e[a] = i, r.mul(i, o)), r.ONE), s = r.inv(n);
  return t.reduceRight((i, o, a) => r.is0(o) ? i : (e[a] = r.mul(i, e[a]), r.mul(i, o)), s), e;
}
function ju(r, t) {
  const e = t !== void 0 ? t : r.toString(2).length, n = Math.ceil(e / 8);
  return { nBitLength: e, nByteLength: n };
}
function Jh(r, t, e = !1, n = {}) {
  if (r <= yt)
    throw new Error(`Expected Field ORDER > 0, got ${r}`);
  const { nBitLength: s, nByteLength: i } = ju(r, t);
  if (i > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const o = Gh(r), a = Object.freeze({
    ORDER: r,
    BITS: s,
    BYTES: i,
    MASK: Ba(s),
    ZERO: yt,
    ONE: lt,
    create: (c) => Mt(c, r),
    isValid: (c) => {
      if (typeof c != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
      return yt <= c && c < r;
    },
    is0: (c) => c === yt,
    isOdd: (c) => (c & lt) === lt,
    neg: (c) => Mt(-c, r),
    eql: (c, u) => c === u,
    sqr: (c) => Mt(c * c, r),
    add: (c, u) => Mt(c + u, r),
    sub: (c, u) => Mt(c - u, r),
    mul: (c, u) => Mt(c * u, r),
    pow: (c, u) => _h(a, c, u),
    div: (c, u) => Mt(c * Wo(u, r), r),
    // Same as above, but doesn't normalize
    sqrN: (c) => c * c,
    addN: (c, u) => c + u,
    subN: (c, u) => c - u,
    mulN: (c, u) => c * u,
    inv: (c) => Wo(c, r),
    sqrt: n.sqrt || ((c) => o(a, c)),
    invertBatch: (c) => Vh(a, c),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (c, u, f) => f ? u : c,
    toBytes: (c) => e ? Ia(c, i) : bs(c, i),
    fromBytes: (c) => {
      if (c.length !== i)
        throw new Error(`Fp.fromBytes: expected ${i}, got ${c.length}`);
      return e ? Oa(c) : ir(c);
    }
  });
  return Object.freeze(a);
}
function zu(r) {
  if (typeof r != "bigint")
    throw new Error("field order must be bigint");
  const t = r.toString(2).length;
  return Math.ceil(t / 8);
}
function Ku(r) {
  const t = zu(r);
  return t + Math.ceil(t / 2);
}
function jh(r, t, e = !1) {
  const n = r.length, s = zu(t), i = Ku(t);
  if (n < 16 || n < i || n > 1024)
    throw new Error(`expected ${i}-1024 bytes of input, got ${n}`);
  const o = e ? ir(r) : Oa(r), a = Mt(o, t - lt) + lt;
  return e ? Ia(a, s) : bs(a, s);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const zh = BigInt(0), Ro = BigInt(1);
function Kh(r, t) {
  const e = (s, i) => {
    const o = i.negate();
    return s ? o : i;
  }, n = (s) => {
    const i = Math.ceil(t / s) + 1, o = 2 ** (s - 1);
    return { windows: i, windowSize: o };
  };
  return {
    constTimeNegate: e,
    // non-const time multiplication ladder
    unsafeLadder(s, i) {
      let o = r.ZERO, a = s;
      for (; i > zh; )
        i & Ro && (o = o.add(a)), a = a.double(), i >>= Ro;
      return o;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(s, i) {
      const { windows: o, windowSize: a } = n(i), c = [];
      let u = s, f = u;
      for (let h = 0; h < o; h++) {
        f = u, c.push(f);
        for (let g = 1; g < a; g++)
          f = f.add(u), c.push(f);
        u = f.double();
      }
      return c;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(s, i, o) {
      const { windows: a, windowSize: c } = n(s);
      let u = r.ZERO, f = r.BASE;
      const h = BigInt(2 ** s - 1), g = 2 ** s, w = BigInt(s);
      for (let E = 0; E < a; E++) {
        const m = E * c;
        let x = Number(o & h);
        o >>= w, x > c && (x -= g, o += Ro);
        const v = m, B = m + Math.abs(x) - 1, T = E % 2 !== 0, H = x < 0;
        x === 0 ? f = f.add(e(T, i[v])) : u = u.add(e(H, i[B]));
      }
      return { p: u, f };
    },
    wNAFCached(s, i, o, a) {
      const c = s._WINDOW_SIZE || 1;
      let u = i.get(s);
      return u || (u = this.precomputeWindow(s, c), c !== 1 && i.set(s, a(u))), this.wNAF(c, u, o);
    }
  };
}
function Wu(r) {
  return Hh(r.Fp), di(r, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...ju(r.n, r.nBitLength),
    ...r,
    p: r.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Wh(r) {
  const t = Wu(r);
  di(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: e, Fp: n, a: s } = t;
  if (e) {
    if (!n.eql(s, n.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof e != "object" || typeof e.beta != "bigint" || typeof e.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: Yh, hexToBytes: Zh } = Dh, Ln = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(t = "") {
      super(t);
    }
  },
  _parseInt(r) {
    const { Err: t } = Ln;
    if (r.length < 2 || r[0] !== 2)
      throw new t("Invalid signature integer tag");
    const e = r[1], n = r.subarray(2, e + 2);
    if (!e || n.length !== e)
      throw new t("Invalid signature integer: wrong length");
    if (n[0] & 128)
      throw new t("Invalid signature integer: negative");
    if (n[0] === 0 && !(n[1] & 128))
      throw new t("Invalid signature integer: unnecessary leading zero");
    return { d: Yh(n), l: r.subarray(e + 2) };
  },
  toSig(r) {
    const { Err: t } = Ln, e = typeof r == "string" ? Zh(r) : r;
    if (!(e instanceof Uint8Array))
      throw new Error("ui8a expected");
    let n = e.length;
    if (n < 2 || e[0] != 48)
      throw new t("Invalid signature tag");
    if (e[1] !== n - 2)
      throw new t("Invalid signature: incorrect length");
    const { d: s, l: i } = Ln._parseInt(e.subarray(2)), { d: o, l: a } = Ln._parseInt(i);
    if (a.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: s, s: o };
  },
  hexFromSig(r) {
    const t = (u) => Number.parseInt(u[0], 16) & 8 ? "00" + u : u, e = (u) => {
      const f = u.toString(16);
      return f.length & 1 ? `0${f}` : f;
    }, n = t(e(r.s)), s = t(e(r.r)), i = n.length / 2, o = s.length / 2, a = e(i), c = e(o);
    return `30${e(o + i + 4)}02${c}${s}02${a}${n}`;
  }
}, $e = BigInt(0), ie = BigInt(1);
BigInt(2);
const bc = BigInt(3);
BigInt(4);
function Xh(r) {
  const t = Wh(r), { Fp: e } = t, n = t.toBytes || ((E, m, x) => {
    const v = m.toAffine();
    return Qs(Uint8Array.from([4]), e.toBytes(v.x), e.toBytes(v.y));
  }), s = t.fromBytes || ((E) => {
    const m = E.subarray(1), x = e.fromBytes(m.subarray(0, e.BYTES)), v = e.fromBytes(m.subarray(e.BYTES, 2 * e.BYTES));
    return { x, y: v };
  });
  function i(E) {
    const { a: m, b: x } = t, v = e.sqr(E), B = e.mul(v, E);
    return e.add(e.add(B, e.mul(E, m)), x);
  }
  if (!e.eql(e.sqr(t.Gy), i(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function o(E) {
    return typeof E == "bigint" && $e < E && E < t.n;
  }
  function a(E) {
    if (!o(E))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function c(E) {
    const { allowedPrivateKeyLengths: m, nByteLength: x, wrapPrivateKey: v, n: B } = t;
    if (m && typeof E != "bigint") {
      if (E instanceof Uint8Array && (E = ws(E)), typeof E != "string" || !m.includes(E.length))
        throw new Error("Invalid key");
      E = E.padStart(x * 2, "0");
    }
    let T;
    try {
      T = typeof E == "bigint" ? E : ir(he("private key", E, x));
    } catch {
      throw new Error(`private key must be ${x} bytes, hex or bigint, not ${typeof E}`);
    }
    return v && (T = Mt(T, B)), a(T), T;
  }
  const u = /* @__PURE__ */ new Map();
  function f(E) {
    if (!(E instanceof h))
      throw new Error("ProjectivePoint expected");
  }
  class h {
    constructor(m, x, v) {
      if (this.px = m, this.py = x, this.pz = v, m == null || !e.isValid(m))
        throw new Error("x required");
      if (x == null || !e.isValid(x))
        throw new Error("y required");
      if (v == null || !e.isValid(v))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(m) {
      const { x, y: v } = m || {};
      if (!m || !e.isValid(x) || !e.isValid(v))
        throw new Error("invalid affine point");
      if (m instanceof h)
        throw new Error("projective point not allowed");
      const B = (T) => e.eql(T, e.ZERO);
      return B(x) && B(v) ? h.ZERO : new h(x, v, e.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(m) {
      const x = e.invertBatch(m.map((v) => v.pz));
      return m.map((v, B) => v.toAffine(x[B])).map(h.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(m) {
      const x = h.fromAffine(s(he("pointHex", m)));
      return x.assertValidity(), x;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(m) {
      return h.BASE.multiply(c(m));
    }
    // "Private method", don't use it directly
    _setWindowSize(m) {
      this._WINDOW_SIZE = m, u.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint && !e.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: m, y: x } = this.toAffine();
      if (!e.isValid(m) || !e.isValid(x))
        throw new Error("bad point: x or y not FE");
      const v = e.sqr(x), B = i(m);
      if (!e.eql(v, B))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: m } = this.toAffine();
      if (e.isOdd)
        return !e.isOdd(m);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(m) {
      f(m);
      const { px: x, py: v, pz: B } = this, { px: T, py: H, pz: G } = m, U = e.eql(e.mul(x, G), e.mul(T, B)), D = e.eql(e.mul(v, G), e.mul(H, B));
      return U && D;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new h(this.px, e.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: m, b: x } = t, v = e.mul(x, bc), { px: B, py: T, pz: H } = this;
      let G = e.ZERO, U = e.ZERO, D = e.ZERO, S = e.mul(B, B), nt = e.mul(T, T), Y = e.mul(H, H), K = e.mul(B, T);
      return K = e.add(K, K), D = e.mul(B, H), D = e.add(D, D), G = e.mul(m, D), U = e.mul(v, Y), U = e.add(G, U), G = e.sub(nt, U), U = e.add(nt, U), U = e.mul(G, U), G = e.mul(K, G), D = e.mul(v, D), Y = e.mul(m, Y), K = e.sub(S, Y), K = e.mul(m, K), K = e.add(K, D), D = e.add(S, S), S = e.add(D, S), S = e.add(S, Y), S = e.mul(S, K), U = e.add(U, S), Y = e.mul(T, H), Y = e.add(Y, Y), S = e.mul(Y, K), G = e.sub(G, S), D = e.mul(Y, nt), D = e.add(D, D), D = e.add(D, D), new h(G, U, D);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(m) {
      f(m);
      const { px: x, py: v, pz: B } = this, { px: T, py: H, pz: G } = m;
      let U = e.ZERO, D = e.ZERO, S = e.ZERO;
      const nt = t.a, Y = e.mul(t.b, bc);
      let K = e.mul(x, T), Ot = e.mul(v, H), bt = e.mul(B, G), ht = e.add(x, v), C = e.add(T, H);
      ht = e.mul(ht, C), C = e.add(K, Ot), ht = e.sub(ht, C), C = e.add(x, B);
      let k = e.add(T, G);
      return C = e.mul(C, k), k = e.add(K, bt), C = e.sub(C, k), k = e.add(v, B), U = e.add(H, G), k = e.mul(k, U), U = e.add(Ot, bt), k = e.sub(k, U), S = e.mul(nt, C), U = e.mul(Y, bt), S = e.add(U, S), U = e.sub(Ot, S), S = e.add(Ot, S), D = e.mul(U, S), Ot = e.add(K, K), Ot = e.add(Ot, K), bt = e.mul(nt, bt), C = e.mul(Y, C), Ot = e.add(Ot, bt), bt = e.sub(K, bt), bt = e.mul(nt, bt), C = e.add(C, bt), K = e.mul(Ot, C), D = e.add(D, K), K = e.mul(k, C), U = e.mul(ht, U), U = e.sub(U, K), K = e.mul(ht, Ot), S = e.mul(k, S), S = e.add(S, K), new h(U, D, S);
    }
    subtract(m) {
      return this.add(m.negate());
    }
    is0() {
      return this.equals(h.ZERO);
    }
    wNAF(m) {
      return w.wNAFCached(this, u, m, (x) => {
        const v = e.invertBatch(x.map((B) => B.pz));
        return x.map((B, T) => B.toAffine(v[T])).map(h.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(m) {
      const x = h.ZERO;
      if (m === $e)
        return x;
      if (a(m), m === ie)
        return this;
      const { endo: v } = t;
      if (!v)
        return w.unsafeLadder(this, m);
      let { k1neg: B, k1: T, k2neg: H, k2: G } = v.splitScalar(m), U = x, D = x, S = this;
      for (; T > $e || G > $e; )
        T & ie && (U = U.add(S)), G & ie && (D = D.add(S)), S = S.double(), T >>= ie, G >>= ie;
      return B && (U = U.negate()), H && (D = D.negate()), D = new h(e.mul(D.px, v.beta), D.py, D.pz), U.add(D);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(m) {
      a(m);
      let x = m, v, B;
      const { endo: T } = t;
      if (T) {
        const { k1neg: H, k1: G, k2neg: U, k2: D } = T.splitScalar(x);
        let { p: S, f: nt } = this.wNAF(G), { p: Y, f: K } = this.wNAF(D);
        S = w.constTimeNegate(H, S), Y = w.constTimeNegate(U, Y), Y = new h(e.mul(Y.px, T.beta), Y.py, Y.pz), v = S.add(Y), B = nt.add(K);
      } else {
        const { p: H, f: G } = this.wNAF(x);
        v = H, B = G;
      }
      return h.normalizeZ([v, B])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(m, x, v) {
      const B = h.BASE, T = (G, U) => U === $e || U === ie || !G.equals(B) ? G.multiplyUnsafe(U) : G.multiply(U), H = T(this, x).add(T(m, v));
      return H.is0() ? void 0 : H;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(m) {
      const { px: x, py: v, pz: B } = this, T = this.is0();
      m == null && (m = T ? e.ONE : e.inv(B));
      const H = e.mul(x, m), G = e.mul(v, m), U = e.mul(B, m);
      if (T)
        return { x: e.ZERO, y: e.ZERO };
      if (!e.eql(U, e.ONE))
        throw new Error("invZ was invalid");
      return { x: H, y: G };
    }
    isTorsionFree() {
      const { h: m, isTorsionFree: x } = t;
      if (m === ie)
        return !0;
      if (x)
        return x(h, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: m, clearCofactor: x } = t;
      return m === ie ? this : x ? x(h, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(m = !0) {
      return this.assertValidity(), n(h, this, m);
    }
    toHex(m = !0) {
      return ws(this.toRawBytes(m));
    }
  }
  h.BASE = new h(t.Gx, t.Gy, e.ONE), h.ZERO = new h(e.ZERO, e.ONE, e.ZERO);
  const g = t.nBitLength, w = Kh(h, t.endo ? Math.ceil(g / 2) : g);
  return {
    CURVE: t,
    ProjectivePoint: h,
    normPrivateKeyToScalar: c,
    weierstrassEquation: i,
    isWithinCurveOrder: o
  };
}
function qh(r) {
  const t = Wu(r);
  return di(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function $h(r) {
  const t = qh(r), { Fp: e, n } = t, s = e.BYTES + 1, i = 2 * e.BYTES + 1;
  function o(C) {
    return $e < C && C < e.ORDER;
  }
  function a(C) {
    return Mt(C, n);
  }
  function c(C) {
    return Wo(C, n);
  }
  const { ProjectivePoint: u, normPrivateKeyToScalar: f, weierstrassEquation: h, isWithinCurveOrder: g } = Xh({
    ...t,
    toBytes(C, k, _) {
      const $ = k.toAffine(), Z = e.toBytes($.x), ct = Qs;
      return _ ? ct(Uint8Array.from([k.hasEvenY() ? 2 : 3]), Z) : ct(Uint8Array.from([4]), Z, e.toBytes($.y));
    },
    fromBytes(C) {
      const k = C.length, _ = C[0], $ = C.subarray(1);
      if (k === s && (_ === 2 || _ === 3)) {
        const Z = ir($);
        if (!o(Z))
          throw new Error("Point is not on curve");
        const ct = h(Z);
        let Et = e.sqrt(ct);
        const vt = (Et & ie) === ie;
        return (_ & 1) === 1 !== vt && (Et = e.neg(Et)), { x: Z, y: Et };
      } else if (k === i && _ === 4) {
        const Z = e.fromBytes($.subarray(0, e.BYTES)), ct = e.fromBytes($.subarray(e.BYTES, 2 * e.BYTES));
        return { x: Z, y: ct };
      } else
        throw new Error(`Point of length ${k} was invalid. Expected ${s} compressed bytes or ${i} uncompressed bytes`);
    }
  }), w = (C) => ws(bs(C, t.nByteLength));
  function E(C) {
    const k = n >> ie;
    return C > k;
  }
  function m(C) {
    return E(C) ? a(-C) : C;
  }
  const x = (C, k, _) => ir(C.slice(k, _));
  class v {
    constructor(k, _, $) {
      this.r = k, this.s = _, this.recovery = $, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(k) {
      const _ = t.nByteLength;
      return k = he("compactSignature", k, _ * 2), new v(x(k, 0, _), x(k, _, 2 * _));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(k) {
      const { r: _, s: $ } = Ln.toSig(he("DER", k));
      return new v(_, $);
    }
    assertValidity() {
      if (!g(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!g(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(k) {
      return new v(this.r, this.s, k);
    }
    recoverPublicKey(k) {
      const { r: _, s: $, recovery: Z } = this, ct = D(he("msgHash", k));
      if (Z == null || ![0, 1, 2, 3].includes(Z))
        throw new Error("recovery id invalid");
      const Et = Z === 2 || Z === 3 ? _ + t.n : _;
      if (Et >= e.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const vt = Z & 1 ? "03" : "02", ce = u.fromHex(vt + w(Et)), Ee = c(Et), on = a(-ct * Ee), Se = a($ * Ee), Zt = u.BASE.multiplyAndAddUnsafe(ce, on, Se);
      if (!Zt)
        throw new Error("point at infinify");
      return Zt.assertValidity(), Zt;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return E(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new v(this.r, a(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return As(this.toDERHex());
    }
    toDERHex() {
      return Ln.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return As(this.toCompactHex());
    }
    toCompactHex() {
      return w(this.r) + w(this.s);
    }
  }
  const B = {
    isValidPrivateKey(C) {
      try {
        return f(C), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: f,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const C = Ku(t.n);
      return jh(t.randomBytes(C), t.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(C = 8, k = u.BASE) {
      return k._setWindowSize(C), k.multiply(BigInt(3)), k;
    }
  };
  function T(C, k = !0) {
    return u.fromPrivateKey(C).toRawBytes(k);
  }
  function H(C) {
    const k = C instanceof Uint8Array, _ = typeof C == "string", $ = (k || _) && C.length;
    return k ? $ === s || $ === i : _ ? $ === 2 * s || $ === 2 * i : C instanceof u;
  }
  function G(C, k, _ = !0) {
    if (H(C))
      throw new Error("first arg must be private key");
    if (!H(k))
      throw new Error("second arg must be public key");
    return u.fromHex(k).multiply(f(C)).toRawBytes(_);
  }
  const U = t.bits2int || function(C) {
    const k = ir(C), _ = C.length * 8 - t.nBitLength;
    return _ > 0 ? k >> BigInt(_) : k;
  }, D = t.bits2int_modN || function(C) {
    return a(U(C));
  }, S = Ba(t.nBitLength);
  function nt(C) {
    if (typeof C != "bigint")
      throw new Error("bigint expected");
    if (!($e <= C && C < S))
      throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return bs(C, t.nByteLength);
  }
  function Y(C, k, _ = K) {
    if (["recovered", "canonical"].some((ue) => ue in _))
      throw new Error("sign() legacy options not supported");
    const { hash: $, randomBytes: Z } = t;
    let { lowS: ct, prehash: Et, extraEntropy: vt } = _;
    ct == null && (ct = !0), C = he("msgHash", C), Et && (C = he("prehashed msgHash", $(C)));
    const ce = D(C), Ee = f(k), on = [nt(Ee), nt(ce)];
    if (vt != null) {
      const ue = vt === !0 ? Z(e.BYTES) : vt;
      on.push(he("extraEntropy", ue));
    }
    const Se = Qs(...on), Zt = ce;
    function an(ue) {
      const le = U(ue);
      if (!g(le))
        return;
      const mi = c(le), Ue = u.BASE.multiply(le).toAffine(), Ft = a(Ue.x);
      if (Ft === $e)
        return;
      const cn = a(mi * a(Zt + Ft * Ee));
      if (cn === $e)
        return;
      let Sn = (Ue.x === Ft ? 0 : 2) | Number(Ue.y & ie), Ps = cn;
      return ct && E(cn) && (Ps = m(cn), Sn ^= 1), new v(Ft, Ps, Sn);
    }
    return { seed: Se, k2sig: an };
  }
  const K = { lowS: t.lowS, prehash: !1 }, Ot = { lowS: t.lowS, prehash: !1 };
  function bt(C, k, _ = K) {
    const { seed: $, k2sig: Z } = Y(C, k, _), ct = t;
    return Ju(ct.hash.outputLen, ct.nByteLength, ct.hmac)($, Z);
  }
  u.BASE._setWindowSize(8);
  function ht(C, k, _, $ = Ot) {
    var Ue;
    const Z = C;
    if (k = he("msgHash", k), _ = he("publicKey", _), "strict" in $)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: ct, prehash: Et } = $;
    let vt, ce;
    try {
      if (typeof Z == "string" || Z instanceof Uint8Array)
        try {
          vt = v.fromDER(Z);
        } catch (Ft) {
          if (!(Ft instanceof Ln.Err))
            throw Ft;
          vt = v.fromCompact(Z);
        }
      else if (typeof Z == "object" && typeof Z.r == "bigint" && typeof Z.s == "bigint") {
        const { r: Ft, s: cn } = Z;
        vt = new v(Ft, cn);
      } else
        throw new Error("PARSE");
      ce = u.fromHex(_);
    } catch (Ft) {
      if (Ft.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (ct && vt.hasHighS())
      return !1;
    Et && (k = t.hash(k));
    const { r: Ee, s: on } = vt, Se = D(k), Zt = c(on), an = a(Se * Zt), ue = a(Ee * Zt), le = (Ue = u.BASE.multiplyAndAddUnsafe(ce, an, ue)) == null ? void 0 : Ue.toAffine();
    return le ? a(le.x) === Ee : !1;
  }
  return {
    CURVE: t,
    getPublicKey: T,
    getSharedSecret: G,
    sign: bt,
    verify: ht,
    ProjectivePoint: u,
    Signature: v,
    utils: B
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function td(r) {
  return {
    hash: r,
    hmac: (t, ...e) => Du(r, t, eh(...e)),
    randomBytes: nh
  };
}
function ed(r, t) {
  const e = (n) => $h({ ...r, ...td(n) });
  return Object.freeze({ ...e(t), create: e });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Yu = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), Ec = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), nd = BigInt(1), Yo = BigInt(2), vc = (r, t) => (r + t / Yo) / t;
function rd(r) {
  const t = Yu, e = BigInt(3), n = BigInt(6), s = BigInt(11), i = BigInt(22), o = BigInt(23), a = BigInt(44), c = BigInt(88), u = r * r * r % t, f = u * u * r % t, h = Xt(f, e, t) * f % t, g = Xt(h, e, t) * f % t, w = Xt(g, Yo, t) * u % t, E = Xt(w, s, t) * w % t, m = Xt(E, i, t) * E % t, x = Xt(m, a, t) * m % t, v = Xt(x, c, t) * x % t, B = Xt(v, a, t) * m % t, T = Xt(B, e, t) * f % t, H = Xt(T, o, t) * E % t, G = Xt(H, n, t) * u % t, U = Xt(G, Yo, t);
  if (!Zo.eql(Zo.sqr(U), r))
    throw new Error("Cannot find square root");
  return U;
}
const Zo = Jh(Yu, void 0, void 0, { sqrt: rd }), fn = ed({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Zo,
  n: Ec,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (r) => {
      const t = Ec, e = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -nd * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), i = e, o = BigInt("0x100000000000000000000000000000000"), a = vc(i * r, t), c = vc(-n * r, t);
      let u = Mt(r - a * e - c * s, t), f = Mt(-a * n - c * i, t);
      const h = u > o, g = f > o;
      if (h && (u = t - u), g && (f = t - f), u > o || f > o)
        throw new Error("splitScalar: Endomorphism failed, k=" + r);
      return { k1neg: h, k1: u, k2neg: g, k2: f };
    }
  }
}, uh);
BigInt(0);
fn.ProjectivePoint;
const Xo = "0x0000000000000000000000000000000000000000", xc = "0x0000000000000000000000000000000000000000000000000000000000000000", Pc = BigInt(0), Nc = BigInt(1), Cc = BigInt(2), Tc = BigInt(27), Oc = BigInt(28), xi = BigInt(35), yr = {};
function Ic(r) {
  return ar(Yt(r), 32);
}
var Mr, Gr, Qr, Kn;
const fe = class fe {
  /**
   *  @private
   */
  constructor(t, e, n, s) {
    b(this, Mr, void 0);
    b(this, Gr, void 0);
    b(this, Qr, void 0);
    b(this, Kn, void 0);
    so(t, yr, "Signature"), d(this, Mr, e), d(this, Gr, n), d(this, Qr, s), d(this, Kn, null);
  }
  /**
   *  The ``r`` value for a signautre.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return l(this, Mr);
  }
  set r(t) {
    y(Ir(t) === 32, "invalid r", "value", t), d(this, Mr, F(t));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return l(this, Gr);
  }
  set s(t) {
    y(Ir(t) === 32, "invalid s", "value", t);
    const e = F(t);
    y(parseInt(e.substring(0, 3)) < 8, "non-canonical s", "value", e), d(this, Gr, e);
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return l(this, Qr);
  }
  set v(t) {
    const e = V(t, "value");
    y(e === 27 || e === 28, "invalid v", "v", t), d(this, Qr, e);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return l(this, Kn);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const t = this.networkV;
    return t == null ? null : fe.getChainId(t);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const t = X(this.s);
    return this.yParity && (t[0] |= 128), F(t);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return pt([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return pt([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const t = new fe(yr, this.r, this.s, this.v);
    return this.networkV && d(t, Kn, this.networkV), t;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const t = this.networkV;
    return {
      _type: "signature",
      networkV: t != null ? t.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(t) {
    const e = L(t, "v");
    return e == Tc || e == Oc ? Pc : (y(e >= xi, "invalid EIP-155 v", "v", t), (e - xi) / Cc);
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(t, e) {
    return L(t) * Cc + BigInt(35 + e - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(t) {
    const e = L(t);
    return e === Pc || e === Tc ? 27 : e === Nc || e === Oc ? 28 : (y(e >= xi, "invalid v", "v", t), e & Nc ? 27 : 28);
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(t) {
    function e(u, f) {
      y(u, f, "signature", t);
    }
    if (t == null)
      return new fe(yr, xc, xc, 27);
    if (typeof t == "string") {
      const u = X(t, "signature");
      if (u.length === 64) {
        const f = F(u.slice(0, 32)), h = u.slice(32, 64), g = h[0] & 128 ? 28 : 27;
        return h[0] &= 127, new fe(yr, f, F(h), g);
      }
      if (u.length === 65) {
        const f = F(u.slice(0, 32)), h = u.slice(32, 64);
        e((h[0] & 128) === 0, "non-canonical s");
        const g = fe.getNormalizedV(u[64]);
        return new fe(yr, f, F(h), g);
      }
      e(!1, "invalid raw signature length");
    }
    if (t instanceof fe)
      return t.clone();
    const n = t.r;
    e(n != null, "missing r");
    const s = Ic(n), i = function(u, f) {
      if (u != null)
        return Ic(u);
      if (f != null) {
        e(ot(f, 32), "invalid yParityAndS");
        const h = X(f);
        return h[0] &= 127, F(h);
      }
      e(!1, "missing s");
    }(t.s, t.yParityAndS);
    e((X(i)[0] & 128) == 0, "non-canonical s");
    const { networkV: o, v: a } = function(u, f, h) {
      if (u != null) {
        const g = L(u);
        return {
          networkV: g >= xi ? g : void 0,
          v: fe.getNormalizedV(g)
        };
      }
      if (f != null)
        return e(ot(f, 32), "invalid yParityAndS"), { v: X(f)[0] & 128 ? 28 : 27 };
      if (h != null) {
        switch (V(h, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        e(!1, "invalid yParity");
      }
      e(!1, "missing v");
    }(t.v, t.yParityAndS, t.yParity), c = new fe(yr, s, i, a);
    return o && d(c, Kn, o), e(t.yParity == null || V(t.yParity, "sig.yParity") === c.yParity, "yParity mismatch"), e(t.yParityAndS == null || t.yParityAndS === c.yParityAndS, "yParityAndS mismatch"), c;
  }
};
Mr = new WeakMap(), Gr = new WeakMap(), Qr = new WeakMap(), Kn = new WeakMap();
let we = fe;
var Je;
const Fn = class Fn {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(t) {
    b(this, Je, void 0);
    y(Ir(t) === 32, "invalid private key", "privateKey", "[REDACTED]"), d(this, Je, F(t));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return l(this, Je);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return Fn.computePublicKey(l(this, Je));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return Fn.computePublicKey(l(this, Je), !0);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(t) {
    y(Ir(t) === 32, "invalid digest length", "digest", t);
    const e = fn.sign(Ht(t), Ht(l(this, Je)), {
      lowS: !0
    });
    return we.from({
      r: Bn(e.r, 32),
      s: Bn(e.s, 32),
      v: e.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(t) {
    const e = Fn.computePublicKey(t);
    return F(fn.getSharedSecret(Ht(l(this, Je)), X(e), !1));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(t, e) {
    let n = X(t, "key");
    if (n.length === 32) {
      const i = fn.getPublicKey(n, !!e);
      return F(i);
    }
    if (n.length === 64) {
      const i = new Uint8Array(65);
      i[0] = 4, i.set(n, 1), n = i;
    }
    const s = fn.ProjectivePoint.fromHex(n);
    return F(s.toRawBytes(e));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(t, e) {
    y(Ir(t) === 32, "invalid digest length", "digest", t);
    const n = we.from(e);
    let s = fn.Signature.fromCompact(Ht(pt([n.r, n.s])));
    s = s.addRecoveryBit(n.yParity);
    const i = s.recoverPublicKey(Ht(t));
    return y(i != null, "invalid signautre for digest", "signature", e), "0x" + i.toHex(!1);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(t, e, n) {
    const s = fn.ProjectivePoint.fromHex(Fn.computePublicKey(t).substring(2)), i = fn.ProjectivePoint.fromHex(Fn.computePublicKey(e).substring(2));
    return "0x" + s.add(i).toHex(!!n);
  }
};
Je = new WeakMap();
let Hs = Fn;
const sd = BigInt(0), id = BigInt(36);
function Bc(r) {
  r = r.toLowerCase();
  const t = r.substring(2).split(""), e = new Uint8Array(40);
  for (let s = 0; s < 40; s++)
    e[s] = t[s].charCodeAt(0);
  const n = X(it(e));
  for (let s = 0; s < 40; s += 2)
    n[s >> 1] >> 4 >= 8 && (t[s] = t[s].toUpperCase()), (n[s >> 1] & 15) >= 8 && (t[s + 1] = t[s + 1].toUpperCase());
  return "0x" + t.join("");
}
const Ra = {};
for (let r = 0; r < 10; r++)
  Ra[String(r)] = String(r);
for (let r = 0; r < 26; r++)
  Ra[String.fromCharCode(65 + r)] = String(10 + r);
const Rc = 15;
function od(r) {
  r = r.toUpperCase(), r = r.substring(4) + r.substring(0, 2) + "00";
  let t = r.split("").map((n) => Ra[n]).join("");
  for (; t.length >= Rc; ) {
    let n = t.substring(0, Rc);
    t = parseInt(n, 10) % 97 + t.substring(n.length);
  }
  let e = String(98 - parseInt(t, 10) % 97);
  for (; e.length < 2; )
    e = "0" + e;
  return e;
}
const ad = function() {
  const r = {};
  for (let t = 0; t < 36; t++) {
    const e = "0123456789abcdefghijklmnopqrstuvwxyz"[t];
    r[e] = BigInt(t);
  }
  return r;
}();
function cd(r) {
  r = r.toLowerCase();
  let t = sd;
  for (let e = 0; e < r.length; e++)
    t = t * id + ad[r[e]];
  return t;
}
function W(r) {
  if (y(typeof r == "string", "invalid address", "address", r), r.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    r.startsWith("0x") || (r = "0x" + r);
    const t = Bc(r);
    return y(!r.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || t === r, "bad address checksum", "address", r), t;
  }
  if (r.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    y(r.substring(2, 4) === od(r), "bad icap checksum", "address", r);
    let t = cd(r.substring(4)).toString(16);
    for (; t.length < 40; )
      t = "0" + t;
    return Bc("0x" + t);
  }
  y(!1, "invalid address", "address", r);
}
function ud(r) {
  const t = W(r.from);
  let n = L(r.nonce, "tx.nonce").toString(16);
  return n === "0" ? n = "0x" : n.length % 2 ? n = "0x0" + n : n = "0x" + n, W(at(it(Gs([t, n])), 12));
}
function Zu(r) {
  return r && typeof r.getAddress == "function";
}
async function ko(r, t) {
  const e = await t;
  return (e == null || e === "0x0000000000000000000000000000000000000000") && (P(typeof r != "string", "unconfigured name", "UNCONFIGURED_NAME", { value: r }), y(!1, "invalid AddressLike value; did not resolve to a value address", "target", r)), W(e);
}
function Ut(r, t) {
  if (typeof r == "string")
    return r.match(/^0x[0-9a-f]{40}$/i) ? W(r) : (P(t != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" }), ko(r, t.resolveName(r)));
  if (Zu(r))
    return ko(r, r.getAddress());
  if (r && typeof r.then == "function")
    return ko(r, r);
  y(!1, "unsupported addressable value", "target", r);
}
const Le = {};
function R(r, t) {
  let e = !1;
  return t < 0 && (e = !0, t *= -1), new Tt(Le, `${e ? "" : "u"}int${t}`, r, { signed: e, width: t });
}
function z(r, t) {
  return new Tt(Le, `bytes${t || ""}`, r, { size: t });
}
const kc = Symbol.for("_ethers_typed");
var Wn;
const Me = class Me {
  /**
   *  @_ignore:
   */
  constructor(t, e, n, s) {
    /**
     *  The type, as a Solidity-compatible type.
     */
    A(this, "type");
    /**
     *  The actual value.
     */
    A(this, "value");
    b(this, Wn, void 0);
    /**
     *  @_ignore:
     */
    A(this, "_typedSymbol");
    s == null && (s = null), so(Le, t, "Typed"), M(this, { _typedSymbol: kc, type: e, value: n }), d(this, Wn, s), this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array")
      throw new Error("");
    if (this.type === "dynamicArray")
      throw new Error("");
    return this.type === "tuple" ? `tuple(${this.value.map((t) => t.format()).join(",")})` : this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple")
      throw TypeError("not a tuple");
    return l(this, Wn);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array")
      throw TypeError("not an array");
    return l(this, Wn) === !0 ? -1 : l(this, Wn) === !1 ? this.value.length : null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(t, e) {
    return new Me(Le, t, e);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(t) {
    return R(t, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(t) {
    return R(t, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(t) {
    return R(t, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(t) {
    return R(t, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(t) {
    return R(t, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(t) {
    return R(t, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(t) {
    return R(t, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(t) {
    return R(t, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(t) {
    return R(t, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(t) {
    return R(t, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(t) {
    return R(t, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(t) {
    return R(t, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(t) {
    return R(t, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(t) {
    return R(t, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(t) {
    return R(t, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(t) {
    return R(t, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(t) {
    return R(t, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(t) {
    return R(t, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(t) {
    return R(t, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(t) {
    return R(t, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(t) {
    return R(t, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(t) {
    return R(t, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(t) {
    return R(t, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(t) {
    return R(t, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(t) {
    return R(t, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(t) {
    return R(t, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(t) {
    return R(t, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(t) {
    return R(t, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(t) {
    return R(t, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(t) {
    return R(t, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(t) {
    return R(t, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(t) {
    return R(t, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(t) {
    return R(t, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(t) {
    return R(t, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(t) {
    return R(t, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(t) {
    return R(t, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(t) {
    return R(t, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(t) {
    return R(t, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(t) {
    return R(t, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(t) {
    return R(t, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(t) {
    return R(t, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(t) {
    return R(t, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(t) {
    return R(t, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(t) {
    return R(t, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(t) {
    return R(t, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(t) {
    return R(t, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(t) {
    return R(t, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(t) {
    return R(t, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(t) {
    return R(t, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(t) {
    return R(t, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(t) {
    return R(t, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(t) {
    return R(t, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(t) {
    return R(t, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(t) {
    return R(t, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(t) {
    return R(t, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(t) {
    return R(t, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(t) {
    return R(t, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(t) {
    return R(t, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(t) {
    return R(t, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(t) {
    return R(t, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(t) {
    return R(t, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(t) {
    return R(t, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(t) {
    return R(t, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(t) {
    return R(t, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(t) {
    return R(t, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(t) {
    return R(t, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(t) {
    return z(t, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(t) {
    return z(t, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(t) {
    return z(t, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(t) {
    return z(t, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(t) {
    return z(t, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(t) {
    return z(t, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(t) {
    return z(t, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(t) {
    return z(t, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(t) {
    return z(t, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(t) {
    return z(t, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(t) {
    return z(t, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(t) {
    return z(t, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(t) {
    return z(t, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(t) {
    return z(t, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(t) {
    return z(t, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(t) {
    return z(t, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(t) {
    return z(t, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(t) {
    return z(t, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(t) {
    return z(t, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(t) {
    return z(t, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(t) {
    return z(t, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(t) {
    return z(t, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(t) {
    return z(t, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(t) {
    return z(t, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(t) {
    return z(t, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(t) {
    return z(t, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(t) {
    return z(t, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(t) {
    return z(t, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(t) {
    return z(t, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(t) {
    return z(t, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(t) {
    return z(t, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(t) {
    return z(t, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(t) {
    return new Me(Le, "address", t);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(t) {
    return new Me(Le, "bool", !!t);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(t) {
    return new Me(Le, "bytes", t);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(t) {
    return new Me(Le, "string", t);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(t, e) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(t, e) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(t) {
    return new Me(Le, "overrides", Object.assign({}, t));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(t) {
    return t && typeof t == "object" && "_typedSymbol" in t && t._typedSymbol === kc;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(t, e) {
    if (Me.isTyped(t)) {
      if (t.type !== e)
        throw new Error(`invalid type: expecetd ${e}, got ${t.type}`);
      return t.value;
    }
    return t;
  }
};
Wn = new WeakMap();
let Tt = Me;
class ld extends sn {
  constructor(t) {
    super("address", "address", t, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(t, e) {
    let n = Tt.dereference(e, "string");
    try {
      n = W(n);
    } catch (s) {
      return this._throwError(s.message, e);
    }
    return t.writeValue(n);
  }
  decode(t) {
    return W(Bn(t.readValue(), 20));
  }
}
class fd extends sn {
  constructor(e) {
    super(e.name, e.type, "_", e.dynamic);
    A(this, "coder");
    this.coder = e;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(e, n) {
    return this.coder.encode(e, n);
  }
  decode(e) {
    return this.coder.decode(e);
  }
}
function Xu(r, t, e) {
  let n = [];
  if (Array.isArray(e))
    n = e;
  else if (e && typeof e == "object") {
    let c = {};
    n = t.map((u) => {
      const f = u.localName;
      return P(f, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder: u }, value: e }), P(!c[f], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder: u }, value: e }), c[f] = !0, e[f];
    });
  } else
    y(!1, "invalid tuple value", "tuple", e);
  y(t.length === n.length, "types/value length mismatch", "tuple", e);
  let s = new jo(), i = new jo(), o = [];
  t.forEach((c, u) => {
    let f = n[u];
    if (c.dynamic) {
      let h = i.length;
      c.encode(i, f);
      let g = s.writeUpdatableValue();
      o.push((w) => {
        g(w + h);
      });
    } else
      c.encode(s, f);
  }), o.forEach((c) => {
    c(s.length);
  });
  let a = r.appendWriter(s);
  return a += r.appendWriter(i), a;
}
function qu(r, t) {
  let e = [], n = [], s = r.subReader(0);
  return t.forEach((i) => {
    let o = null;
    if (i.dynamic) {
      let a = r.readIndex(), c = s.subReader(a);
      try {
        o = i.decode(c);
      } catch (u) {
        if (oe(u, "BUFFER_OVERRUN"))
          throw u;
        o = u, o.baseType = i.name, o.name = i.localName, o.type = i.type;
      }
    } else
      try {
        o = i.decode(r);
      } catch (a) {
        if (oe(a, "BUFFER_OVERRUN"))
          throw a;
        o = a, o.baseType = i.name, o.name = i.localName, o.type = i.type;
      }
    if (o == null)
      throw new Error("investigate");
    e.push(o), n.push(i.localName || null);
  }), Mi.fromItems(e, n);
}
class hd extends sn {
  constructor(e, n, s) {
    const i = e.type + "[" + (n >= 0 ? n : "") + "]", o = n === -1 || e.dynamic;
    super("array", i, s, o);
    A(this, "coder");
    A(this, "length");
    M(this, { coder: e, length: n });
  }
  defaultValue() {
    const e = this.coder.defaultValue(), n = [];
    for (let s = 0; s < this.length; s++)
      n.push(e);
    return n;
  }
  encode(e, n) {
    const s = Tt.dereference(n, "array");
    Array.isArray(s) || this._throwError("expected array value", s);
    let i = this.length;
    i === -1 && (i = s.length, e.writeValue(s.length)), wu(s.length, i, "coder array" + (this.localName ? " " + this.localName : ""));
    let o = [];
    for (let a = 0; a < s.length; a++)
      o.push(this.coder);
    return Xu(e, o, s);
  }
  decode(e) {
    let n = this.length;
    n === -1 && (n = e.readIndex(), P(n * St <= e.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: e.bytes, offset: n * St, length: e.dataLength }));
    let s = [];
    for (let i = 0; i < n; i++)
      s.push(new fd(this.coder));
    return qu(e, s);
  }
}
class dd extends sn {
  constructor(t) {
    super("bool", "bool", t, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(t, e) {
    const n = Tt.dereference(e, "bool");
    return t.writeValue(n ? 1 : 0);
  }
  decode(t) {
    return !!t.readValue();
  }
}
class $u extends sn {
  constructor(t, e) {
    super(t, t, e, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(t, e) {
    e = Ht(e);
    let n = t.writeValue(e.length);
    return n += t.writeBytes(e), n;
  }
  decode(t) {
    return t.readBytes(t.readIndex(), !0);
  }
}
class pd extends $u {
  constructor(t) {
    super("bytes", t);
  }
  decode(t) {
    return F(super.decode(t));
  }
}
class gd extends sn {
  constructor(e, n) {
    let s = "bytes" + String(e);
    super(s, s, n, !1);
    A(this, "size");
    M(this, { size: e }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(e, n) {
    let s = Ht(Tt.dereference(n, this.type));
    return s.length !== this.size && this._throwError("incorrect data length", n), e.writeBytes(s);
  }
  decode(e) {
    return F(e.readBytes(this.size));
  }
}
const yd = new Uint8Array([]);
class md extends sn {
  constructor(t) {
    super("null", "", t, !1);
  }
  defaultValue() {
    return null;
  }
  encode(t, e) {
    return e != null && this._throwError("not null", e), t.writeBytes(yd);
  }
  decode(t) {
    return t.readBytes(0), null;
  }
}
const wd = BigInt(0), Ad = BigInt(1), bd = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class Ed extends sn {
  constructor(e, n, s) {
    const i = (n ? "int" : "uint") + e * 8;
    super(i, i, s, !1);
    A(this, "size");
    A(this, "signed");
    M(this, { size: e, signed: n }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(e, n) {
    let s = L(Tt.dereference(n, this.type)), i = Is(bd, St * 8);
    if (this.signed) {
      let o = Is(i, this.size * 8 - 1);
      (s > o || s < -(o + Ad)) && this._throwError("value out-of-bounds", n), s = Eu(s, 8 * St);
    } else
      (s < wd || s > Is(i, this.size * 8)) && this._throwError("value out-of-bounds", n);
    return e.writeValue(s);
  }
  decode(e) {
    let n = Is(e.readValue(), this.size * 8);
    return this.signed && (n = Rf(n, this.size * 8)), n;
  }
}
class vd extends $u {
  constructor(t) {
    super("string", t);
  }
  defaultValue() {
    return "";
  }
  encode(t, e) {
    return super.encode(t, en(Tt.dereference(e, "string")));
  }
  decode(t) {
    return va(super.decode(t));
  }
}
class Pi extends sn {
  constructor(e, n) {
    let s = !1;
    const i = [];
    e.forEach((a) => {
      a.dynamic && (s = !0), i.push(a.type);
    });
    const o = "tuple(" + i.join(",") + ")";
    super("tuple", o, n, s);
    A(this, "coders");
    M(this, { coders: Object.freeze(e.slice()) });
  }
  defaultValue() {
    const e = [];
    this.coders.forEach((s) => {
      e.push(s.defaultValue());
    });
    const n = this.coders.reduce((s, i) => {
      const o = i.localName;
      return o && (s[o] || (s[o] = 0), s[o]++), s;
    }, {});
    return this.coders.forEach((s, i) => {
      let o = s.localName;
      !o || n[o] !== 1 || (o === "length" && (o = "_length"), e[o] == null && (e[o] = e[i]));
    }), Object.freeze(e);
  }
  encode(e, n) {
    const s = Tt.dereference(n, "tuple");
    return Xu(e, this.coders, s);
  }
  decode(e) {
    return qu(e, this.coders);
  }
}
function cr(r) {
  return it(en(r));
}
var xd = "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";
const Sc = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]), Uc = 4;
function Pd(r) {
  let t = 0;
  function e() {
    return r[t++] << 8 | r[t++];
  }
  let n = e(), s = 1, i = [0, 1];
  for (let G = 1; G < n; G++)
    i.push(s += e());
  let o = e(), a = t;
  t += o;
  let c = 0, u = 0;
  function f() {
    return c == 0 && (u = u << 8 | r[t++], c = 8), u >> --c & 1;
  }
  const h = 31, g = 2 ** h, w = g >>> 1, E = w >> 1, m = g - 1;
  let x = 0;
  for (let G = 0; G < h; G++)
    x = x << 1 | f();
  let v = [], B = 0, T = g;
  for (; ; ) {
    let G = Math.floor(((x - B + 1) * s - 1) / T), U = 0, D = n;
    for (; D - U > 1; ) {
      let Y = U + D >>> 1;
      G < i[Y] ? D = Y : U = Y;
    }
    if (U == 0)
      break;
    v.push(U);
    let S = B + Math.floor(T * i[U] / s), nt = B + Math.floor(T * i[U + 1] / s) - 1;
    for (; !((S ^ nt) & w); )
      x = x << 1 & m | f(), S = S << 1 & m, nt = nt << 1 & m | 1;
    for (; S & ~nt & E; )
      x = x & w | x << 1 & m >>> 1 | f(), S = S << 1 ^ w, nt = (nt ^ w) << 1 | w | 1;
    B = S, T = 1 + nt - S;
  }
  let H = n - 4;
  return v.map((G) => {
    switch (G - H) {
      case 3:
        return H + 65792 + (r[a++] << 16 | r[a++] << 8 | r[a++]);
      case 2:
        return H + 256 + (r[a++] << 8 | r[a++]);
      case 1:
        return H + r[a++];
      default:
        return G - 1;
    }
  });
}
function Nd(r) {
  let t = 0;
  return () => r[t++];
}
function tl(r) {
  return Nd(Pd(Cd(r)));
}
function Cd(r) {
  let t = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((s, i) => t[s.charCodeAt(0)] = i);
  let e = r.length, n = new Uint8Array(6 * e >> 3);
  for (let s = 0, i = 0, o = 0, a = 0; s < e; s++)
    a = a << 6 | t[r.charCodeAt(s)], o += 6, o >= 8 && (n[i++] = a >> (o -= 8));
  return n;
}
function Td(r) {
  return r & 1 ? ~r >> 1 : r >> 1;
}
function Od(r, t) {
  let e = Array(r);
  for (let n = 0, s = 0; n < r; n++)
    e[n] = s += Td(t());
  return e;
}
function _s(r, t = 0) {
  let e = [];
  for (; ; ) {
    let n = r(), s = r();
    if (!s)
      break;
    t += n;
    for (let i = 0; i < s; i++)
      e.push(t + i);
    t += s + 1;
  }
  return e;
}
function el(r) {
  return Vs(() => {
    let t = _s(r);
    if (t.length)
      return t;
  });
}
function nl(r) {
  let t = [];
  for (; ; ) {
    let e = r();
    if (e == 0)
      break;
    t.push(Id(e, r));
  }
  for (; ; ) {
    let e = r() - 1;
    if (e < 0)
      break;
    t.push(Bd(e, r));
  }
  return t.flat();
}
function Vs(r) {
  let t = [];
  for (; ; ) {
    let e = r(t.length);
    if (!e)
      break;
    t.push(e);
  }
  return t;
}
function rl(r, t, e) {
  let n = Array(r).fill().map(() => []);
  for (let s = 0; s < t; s++)
    Od(r, e).forEach((i, o) => n[o].push(i));
  return n;
}
function Id(r, t) {
  let e = 1 + t(), n = t(), s = Vs(t);
  return rl(s.length, 1 + r, t).flatMap((o, a) => {
    let [c, ...u] = o;
    return Array(s[a]).fill().map((f, h) => {
      let g = h * n;
      return [c + h * e, u.map((w) => w + g)];
    });
  });
}
function Bd(r, t) {
  let e = 1 + t();
  return rl(e, 1 + r, t).map((s) => [s[0], s.slice(1)]);
}
function Rd(r) {
  let t = [], e = _s(r);
  return s(n([]), []), t;
  function n(i) {
    let o = r(), a = Vs(() => {
      let c = _s(r).map((u) => e[u]);
      if (c.length)
        return n(c);
    });
    return { S: o, B: a, Q: i };
  }
  function s({ S: i, B: o }, a, c) {
    if (!(i & 4 && c === a[a.length - 1])) {
      i & 2 && (c = a[a.length - 1]), i & 1 && t.push(a);
      for (let u of o)
        for (let f of u.Q)
          s(u, [...a, f], c);
    }
  }
}
function kd(r) {
  return r.toString(16).toUpperCase().padStart(2, "0");
}
function sl(r) {
  return `{${kd(r)}}`;
}
function Sd(r) {
  let t = [];
  for (let e = 0, n = r.length; e < n; ) {
    let s = r.codePointAt(e);
    e += s < 65536 ? 1 : 2, t.push(s);
  }
  return t;
}
function Es(r) {
  let e = r.length;
  if (e < 4096)
    return String.fromCodePoint(...r);
  let n = [];
  for (let s = 0; s < e; )
    n.push(String.fromCodePoint(...r.slice(s, s += 4096)));
  return n.join("");
}
function Ud(r, t) {
  let e = r.length, n = e - t.length;
  for (let s = 0; n == 0 && s < e; s++)
    n = r[s] - t[s];
  return n;
}
var Dd = "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";
const Js = 44032, Qi = 4352, Hi = 4449, _i = 4519, il = 19, ol = 21, vs = 28, Vi = ol * vs, Fd = il * Vi, Ld = Js + Fd, Md = Qi + il, Gd = Hi + ol, Qd = _i + vs;
function Rs(r) {
  return r >> 24 & 255;
}
function al(r) {
  return r & 16777215;
}
let qo, Dc, $o, Bi;
function Hd() {
  let r = tl(Dd);
  qo = new Map(el(r).flatMap((t, e) => t.map((n) => [n, e + 1 << 24]))), Dc = new Set(_s(r)), $o = /* @__PURE__ */ new Map(), Bi = /* @__PURE__ */ new Map();
  for (let [t, e] of nl(r)) {
    if (!Dc.has(t) && e.length == 2) {
      let [n, s] = e, i = Bi.get(n);
      i || (i = /* @__PURE__ */ new Map(), Bi.set(n, i)), i.set(s, t);
    }
    $o.set(t, e.reverse());
  }
}
function cl(r) {
  return r >= Js && r < Ld;
}
function _d(r, t) {
  if (r >= Qi && r < Md && t >= Hi && t < Gd)
    return Js + (r - Qi) * Vi + (t - Hi) * vs;
  if (cl(r) && t > _i && t < Qd && (r - Js) % vs == 0)
    return r + (t - _i);
  {
    let e = Bi.get(r);
    return e && (e = e.get(t), e) ? e : -1;
  }
}
function ul(r) {
  qo || Hd();
  let t = [], e = [], n = !1;
  function s(i) {
    let o = qo.get(i);
    o && (n = !0, i |= o), t.push(i);
  }
  for (let i of r)
    for (; ; ) {
      if (i < 128)
        t.push(i);
      else if (cl(i)) {
        let o = i - Js, a = o / Vi | 0, c = o % Vi / vs | 0, u = o % vs;
        s(Qi + a), s(Hi + c), u > 0 && s(_i + u);
      } else {
        let o = $o.get(i);
        o ? e.push(...o) : s(i);
      }
      if (!e.length)
        break;
      i = e.pop();
    }
  if (n && t.length > 1) {
    let i = Rs(t[0]);
    for (let o = 1; o < t.length; o++) {
      let a = Rs(t[o]);
      if (a == 0 || i <= a) {
        i = a;
        continue;
      }
      let c = o - 1;
      for (; ; ) {
        let u = t[c + 1];
        if (t[c + 1] = t[c], t[c] = u, !c || (i = Rs(t[--c]), i <= a))
          break;
      }
      i = Rs(t[o]);
    }
  }
  return t;
}
function Vd(r) {
  let t = [], e = [], n = -1, s = 0;
  for (let i of r) {
    let o = Rs(i), a = al(i);
    if (n == -1)
      o == 0 ? n = a : t.push(a);
    else if (s > 0 && s >= o)
      o == 0 ? (t.push(n, ...e), e.length = 0, n = a) : e.push(a), s = o;
    else {
      let c = _d(n, a);
      c >= 0 ? n = c : s == 0 && o == 0 ? (t.push(n), n = a) : (e.push(a), s = o);
    }
  }
  return n >= 0 && t.push(n, ...e), t;
}
function ll(r) {
  return ul(r).map(al);
}
function Jd(r) {
  return Vd(ul(r));
}
const Fc = 45, fl = ".", hl = 65039, dl = 1, Nr = (r) => Array.from(r);
function js(r, t) {
  return r.P.has(t) || r.Q.has(t);
}
class jd extends Array {
  get is_emoji() {
    return !0;
  }
  // free tagging system
}
let ta, pl, Mn, ea, gl, Br, So, Ar, yl, Lc, na;
function ka() {
  if (ta)
    return;
  let r = tl(xd);
  const t = () => _s(r), e = () => new Set(t());
  ta = new Map(nl(r)), pl = e(), Mn = t(), ea = new Set(t().map((f) => Mn[f])), Mn = new Set(Mn), gl = e(), e();
  let n = el(r), s = r();
  const i = () => new Set(t().flatMap((f) => n[f]).concat(t()));
  Br = Vs((f) => {
    let h = Vs(r).map((g) => g + 96);
    if (h.length) {
      let g = f >= s;
      h[0] -= 32, h = Es(h), g && (h = `Restricted[${h}]`);
      let w = i(), E = i(), m = !r();
      return { N: h, P: w, Q: E, M: m, R: g };
    }
  }), So = e(), Ar = /* @__PURE__ */ new Map();
  let o = t().concat(Nr(So)).sort((f, h) => f - h);
  o.forEach((f, h) => {
    let g = r(), w = o[h] = g ? o[h - g] : { V: [], M: /* @__PURE__ */ new Map() };
    w.V.push(f), So.has(f) || Ar.set(f, w);
  });
  for (let { V: f, M: h } of new Set(Ar.values())) {
    let g = [];
    for (let E of f) {
      let m = Br.filter((v) => js(v, E)), x = g.find(({ G: v }) => m.some((B) => v.has(B)));
      x || (x = { G: /* @__PURE__ */ new Set(), V: [] }, g.push(x)), x.V.push(E), m.forEach((v) => x.G.add(v));
    }
    let w = g.flatMap((E) => Nr(E.G));
    for (let { G: E, V: m } of g) {
      let x = new Set(w.filter((v) => !E.has(v)));
      for (let v of m)
        h.set(v, x);
    }
  }
  let a = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();
  const u = (f) => a.has(f) ? c.add(f) : a.add(f);
  for (let f of Br) {
    for (let h of f.P)
      u(h);
    for (let h of f.Q)
      u(h);
  }
  for (let f of a)
    !Ar.has(f) && !c.has(f) && Ar.set(f, dl);
  yl = new Set(Nr(a).concat(Nr(ll(a)))), Lc = Rd(r).map((f) => jd.from(f)).sort(Ud), na = /* @__PURE__ */ new Map();
  for (let f of Lc) {
    let h = [na];
    for (let g of f) {
      let w = h.map((E) => {
        let m = E.get(g);
        return m || (m = /* @__PURE__ */ new Map(), E.set(g, m)), m;
      });
      g === hl ? h.push(...w) : h = w;
    }
    for (let g of h)
      g.V = f;
  }
}
function Sa(r) {
  return (ml(r) ? "" : `${Ua(lo([r]))} `) + sl(r);
}
function Ua(r) {
  return `"${r}"‎`;
}
function zd(r) {
  if (r.length >= 4 && r[2] == Fc && r[3] == Fc)
    throw new Error(`invalid label extension: "${Es(r.slice(0, 4))}"`);
}
function Kd(r) {
  for (let e = r.lastIndexOf(95); e > 0; )
    if (r[--e] !== 95)
      throw new Error("underscore allowed only at start");
}
function Wd(r) {
  let t = r[0], e = Sc.get(t);
  if (e)
    throw Ds(`leading ${e}`);
  let n = r.length, s = -1;
  for (let i = 1; i < n; i++) {
    t = r[i];
    let o = Sc.get(t);
    if (o) {
      if (s == i)
        throw Ds(`${e} + ${o}`);
      s = i + 1, e = o;
    }
  }
  if (s == n)
    throw Ds(`trailing ${e}`);
}
function lo(r, t = sl) {
  let e = [];
  Yd(r[0]) && e.push("◌");
  let n = 0, s = r.length;
  for (let i = 0; i < s; i++) {
    let o = r[i];
    ml(o) && (e.push(Es(r.slice(n, i))), e.push(t(o)), n = i + 1);
  }
  return e.push(Es(r.slice(n, s))), e.join("");
}
function Yd(r) {
  return ka(), Mn.has(r);
}
function ml(r) {
  return ka(), gl.has(r);
}
function Zd(r) {
  return tp(Xd(r, Jd, rp));
}
function Xd(r, t, e) {
  if (!r)
    return [];
  ka();
  let n = 0;
  return r.split(fl).map((s) => {
    let i = Sd(s), o = {
      input: i,
      offset: n
      // codepoint, not substring!
    };
    n += i.length + 1;
    try {
      let a = o.tokens = np(i, t, e), c = a.length, u;
      if (!c)
        throw new Error("empty label");
      let f = o.output = a.flat();
      if (Kd(f), !(o.emoji = c > 1 || a[0].is_emoji) && f.every((g) => g < 128))
        zd(f), u = "ASCII";
      else {
        let g = a.flatMap((w) => w.is_emoji ? [] : w);
        if (!g.length)
          u = "Emoji";
        else {
          if (Mn.has(f[0]))
            throw Ds("leading combining mark");
          for (let m = 1; m < c; m++) {
            let x = a[m];
            if (!x.is_emoji && Mn.has(x[0]))
              throw Ds(`emoji + combining mark: "${Es(a[m - 1])} + ${lo([x[0]])}"`);
          }
          Wd(f);
          let w = Nr(new Set(g)), [E] = $d(w);
          ep(E, g), qd(E, w), u = E.N;
        }
      }
      o.type = u;
    } catch (a) {
      o.error = a;
    }
    return o;
  });
}
function qd(r, t) {
  let e, n = [];
  for (let s of t) {
    let i = Ar.get(s);
    if (i === dl)
      return;
    if (i) {
      let o = i.M.get(s);
      if (e = e ? e.filter((a) => o.has(a)) : Nr(o), !e.length)
        return;
    } else
      n.push(s);
  }
  if (e) {
    for (let s of e)
      if (n.every((i) => js(s, i)))
        throw new Error(`whole-script confusable: ${r.N}/${s.N}`);
  }
}
function $d(r) {
  let t = Br;
  for (let e of r) {
    let n = t.filter((s) => js(s, e));
    if (!n.length)
      throw Br.some((s) => js(s, e)) ? Al(t[0], e) : wl(e);
    if (t = n, n.length == 1)
      break;
  }
  return t;
}
function tp(r) {
  return r.map(({ input: t, error: e, output: n }) => {
    if (e) {
      let s = e.message;
      throw new Error(r.length == 1 ? s : `Invalid label ${Ua(lo(t))}: ${s}`);
    }
    return Es(n);
  }).join(fl);
}
function wl(r) {
  return new Error(`disallowed character: ${Sa(r)}`);
}
function Al(r, t) {
  let e = Sa(t), n = Br.find((s) => s.P.has(t));
  return n && (e = `${n.N} ${e}`), new Error(`illegal mixture: ${r.N} + ${e}`);
}
function Ds(r) {
  return new Error(`illegal placement: ${r}`);
}
function ep(r, t) {
  for (let e of t)
    if (!js(r, e))
      throw Al(r, e);
  if (r.M) {
    let e = ll(t);
    for (let n = 1, s = e.length; n < s; n++)
      if (ea.has(e[n])) {
        let i = n + 1;
        for (let o; i < s && ea.has(o = e[i]); i++)
          for (let a = n; a < i; a++)
            if (e[a] == o)
              throw new Error(`duplicate non-spacing marks: ${Sa(o)}`);
        if (i - n > Uc)
          throw new Error(`excessive non-spacing marks: ${Ua(lo(e.slice(n - 1, i)))} (${i - n}/${Uc})`);
        n = i;
      }
  }
}
function np(r, t, e) {
  let n = [], s = [];
  for (r = r.slice().reverse(); r.length; ) {
    let i = sp(r);
    if (i)
      s.length && (n.push(t(s)), s = []), n.push(e(i));
    else {
      let o = r.pop();
      if (yl.has(o))
        s.push(o);
      else {
        let a = ta.get(o);
        if (a)
          s.push(...a);
        else if (!pl.has(o))
          throw wl(o);
      }
    }
  }
  return s.length && n.push(t(s)), n;
}
function rp(r) {
  return r.filter((t) => t != hl);
}
function sp(r, t) {
  let e = na, n, s = r.length;
  for (; s && (e = e.get(r[--s]), !!e); ) {
    let { V: i } = e;
    i && (n = i, t && t.push(...r.slice(s).reverse()), r.length = s);
  }
  return n;
}
const bl = new Uint8Array(32);
bl.fill(0);
function Mc(r) {
  return y(r.length !== 0, "invalid ENS name; empty component", "comp", r), r;
}
function El(r) {
  const t = en(ip(r)), e = [];
  if (r.length === 0)
    return e;
  let n = 0;
  for (let s = 0; s < t.length; s++)
    t[s] === 46 && (e.push(Mc(t.slice(n, s))), n = s + 1);
  return y(n < t.length, "invalid ENS name; empty component", "name", r), e.push(Mc(t.slice(n))), e;
}
function ip(r) {
  try {
    if (r.length === 0)
      throw new Error("empty label");
    return Zd(r);
  } catch (t) {
    y(!1, `invalid ENS name (${t.message})`, "name", r);
  }
}
function ra(r) {
  y(typeof r == "string", "invalid ENS name; not a string", "name", r), y(r.length, "invalid ENS name (empty label)", "name", r);
  let t = bl;
  const e = El(r);
  for (; e.length; )
    t = it(pt([t, it(e.pop())]));
  return F(t);
}
function op(r) {
  return F(pt(El(r).map((t) => {
    if (t.length > 63)
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    const e = new Uint8Array(t.length + 1);
    return e.set(t, 1), e[0] = e.length - 1, e;
  }))) + "00";
}
function Uo(r, t) {
  return {
    address: W(r),
    storageKeys: t.map((e, n) => (y(ot(e, 32), "invalid slot", `storageKeys[${n}]`, e), e.toLowerCase()))
  };
}
function hr(r) {
  if (Array.isArray(r))
    return r.map((e, n) => Array.isArray(e) ? (y(e.length === 2, "invalid slot set", `value[${n}]`, e), Uo(e[0], e[1])) : (y(e != null && typeof e == "object", "invalid address-slot set", "value", r), Uo(e.address, e.storageKeys)));
  y(r != null && typeof r == "object", "invalid access list", "value", r);
  const t = Object.keys(r).map((e) => {
    const n = r[e].reduce((s, i) => (s[i] = !0, s), {});
    return Uo(e, Object.keys(n).sort());
  });
  return t.sort((e, n) => e.address.localeCompare(n.address)), t;
}
function ap(r) {
  let t;
  return typeof r == "string" ? t = Hs.computePublicKey(r, !1) : t = r.publicKey, W(it("0x" + t.substring(4)).substring(26));
}
function cp(r, t) {
  return ap(Hs.recoverPublicKey(r, t));
}
const Gt = BigInt(0), up = BigInt(2), lp = BigInt(27), fp = BigInt(28), hp = BigInt(35), dp = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function Da(r) {
  return r === "0x" ? null : W(r);
}
function vl(r, t) {
  try {
    return hr(r);
  } catch (e) {
    y(!1, e.message, t, r);
  }
}
function fo(r, t) {
  return r === "0x" ? 0 : V(r, t);
}
function kt(r, t) {
  if (r === "0x")
    return Gt;
  const e = L(r, t);
  return y(e <= dp, "value exceeds uint size", t, e), e;
}
function wt(r, t) {
  const e = L(r, "value"), n = Yt(e);
  return y(n.length <= 32, "value too large", `tx.${t}`, e), n;
}
function xl(r) {
  return hr(r).map((t) => [t.address, t.storageKeys]);
}
function pp(r) {
  const t = xa(r);
  y(Array.isArray(t) && (t.length === 9 || t.length === 6), "invalid field count for legacy transaction", "data", r);
  const e = {
    type: 0,
    nonce: fo(t[0], "nonce"),
    gasPrice: kt(t[1], "gasPrice"),
    gasLimit: kt(t[2], "gasLimit"),
    to: Da(t[3]),
    value: kt(t[4], "value"),
    data: F(t[5]),
    chainId: Gt
  };
  if (t.length === 6)
    return e;
  const n = kt(t[6], "v"), s = kt(t[7], "r"), i = kt(t[8], "s");
  if (s === Gt && i === Gt)
    e.chainId = n;
  else {
    let o = (n - hp) / up;
    o < Gt && (o = Gt), e.chainId = o, y(o !== Gt || n === lp || n === fp, "non-canonical legacy v", "v", t[6]), e.signature = we.from({
      r: ar(t[7], 32),
      s: ar(t[8], 32),
      v: n
    }), e.hash = it(r);
  }
  return e;
}
function Gc(r, t) {
  const e = [
    wt(r.nonce || 0, "nonce"),
    wt(r.gasPrice || 0, "gasPrice"),
    wt(r.gasLimit || 0, "gasLimit"),
    r.to != null ? W(r.to) : "0x",
    wt(r.value || 0, "value"),
    r.data || "0x"
  ];
  let n = Gt;
  if (r.chainId != Gt)
    n = L(r.chainId, "tx.chainId"), y(!t || t.networkV == null || t.legacyChainId === n, "tx.chainId/sig.v mismatch", "sig", t);
  else if (r.signature) {
    const i = r.signature.legacyChainId;
    i != null && (n = i);
  }
  if (!t)
    return n !== Gt && (e.push(Yt(n)), e.push("0x"), e.push("0x")), Gs(e);
  let s = BigInt(27 + t.yParity);
  return n !== Gt ? s = we.getChainIdV(n, t.v) : BigInt(t.v) !== s && y(!1, "tx.chainId/sig.v mismatch", "sig", t), e.push(Yt(s)), e.push(Yt(t.r)), e.push(Yt(t.s)), Gs(e);
}
function Pl(r, t) {
  let e;
  try {
    if (e = fo(t[0], "yParity"), e !== 0 && e !== 1)
      throw new Error("bad yParity");
  } catch {
    y(!1, "invalid yParity", "yParity", t[0]);
  }
  const n = ar(t[1], 32), s = ar(t[2], 32), i = we.from({ r: n, s, yParity: e });
  r.signature = i;
}
function gp(r) {
  const t = xa(X(r).slice(1));
  y(Array.isArray(t) && (t.length === 9 || t.length === 12), "invalid field count for transaction type: 2", "data", F(r));
  const e = kt(t[2], "maxPriorityFeePerGas"), n = kt(t[3], "maxFeePerGas"), s = {
    type: 2,
    chainId: kt(t[0], "chainId"),
    nonce: fo(t[1], "nonce"),
    maxPriorityFeePerGas: e,
    maxFeePerGas: n,
    gasPrice: null,
    gasLimit: kt(t[4], "gasLimit"),
    to: Da(t[5]),
    value: kt(t[6], "value"),
    data: F(t[7]),
    accessList: vl(t[8], "accessList")
  };
  return t.length === 9 || (s.hash = it(r), Pl(s, t.slice(9))), s;
}
function Qc(r, t) {
  const e = [
    wt(r.chainId || 0, "chainId"),
    wt(r.nonce || 0, "nonce"),
    wt(r.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    wt(r.maxFeePerGas || 0, "maxFeePerGas"),
    wt(r.gasLimit || 0, "gasLimit"),
    r.to != null ? W(r.to) : "0x",
    wt(r.value || 0, "value"),
    r.data || "0x",
    xl(r.accessList || [])
  ];
  return t && (e.push(wt(t.yParity, "yParity")), e.push(Yt(t.r)), e.push(Yt(t.s))), pt(["0x02", Gs(e)]);
}
function yp(r) {
  const t = xa(X(r).slice(1));
  y(Array.isArray(t) && (t.length === 8 || t.length === 11), "invalid field count for transaction type: 1", "data", F(r));
  const e = {
    type: 1,
    chainId: kt(t[0], "chainId"),
    nonce: fo(t[1], "nonce"),
    gasPrice: kt(t[2], "gasPrice"),
    gasLimit: kt(t[3], "gasLimit"),
    to: Da(t[4]),
    value: kt(t[5], "value"),
    data: F(t[6]),
    accessList: vl(t[7], "accessList")
  };
  return t.length === 8 || (e.hash = it(r), Pl(e, t.slice(8))), e;
}
function Hc(r, t) {
  const e = [
    wt(r.chainId || 0, "chainId"),
    wt(r.nonce || 0, "nonce"),
    wt(r.gasPrice || 0, "gasPrice"),
    wt(r.gasLimit || 0, "gasLimit"),
    r.to != null ? W(r.to) : "0x",
    wt(r.value || 0, "value"),
    r.data || "0x",
    xl(r.accessList || [])
  ];
  return t && (e.push(wt(t.yParity, "recoveryParam")), e.push(Yt(t.r)), e.push(Yt(t.s))), pt(["0x01", Gs(e)]);
}
var je, Hr, _r, Vr, Jr, jr, zr, Kr, Wr, Yr, Zr, Xr;
const hn = class hn {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    b(this, je, void 0);
    b(this, Hr, void 0);
    b(this, _r, void 0);
    b(this, Vr, void 0);
    b(this, Jr, void 0);
    b(this, jr, void 0);
    b(this, zr, void 0);
    b(this, Kr, void 0);
    b(this, Wr, void 0);
    b(this, Yr, void 0);
    b(this, Zr, void 0);
    b(this, Xr, void 0);
    d(this, je, null), d(this, Hr, null), d(this, Vr, 0), d(this, Jr, BigInt(0)), d(this, jr, null), d(this, zr, null), d(this, Kr, null), d(this, _r, "0x"), d(this, Wr, BigInt(0)), d(this, Yr, BigInt(0)), d(this, Zr, null), d(this, Xr, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return l(this, je);
  }
  set type(t) {
    switch (t) {
      case null:
        d(this, je, null);
        break;
      case 0:
      case "legacy":
        d(this, je, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        d(this, je, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        d(this, je, 2);
        break;
      default:
        y(!1, "unsupported transaction type", "type", t);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    return l(this, Hr);
  }
  set to(t) {
    d(this, Hr, t == null ? null : W(t));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return l(this, Vr);
  }
  set nonce(t) {
    d(this, Vr, V(t, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return l(this, Jr);
  }
  set gasLimit(t) {
    d(this, Jr, L(t));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const t = l(this, jr);
    return t == null && (this.type === 0 || this.type === 1) ? Gt : t;
  }
  set gasPrice(t) {
    d(this, jr, t == null ? null : L(t, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const t = l(this, zr);
    return t ?? (this.type === 2 ? Gt : null);
  }
  set maxPriorityFeePerGas(t) {
    d(this, zr, t == null ? null : L(t, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const t = l(this, Kr);
    return t ?? (this.type === 2 ? Gt : null);
  }
  set maxFeePerGas(t) {
    d(this, Kr, t == null ? null : L(t, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return l(this, _r);
  }
  set data(t) {
    d(this, _r, F(t));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return l(this, Wr);
  }
  set value(t) {
    d(this, Wr, L(t, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return l(this, Yr);
  }
  set chainId(t) {
    d(this, Yr, L(t));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return l(this, Zr) || null;
  }
  set signature(t) {
    d(this, Zr, t == null ? null : we.from(t));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const t = l(this, Xr) || null;
    return t ?? (this.type === 1 || this.type === 2 ? [] : null);
  }
  set accessList(t) {
    d(this, Xr, t == null ? null : hr(t));
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    return this.signature == null ? null : it(this.serialized);
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return it(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    return this.signature == null ? null : cp(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    return this.signature == null ? null : Hs.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    switch (P(this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" }), this.inferType()) {
      case 0:
        return Gc(this, this.signature);
      case 1:
        return Hc(this, this.signature);
      case 2:
        return Qc(this, this.signature);
    }
    P(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    switch (this.inferType()) {
      case 0:
        return Gc(this);
      case 1:
        return Hc(this);
      case 2:
        return Qc(this);
    }
    P(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".unsignedSerialized" });
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    return this.inferTypes().pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const t = this.gasPrice != null, e = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null, n = this.accessList != null;
    this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && P(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this }), P(!e || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this }), P(this.type !== 0 || !n, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const s = [];
    return this.type != null ? s.push(this.type) : e ? s.push(2) : t ? (s.push(1), n || s.push(0)) : n ? (s.push(1), s.push(2)) : (s.push(0), s.push(1), s.push(2)), s.sort(), s;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return hn.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const t = (e) => e == null ? null : e.toString();
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: t(this.gasLimit),
      gasPrice: t(this.gasPrice),
      maxPriorityFeePerGas: t(this.maxPriorityFeePerGas),
      maxFeePerGas: t(this.maxFeePerGas),
      value: t(this.value),
      chainId: t(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(t) {
    if (t == null)
      return new hn();
    if (typeof t == "string") {
      const n = X(t);
      if (n[0] >= 127)
        return hn.from(pp(n));
      switch (n[0]) {
        case 1:
          return hn.from(yp(n));
        case 2:
          return hn.from(gp(n));
      }
      P(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const e = new hn();
    return t.type != null && (e.type = t.type), t.to != null && (e.to = t.to), t.nonce != null && (e.nonce = t.nonce), t.gasLimit != null && (e.gasLimit = t.gasLimit), t.gasPrice != null && (e.gasPrice = t.gasPrice), t.maxPriorityFeePerGas != null && (e.maxPriorityFeePerGas = t.maxPriorityFeePerGas), t.maxFeePerGas != null && (e.maxFeePerGas = t.maxFeePerGas), t.data != null && (e.data = t.data), t.value != null && (e.value = t.value), t.chainId != null && (e.chainId = t.chainId), t.signature != null && (e.signature = we.from(t.signature)), t.accessList != null && (e.accessList = t.accessList), t.hash != null && (y(e.isSigned(), "unsigned transaction cannot define hash", "tx", t), y(e.hash === t.hash, "hash mismatch", "tx", t)), t.from != null && (y(e.isSigned(), "unsigned transaction cannot define from", "tx", t), y(e.from.toLowerCase() === (t.from || "").toLowerCase(), "from mismatch", "tx", t)), e;
  }
};
je = new WeakMap(), Hr = new WeakMap(), _r = new WeakMap(), Vr = new WeakMap(), Jr = new WeakMap(), jr = new WeakMap(), zr = new WeakMap(), Kr = new WeakMap(), Wr = new WeakMap(), Yr = new WeakMap(), Zr = new WeakMap(), Xr = new WeakMap();
let Ji = hn;
const Nl = new Uint8Array(32);
Nl.fill(0);
const mp = BigInt(-1), Cl = BigInt(0), Tl = BigInt(1), wp = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function Ap(r) {
  const t = X(r), e = t.length % 32;
  return e ? pt([t, Nl.slice(e)]) : F(t);
}
const bp = Bn(Tl, 32), Ep = Bn(Cl, 32), _c = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, Do = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function Vc(r) {
  return function(t) {
    return y(typeof t == "string", `invalid domain value for ${JSON.stringify(r)}`, `domain.${r}`, t), t;
  };
}
const vp = {
  name: Vc("name"),
  version: Vc("version"),
  chainId: function(r) {
    const t = L(r, "domain.chainId");
    return y(t >= 0, "invalid chain ID", "domain.chainId", r), Number.isSafeInteger(t) ? Number(t) : Pr(t);
  },
  verifyingContract: function(r) {
    try {
      return W(r).toLowerCase();
    } catch {
    }
    y(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", r);
  },
  salt: function(r) {
    const t = X(r, "domain.salt");
    return y(t.length === 32, 'invalid domain value "salt"', "domain.salt", r), F(t);
  }
};
function Fo(r) {
  {
    const t = r.match(/^(u?)int(\d*)$/);
    if (t) {
      const e = t[1] === "", n = parseInt(t[2] || "256");
      y(n % 8 === 0 && n !== 0 && n <= 256 && (t[2] == null || t[2] === String(n)), "invalid numeric width", "type", r);
      const s = Is(wp, e ? n - 1 : n), i = e ? (s + Tl) * mp : Cl;
      return function(o) {
        const a = L(o, "value");
        return y(a >= i && a <= s, `value out-of-bounds for ${r}`, "value", a), Bn(e ? Eu(a, 256) : a, 32);
      };
    }
  }
  {
    const t = r.match(/^bytes(\d+)$/);
    if (t) {
      const e = parseInt(t[1]);
      return y(e !== 0 && e <= 32 && t[1] === String(e), "invalid bytes width", "type", r), function(n) {
        const s = X(n);
        return y(s.length === e, `invalid length for ${r}`, "value", n), Ap(n);
      };
    }
  }
  switch (r) {
    case "address":
      return function(t) {
        return ar(W(t), 32);
      };
    case "bool":
      return function(t) {
        return t ? bp : Ep;
      };
    case "bytes":
      return function(t) {
        return it(t);
      };
    case "string":
      return function(t) {
        return cr(t);
      };
  }
  return null;
}
function Jc(r, t) {
  return `${r}(${t.map(({ name: e, type: n }) => n + " " + e).join(",")})`;
}
var $s, ze, qr, qi, Ol;
const qt = class qt {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(t) {
    b(this, qi);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    A(this, "primaryType");
    b(this, $s, void 0);
    b(this, ze, void 0);
    b(this, qr, void 0);
    d(this, $s, JSON.stringify(t)), d(this, ze, /* @__PURE__ */ new Map()), d(this, qr, /* @__PURE__ */ new Map());
    const e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
    Object.keys(t).forEach((a) => {
      e.set(a, /* @__PURE__ */ new Set()), n.set(a, []), s.set(a, /* @__PURE__ */ new Set());
    });
    for (const a in t) {
      const c = /* @__PURE__ */ new Set();
      for (const u of t[a]) {
        y(!c.has(u.name), `duplicate variable name ${JSON.stringify(u.name)} in ${JSON.stringify(a)}`, "types", t), c.add(u.name);
        const f = u.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
        y(f !== a, `circular type reference to ${JSON.stringify(f)}`, "types", t), !Fo(f) && (y(n.has(f), `unknown type ${JSON.stringify(f)}`, "types", t), n.get(f).push(a), e.get(a).add(f));
      }
    }
    const i = Array.from(n.keys()).filter((a) => n.get(a).length === 0);
    y(i.length !== 0, "missing primary type", "types", t), y(i.length === 1, `ambiguous primary types or unused types: ${i.map((a) => JSON.stringify(a)).join(", ")}`, "types", t), M(this, { primaryType: i[0] });
    function o(a, c) {
      y(!c.has(a), `circular type reference to ${JSON.stringify(a)}`, "types", t), c.add(a);
      for (const u of e.get(a))
        if (n.has(u)) {
          o(u, c);
          for (const f of c)
            s.get(f).add(u);
        }
      c.delete(a);
    }
    o(this.primaryType, /* @__PURE__ */ new Set());
    for (const [a, c] of s) {
      const u = Array.from(c);
      u.sort(), l(this, ze).set(a, Jc(a, t[a]) + u.map((f) => Jc(f, t[f])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(l(this, $s));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(t) {
    let e = l(this, qr).get(t);
    return e || (e = O(this, qi, Ol).call(this, t), l(this, qr).set(t, e)), e;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(t) {
    const e = l(this, ze).get(t);
    return y(e, `unknown type: ${JSON.stringify(t)}`, "name", t), e;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(t, e) {
    return this.getEncoder(t)(e);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(t, e) {
    return it(this.encodeData(t, e));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(t) {
    return this.encodeData(this.primaryType, t);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(t) {
    return this.hashStruct(this.primaryType, t);
  }
  /**
   *  @_ignore:
   */
  _visit(t, e, n) {
    if (Fo(t))
      return n(t, e);
    const s = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (s)
      return y(!s[3] || parseInt(s[3]) === e.length, `array length mismatch; expected length ${parseInt(s[3])}`, "value", e), e.map((o) => this._visit(s[1], o, n));
    const i = this.types[t];
    if (i)
      return i.reduce((o, { name: a, type: c }) => (o[a] = this._visit(c, e[a], n), o), {});
    y(!1, `unknown type: ${t}`, "type", t);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(t, e) {
    return this._visit(this.primaryType, t, e);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(t) {
    return new qt(t);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(t) {
    return qt.from(t).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(t, e, n) {
    return qt.from(e).hashStruct(t, n);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(t) {
    const e = [];
    for (const n in t) {
      if (t[n] == null)
        continue;
      const s = _c[n];
      y(s, `invalid typed-data domain key: ${JSON.stringify(n)}`, "domain", t), e.push({ name: n, type: s });
    }
    return e.sort((n, s) => Do.indexOf(n.name) - Do.indexOf(s.name)), qt.hashStruct("EIP712Domain", { EIP712Domain: e }, t);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(t, e, n) {
    return pt([
      "0x1901",
      qt.hashDomain(t),
      qt.from(e).hash(n)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(t, e, n) {
    return it(qt.encode(t, e, n));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(t, e, n, s) {
    t = Object.assign({}, t);
    for (const a in t)
      t[a] == null && delete t[a];
    const i = {};
    t.verifyingContract && !ot(t.verifyingContract, 20) && (i[t.verifyingContract] = "0x");
    const o = qt.from(e);
    o.visit(n, (a, c) => (a === "address" && !ot(c, 20) && (i[c] = "0x"), c));
    for (const a in i)
      i[a] = await s(a);
    return t.verifyingContract && i[t.verifyingContract] && (t.verifyingContract = i[t.verifyingContract]), n = o.visit(n, (a, c) => a === "address" && i[c] ? i[c] : c), { domain: t, value: n };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(t, e, n) {
    qt.hashDomain(t);
    const s = {}, i = [];
    Do.forEach((c) => {
      const u = t[c];
      u != null && (s[c] = vp[c](u), i.push({ name: c, type: _c[c] }));
    });
    const o = qt.from(e), a = Object.assign({}, e);
    return y(a.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", e), a.EIP712Domain = i, o.encode(n), {
      types: a,
      domain: s,
      primaryType: o.primaryType,
      message: o.visit(n, (c, u) => {
        if (c.match(/^bytes(\d*)/))
          return F(X(u));
        if (c.match(/^u?int/))
          return L(u).toString();
        switch (c) {
          case "address":
            return u.toLowerCase();
          case "bool":
            return !!u;
          case "string":
            return y(typeof u == "string", "invalid string", "value", u), u;
        }
        y(!1, "unsupported type", "type", c);
      })
    };
  }
};
$s = new WeakMap(), ze = new WeakMap(), qr = new WeakMap(), qi = new WeakSet(), Ol = function(t) {
  {
    const s = Fo(t);
    if (s)
      return s;
  }
  const e = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
  if (e) {
    const s = e[1], i = this.getEncoder(s);
    return (o) => {
      y(!e[3] || parseInt(e[3]) === o.length, `array length mismatch; expected length ${parseInt(e[3])}`, "value", o);
      let a = o.map(i);
      return l(this, ze).has(s) && (a = a.map(it)), it(pt(a));
    };
  }
  const n = this.types[t];
  if (n) {
    const s = cr(l(this, ze).get(t));
    return (i) => {
      const o = n.map(({ name: a, type: c }) => {
        const u = this.getEncoder(c)(i[a]);
        return l(this, ze).has(c) ? it(u) : u;
      });
      return o.unshift(s), pt(o);
    };
  }
  y(!1, `unknown type: ${t}`, "type", t);
};
let ji = qt;
function Dt(r) {
  const t = /* @__PURE__ */ new Set();
  return r.forEach((e) => t.add(e)), Object.freeze(t);
}
const xp = "external public payable", Pp = Dt(xp.split(" ")), Il = "constant external internal payable private public pure view", Np = Dt(Il.split(" ")), Bl = "constructor error event fallback function receive struct", Rl = Dt(Bl.split(" ")), kl = "calldata memory storage payable indexed", Cp = Dt(kl.split(" ")), Tp = "tuple returns", Op = [Bl, kl, Tp, Il].join(" "), Ip = Dt(Op.split(" ")), Bp = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
}, Rp = new RegExp("^(\\s*)"), kp = new RegExp("^([0-9]+)"), Sp = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"), Sl = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"), Ul = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var mt, ge, ti, sa;
const $i = class $i {
  constructor(t) {
    b(this, ti);
    b(this, mt, void 0);
    b(this, ge, void 0);
    d(this, mt, 0), d(this, ge, t.slice());
  }
  get offset() {
    return l(this, mt);
  }
  get length() {
    return l(this, ge).length - l(this, mt);
  }
  clone() {
    return new $i(l(this, ge));
  }
  reset() {
    d(this, mt, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(t) {
    const e = this.peek();
    if (e.type !== "KEYWORD" || !t.has(e.text))
      throw new Error(`expected keyword ${e.text}`);
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(t) {
    if (this.peek().type !== t)
      throw new Error(`expected ${t}; got ${JSON.stringify(this.peek())}`);
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const t = this.peek();
    if (t.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const e = O(this, ti, sa).call(this, l(this, mt) + 1, t.match + 1);
    return d(this, mt, t.match + 1), e;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const t = this.peek();
    if (t.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const e = [];
    for (; l(this, mt) < t.match - 1; ) {
      const n = this.peek().linkNext;
      e.push(O(this, ti, sa).call(this, l(this, mt) + 1, n)), d(this, mt, n);
    }
    return d(this, mt, t.match + 1), e;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (l(this, mt) >= l(this, ge).length)
      throw new Error("out-of-bounds");
    return l(this, ge)[l(this, mt)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(t) {
    const e = this.peekType("KEYWORD");
    return e != null && t.has(e) ? e : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(t) {
    if (this.length === 0)
      return null;
    const e = this.peek();
    return e.type === t ? e.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const t = this.peek();
    return Cs(this, mt)._++, t;
  }
  toString() {
    const t = [];
    for (let e = l(this, mt); e < l(this, ge).length; e++) {
      const n = l(this, ge)[e];
      t.push(`${n.type}:${n.text}`);
    }
    return `<TokenString ${t.join(" ")}>`;
  }
};
mt = new WeakMap(), ge = new WeakMap(), ti = new WeakSet(), sa = function(t = 0, e = 0) {
  return new $i(l(this, ge).slice(t, e).map((n) => Object.freeze(Object.assign({}, n, {
    match: n.match - t,
    linkBack: n.linkBack - t,
    linkNext: n.linkNext - t
  }))));
};
let Ae = $i;
function kn(r) {
  const t = [], e = (o) => {
    const a = i < r.length ? JSON.stringify(r[i]) : "$EOI";
    throw new Error(`invalid token ${a} at ${i}: ${o}`);
  };
  let n = [], s = [], i = 0;
  for (; i < r.length; ) {
    let o = r.substring(i), a = o.match(Rp);
    a && (i += a[1].length, o = r.substring(i));
    const c = { depth: n.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset: i, value: -1 };
    t.push(c);
    let u = Bp[o[0]] || "";
    if (u) {
      if (c.type = u, c.text = o[0], i++, u === "OPEN_PAREN")
        n.push(t.length - 1), s.push(t.length - 1);
      else if (u == "CLOSE_PAREN")
        n.length === 0 && e("no matching open bracket"), c.match = n.pop(), t[c.match].match = t.length - 1, c.depth--, c.linkBack = s.pop(), t[c.linkBack].linkNext = t.length - 1;
      else if (u === "COMMA")
        c.linkBack = s.pop(), t[c.linkBack].linkNext = t.length - 1, s.push(t.length - 1);
      else if (u === "OPEN_BRACKET")
        c.type = "BRACKET";
      else if (u === "CLOSE_BRACKET") {
        let f = t.pop().text;
        if (t.length > 0 && t[t.length - 1].type === "NUMBER") {
          const h = t.pop().text;
          f = h + f, t[t.length - 1].value = V(h);
        }
        if (t.length === 0 || t[t.length - 1].type !== "BRACKET")
          throw new Error("missing opening bracket");
        t[t.length - 1].text += f;
      }
      continue;
    }
    if (a = o.match(Sp), a) {
      if (c.text = a[1], i += c.text.length, Ip.has(c.text)) {
        c.type = "KEYWORD";
        continue;
      }
      if (c.text.match(Ul)) {
        c.type = "TYPE";
        continue;
      }
      c.type = "ID";
      continue;
    }
    if (a = o.match(kp), a) {
      c.text = a[1], c.type = "NUMBER", i += c.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(o[0])} at position ${i}`);
  }
  return new Ae(t.map((o) => Object.freeze(o)));
}
function jc(r, t) {
  let e = [];
  for (const n in t.keys())
    r.has(n) && e.push(n);
  if (e.length > 1)
    throw new Error(`conflicting types: ${e.join(", ")}`);
}
function ho(r, t) {
  if (t.peekKeyword(Rl)) {
    const e = t.pop().text;
    if (e !== r)
      throw new Error(`expected ${r}, got ${e}`);
  }
  return t.popType("ID");
}
function rn(r, t) {
  const e = /* @__PURE__ */ new Set();
  for (; ; ) {
    const n = r.peekType("KEYWORD");
    if (n == null || t && !t.has(n))
      break;
    if (r.pop(), e.has(n))
      throw new Error(`duplicate keywords: ${JSON.stringify(n)}`);
    e.add(n);
  }
  return Object.freeze(e);
}
function Dl(r) {
  let t = rn(r, Np);
  return jc(t, Dt("constant payable nonpayable".split(" "))), jc(t, Dt("pure view payable nonpayable".split(" "))), t.has("view") ? "view" : t.has("pure") ? "pure" : t.has("payable") ? "payable" : t.has("nonpayable") ? "nonpayable" : t.has("constant") ? "view" : "nonpayable";
}
function nn(r, t) {
  return r.popParams().map((e) => At.from(e, t));
}
function Fl(r) {
  if (r.peekType("AT")) {
    if (r.pop(), r.peekType("NUMBER"))
      return L(r.pop().text);
    throw new Error("invalid gas");
  }
  return null;
}
function ur(r) {
  if (r.length)
    throw new Error(`unexpected tokens: ${r.toString()}`);
}
const Up = new RegExp(/^(.*)\[([0-9]*)\]$/);
function zc(r) {
  const t = r.match(Ul);
  if (y(t, "invalid type", "type", r), r === "uint")
    return "uint256";
  if (r === "int")
    return "int256";
  if (t[2]) {
    const e = parseInt(t[2]);
    y(e !== 0 && e <= 32, "invalid bytes length", "type", r);
  } else if (t[3]) {
    const e = parseInt(t[3]);
    y(e !== 0 && e <= 256 && e % 8 === 0, "invalid numeric width", "type", r);
  }
  return r;
}
const st = {}, _t = Symbol.for("_ethers_internal"), Kc = "_ParamTypeInternal", Wc = "_ErrorInternal", Yc = "_EventInternal", Zc = "_ConstructorInternal", Xc = "_FallbackInternal", qc = "_FunctionInternal", $c = "_StructInternal";
var $r, Ri;
const $t = class $t {
  /**
   *  @private
   */
  constructor(t, e, n, s, i, o, a, c) {
    b(this, $r);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    A(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    A(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    A(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    A(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    A(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    A(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    A(this, "arrayChildren");
    if (so(t, st, "ParamType"), Object.defineProperty(this, _t, { value: Kc }), o && (o = Object.freeze(o.slice())), s === "array") {
      if (a == null || c == null)
        throw new Error("");
    } else if (a != null || c != null)
      throw new Error("");
    if (s === "tuple") {
      if (o == null)
        throw new Error("");
    } else if (o != null)
      throw new Error("");
    M(this, {
      name: e,
      type: n,
      baseType: s,
      indexed: i,
      components: o,
      arrayLength: a,
      arrayChildren: c
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(t) {
    if (t == null && (t = "sighash"), t === "json") {
      const n = this.name || "";
      if (this.isArray()) {
        const i = JSON.parse(this.arrayChildren.format("json"));
        return i.name = n, i.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`, JSON.stringify(i);
      }
      const s = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: n
      };
      return typeof this.indexed == "boolean" && (s.indexed = this.indexed), this.isTuple() && (s.components = this.components.map((i) => JSON.parse(i.format(t)))), JSON.stringify(s);
    }
    let e = "";
    return this.isArray() ? (e += this.arrayChildren.format(t), e += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`) : this.isTuple() ? e += "(" + this.components.map((n) => n.format(t)).join(t === "full" ? ", " : ",") + ")" : e += this.type, t !== "sighash" && (this.indexed === !0 && (e += " indexed"), t === "full" && this.name && (e += " " + this.name)), e;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(t, e) {
    if (this.isArray()) {
      if (!Array.isArray(t))
        throw new Error("invalid array value");
      if (this.arrayLength !== -1 && t.length !== this.arrayLength)
        throw new Error("array is wrong length");
      const n = this;
      return t.map((s) => n.arrayChildren.walk(s, e));
    }
    if (this.isTuple()) {
      if (!Array.isArray(t))
        throw new Error("invalid tuple value");
      if (t.length !== this.components.length)
        throw new Error("array is wrong length");
      const n = this;
      return t.map((s, i) => n.components[i].walk(s, e));
    }
    return e(this.type, t);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS naes by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(t, e) {
    const n = [], s = [t];
    return O(this, $r, Ri).call(this, n, t, e, (i) => {
      s[0] = i;
    }), n.length && await Promise.all(n), s[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(t, e) {
    if ($t.isParamType(t))
      return t;
    if (typeof t == "string")
      try {
        return $t.from(kn(t), e);
      } catch {
        y(!1, "invalid param type", "obj", t);
      }
    else if (t instanceof Ae) {
      let a = "", c = "", u = null;
      rn(t, Dt(["tuple"])).has("tuple") || t.peekType("OPEN_PAREN") ? (c = "tuple", u = t.popParams().map((m) => $t.from(m)), a = `tuple(${u.map((m) => m.format()).join(",")})`) : (a = zc(t.popType("TYPE")), c = a);
      let f = null, h = null;
      for (; t.length && t.peekType("BRACKET"); ) {
        const m = t.pop();
        f = new $t(st, "", a, c, null, u, h, f), h = m.value, a += m.text, c = "array", u = null;
      }
      let g = null;
      if (rn(t, Cp).has("indexed")) {
        if (!e)
          throw new Error("");
        g = !0;
      }
      const E = t.peekType("ID") ? t.pop().text : "";
      if (t.length)
        throw new Error("leftover tokens");
      return new $t(st, E, a, c, g, u, h, f);
    }
    const n = t.name;
    y(!n || typeof n == "string" && n.match(Sl), "invalid name", "obj.name", n);
    let s = t.indexed;
    s != null && (y(e, "parameter cannot be indexed", "obj.indexed", t.indexed), s = !!s);
    let i = t.type, o = i.match(Up);
    if (o) {
      const a = parseInt(o[2] || "-1"), c = $t.from({
        type: o[1],
        components: t.components
      });
      return new $t(st, n || "", i, "array", s, null, a, c);
    }
    if (i === "tuple" || i.startsWith(
      "tuple("
      /* fix: ) */
    ) || i.startsWith(
      "("
      /* fix: ) */
    )) {
      const a = t.components != null ? t.components.map((u) => $t.from(u)) : null;
      return new $t(st, n || "", i, "tuple", s, a, null, null);
    }
    return i = zc(t.type), new $t(st, n || "", i, i, s, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(t) {
    return t && t[_t] === Kc;
  }
};
$r = new WeakSet(), Ri = function(t, e, n, s) {
  if (this.isArray()) {
    if (!Array.isArray(e))
      throw new Error("invalid array value");
    if (this.arrayLength !== -1 && e.length !== this.arrayLength)
      throw new Error("array is wrong length");
    const o = this.arrayChildren, a = e.slice();
    a.forEach((c, u) => {
      var f;
      O(f = o, $r, Ri).call(f, t, c, n, (h) => {
        a[u] = h;
      });
    }), s(a);
    return;
  }
  if (this.isTuple()) {
    const o = this.components;
    let a;
    if (Array.isArray(e))
      a = e.slice();
    else {
      if (e == null || typeof e != "object")
        throw new Error("invalid tuple value");
      a = o.map((c) => {
        if (!c.name)
          throw new Error("cannot use object value with unnamed components");
        if (!(c.name in e))
          throw new Error(`missing value for component ${c.name}`);
        return e[c.name];
      });
    }
    if (a.length !== this.components.length)
      throw new Error("array is wrong length");
    a.forEach((c, u) => {
      var f;
      O(f = o[u], $r, Ri).call(f, t, c, n, (h) => {
        a[u] = h;
      });
    }), s(a);
    return;
  }
  const i = n(this.type, e);
  i.then ? t.push(async function() {
    s(await i);
  }()) : s(i);
};
let At = $t;
class lr {
  /**
   *  @private
   */
  constructor(t, e, n) {
    /**
     *  The type of the fragment.
     */
    A(this, "type");
    /**
     *  The inputs for the fragment.
     */
    A(this, "inputs");
    so(t, st, "Fragment"), n = Object.freeze(n.slice()), M(this, { type: e, inputs: n });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(t) {
    if (typeof t == "string") {
      try {
        lr.from(JSON.parse(t));
      } catch {
      }
      return lr.from(kn(t));
    }
    if (t instanceof Ae)
      switch (t.peekKeyword(Rl)) {
        case "constructor":
          return tn.from(t);
        case "error":
          return Qt.from(t);
        case "event":
          return Be.from(t);
        case "fallback":
        case "receive":
          return Ge.from(t);
        case "function":
          return Re.from(t);
        case "struct":
          return or.from(t);
      }
    else if (typeof t == "object") {
      switch (t.type) {
        case "constructor":
          return tn.from(t);
        case "error":
          return Qt.from(t);
        case "event":
          return Be.from(t);
        case "fallback":
        case "receive":
          return Ge.from(t);
        case "function":
          return Re.from(t);
        case "struct":
          return or.from(t);
      }
      P(!1, `unsupported type: ${t.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    y(!1, "unsupported frgament object", "obj", t);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(t) {
    return tn.isFragment(t);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(t) {
    return Qt.isFragment(t);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(t) {
    return Be.isFragment(t);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(t) {
    return Re.isFragment(t);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(t) {
    return or.isFragment(t);
  }
}
class po extends lr {
  /**
   *  @private
   */
  constructor(e, n, s, i) {
    super(e, n, i);
    /**
     *  The name of the fragment.
     */
    A(this, "name");
    y(typeof s == "string" && s.match(Sl), "invalid identifier", "name", s), i = Object.freeze(i.slice()), M(this, { name: s });
  }
}
function zs(r, t) {
  return "(" + t.map((e) => e.format(r)).join(r === "full" ? ", " : ",") + ")";
}
class Qt extends po {
  /**
   *  @private
   */
  constructor(t, e, n) {
    super(t, "error", e, n), Object.defineProperty(this, _t, { value: Wc });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return cr(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(t) {
    if (t == null && (t = "sighash"), t === "json")
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((n) => JSON.parse(n.format(t)))
      });
    const e = [];
    return t !== "sighash" && e.push("error"), e.push(this.name + zs(t, this.inputs)), e.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(t) {
    if (Qt.isFragment(t))
      return t;
    if (typeof t == "string")
      return Qt.from(kn(t));
    if (t instanceof Ae) {
      const e = ho("error", t), n = nn(t);
      return ur(t), new Qt(st, e, n);
    }
    return new Qt(st, t.name, t.inputs ? t.inputs.map(At.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(t) {
    return t && t[_t] === Wc;
  }
}
class Be extends po {
  /**
   *  @private
   */
  constructor(e, n, s, i) {
    super(e, "event", n, s);
    /**
     *  Whether this event is anonymous.
     */
    A(this, "anonymous");
    Object.defineProperty(this, _t, { value: Yc }), M(this, { anonymous: i });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return cr(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json")
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((s) => JSON.parse(s.format(e)))
      });
    const n = [];
    return e !== "sighash" && n.push("event"), n.push(this.name + zs(e, this.inputs)), e !== "sighash" && this.anonymous && n.push("anonymous"), n.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(e, n) {
    return n = (n || []).map((i) => At.from(i)), new Be(st, e, n, !1).topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(e) {
    if (Be.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return Be.from(kn(e));
      } catch {
        y(!1, "invalid event fragment", "obj", e);
      }
    else if (e instanceof Ae) {
      const n = ho("event", e), s = nn(e, !0), i = !!rn(e, Dt(["anonymous"])).has("anonymous");
      return ur(e), new Be(st, n, s, i);
    }
    return new Be(st, e.name, e.inputs ? e.inputs.map((n) => At.from(n, !0)) : [], !!e.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(e) {
    return e && e[_t] === Yc;
  }
}
class tn extends lr {
  /**
   *  @private
   */
  constructor(e, n, s, i, o) {
    super(e, n, s);
    /**
     *  Whether the constructor can receive an endowment.
     */
    A(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    A(this, "gas");
    Object.defineProperty(this, _t, { value: Zc }), M(this, { payable: i, gas: o });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(e) {
    if (P(e != null && e !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" }), e === "json")
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((s) => JSON.parse(s.format(e)))
      });
    const n = [`constructor${zs(e, this.inputs)}`];
    return this.payable && n.push("payable"), this.gas != null && n.push(`@${this.gas.toString()}`), n.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(e) {
    if (tn.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return tn.from(kn(e));
      } catch {
        y(!1, "invalid constuctor fragment", "obj", e);
      }
    else if (e instanceof Ae) {
      rn(e, Dt(["constructor"]));
      const n = nn(e), s = !!rn(e, Pp).has("payable"), i = Fl(e);
      return ur(e), new tn(st, "constructor", n, s, i);
    }
    return new tn(st, "constructor", e.inputs ? e.inputs.map(At.from) : [], !!e.payable, e.gas != null ? e.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(e) {
    return e && e[_t] === Zc;
  }
}
class Ge extends lr {
  constructor(e, n, s) {
    super(e, "fallback", n);
    /**
     *  If the function can be sent value during invocation.
     */
    A(this, "payable");
    Object.defineProperty(this, _t, { value: Xc }), M(this, { payable: s });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(e) {
    const n = this.inputs.length === 0 ? "receive" : "fallback";
    if (e === "json") {
      const s = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type: n, stateMutability: s });
    }
    return `${n}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(e) {
    if (Ge.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return Ge.from(kn(e));
      } catch {
        y(!1, "invalid fallback fragment", "obj", e);
      }
    else if (e instanceof Ae) {
      const n = e.toString(), s = e.peekKeyword(Dt(["fallback", "receive"]));
      if (y(s, "type must be fallback or receive", "obj", n), e.popKeyword(Dt(["fallback", "receive"])) === "receive") {
        const c = nn(e);
        return y(c.length === 0, "receive cannot have arguments", "obj.inputs", c), rn(e, Dt(["payable"])), ur(e), new Ge(st, [], !0);
      }
      let o = nn(e);
      o.length ? y(o.length === 1 && o[0].type === "bytes", "invalid fallback inputs", "obj.inputs", o.map((c) => c.format("minimal")).join(", ")) : o = [At.from("bytes")];
      const a = Dl(e);
      if (y(a === "nonpayable" || a === "payable", "fallback cannot be constants", "obj.stateMutability", a), rn(e, Dt(["returns"])).has("returns")) {
        const c = nn(e);
        y(c.length === 1 && c[0].type === "bytes", "invalid fallback outputs", "obj.outputs", c.map((u) => u.format("minimal")).join(", "));
      }
      return ur(e), new Ge(st, o, a === "payable");
    }
    if (e.type === "receive")
      return new Ge(st, [], !0);
    if (e.type === "fallback") {
      const n = [At.from("bytes")], s = e.stateMutability === "payable";
      return new Ge(st, n, s);
    }
    y(!1, "invalid fallback description", "obj", e);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(e) {
    return e && e[_t] === Xc;
  }
}
class Re extends po {
  /**
   *  @private
   */
  constructor(e, n, s, i, o, a) {
    super(e, "function", n, i);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    A(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    A(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    A(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    A(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    A(this, "gas");
    Object.defineProperty(this, _t, { value: qc }), o = Object.freeze(o.slice()), M(this, { constant: s === "view" || s === "pure", gas: a, outputs: o, payable: s === "payable", stateMutability: s });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return cr(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json")
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((s) => JSON.parse(s.format(e))),
        outputs: this.outputs.map((s) => JSON.parse(s.format(e)))
      });
    const n = [];
    return e !== "sighash" && n.push("function"), n.push(this.name + zs(e, this.inputs)), e !== "sighash" && (this.stateMutability !== "nonpayable" && n.push(this.stateMutability), this.outputs && this.outputs.length && (n.push("returns"), n.push(zs(e, this.outputs))), this.gas != null && n.push(`@${this.gas.toString()}`)), n.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(e, n) {
    return n = (n || []).map((i) => At.from(i)), new Re(st, e, "view", n, [], null).selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(e) {
    if (Re.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return Re.from(kn(e));
      } catch {
        y(!1, "invalid function fragment", "obj", e);
      }
    else if (e instanceof Ae) {
      const s = ho("function", e), i = nn(e), o = Dl(e);
      let a = [];
      rn(e, Dt(["returns"])).has("returns") && (a = nn(e));
      const c = Fl(e);
      return ur(e), new Re(st, s, o, i, a, c);
    }
    let n = e.stateMutability;
    return n == null && (n = "payable", typeof e.constant == "boolean" ? (n = "view", e.constant || (n = "payable", typeof e.payable == "boolean" && !e.payable && (n = "nonpayable"))) : typeof e.payable == "boolean" && !e.payable && (n = "nonpayable")), new Re(st, e.name, n, e.inputs ? e.inputs.map(At.from) : [], e.outputs ? e.outputs.map(At.from) : [], e.gas != null ? e.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(e) {
    return e && e[_t] === qc;
  }
}
class or extends po {
  /**
   *  @private
   */
  constructor(t, e, n) {
    super(t, "struct", e, n), Object.defineProperty(this, _t, { value: $c });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(t) {
    if (typeof t == "string")
      try {
        return or.from(kn(t));
      } catch {
        y(!1, "invalid struct fragment", "obj", t);
      }
    else if (t instanceof Ae) {
      const e = ho("struct", t), n = nn(t);
      return ur(t), new or(st, e, n);
    }
    return new or(st, t.name, t.inputs ? t.inputs.map(At.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(t) {
    return t && t[_t] === $c;
  }
}
const be = /* @__PURE__ */ new Map();
be.set(0, "GENERIC_PANIC");
be.set(1, "ASSERT_FALSE");
be.set(17, "OVERFLOW");
be.set(18, "DIVIDE_BY_ZERO");
be.set(33, "ENUM_RANGE_ERROR");
be.set(34, "BAD_STORAGE_DATA");
be.set(49, "STACK_UNDERFLOW");
be.set(50, "ARRAY_RANGE_ERROR");
be.set(65, "OUT_OF_MEMORY");
be.set(81, "UNINITIALIZED_FUNCTION_CALL");
const Dp = new RegExp(/^bytes([0-9]*)$/), Fp = new RegExp(/^(u?int)([0-9]*)$/);
let Lo = null;
function Lp(r, t, e, n) {
  let s = "missing revert data", i = null;
  const o = null;
  let a = null;
  if (e) {
    s = "execution reverted";
    const u = X(e);
    if (e = F(e), u.length === 0)
      s += " (no data present; likely require(false) occurred", i = "require(false)";
    else if (u.length % 32 !== 4)
      s += " (could not decode reason; invalid data length)";
    else if (F(u.slice(0, 4)) === "0x08c379a0")
      try {
        i = n.decode(["string"], u.slice(4))[0], a = {
          signature: "Error(string)",
          name: "Error",
          args: [i]
        }, s += `: ${JSON.stringify(i)}`;
      } catch {
        s += " (could not decode reason; invalid string data)";
      }
    else if (F(u.slice(0, 4)) === "0x4e487b71")
      try {
        const f = Number(n.decode(["uint256"], u.slice(4))[0]);
        a = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [f]
        }, i = `Panic due to ${be.get(f) || "UNKNOWN"}(${f})`, s += `: ${i}`;
      } catch {
        s += " (could not decode panic code)";
      }
    else
      s += " (unknown custom error)";
  }
  const c = {
    to: t.to ? W(t.to) : null,
    data: t.data || "0x"
  };
  return t.from && (c.from = W(t.from)), dt(s, "CALL_EXCEPTION", {
    action: r,
    data: e,
    reason: i,
    transaction: c,
    invocation: o,
    revert: a
  });
}
var yn, br;
const to = class to {
  constructor() {
    b(this, yn);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(t) {
    const e = t.map((s) => O(this, yn, br).call(this, At.from(s)));
    return new Pi(e, "_").defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(t, e) {
    wu(e.length, t.length, "types/values length mismatch");
    const n = t.map((o) => O(this, yn, br).call(this, At.from(o))), s = new Pi(n, "_"), i = new jo();
    return s.encode(i, e), i.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(t, e, n) {
    const s = t.map((o) => O(this, yn, br).call(this, At.from(o)));
    return new Pi(s, "_").decode(new zo(e, n));
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    return Lo == null && (Lo = new to()), Lo;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(t, e, n) {
    return Lp(t, e, n, to.defaultAbiCoder());
  }
};
yn = new WeakSet(), br = function(t) {
  if (t.isArray())
    return new hd(O(this, yn, br).call(this, t.arrayChildren), t.arrayLength, t.name);
  if (t.isTuple())
    return new Pi(t.components.map((n) => O(this, yn, br).call(this, n)), t.name);
  switch (t.baseType) {
    case "address":
      return new ld(t.name);
    case "bool":
      return new dd(t.name);
    case "string":
      return new vd(t.name);
    case "bytes":
      return new pd(t.name);
    case "":
      return new md(t.name);
  }
  let e = t.type.match(Fp);
  if (e) {
    let n = parseInt(e[2] || "256");
    return y(n !== 0 && n <= 256 && n % 8 === 0, "invalid " + e[1] + " bit length", "param", t), new Ed(n / 8, e[1] === "int", t.name);
  }
  if (e = t.type.match(Dp), e) {
    let n = parseInt(e[1]);
    return y(n !== 0 && n <= 32, "invalid bytes length", "param", t), new gd(n, t.name);
  }
  y(!1, "invalid type", "type", t.type);
};
let Ks = to;
class Mp {
  /**
   *  @_ignore:
   */
  constructor(t, e, n) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    A(this, "fragment");
    /**
     *  The name of the Event.
     */
    A(this, "name");
    /**
     *  The full Event signature.
     */
    A(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    A(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    A(this, "args");
    const s = t.name, i = t.format();
    M(this, {
      fragment: t,
      name: s,
      signature: i,
      topic: e,
      args: n
    });
  }
}
class Gp {
  /**
   *  @_ignore:
   */
  constructor(t, e, n, s) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    A(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    A(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    A(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    A(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    A(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    A(this, "value");
    const i = t.name, o = t.format();
    M(this, {
      fragment: t,
      name: i,
      args: n,
      signature: o,
      selector: e,
      value: s
    });
  }
}
class Qp {
  /**
   *  @_ignore:
   */
  constructor(t, e, n) {
    /**
     *  The matching fragment.
     */
    A(this, "fragment");
    /**
     *  The name of the Error.
     */
    A(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    A(this, "args");
    /**
     *  The full Error signature.
     */
    A(this, "signature");
    /**
     *  The selector for the Error.
     */
    A(this, "selector");
    const s = t.name, i = t.format();
    M(this, {
      fragment: t,
      name: s,
      args: n,
      signature: i,
      selector: e
    });
  }
}
class tu {
  /**
   *  @_ignore:
   */
  constructor(t) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    A(this, "hash");
    /**
     *  @_ignore:
     */
    A(this, "_isIndexed");
    M(this, { hash: t, _isIndexed: !0 });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(t) {
    return !!(t && t._isIndexed);
  }
}
const eu = {
  0: "generic panic",
  1: "assert(false)",
  17: "arithmetic overflow",
  18: "division or modulo by zero",
  33: "enum overflow",
  34: "invalid encoded storage byte array accessed",
  49: "out-of-bounds array access; popping on an empty array",
  50: "out-of-bounds access of an array or bytesN",
  65: "out of memory",
  81: "uninitialized function"
}, nu = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (r) => `reverted with reason string ${JSON.stringify(r)}`
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (r) => {
      let t = "unknown panic code";
      return r >= 0 && r <= 255 && eu[r.toString()] && (t = eu[r.toString()]), `reverted with panic code 0x${r.toString(16)} (${t})`;
    }
  }
};
var Pe, Ne, Ce, xt, ts, ki, es, Si;
const Cr = class Cr {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(t) {
    // Find a function definition by any means necessary (unless it is ambiguous)
    b(this, ts);
    // Find an event definition by any means necessary (unless it is ambiguous)
    b(this, es);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    A(this, "fragments");
    /**
     *  The Contract constructor.
     */
    A(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    A(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    A(this, "receive");
    b(this, Pe, void 0);
    b(this, Ne, void 0);
    b(this, Ce, void 0);
    //    #structs: Map<string, StructFragment>;
    b(this, xt, void 0);
    let e = [];
    typeof t == "string" ? e = JSON.parse(t) : e = t, d(this, Ce, /* @__PURE__ */ new Map()), d(this, Pe, /* @__PURE__ */ new Map()), d(this, Ne, /* @__PURE__ */ new Map());
    const n = [];
    for (const o of e)
      try {
        n.push(lr.from(o));
      } catch (a) {
        console.log("EE", a);
      }
    M(this, {
      fragments: Object.freeze(n)
    });
    let s = null, i = !1;
    d(this, xt, this.getAbiCoder()), this.fragments.forEach((o, a) => {
      let c;
      switch (o.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          M(this, { deploy: o });
          return;
        case "fallback":
          o.inputs.length === 0 ? i = !0 : (y(!s || o.payable !== s.payable, "conflicting fallback fragments", `fragments[${a}]`, o), s = o, i = s.payable);
          return;
        case "function":
          c = l(this, Ce);
          break;
        case "event":
          c = l(this, Ne);
          break;
        case "error":
          c = l(this, Pe);
          break;
        default:
          return;
      }
      const u = o.format();
      c.has(u) || c.set(u, o);
    }), this.deploy || M(this, {
      deploy: tn.from("constructor()")
    }), M(this, { fallback: s, receive: i });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(t) {
    const e = t ? "minimal" : "full";
    return this.fragments.map((s) => s.format(e));
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const t = this.fragments.map((e) => e.format("json"));
    return JSON.stringify(t.map((e) => JSON.parse(e)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return Ks.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(t) {
    const e = O(this, ts, ki).call(this, t, null, !1);
    return y(e, "no matching function", "key", t), e.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(t) {
    return !!O(this, ts, ki).call(this, t, null, !1);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(t, e) {
    return O(this, ts, ki).call(this, t, e || null, !0);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(t) {
    const e = Array.from(l(this, Ce).keys());
    e.sort((n, s) => n.localeCompare(s));
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      t(l(this, Ce).get(s), n);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(t) {
    const e = O(this, es, Si).call(this, t, null, !1);
    return y(e, "no matching event", "key", t), e.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(t) {
    return !!O(this, es, Si).call(this, t, null, !1);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(t, e) {
    return O(this, es, Si).call(this, t, e || null, !0);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(t) {
    const e = Array.from(l(this, Ne).keys());
    e.sort((n, s) => n.localeCompare(s));
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      t(l(this, Ne).get(s), n);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(t, e) {
    if (ot(t)) {
      const s = t.toLowerCase();
      if (nu[s])
        return Qt.from(nu[s].signature);
      for (const i of l(this, Pe).values())
        if (s === i.selector)
          return i;
      return null;
    }
    if (t.indexOf("(") === -1) {
      const s = [];
      for (const [i, o] of l(this, Pe))
        i.split(
          "("
          /* fix:) */
        )[0] === t && s.push(o);
      if (s.length === 0)
        return t === "Error" ? Qt.from("error Error(string)") : t === "Panic" ? Qt.from("error Panic(uint256)") : null;
      if (s.length > 1) {
        const i = s.map((o) => JSON.stringify(o.format())).join(", ");
        y(!1, `ambiguous error description (i.e. ${i})`, "name", t);
      }
      return s[0];
    }
    if (t = Qt.from(t).format(), t === "Error(string)")
      return Qt.from("error Error(string)");
    if (t === "Panic(uint256)")
      return Qt.from("error Panic(uint256)");
    const n = l(this, Pe).get(t);
    return n || null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(t) {
    const e = Array.from(l(this, Pe).keys());
    e.sort((n, s) => n.localeCompare(s));
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      t(l(this, Pe).get(s), n);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(t, e) {
    return l(this, xt).decode(t, e);
  }
  _encodeParams(t, e) {
    return l(this, xt).encode(t, e);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(t) {
    return this._encodeParams(this.deploy.inputs, t || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(t, e) {
    if (typeof t == "string") {
      const n = this.getError(t);
      y(n, "unknown error", "fragment", t), t = n;
    }
    return y(at(e, 0, 4) === t.selector, `data signature does not match error ${t.name}.`, "data", e), this._decodeParams(t.inputs, at(e, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(t, e) {
    if (typeof t == "string") {
      const n = this.getError(t);
      y(n, "unknown error", "fragment", t), t = n;
    }
    return pt([
      t.selector,
      this._encodeParams(t.inputs, e || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(t, e) {
    if (typeof t == "string") {
      const n = this.getFunction(t);
      y(n, "unknown function", "fragment", t), t = n;
    }
    return y(at(e, 0, 4) === t.selector, `data signature does not match function ${t.name}.`, "data", e), this._decodeParams(t.inputs, at(e, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(t, e) {
    if (typeof t == "string") {
      const n = this.getFunction(t);
      y(n, "unknown function", "fragment", t), t = n;
    }
    return pt([
      t.selector,
      this._encodeParams(t.inputs, e || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(t, e) {
    if (typeof t == "string") {
      const i = this.getFunction(t);
      y(i, "unknown function", "fragment", t), t = i;
    }
    let n = "invalid length for result data";
    const s = Ht(e);
    if (s.length % 32 === 0)
      try {
        return l(this, xt).decode(t.outputs, s);
      } catch {
        n = "could not decode result data";
      }
    P(!1, n, "BAD_DATA", {
      value: F(s),
      info: { method: t.name, signature: t.format() }
    });
  }
  makeError(t, e) {
    const n = X(t, "data"), s = Ks.getBuiltinCallException("call", e, n), i = "execution reverted (unknown custom error)";
    if (s.message.startsWith(i)) {
      const a = F(n.slice(0, 4)), c = this.getError(a);
      if (c)
        try {
          const u = l(this, xt).decode(c.inputs, n.slice(4));
          s.revert = {
            name: c.name,
            signature: c.format(),
            args: u
          }, s.reason = s.revert.signature, s.message = `execution reverted: ${s.reason}`;
        } catch {
          s.message = "execution reverted (coult not decode custom error)";
        }
    }
    const o = this.parseTransaction(e);
    return o && (s.invocation = {
      method: o.name,
      signature: o.signature,
      args: o.args
    }), s;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(t, e) {
    if (typeof t == "string") {
      const n = this.getFunction(t);
      y(n, "unknown function", "fragment", t), t = n;
    }
    return F(l(this, xt).encode(t.outputs, e || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(t, e) {
    if (typeof t == "string") {
      const i = this.getEvent(t);
      y(i, "unknown event", "eventFragment", t), t = i;
    }
    P(e.length <= t.inputs.length, `too many arguments for ${t.format()}`, "UNEXPECTED_ARGUMENT", { count: e.length, expectedCount: t.inputs.length });
    const n = [];
    t.anonymous || n.push(t.topicHash);
    const s = (i, o) => i.type === "string" ? cr(o) : i.type === "bytes" ? it(F(o)) : (i.type === "bool" && typeof o == "boolean" ? o = o ? "0x01" : "0x00" : i.type.match(/^u?int/) ? o = Bn(o) : i.type.match(/^bytes/) ? o = Bf(o, 32) : i.type === "address" && l(this, xt).encode(["address"], [o]), ar(F(o), 32));
    for (e.forEach((i, o) => {
      const a = t.inputs[o];
      if (!a.indexed) {
        y(i == null, "cannot filter non-indexed parameters; must be null", "contract." + a.name, i);
        return;
      }
      i == null ? n.push(null) : a.baseType === "array" || a.baseType === "tuple" ? y(!1, "filtering with tuples or arrays not supported", "contract." + a.name, i) : Array.isArray(i) ? n.push(i.map((c) => s(a, c))) : n.push(s(a, i));
    }); n.length && n[n.length - 1] === null; )
      n.pop();
    return n;
  }
  encodeEventLog(t, e) {
    if (typeof t == "string") {
      const o = this.getEvent(t);
      y(o, "unknown event", "eventFragment", t), t = o;
    }
    const n = [], s = [], i = [];
    return t.anonymous || n.push(t.topicHash), y(e.length === t.inputs.length, "event arguments/values mismatch", "values", e), t.inputs.forEach((o, a) => {
      const c = e[a];
      if (o.indexed)
        if (o.type === "string")
          n.push(cr(c));
        else if (o.type === "bytes")
          n.push(it(c));
        else {
          if (o.baseType === "tuple" || o.baseType === "array")
            throw new Error("not implemented");
          n.push(l(this, xt).encode([o.type], [c]));
        }
      else
        s.push(o), i.push(c);
    }), {
      data: l(this, xt).encode(s, i),
      topics: n
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(t, e, n) {
    if (typeof t == "string") {
      const w = this.getEvent(t);
      y(w, "unknown event", "eventFragment", t), t = w;
    }
    if (n != null && !t.anonymous) {
      const w = t.topicHash;
      y(ot(n[0], 32) && n[0].toLowerCase() === w, "fragment/topic mismatch", "topics[0]", n[0]), n = n.slice(1);
    }
    const s = [], i = [], o = [];
    t.inputs.forEach((w, E) => {
      w.indexed ? w.type === "string" || w.type === "bytes" || w.baseType === "tuple" || w.baseType === "array" ? (s.push(At.from({ type: "bytes32", name: w.name })), o.push(!0)) : (s.push(w), o.push(!1)) : (i.push(w), o.push(!1));
    });
    const a = n != null ? l(this, xt).decode(s, pt(n)) : null, c = l(this, xt).decode(i, e, !0), u = [], f = [];
    let h = 0, g = 0;
    return t.inputs.forEach((w, E) => {
      let m = null;
      if (w.indexed)
        if (a == null)
          m = new tu(null);
        else if (o[E])
          m = new tu(a[g++]);
        else
          try {
            m = a[g++];
          } catch (x) {
            m = x;
          }
      else
        try {
          m = c[h++];
        } catch (x) {
          m = x;
        }
      u.push(m), f.push(w.name || null);
    }), Mi.fromItems(u, f);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(t) {
    const e = X(t.data, "tx.data"), n = L(t.value != null ? t.value : 0, "tx.value"), s = this.getFunction(F(e.slice(0, 4)));
    if (!s)
      return null;
    const i = l(this, xt).decode(s.inputs, e.slice(4));
    return new Gp(s, s.selector, i, n);
  }
  parseCallResult(t) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(t) {
    const e = this.getEvent(t.topics[0]);
    return !e || e.anonymous ? null : new Mp(e, e.topicHash, this.decodeEventLog(e, t.data, t.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(t) {
    const e = F(t), n = this.getError(at(e, 0, 4));
    if (!n)
      return null;
    const s = l(this, xt).decode(n.inputs, at(e, 4));
    return new Qp(n, n.selector, s);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(t) {
    return t instanceof Cr ? t : typeof t == "string" ? new Cr(JSON.parse(t)) : typeof t.format == "function" ? new Cr(t.format("json")) : new Cr(t);
  }
};
Pe = new WeakMap(), Ne = new WeakMap(), Ce = new WeakMap(), xt = new WeakMap(), ts = new WeakSet(), ki = function(t, e, n) {
  if (ot(t)) {
    const i = t.toLowerCase();
    for (const o of l(this, Ce).values())
      if (i === o.selector)
        return o;
    return null;
  }
  if (t.indexOf("(") === -1) {
    const i = [];
    for (const [o, a] of l(this, Ce))
      o.split(
        "("
        /* fix:) */
      )[0] === t && i.push(a);
    if (e) {
      const o = e.length > 0 ? e[e.length - 1] : null;
      let a = e.length, c = !0;
      Tt.isTyped(o) && o.type === "overrides" && (c = !1, a--);
      for (let u = i.length - 1; u >= 0; u--) {
        const f = i[u].inputs.length;
        f !== a && (!c || f !== a - 1) && i.splice(u, 1);
      }
      for (let u = i.length - 1; u >= 0; u--) {
        const f = i[u].inputs;
        for (let h = 0; h < e.length; h++)
          if (Tt.isTyped(e[h])) {
            if (h >= f.length) {
              if (e[h].type === "overrides")
                continue;
              i.splice(u, 1);
              break;
            }
            if (e[h].type !== f[h].baseType) {
              i.splice(u, 1);
              break;
            }
          }
      }
    }
    if (i.length === 1 && e && e.length !== i[0].inputs.length) {
      const o = e[e.length - 1];
      (o == null || Array.isArray(o) || typeof o != "object") && i.splice(0, 1);
    }
    if (i.length === 0)
      return null;
    if (i.length > 1 && n) {
      const o = i.map((a) => JSON.stringify(a.format())).join(", ");
      y(!1, `ambiguous function description (i.e. matches ${o})`, "key", t);
    }
    return i[0];
  }
  const s = l(this, Ce).get(Re.from(t).format());
  return s || null;
}, es = new WeakSet(), Si = function(t, e, n) {
  if (ot(t)) {
    const i = t.toLowerCase();
    for (const o of l(this, Ne).values())
      if (i === o.topicHash)
        return o;
    return null;
  }
  if (t.indexOf("(") === -1) {
    const i = [];
    for (const [o, a] of l(this, Ne))
      o.split(
        "("
        /* fix:) */
      )[0] === t && i.push(a);
    if (e) {
      for (let o = i.length - 1; o >= 0; o--)
        i[o].inputs.length < e.length && i.splice(o, 1);
      for (let o = i.length - 1; o >= 0; o--) {
        const a = i[o].inputs;
        for (let c = 0; c < e.length; c++)
          if (Tt.isTyped(e[c]) && e[c].type !== a[c].baseType) {
            i.splice(o, 1);
            break;
          }
      }
    }
    if (i.length === 0)
      return null;
    if (i.length > 1 && n) {
      const o = i.map((a) => JSON.stringify(a.format())).join(", ");
      y(!1, `ambiguous event description (i.e. matches ${o})`, "key", t);
    }
    return i[0];
  }
  const s = l(this, Ne).get(Be.from(t).format());
  return s || null;
};
let ia = Cr;
const Ll = BigInt(0);
function Fs(r) {
  return r ?? null;
}
function Ct(r) {
  return r == null ? null : r.toString();
}
class ru {
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(t, e, n) {
    /**
     *  The gas price for legacy networks.
     */
    A(this, "gasPrice");
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    A(this, "maxFeePerGas");
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    A(this, "maxPriorityFeePerGas");
    M(this, {
      gasPrice: Fs(t),
      maxFeePerGas: Fs(e),
      maxPriorityFeePerGas: Fs(n)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice: t, maxFeePerGas: e, maxPriorityFeePerGas: n } = this;
    return {
      _type: "FeeData",
      gasPrice: Ct(t),
      maxFeePerGas: Ct(e),
      maxPriorityFeePerGas: Ct(n)
    };
  }
}
function zi(r) {
  const t = {};
  r.to && (t.to = r.to), r.from && (t.from = r.from), r.data && (t.data = F(r.data));
  const e = "chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const s of e)
    !(s in r) || r[s] == null || (t[s] = L(r[s], `request.${s}`));
  const n = "type,nonce".split(/,/);
  for (const s of n)
    !(s in r) || r[s] == null || (t[s] = V(r[s], `request.${s}`));
  return r.accessList && (t.accessList = hr(r.accessList)), "blockTag" in r && (t.blockTag = r.blockTag), "enableCcipRead" in r && (t.enableCcipRead = !!r.enableCcipRead), "customData" in r && (t.customData = r.customData), t;
}
var Ke;
class Hp {
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(t, e) {
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    A(this, "provider");
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    A(this, "number");
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    A(this, "hash");
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    A(this, "timestamp");
    /**
     *  The block hash of the parent block.
     */
    A(this, "parentHash");
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    A(this, "nonce");
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    A(this, "difficulty");
    /**
     *  The total gas limit for this block.
     */
    A(this, "gasLimit");
    /**
     *  The total gas used in this block.
     */
    A(this, "gasUsed");
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    A(this, "miner");
    /**
     *  Any extra data the validator wished to include.
     */
    A(this, "extraData");
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    A(this, "baseFeePerGas");
    b(this, Ke, void 0);
    d(this, Ke, t.transactions.map((n) => typeof n != "string" ? new Ws(n, e) : n)), M(this, {
      provider: e,
      hash: Fs(t.hash),
      number: t.number,
      timestamp: t.timestamp,
      parentHash: t.parentHash,
      nonce: t.nonce,
      difficulty: t.difficulty,
      gasLimit: t.gasLimit,
      gasUsed: t.gasUsed,
      miner: t.miner,
      extraData: t.extraData,
      baseFeePerGas: Fs(t.baseFeePerGas)
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return l(this, Ke).map((t) => typeof t == "string" ? t : t.hash);
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const t = l(this, Ke).slice();
    return t.length === 0 ? [] : (P(typeof t[0] == "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    }), t);
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas: t, difficulty: e, extraData: n, gasLimit: s, gasUsed: i, hash: o, miner: a, nonce: c, number: u, parentHash: f, timestamp: h, transactions: g } = this;
    return {
      _type: "Block",
      baseFeePerGas: Ct(t),
      difficulty: Ct(e),
      extraData: n,
      gasLimit: Ct(s),
      gasUsed: Ct(i),
      hash: o,
      miner: a,
      nonce: c,
      number: u,
      parentHash: f,
      timestamp: h,
      transactions: g
    };
  }
  [Symbol.iterator]() {
    let t = 0;
    const e = this.transactions;
    return {
      next: () => t < this.length ? {
        value: e[t++],
        done: !1
      } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return l(this, Ke).length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    return this.timestamp == null ? null : new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(t) {
    let e;
    if (typeof t == "number")
      e = l(this, Ke)[t];
    else {
      const n = t.toLowerCase();
      for (const s of l(this, Ke))
        if (typeof s == "string") {
          if (s !== n)
            continue;
          e = s;
          break;
        } else {
          if (s.hash === n)
            continue;
          e = s;
          break;
        }
    }
    if (e == null)
      throw new Error("no such tx");
    return typeof e == "string" ? await this.provider.getTransaction(e) : e;
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(t) {
    const e = this.prefetchedTransactions;
    if (typeof t == "number")
      return e[t];
    t = t.toLowerCase();
    for (const n of e)
      if (n.hash === t)
        return n;
    y(!1, "no matching transaction", "indexOrHash", t);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined())
      throw new Error("");
    return _p(this);
  }
}
Ke = new WeakMap();
class pi {
  /**
   *  @_ignore:
   */
  constructor(t, e) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    A(this, "provider");
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    A(this, "transactionHash");
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    A(this, "blockHash");
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    A(this, "blockNumber");
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    A(this, "removed");
    /**
     *  The address of the contract that emitted this log.
     */
    A(this, "address");
    /**
     *  The data included in this log when it was emitted.
     */
    A(this, "data");
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    A(this, "topics");
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    A(this, "index");
    /**
     *  The index within the transaction of this log.
     */
    A(this, "transactionIndex");
    this.provider = e;
    const n = Object.freeze(t.topics.slice());
    M(this, {
      transactionHash: t.transactionHash,
      blockHash: t.blockHash,
      blockNumber: t.blockNumber,
      removed: t.removed,
      address: t.address,
      data: t.data,
      topics: n,
      index: t.index,
      transactionIndex: t.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address: t, blockHash: e, blockNumber: n, data: s, index: i, removed: o, topics: a, transactionHash: c, transactionIndex: u } = this;
    return {
      _type: "log",
      address: t,
      blockHash: e,
      blockNumber: n,
      data: s,
      index: i,
      removed: o,
      topics: a,
      transactionHash: c,
      transactionIndex: u
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const t = await this.provider.getBlock(this.blockHash);
    return P(!!t, "failed to find transaction", "UNKNOWN_ERROR", {}), t;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const t = await this.provider.getTransaction(this.transactionHash);
    return P(!!t, "failed to find transaction", "UNKNOWN_ERROR", {}), t;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const t = await this.provider.getTransactionReceipt(this.transactionHash);
    return P(!!t, "failed to find transaction receipt", "UNKNOWN_ERROR", {}), t;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return Vp(this);
  }
}
var ei;
class Ml {
  /**
   *  @_ignore:
   */
  constructor(t, e) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    A(this, "provider");
    /**
     *  The address the transaction was sent to.
     */
    A(this, "to");
    /**
     *  The sender of the transaction.
     */
    A(this, "from");
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    A(this, "contractAddress");
    /**
     *  The transaction hash.
     */
    A(this, "hash");
    /**
     *  The index of this transaction within the block transactions.
     */
    A(this, "index");
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    A(this, "blockHash");
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    A(this, "blockNumber");
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    A(this, "logsBloom");
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    A(this, "gasUsed");
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    A(this, "cumulativeGasUsed");
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    A(this, "gasPrice");
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    A(this, "type");
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    A(this, "status");
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    A(this, "root");
    b(this, ei, void 0);
    d(this, ei, Object.freeze(t.logs.map((s) => new pi(s, e))));
    let n = Ll;
    t.effectiveGasPrice != null ? n = t.effectiveGasPrice : t.gasPrice != null && (n = t.gasPrice), M(this, {
      provider: e,
      to: t.to,
      from: t.from,
      contractAddress: t.contractAddress,
      hash: t.hash,
      index: t.index,
      blockHash: t.blockHash,
      blockNumber: t.blockNumber,
      logsBloom: t.logsBloom,
      gasUsed: t.gasUsed,
      cumulativeGasUsed: t.cumulativeGasUsed,
      gasPrice: n,
      type: t.type,
      //byzantium: tx.byzantium,
      status: t.status,
      root: t.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return l(this, ei);
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to: t,
      from: e,
      contractAddress: n,
      hash: s,
      index: i,
      blockHash: o,
      blockNumber: a,
      logsBloom: c,
      logs: u,
      //byzantium, 
      status: f,
      root: h
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash: o,
      blockNumber: a,
      //byzantium, 
      contractAddress: n,
      cumulativeGasUsed: Ct(this.cumulativeGasUsed),
      from: e,
      gasPrice: Ct(this.gasPrice),
      gasUsed: Ct(this.gasUsed),
      hash: s,
      index: i,
      logs: u,
      logsBloom: c,
      root: h,
      status: f,
      to: t
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let t = 0;
    return {
      next: () => t < this.length ? { value: this.logs[t++], done: !1 } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const t = await this.provider.getBlock(this.blockHash);
    if (t == null)
      throw new Error("TODO");
    return t;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const t = await this.provider.getTransaction(this.hash);
    if (t == null)
      throw new Error("TODO");
    return t;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return Ql(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(t) {
    return P(!t || t.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" }), Gl(this, t);
  }
}
ei = new WeakMap();
var mn;
const Ja = class Ja {
  /**
   *  @_ignore:
   */
  constructor(t, e) {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    A(this, "provider");
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    A(this, "blockNumber");
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    A(this, "blockHash");
    /**
     *  The index within the block that this transaction resides at.
     */
    A(this, "index");
    /**
     *  The transaction hash.
     */
    A(this, "hash");
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    A(this, "type");
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    A(this, "to");
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    A(this, "from");
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    A(this, "nonce");
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    A(this, "gasLimit");
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    A(this, "gasPrice");
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    A(this, "maxPriorityFeePerGas");
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    A(this, "maxFeePerGas");
    /**
     *  The data.
     */
    A(this, "data");
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    A(this, "value");
    /**
     *  The chain ID.
     */
    A(this, "chainId");
    /**
     *  The signature.
     */
    A(this, "signature");
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    A(this, "accessList");
    b(this, mn, void 0);
    this.provider = e, this.blockNumber = t.blockNumber != null ? t.blockNumber : null, this.blockHash = t.blockHash != null ? t.blockHash : null, this.hash = t.hash, this.index = t.index, this.type = t.type, this.from = t.from, this.to = t.to || null, this.gasLimit = t.gasLimit, this.nonce = t.nonce, this.data = t.data, this.value = t.value, this.gasPrice = t.gasPrice, this.maxPriorityFeePerGas = t.maxPriorityFeePerGas != null ? t.maxPriorityFeePerGas : null, this.maxFeePerGas = t.maxFeePerGas != null ? t.maxFeePerGas : null, this.chainId = t.chainId, this.signature = t.signature, this.accessList = t.accessList != null ? t.accessList : null, d(this, mn, -1);
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber: t, blockHash: e, index: n, hash: s, type: i, to: o, from: a, nonce: c, data: u, signature: f, accessList: h } = this;
    return {
      _type: "TransactionReceipt",
      accessList: h,
      blockNumber: t,
      blockHash: e,
      chainId: Ct(this.chainId),
      data: u,
      from: a,
      gasLimit: Ct(this.gasLimit),
      gasPrice: Ct(this.gasPrice),
      hash: s,
      maxFeePerGas: Ct(this.maxFeePerGas),
      maxPriorityFeePerGas: Ct(this.maxPriorityFeePerGas),
      nonce: c,
      signature: f,
      to: o,
      index: n,
      type: i,
      value: Ct(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let t = this.blockNumber;
    if (t == null) {
      const n = await this.getTransaction();
      n && (t = n.blockNumber);
    }
    if (t == null)
      return null;
    const e = this.provider.getBlock(t);
    if (e == null)
      throw new Error("TODO");
    return e;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx: e, blockNumber: n } = await Rt({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      return e == null || e.blockNumber == null ? 0 : n - e.blockNumber + 1;
    }
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(t, e) {
    const n = t ?? 1, s = e ?? 0;
    let i = l(this, mn), o = -1, a = i === -1;
    const c = async () => {
      if (a)
        return null;
      const { blockNumber: g, nonce: w } = await Rt({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (w < this.nonce) {
        i = g;
        return;
      }
      if (a)
        return null;
      const E = await this.getTransaction();
      if (!(E && E.blockNumber != null))
        for (o === -1 && (o = i - 3, o < l(this, mn) && (o = l(this, mn))); o <= g; ) {
          if (a)
            return null;
          const m = await this.provider.getBlock(o, !0);
          if (m == null)
            return;
          for (const x of m)
            if (x === this.hash)
              return;
          for (let x = 0; x < m.length; x++) {
            const v = await m.getTransaction(x);
            if (v.from === this.from && v.nonce === this.nonce) {
              if (a)
                return null;
              const B = await this.provider.getTransactionReceipt(v.hash);
              if (B == null || g - B.blockNumber + 1 < n)
                return;
              let T = "replaced";
              v.data === this.data && v.to === this.to && v.value === this.value ? T = "repriced" : v.data === "0x" && v.from === v.to && v.value === Ll && (T = "cancelled"), P(!1, "transaction was replaced", "TRANSACTION_REPLACED", {
                cancelled: T === "replaced" || T === "cancelled",
                reason: T,
                replacement: v.replaceableTransaction(i),
                hash: v.hash,
                receipt: B
              });
            }
          }
          o++;
        }
    }, u = (g) => {
      if (g == null || g.status !== 0)
        return g;
      P(!1, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: g.to,
          from: g.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: g
      });
    }, f = await this.provider.getTransactionReceipt(this.hash);
    if (n === 0)
      return u(f);
    if (f) {
      if (await f.confirmations() >= n)
        return u(f);
    } else if (await c(), n === 0)
      return null;
    return await new Promise((g, w) => {
      const E = [], m = () => {
        E.forEach((v) => v());
      };
      if (E.push(() => {
        a = !0;
      }), s > 0) {
        const v = setTimeout(() => {
          m(), w(dt("wait for transaction timeout", "TIMEOUT"));
        }, s);
        E.push(() => {
          clearTimeout(v);
        });
      }
      const x = async (v) => {
        if (await v.confirmations() >= n) {
          m();
          try {
            g(u(v));
          } catch (B) {
            w(B);
          }
        }
      };
      if (E.push(() => {
        this.provider.off(this.hash, x);
      }), this.provider.on(this.hash, x), i >= 0) {
        const v = async () => {
          try {
            await c();
          } catch (B) {
            if (oe(B, "TRANSACTION_REPLACED")) {
              m(), w(B);
              return;
            }
          }
          a || this.provider.once("block", v);
        };
        E.push(() => {
          this.provider.off("block", v);
        }), this.provider.once("block", v);
      }
    });
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    return P(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), Ql(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(t) {
    return P(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), P(!t || t.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), Gl(this, t);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(t) {
    y(Number.isInteger(t) && t >= 0, "invalid startBlock", "startBlock", t);
    const e = new Ja(this, this.provider);
    return d(e, mn, t), e;
  }
};
mn = new WeakMap();
let Ws = Ja;
function _p(r) {
  return { orphan: "drop-block", hash: r.hash, number: r.number };
}
function Gl(r, t) {
  return { orphan: "reorder-transaction", tx: r, other: t };
}
function Ql(r) {
  return { orphan: "drop-transaction", tx: r };
}
function Vp(r) {
  return { orphan: "drop-log", log: {
    transactionHash: r.transactionHash,
    blockHash: r.blockHash,
    blockNumber: r.blockNumber,
    address: r.address,
    data: r.data,
    topics: Object.freeze(r.topics.slice()),
    index: r.index
  } };
}
class Fa extends pi {
  /**
   * @_ignore:
   */
  constructor(e, n, s) {
    super(e, e.provider);
    /**
     *  The Contract Interface.
     */
    A(this, "interface");
    /**
     *  The matching event.
     */
    A(this, "fragment");
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    A(this, "args");
    const i = n.decodeEventLog(s, e.data, e.topics);
    M(this, { args: i, fragment: s, interface: n });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
class Hl extends pi {
  /**
   * @_ignore:
   */
  constructor(e, n) {
    super(e, e.provider);
    /**
     *  The error encounted when trying to decode the log.
     */
    A(this, "error");
    M(this, { error: n });
  }
}
var ns;
class Jp extends Ml {
  /**
   *  @_ignore:
   */
  constructor(e, n, s) {
    super(s, n);
    b(this, ns, void 0);
    d(this, ns, e);
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((e) => {
      const n = e.topics.length ? l(this, ns).getEvent(e.topics[0]) : null;
      if (n)
        try {
          return new Fa(e, l(this, ns), n);
        } catch (s) {
          return new Hl(e, s);
        }
      return e;
    });
  }
}
ns = new WeakMap();
var ni;
class La extends Ws {
  /**
   *  @_ignore:
   */
  constructor(e, n, s) {
    super(s, n);
    b(this, ni, void 0);
    d(this, ni, e);
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(e) {
    const n = await super.wait(e);
    return n == null ? null : new Jp(l(this, ni), this.provider, n);
  }
}
ni = new WeakMap();
class _l extends vu {
  /**
   *  @_event:
   */
  constructor(e, n, s, i) {
    super(e, n, s);
    /**
     *  The log with no matching events.
     */
    A(this, "log");
    M(this, { log: i });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class jp extends _l {
  /**
   *  @_ignore:
   */
  constructor(t, e, n, s, i) {
    super(t, e, n, new Fa(i, t.interface, s));
    const o = t.interface.decodeEventLog(s, this.log.data, this.log.topics);
    M(this, { args: o, fragment: s });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
const su = BigInt(0);
function Vl(r) {
  return r && typeof r.call == "function";
}
function Jl(r) {
  return r && typeof r.estimateGas == "function";
}
function go(r) {
  return r && typeof r.resolveName == "function";
}
function jl(r) {
  return r && typeof r.sendTransaction == "function";
}
function zl(r) {
  if (r != null) {
    if (go(r))
      return r;
    if (r.provider)
      return r.provider;
  }
}
var ri;
class zp {
  constructor(t, e, n) {
    b(this, ri, void 0);
    A(this, "fragment");
    if (M(this, { fragment: e }), e.inputs.length < n.length)
      throw new Error("too many arguments");
    const s = fr(t.runner, "resolveName"), i = go(s) ? s : null;
    d(this, ri, async function() {
      const o = await Promise.all(e.inputs.map((a, c) => n[c] == null ? null : a.walkAsync(n[c], (f, h) => f === "address" ? Array.isArray(h) ? Promise.all(h.map((g) => Ut(g, i))) : Ut(h, i) : h)));
      return t.interface.encodeFilterTopics(e, o);
    }());
  }
  getTopicFilter() {
    return l(this, ri);
  }
}
ri = new WeakMap();
function fr(r, t) {
  return r == null ? null : typeof r[t] == "function" ? r : r.provider && typeof r.provider[t] == "function" ? r.provider : null;
}
function Gn(r) {
  return r == null ? null : r.provider || null;
}
async function Kl(r, t) {
  const e = Tt.dereference(r, "overrides");
  y(typeof e == "object", "invalid overrides parameter", "overrides", r);
  const n = zi(e);
  return y(n.to == null || (t || []).indexOf("to") >= 0, "cannot override to", "overrides.to", n.to), y(n.data == null || (t || []).indexOf("data") >= 0, "cannot override data", "overrides.data", n.data), n.from && (n.from = n.from), n;
}
async function Kp(r, t, e) {
  const n = fr(r, "resolveName"), s = go(n) ? n : null;
  return await Promise.all(t.map((i, o) => i.walkAsync(e[o], (a, c) => (c = Tt.dereference(c, a), a === "address" ? Ut(c, s) : c))));
}
function Wp(r) {
  const t = async function(o) {
    const a = await Kl(o, ["data"]);
    a.to = await r.getAddress(), a.from && (a.from = await Ut(a.from, zl(r.runner)));
    const c = r.interface, u = L(a.value || su, "overrides.value") === su, f = (a.data || "0x") === "0x";
    c.fallback && !c.fallback.payable && c.receive && !f && !u && y(!1, "cannot send data to receive or send value to non-payable fallback", "overrides", o), y(c.fallback || f, "cannot send data to receive-only contract", "overrides.data", a.data);
    const h = c.receive || c.fallback && c.fallback.payable;
    return y(h || u, "cannot send value to non-payable fallback", "overrides.value", a.value), y(c.fallback || f, "cannot send data to receive-only contract", "overrides.data", a.data), a;
  }, e = async function(o) {
    const a = fr(r.runner, "call");
    P(Vl(a), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const c = await t(o);
    try {
      return await a.call(c);
    } catch (u) {
      throw ba(u) && u.data ? r.interface.makeError(u.data, c) : u;
    }
  }, n = async function(o) {
    const a = r.runner;
    P(jl(a), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const c = await a.sendTransaction(await t(o)), u = Gn(r.runner);
    return new La(r.interface, u, c);
  }, s = async function(o) {
    const a = fr(r.runner, "estimateGas");
    return P(Jl(a), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await a.estimateGas(await t(o));
  }, i = async (o) => await n(o);
  return M(i, {
    _contract: r,
    estimateGas: s,
    populateTransaction: t,
    send: n,
    staticCall: e
  }), i;
}
function Yp(r, t) {
  const e = function(...u) {
    const f = r.interface.getFunction(t, u);
    return P(f, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: t, args: u }
    }), f;
  }, n = async function(...u) {
    const f = e(...u);
    let h = {};
    if (f.inputs.length + 1 === u.length && (h = await Kl(u.pop()), h.from && (h.from = await Ut(h.from, zl(r.runner)))), f.inputs.length !== u.length)
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    const g = await Kp(r.runner, f.inputs, u);
    return Object.assign({}, h, await Rt({
      to: r.getAddress(),
      data: r.interface.encodeFunctionData(f, g)
    }));
  }, s = async function(...u) {
    const f = await a(...u);
    return f.length === 1 ? f[0] : f;
  }, i = async function(...u) {
    const f = r.runner;
    P(jl(f), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const h = await f.sendTransaction(await n(...u)), g = Gn(r.runner);
    return new La(r.interface, g, h);
  }, o = async function(...u) {
    const f = fr(r.runner, "estimateGas");
    return P(Jl(f), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await f.estimateGas(await n(...u));
  }, a = async function(...u) {
    const f = fr(r.runner, "call");
    P(Vl(f), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const h = await n(...u);
    let g = "0x";
    try {
      g = await f.call(h);
    } catch (E) {
      throw ba(E) && E.data ? r.interface.makeError(E.data, h) : E;
    }
    const w = e(...u);
    return r.interface.decodeFunctionResult(w, g);
  }, c = async (...u) => e(...u).constant ? await s(...u) : await i(...u);
  return M(c, {
    name: r.interface.getFunctionName(t),
    _contract: r,
    _key: t,
    getFragment: e,
    estimateGas: o,
    populateTransaction: n,
    send: i,
    staticCall: s,
    staticCallResult: a
  }), Object.defineProperty(c, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const u = r.interface.getFunction(t);
      return P(u, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: t }
      }), u;
    }
  }), c;
}
function Zp(r, t) {
  const e = function(...s) {
    const i = r.interface.getEvent(t, s);
    return P(i, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: t, args: s }
    }), i;
  }, n = function(...s) {
    return new zp(r, e(...s), s);
  };
  return M(n, {
    name: r.interface.getEventName(t),
    _contract: r,
    _key: t,
    getFragment: e
  }), Object.defineProperty(n, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const s = r.interface.getEvent(t);
      return P(s, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: t }
      }), s;
    }
  }), n;
}
const Ki = Symbol.for("_ethersInternal_contract"), Wl = /* @__PURE__ */ new WeakMap();
function Xp(r, t) {
  Wl.set(r[Ki], t);
}
function Jt(r) {
  return Wl.get(r[Ki]);
}
function qp(r) {
  return r && typeof r == "object" && "getTopicFilter" in r && typeof r.getTopicFilter == "function" && r.fragment;
}
async function Ma(r, t) {
  let e, n = null;
  if (Array.isArray(t)) {
    const i = function(o) {
      if (ot(o, 32))
        return o;
      const a = r.interface.getEvent(o);
      return y(a, "unknown fragment", "name", o), a.topicHash;
    };
    e = t.map((o) => o == null ? null : Array.isArray(o) ? o.map(i) : i(o));
  } else
    t === "*" ? e = [null] : typeof t == "string" ? ot(t, 32) ? e = [t] : (n = r.interface.getEvent(t), y(n, "unknown fragment", "event", t), e = [n.topicHash]) : qp(t) ? e = await t.getTopicFilter() : "fragment" in t ? (n = t.fragment, e = [n.topicHash]) : y(!1, "unknown event name", "event", t);
  e = e.map((i) => {
    if (i == null)
      return null;
    if (Array.isArray(i)) {
      const o = Array.from(new Set(i.map((a) => a.toLowerCase())).values());
      return o.length === 1 ? o[0] : (o.sort(), o);
    }
    return i.toLowerCase();
  });
  const s = e.map((i) => i == null ? "null" : Array.isArray(i) ? i.join("|") : i).join("&");
  return { fragment: n, tag: s, topics: e };
}
async function ks(r, t) {
  const { subs: e } = Jt(r);
  return e.get((await Ma(r, t)).tag) || null;
}
async function iu(r, t, e) {
  const n = Gn(r.runner);
  P(n, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation: t });
  const { fragment: s, tag: i, topics: o } = await Ma(r, e), { addr: a, subs: c } = Jt(r);
  let u = c.get(i);
  if (!u) {
    const h = { address: a || r, topics: o }, g = (x) => {
      let v = s;
      if (v == null)
        try {
          v = r.interface.getEvent(x.topics[0]);
        } catch {
        }
      if (v) {
        const B = v, T = s ? r.interface.decodeEventLog(s, x.data, x.topics) : [];
        aa(r, e, T, (H) => new jp(r, H, e, B, x));
      } else
        aa(r, e, [], (B) => new _l(r, B, e, x));
    };
    let w = [];
    u = { tag: i, listeners: [], start: () => {
      w.length || w.push(n.on(h, g));
    }, stop: async () => {
      if (w.length == 0)
        return;
      let x = w;
      w = [], await Promise.all(x), n.off(h, g);
    } }, c.set(i, u);
  }
  return u;
}
let oa = Promise.resolve();
async function $p(r, t, e, n) {
  await oa;
  const s = await ks(r, t);
  if (!s)
    return !1;
  const i = s.listeners.length;
  return s.listeners = s.listeners.filter(({ listener: o, once: a }) => {
    const c = Array.from(e);
    n && c.push(n(a ? null : o));
    try {
      o.call(r, ...c);
    } catch {
    }
    return !a;
  }), s.listeners.length === 0 && (s.stop(), Jt(r).subs.delete(s.tag)), i > 0;
}
async function aa(r, t, e, n) {
  try {
    await oa;
  } catch {
  }
  const s = $p(r, t, e, n);
  return oa = s, await s;
}
const Ni = ["then"];
var qg;
const Ms = class Ms {
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(t, e, n, s) {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    A(this, "target");
    /**
     *  The contract Interface.
     */
    A(this, "interface");
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    A(this, "runner");
    /**
     *  All the Events available on this contract.
     */
    A(this, "filters");
    /**
     *  @_ignore:
     */
    A(this, qg);
    /**
     *  The fallback or receive function if any.
     */
    A(this, "fallback");
    y(typeof t == "string" || Zu(t), "invalid value for Contract target", "target", t), n == null && (n = null);
    const i = ia.from(e);
    M(this, { target: t, runner: n, interface: i }), Object.defineProperty(this, Ki, { value: {} });
    let o, a = null, c = null;
    if (s) {
      const h = Gn(n);
      c = new La(this.interface, h, s);
    }
    let u = /* @__PURE__ */ new Map();
    if (typeof t == "string")
      if (ot(t))
        a = t, o = Promise.resolve(t);
      else {
        const h = fr(n, "resolveName");
        if (!go(h))
          throw dt("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        o = h.resolveName(t).then((g) => {
          if (g == null)
            throw dt("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: t
            });
          return Jt(this).addr = g, g;
        });
      }
    else
      o = t.getAddress().then((h) => {
        if (h == null)
          throw new Error("TODO");
        return Jt(this).addr = h, h;
      });
    Xp(this, { addrPromise: o, addr: a, deployTx: c, subs: u });
    const f = new Proxy({}, {
      get: (h, g, w) => {
        if (typeof g == "symbol" || Ni.indexOf(g) >= 0)
          return Reflect.get(h, g, w);
        try {
          return this.getEvent(g);
        } catch (E) {
          if (!oe(E, "INVALID_ARGUMENT") || E.argument !== "key")
            throw E;
        }
      },
      has: (h, g) => Ni.indexOf(g) >= 0 ? Reflect.has(h, g) : Reflect.has(h, g) || this.interface.hasEvent(String(g))
    });
    return M(this, { filters: f }), M(this, {
      fallback: i.receive || i.fallback ? Wp(this) : null
    }), new Proxy(this, {
      get: (h, g, w) => {
        if (typeof g == "symbol" || g in h || Ni.indexOf(g) >= 0)
          return Reflect.get(h, g, w);
        try {
          return h.getFunction(g);
        } catch (E) {
          if (!oe(E, "INVALID_ARGUMENT") || E.argument !== "key")
            throw E;
        }
      },
      has: (h, g) => typeof g == "symbol" || g in h || Ni.indexOf(g) >= 0 ? Reflect.has(h, g) : h.interface.hasFunction(g)
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(t) {
    return new Ms(this.target, this.interface, t);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(t) {
    return new Ms(t, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await Jt(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const t = Gn(this.runner);
    P(t, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const e = await t.getCode(await this.getAddress());
    return e === "0x" ? null : e;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const t = this.deploymentTransaction();
    if (t)
      return await t.wait(), this;
    if (await this.getDeployedCode() != null)
      return this;
    const n = Gn(this.runner);
    return P(n != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" }), new Promise((s, i) => {
      const o = async () => {
        try {
          if (await this.getDeployedCode() != null)
            return s(this);
          n.once("block", o);
        } catch (a) {
          i(a);
        }
      };
      o();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return Jt(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(t) {
    return typeof t != "string" && (t = t.format()), Yp(this, t);
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(t) {
    return typeof t != "string" && (t = t.format()), Zp(this, t);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(t) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(t, e, n) {
    e == null && (e = 0), n == null && (n = "latest");
    const { addr: s, addrPromise: i } = Jt(this), o = s || await i, { fragment: a, topics: c } = await Ma(this, t), u = { address: o, topics: c, fromBlock: e, toBlock: n }, f = Gn(this.runner);
    return P(f, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" }), (await f.getLogs(u)).map((h) => {
      let g = a;
      if (g == null)
        try {
          g = this.interface.getEvent(h.topics[0]);
        } catch {
        }
      if (g)
        try {
          return new Fa(h, this.interface, g);
        } catch (w) {
          return new Hl(h, w);
        }
      return new pi(h, f);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(t, e) {
    const n = await iu(this, "on", t);
    return n.listeners.push({ listener: e, once: !1 }), n.start(), this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(t, e) {
    const n = await iu(this, "once", t);
    return n.listeners.push({ listener: e, once: !0 }), n.start(), this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(t, ...e) {
    return await aa(this, t, e, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(t) {
    if (t) {
      const s = await ks(this, t);
      return s ? s.listeners.length : 0;
    }
    const { subs: e } = Jt(this);
    let n = 0;
    for (const { listeners: s } of e.values())
      n += s.length;
    return n;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(t) {
    if (t) {
      const s = await ks(this, t);
      return s ? s.listeners.map(({ listener: i }) => i) : [];
    }
    const { subs: e } = Jt(this);
    let n = [];
    for (const { listeners: s } of e.values())
      n = n.concat(s.map(({ listener: i }) => i));
    return n;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(t, e) {
    const n = await ks(this, t);
    if (!n)
      return this;
    if (e) {
      const s = n.listeners.map(({ listener: i }) => i).indexOf(e);
      s >= 0 && n.listeners.splice(s, 1);
    }
    return (e == null || n.listeners.length === 0) && (n.stop(), Jt(this).subs.delete(n.tag)), this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(t) {
    if (t) {
      const e = await ks(this, t);
      if (!e)
        return this;
      e.stop(), Jt(this).subs.delete(e.tag);
    } else {
      const { subs: e } = Jt(this);
      for (const { tag: n, stop: s } of e.values())
        s(), e.delete(n);
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(t, e) {
    return await this.on(t, e);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(t, e) {
    return await this.off(t, e);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(t) {
    class e extends Ms {
      constructor(s, i = null) {
        super(s, t, i);
      }
    }
    return e;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(t, e, n) {
    return n == null && (n = null), new this(t, e, n);
  }
};
qg = Ki;
let ca = Ms;
function tg() {
  return ca;
}
class In extends tg() {
}
function Mo(r) {
  return r.match(/^ipfs:\/\/ipfs\//i) ? r = r.substring(12) : r.match(/^ipfs:\/\//i) ? r = r.substring(7) : y(!1, "unsupported IPFS format", "link", r), `https://gateway.ipfs.io/ipfs/${r}`;
}
class eg {
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(t) {
    /**
     *  The name.
     */
    A(this, "name");
    M(this, { name: t });
  }
  connect(t) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(t) {
    return !1;
  }
  /**
   *  Resovles to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(t, e) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resovles to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(t, e) {
    throw new Error("unsupported coin");
  }
}
const Yl = new RegExp("^(ipfs)://(.*)$", "i"), ou = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  Yl,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
var wn, Yn, An, Er, eo, Zl;
const Tr = class Tr {
  constructor(t, e, n) {
    b(this, An);
    /**
     *  The connected provider.
     */
    A(this, "provider");
    /**
     *  The address of the resolver.
     */
    A(this, "address");
    /**
     *  The name this resolver was resolved against.
     */
    A(this, "name");
    // For EIP-2544 names, the ancestor that provided the resolver
    b(this, wn, void 0);
    b(this, Yn, void 0);
    M(this, { provider: t, address: e, name: n }), d(this, wn, null), d(this, Yn, new In(e, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], t));
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    return l(this, wn) == null && d(this, wn, (async () => {
      try {
        return await l(this, Yn).supportsInterface("0x9061b923");
      } catch (t) {
        if (oe(t, "CALL_EXCEPTION"))
          return !1;
        throw d(this, wn, null), t;
      }
    })()), await l(this, wn);
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(t) {
    if (t == null && (t = 60), t === 60)
      try {
        const i = await O(this, An, Er).call(this, "addr(bytes32)");
        return i == null || i === Xo ? null : i;
      } catch (i) {
        if (oe(i, "CALL_EXCEPTION"))
          return null;
        throw i;
      }
    if (t >= 0 && t < 2147483648) {
      let i = t + 2147483648;
      const o = await O(this, An, Er).call(this, "addr(bytes32,uint)", [i]);
      if (ot(o, 20))
        return W(o);
    }
    let e = null;
    for (const i of this.provider.plugins)
      if (i instanceof eg && i.supportsCoinType(t)) {
        e = i;
        break;
      }
    if (e == null)
      return null;
    const n = await O(this, An, Er).call(this, "addr(bytes32,uint)", [t]);
    if (n == null || n === "0x")
      return null;
    const s = await e.decodeAddress(t, n);
    if (s != null)
      return s;
    P(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${t})`,
      info: { coinType: t, data: n }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(t) {
    const e = await O(this, An, Er).call(this, "text(bytes32,string)", [t]);
    return e == null || e === "0x" ? null : e;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const t = await O(this, An, Er).call(this, "contenthash(bytes32)");
    if (t == null || t === "0x")
      return null;
    const e = t.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (e) {
      const s = e[1] === "e3010170" ? "ipfs" : "ipns", i = parseInt(e[4], 16);
      if (e[5].length === i * 2)
        return `${s}://${Uf("0x" + e[2])}`;
    }
    const n = t.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (n && n[1].length === 64)
      return `bzz://${n[1]}`;
    P(!1, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data: t }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    return (await this._getAvatar()).url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const t = [{ type: "name", value: this.name }];
    try {
      const e = await this.getText("avatar");
      if (e == null)
        return t.push({ type: "!avatar", value: "" }), { url: null, linkage: t };
      t.push({ type: "avatar", value: e });
      for (let n = 0; n < ou.length; n++) {
        const s = e.match(ou[n]);
        if (s == null)
          continue;
        const i = s[1].toLowerCase();
        switch (i) {
          case "https":
          case "data":
            return t.push({ type: "url", value: e }), { linkage: t, url: e };
          case "ipfs": {
            const o = Mo(e);
            return t.push({ type: "ipfs", value: e }), t.push({ type: "url", value: o }), { linkage: t, url: o };
          }
          case "erc721":
          case "erc1155": {
            const o = i === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            t.push({ type: i, value: e });
            const a = await this.getAddress();
            if (a == null)
              return t.push({ type: "!owner", value: "" }), { url: null, linkage: t };
            const c = (s[2] || "").split("/");
            if (c.length !== 2)
              return t.push({ type: `!${i}caip`, value: s[2] || "" }), { url: null, linkage: t };
            const u = c[1], f = new In(c[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (i === "erc721") {
              const m = await f.ownerOf(u);
              if (a !== m)
                return t.push({ type: "!owner", value: m }), { url: null, linkage: t };
              t.push({ type: "owner", value: m });
            } else if (i === "erc1155") {
              const m = await f.balanceOf(a, u);
              if (!m)
                return t.push({ type: "!balance", value: "0" }), { url: null, linkage: t };
              t.push({ type: "balance", value: m.toString() });
            }
            let h = await f[o](u);
            if (h == null || h === "0x")
              return t.push({ type: "!metadata-url", value: "" }), { url: null, linkage: t };
            t.push({ type: "metadata-url-base", value: h }), i === "erc1155" && (h = h.replace("{id}", Bn(u, 32).substring(2)), t.push({ type: "metadata-url-expanded", value: h })), h.match(/^ipfs:/i) && (h = Mo(h)), t.push({ type: "metadata-url", value: h });
            let g = {};
            const w = await new Rn(h).send();
            w.assertOk();
            try {
              g = w.bodyJson;
            } catch {
              try {
                t.push({ type: "!metadata", value: w.bodyText });
              } catch {
                const v = w.body;
                return v && t.push({ type: "!metadata", value: F(v) }), { url: null, linkage: t };
              }
              return { url: null, linkage: t };
            }
            if (!g)
              return t.push({ type: "!metadata", value: "" }), { url: null, linkage: t };
            t.push({ type: "metadata", value: JSON.stringify(g) });
            let E = g.image;
            if (typeof E != "string")
              return t.push({ type: "!imageUrl", value: "" }), { url: null, linkage: t };
            if (!E.match(/^(https:\/\/|data:)/i)) {
              if (E.match(Yl) == null)
                return t.push({ type: "!imageUrl-ipfs", value: E }), { url: null, linkage: t };
              t.push({ type: "imageUrl-ipfs", value: E }), E = Mo(E);
            }
            return t.push({ type: "url", value: E }), { linkage: t, url: E };
          }
        }
      }
    } catch {
    }
    return { linkage: t, url: null };
  }
  static async getEnsAddress(t) {
    const e = await t.getNetwork(), n = e.getPlugin("org.ethers.plugins.network.Ens");
    return P(n, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network: e }
    }), n.address;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(t, e) {
    var s;
    let n = e;
    for (; ; ) {
      if (n === "" || n === "." || e !== "eth" && n === "eth")
        return null;
      const i = await O(s = Tr, eo, Zl).call(s, t, n);
      if (i != null) {
        const o = new Tr(t, i, e);
        return n !== e && !await o.supportsWildcard() ? null : o;
      }
      n = n.split(".").slice(1).join(".");
    }
  }
};
wn = new WeakMap(), Yn = new WeakMap(), An = new WeakSet(), Er = async function(t, e) {
  e = (e || []).slice();
  const n = l(this, Yn).interface;
  e.unshift(ra(this.name));
  let s = null;
  await this.supportsWildcard() && (s = n.getFunction(t), P(s, "missing fragment", "UNKNOWN_ERROR", {
    info: { funcName: t }
  }), e = [
    op(this.name),
    n.encodeFunctionData(s, e)
  ], t = "resolve(bytes,bytes)"), e.push({
    enableCcipRead: !0
  });
  try {
    const i = await l(this, Yn)[t](...e);
    return s ? n.decodeFunctionResult(s, i)[0] : i;
  } catch (i) {
    if (!oe(i, "CALL_EXCEPTION"))
      throw i;
  }
  return null;
}, eo = new WeakSet(), Zl = async function(t, e) {
  const n = await Tr.getEnsAddress(t);
  try {
    const i = await new In(n, [
      "function resolver(bytes32) view returns (address)"
    ], t).resolver(ra(e), {
      enableCcipRead: !0
    });
    return i === Xo ? null : i;
  } catch (s) {
    throw s;
  }
  return null;
}, b(Tr, eo);
let Wi = Tr;
const au = BigInt(0);
function rt(r, t) {
  return function(e) {
    return e == null ? t : r(e);
  };
}
function Ga(r) {
  return (t) => {
    if (!Array.isArray(t))
      throw new Error("not an array");
    return t.map((e) => r(e));
  };
}
function gi(r, t) {
  return (e) => {
    const n = {};
    for (const s in r) {
      let i = s;
      if (t && s in t && !(i in e)) {
        for (const o of t[s])
          if (o in e) {
            i = o;
            break;
          }
      }
      try {
        const o = r[s](e[i]);
        o !== void 0 && (n[s] = o);
      } catch (o) {
        const a = o instanceof Error ? o.message : "not-an-error";
        P(!1, `invalid value for value.${s} (${a})`, "BAD_DATA", { value: e });
      }
    }
    return n;
  };
}
function ng(r) {
  switch (r) {
    case !0:
    case "true":
      return !0;
    case !1:
    case "false":
      return !1;
  }
  y(!1, `invalid boolean; ${JSON.stringify(r)}`, "value", r);
}
function xs(r) {
  return y(ot(r, !0), "invalid data", "value", r), r;
}
function ae(r) {
  return y(ot(r, 32), "invalid hash", "value", r), r;
}
const rg = gi({
  address: W,
  blockHash: ae,
  blockNumber: V,
  data: xs,
  index: V,
  removed: rt(ng, !1),
  topics: Ga(ae),
  transactionHash: ae,
  transactionIndex: V
}, {
  index: ["logIndex"]
});
function sg(r) {
  return rg(r);
}
const ig = gi({
  hash: rt(ae),
  parentHash: ae,
  number: V,
  timestamp: V,
  nonce: rt(xs),
  difficulty: L,
  gasLimit: L,
  gasUsed: L,
  miner: rt(W),
  extraData: xs,
  baseFeePerGas: rt(L)
});
function og(r) {
  const t = ig(r);
  return t.transactions = r.transactions.map((e) => typeof e == "string" ? e : Xl(e)), t;
}
const ag = gi({
  transactionIndex: V,
  blockNumber: V,
  transactionHash: ae,
  address: W,
  topics: Ga(ae),
  data: xs,
  index: V,
  blockHash: ae
}, {
  index: ["logIndex"]
});
function cg(r) {
  return ag(r);
}
const ug = gi({
  to: rt(W, null),
  from: rt(W, null),
  contractAddress: rt(W, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: V,
  root: rt(F),
  gasUsed: L,
  logsBloom: rt(xs),
  blockHash: ae,
  hash: ae,
  logs: Ga(cg),
  blockNumber: V,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: L,
  effectiveGasPrice: rt(L),
  status: rt(V),
  type: rt(V, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function lg(r) {
  return ug(r);
}
function Xl(r) {
  r.to && L(r.to) === au && (r.to = "0x0000000000000000000000000000000000000000");
  const t = gi({
    hash: ae,
    type: (e) => e === "0x" || e == null ? 0 : V(e),
    accessList: rt(hr, null),
    blockHash: rt(ae, null),
    blockNumber: rt(V, null),
    transactionIndex: rt(V, null),
    //confirmations: allowNull(getNumber, null),
    from: W,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: rt(L),
    maxPriorityFeePerGas: rt(L),
    maxFeePerGas: rt(L),
    gasLimit: L,
    to: rt(W, null),
    value: L,
    nonce: V,
    data: xs,
    creates: rt(W, null),
    chainId: rt(L, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"]
  })(r);
  if (t.to == null && t.creates == null && (t.creates = ud(t)), (r.type === 1 || r.type === 2) && r.accessList == null && (t.accessList = []), r.signature ? t.signature = we.from(r.signature) : t.signature = we.from(r), t.chainId == null) {
    const e = t.signature.legacyChainId;
    e != null && (t.chainId = e);
  }
  return t.blockHash && L(t.blockHash) === au && (t.blockHash = null), t;
}
const fg = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class yi {
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(t) {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    A(this, "name");
    M(this, { name: t });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new yi(this.name);
  }
}
class yo extends yi {
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(e, n) {
    e == null && (e = 0);
    super(`org.ethers.network.plugins.GasCost#${e || 0}`);
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    A(this, "effectiveBlock");
    /**
     *  The transactions base fee.
     */
    A(this, "txBase");
    /**
     *  The fee for creating a new account.
     */
    A(this, "txCreate");
    /**
     *  The fee per zero-byte in the data.
     */
    A(this, "txDataZero");
    /**
     *  The fee per non-zero-byte in the data.
     */
    A(this, "txDataNonzero");
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    A(this, "txAccessListStorageKey");
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    A(this, "txAccessListAddress");
    const s = { effectiveBlock: e };
    function i(o, a) {
      let c = (n || {})[o];
      c == null && (c = a), y(typeof c == "number", `invalud value for ${o}`, "costs", n), s[o] = c;
    }
    i("txBase", 21e3), i("txCreate", 32e3), i("txDataZero", 4), i("txDataNonzero", 16), i("txAccessListStorageKey", 1900), i("txAccessListAddress", 2400), M(this, s);
  }
  clone() {
    return new yo(this.effectiveBlock, this);
  }
}
class mo extends yi {
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(e, n) {
    super("org.ethers.plugins.network.Ens");
    /**
     *  The ENS Registrty Contract address.
     */
    A(this, "address");
    /**
     *  The chain ID that the ENS contract lives on.
     */
    A(this, "targetNetwork");
    M(this, {
      address: e || fg,
      targetNetwork: n ?? 1
    });
  }
  clone() {
    return new mo(this.address, this.targetNetwork);
  }
}
var si, ii;
class hg extends yi {
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(e, n) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    b(this, si, void 0);
    b(this, ii, void 0);
    d(this, si, e), d(this, ii, n);
  }
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return l(this, si);
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return l(this, ii);
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
}
si = new WeakMap(), ii = new WeakMap();
const Go = /* @__PURE__ */ new Map();
var rs, ss, bn;
const Or = class Or {
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(t, e) {
    b(this, rs, void 0);
    b(this, ss, void 0);
    b(this, bn, void 0);
    d(this, rs, t), d(this, ss, L(e)), d(this, bn, /* @__PURE__ */ new Map());
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return l(this, rs);
  }
  set name(t) {
    d(this, rs, t);
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return l(this, ss);
  }
  set chainId(t) {
    d(this, ss, L(t, "chainId"));
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(t) {
    if (t == null)
      return !1;
    if (typeof t == "string") {
      try {
        return this.chainId === L(t);
      } catch {
      }
      return this.name === t;
    }
    if (typeof t == "number" || typeof t == "bigint") {
      try {
        return this.chainId === L(t);
      } catch {
      }
      return !1;
    }
    if (typeof t == "object") {
      if (t.chainId != null) {
        try {
          return this.chainId === L(t.chainId);
        } catch {
        }
        return !1;
      }
      return t.name != null ? this.name === t.name : !1;
    }
    return !1;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(l(this, bn).values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(t) {
    if (l(this, bn).get(t.name))
      throw new Error(`cannot replace existing plugin: ${t.name} `);
    return l(this, bn).set(t.name, t.clone()), this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(t) {
    return l(this, bn).get(t) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(t) {
    return this.plugins.filter((e) => e.name.split("#")[0] === t);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const t = new Or(this.name, this.chainId);
    return this.plugins.forEach((e) => {
      t.attachPlugin(e.clone());
    }), t;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(t) {
    const e = this.getPlugin("org.ethers.plugins.network.GasCost") || new yo();
    let n = e.txBase;
    if (t.to == null && (n += e.txCreate), t.data)
      for (let s = 2; s < t.data.length; s += 2)
        t.data.substring(s, s + 2) === "00" ? n += e.txDataZero : n += e.txDataNonzero;
    if (t.accessList) {
      const s = hr(t.accessList);
      for (const i in s)
        n += e.txAccessListAddress + e.txAccessListStorageKey * s[i].storageKeys.length;
    }
    return n;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(t) {
    if (dg(), t == null)
      return Or.from("mainnet");
    if (typeof t == "number" && (t = BigInt(t)), typeof t == "string" || typeof t == "bigint") {
      const e = Go.get(t);
      if (e)
        return e();
      if (typeof t == "bigint")
        return new Or("unknown", t);
      y(!1, "unknown network", "network", t);
    }
    if (typeof t.clone == "function")
      return t.clone();
    if (typeof t == "object") {
      y(typeof t.name == "string" && typeof t.chainId == "number", "invalid network object name or chainId", "network", t);
      const e = new Or(t.name, t.chainId);
      return (t.ensAddress || t.ensNetwork != null) && e.attachPlugin(new mo(t.ensAddress, t.ensNetwork)), e;
    }
    y(!1, "invalid network", "network", t);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(t, e) {
    typeof t == "number" && (t = BigInt(t));
    const n = Go.get(t);
    n && y(!1, `conflicting network for ${JSON.stringify(n.name)}`, "nameOrChainId", t), Go.set(t, e);
  }
};
rs = new WeakMap(), ss = new WeakMap(), bn = new WeakMap();
let ke = Or;
function cu(r, t) {
  const e = String(r);
  if (!e.match(/^[0-9.]+$/))
    throw new Error(`invalid gwei value: ${r}`);
  const n = e.split(".");
  if (n.length === 1 && n.push(""), n.length !== 2)
    throw new Error(`invalid gwei value: ${r}`);
  for (; n[1].length < t; )
    n[1] += "0";
  if (n[1].length > 9) {
    let s = BigInt(n[1].substring(0, 9));
    n[1].substring(9).match(/^0+$/) || s++, n[1] = s.toString();
  }
  return BigInt(n[0] + n[1]);
}
function uu(r) {
  return new hg(r, async (t, e, n) => {
    n.setHeader("User-Agent", "ethers");
    let s;
    try {
      const [i, o] = await Promise.all([
        n.send(),
        t()
      ]);
      s = i;
      const a = s.bodyJson.standard;
      return {
        gasPrice: o.gasPrice,
        maxFeePerGas: cu(a.maxFee, 9),
        maxPriorityFeePerGas: cu(a.maxPriorityFee, 9)
      };
    } catch (i) {
      P(!1, `error encountered with polygon gas station (${JSON.stringify(n.url)})`, "SERVER_ERROR", { request: n, response: s, error: i });
    }
  });
}
let lu = !1;
function dg() {
  if (lu)
    return;
  lu = !0;
  function r(t, e, n) {
    const s = function() {
      const i = new ke(t, e);
      return n.ensNetwork != null && i.attachPlugin(new mo(null, n.ensNetwork)), i.attachPlugin(new yo()), (n.plugins || []).forEach((o) => {
        i.attachPlugin(o);
      }), i;
    };
    ke.register(t, s), ke.register(e, s), n.altNames && n.altNames.forEach((i) => {
      ke.register(i, s);
    });
  }
  r("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }), r("ropsten", 3, { ensNetwork: 3 }), r("rinkeby", 4, { ensNetwork: 4 }), r("goerli", 5, { ensNetwork: 5 }), r("kovan", 42, { ensNetwork: 42 }), r("sepolia", 11155111, { ensNetwork: 11155111 }), r("classic", 61, {}), r("classicKotti", 6, {}), r("arbitrum", 42161, {
    ensNetwork: 1
  }), r("arbitrum-goerli", 421613, {}), r("base", 8453, { ensNetwork: 1 }), r("base-goerli", 84531, {}), r("base-sepolia", 84532, {}), r("bnb", 56, { ensNetwork: 1 }), r("bnbt", 97, {}), r("linea", 59144, { ensNetwork: 1 }), r("linea-goerli", 59140, {}), r("matic", 137, {
    ensNetwork: 1,
    plugins: [
      uu("https://gasstation.polygon.technology/v2")
    ]
  }), r("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      uu("https://gasstation-testnet.polygon.technology/v2")
    ]
  }), r("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  }), r("optimism-goerli", 420, {}), r("xdai", 100, { ensNetwork: 1 });
}
function ua(r) {
  return JSON.parse(JSON.stringify(r));
}
var We, ee, En, Te, is, Ui;
class pg {
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(t) {
    b(this, is);
    b(this, We, void 0);
    b(this, ee, void 0);
    b(this, En, void 0);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    b(this, Te, void 0);
    d(this, We, t), d(this, ee, null), d(this, En, 4e3), d(this, Te, -2);
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return l(this, En);
  }
  set pollingInterval(t) {
    d(this, En, t);
  }
  start() {
    l(this, ee) || (d(this, ee, l(this, We)._setTimeout(O(this, is, Ui).bind(this), l(this, En))), O(this, is, Ui).call(this));
  }
  stop() {
    l(this, ee) && (l(this, We)._clearTimeout(l(this, ee)), d(this, ee, null));
  }
  pause(t) {
    this.stop(), t && d(this, Te, -2);
  }
  resume() {
    this.start();
  }
}
We = new WeakMap(), ee = new WeakMap(), En = new WeakMap(), Te = new WeakMap(), is = new WeakSet(), Ui = async function() {
  try {
    const t = await l(this, We).getBlockNumber();
    if (l(this, Te) === -2) {
      d(this, Te, t);
      return;
    }
    if (t !== l(this, Te)) {
      for (let e = l(this, Te) + 1; e <= t; e++) {
        if (l(this, ee) == null)
          return;
        await l(this, We).emit("block", e);
      }
      d(this, Te, t);
    }
  } catch {
  }
  l(this, ee) != null && d(this, ee, l(this, We)._setTimeout(O(this, is, Ui).bind(this), l(this, En)));
};
var Zn, Xn, vn;
class Qa {
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(t) {
    b(this, Zn, void 0);
    b(this, Xn, void 0);
    b(this, vn, void 0);
    d(this, Zn, t), d(this, vn, !1), d(this, Xn, (e) => {
      this._poll(e, l(this, Zn));
    });
  }
  /**
   *  Called on every new block.
   */
  async _poll(t, e) {
    throw new Error("sub-classes must override this");
  }
  start() {
    l(this, vn) || (d(this, vn, !0), l(this, Xn).call(this, -2), l(this, Zn).on("block", l(this, Xn)));
  }
  stop() {
    l(this, vn) && (d(this, vn, !1), l(this, Zn).off("block", l(this, Xn)));
  }
  pause(t) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
Zn = new WeakMap(), Xn = new WeakMap(), vn = new WeakMap();
var os, Ye;
class gg extends Qa {
  constructor(e, n) {
    super(e);
    b(this, os, void 0);
    b(this, Ye, void 0);
    d(this, os, n), d(this, Ye, -2);
  }
  pause(e) {
    e && d(this, Ye, -2), super.pause(e);
  }
  async _poll(e, n) {
    const s = await n.getBlock(l(this, os));
    s != null && (l(this, Ye) === -2 ? d(this, Ye, s.number) : s.number > l(this, Ye) && (n.emit(l(this, os), s.number), d(this, Ye, s.number)));
  }
}
os = new WeakMap(), Ye = new WeakMap();
var no;
class yg extends Qa {
  constructor(e, n) {
    super(e);
    b(this, no, void 0);
    d(this, no, ua(n));
  }
  async _poll(e, n) {
    throw new Error("@TODO");
  }
}
no = new WeakMap();
var as;
class mg extends Qa {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(e, n) {
    super(e);
    b(this, as, void 0);
    d(this, as, n);
  }
  async _poll(e, n) {
    const s = await n.getTransactionReceipt(l(this, as));
    s && n.emit(l(this, as), s);
  }
}
as = new WeakMap();
var Ze, cs, us, xn, ne, ro, ql;
class Ha {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(t, e) {
    b(this, ro);
    b(this, Ze, void 0);
    b(this, cs, void 0);
    b(this, us, void 0);
    b(this, xn, void 0);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    b(this, ne, void 0);
    d(this, Ze, t), d(this, cs, ua(e)), d(this, us, O(this, ro, ql).bind(this)), d(this, xn, !1), d(this, ne, -2);
  }
  start() {
    l(this, xn) || (d(this, xn, !0), l(this, ne) === -2 && l(this, Ze).getBlockNumber().then((t) => {
      d(this, ne, t);
    }), l(this, Ze).on("block", l(this, us)));
  }
  stop() {
    l(this, xn) && (d(this, xn, !1), l(this, Ze).off("block", l(this, us)));
  }
  pause(t) {
    this.stop(), t && d(this, ne, -2);
  }
  resume() {
    this.start();
  }
}
Ze = new WeakMap(), cs = new WeakMap(), us = new WeakMap(), xn = new WeakMap(), ne = new WeakMap(), ro = new WeakSet(), ql = async function(t) {
  if (l(this, ne) === -2)
    return;
  const e = ua(l(this, cs));
  e.fromBlock = l(this, ne) + 1, e.toBlock = t;
  const n = await l(this, Ze).getLogs(e);
  if (n.length === 0) {
    l(this, ne) < t - 60 && d(this, ne, t - 60);
    return;
  }
  for (const s of n)
    l(this, Ze).emit(l(this, cs), s), d(this, ne, s.blockNumber);
};
const wg = BigInt(2), Ag = 10;
function Ci(r) {
  return r && typeof r.then == "function";
}
function Di(r, t) {
  return r + ":" + JSON.stringify(t, (e, n) => {
    if (n == null)
      return "null";
    if (typeof n == "bigint")
      return `bigint:${n.toString()}`;
    if (typeof n == "string")
      return n.toLowerCase();
    if (typeof n == "object" && !Array.isArray(n)) {
      const s = Object.keys(n);
      return s.sort(), s.reduce((i, o) => (i[o] = n[o], i), {});
    }
    return n;
  });
}
class $l {
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(t) {
    /**
     *  The name fof the event.
     */
    A(this, "name");
    M(this, { name: t });
  }
  start() {
  }
  stop() {
  }
  pause(t) {
  }
  resume() {
  }
}
function bg(r) {
  return JSON.parse(JSON.stringify(r));
}
function la(r) {
  return r = Array.from(new Set(r).values()), r.sort(), r;
}
async function Qo(r, t) {
  if (r == null)
    throw new Error("invalid event");
  if (Array.isArray(r) && (r = { topics: r }), typeof r == "string")
    switch (r) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe":
        return { type: r, tag: r };
    }
  if (ot(r, 32)) {
    const e = r.toLowerCase();
    return { type: "transaction", tag: Di("tx", { hash: e }), hash: e };
  }
  if (r.orphan) {
    const e = r;
    return { type: "orphan", tag: Di("orphan", e), filter: bg(e) };
  }
  if (r.address || r.topics) {
    const e = r, n = {
      topics: (e.topics || []).map((s) => s == null ? null : Array.isArray(s) ? la(s.map((i) => i.toLowerCase())) : s.toLowerCase())
    };
    if (e.address) {
      const s = [], i = [], o = (a) => {
        ot(a) ? s.push(a) : i.push((async () => {
          s.push(await Ut(a, t));
        })());
      };
      Array.isArray(e.address) ? e.address.forEach(o) : o(e.address), i.length && await Promise.all(i), n.address = la(s.map((a) => a.toLowerCase()));
    }
    return { filter: n, tag: Di("event", n), type: "event" };
  }
  y(!1, "unknown ProviderEvent", "event", r);
}
function Ho() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const Eg = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
var Pt, Pn, Nt, ls, Kt, qn, Nn, Xe, oi, re, fs, hs, Bt, Vt, ai, fa, ci, ha, $n, Ss, ui, da, tr, Us, ds, Fi;
class vg {
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(t, e) {
    // Shares multiple identical requests made during the same 250ms
    b(this, Bt);
    b(this, ai);
    b(this, ci);
    // Account
    b(this, $n);
    b(this, ui);
    b(this, tr);
    b(this, ds);
    b(this, Pt, void 0);
    b(this, Pn, void 0);
    // null=unpaused, true=paused+dropWhilePaused, false=paused
    b(this, Nt, void 0);
    b(this, ls, void 0);
    b(this, Kt, void 0);
    b(this, qn, void 0);
    b(this, Nn, void 0);
    // The most recent block number if running an event or -1 if no "block" event
    b(this, Xe, void 0);
    b(this, oi, void 0);
    b(this, re, void 0);
    b(this, fs, void 0);
    b(this, hs, void 0);
    if (d(this, hs, Object.assign({}, Eg, e || {})), t === "any")
      d(this, qn, !0), d(this, Kt, null);
    else if (t) {
      const n = ke.from(t);
      d(this, qn, !1), d(this, Kt, Promise.resolve(n)), setTimeout(() => {
        this.emit("network", n, null);
      }, 0);
    } else
      d(this, qn, !1), d(this, Kt, null);
    d(this, Xe, -1), d(this, Nn, /* @__PURE__ */ new Map()), d(this, Pt, /* @__PURE__ */ new Map()), d(this, Pn, /* @__PURE__ */ new Map()), d(this, Nt, null), d(this, ls, !1), d(this, oi, 1), d(this, re, /* @__PURE__ */ new Map()), d(this, fs, !1);
  }
  get pollingInterval() {
    return l(this, hs).pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(l(this, Pn).values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(t) {
    if (l(this, Pn).get(t.name))
      throw new Error(`cannot replace existing plugin: ${t.name} `);
    return l(this, Pn).set(t.name, t.connect(this)), this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(t) {
    return l(this, Pn).get(t) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return l(this, fs);
  }
  set disableCcipRead(t) {
    d(this, fs, !!t);
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(t, e, n) {
    if (this.disableCcipRead || n.length === 0 || t.to == null)
      return null;
    const s = t.to.toLowerCase(), i = e.toLowerCase(), o = [];
    for (let a = 0; a < n.length; a++) {
      const c = n[a], u = c.replace("{sender}", s).replace("{data}", i), f = new Rn(u);
      c.indexOf("{data}") === -1 && (f.body = { data: i, sender: s }), this.emit("debug", { action: "sendCcipReadFetchRequest", request: f, index: a, urls: n });
      let h = "unknown error";
      const g = await f.send();
      try {
        const w = g.bodyJson;
        if (w.data)
          return this.emit("debug", { action: "receiveCcipReadFetchResult", request: f, result: w }), w.data;
        w.message && (h = w.message), this.emit("debug", { action: "receiveCcipReadFetchError", request: f, result: w });
      } catch {
      }
      P(g.statusCode < 400 || g.statusCode >= 500, `response not found during CCIP fetch: ${h}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: t, info: { url: c, errorMessage: h } }), o.push(h);
    }
    P(!1, `error encountered during CCIP fetch: ${o.map((a) => JSON.stringify(a)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: t,
      info: { urls: n, errorMessages: o }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(t, e) {
    return new Hp(og(t), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(t, e) {
    return new pi(sg(t), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(t, e) {
    return new Ml(lg(t), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(t, e) {
    return new Ws(Xl(t), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    P(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(t) {
    P(!1, `unsupported method: ${t.method}`, "UNSUPPORTED_OPERATION", {
      operation: t.method,
      info: t
    });
  }
  // State
  async getBlockNumber() {
    const t = V(await O(this, Bt, Vt).call(this, { method: "getBlockNumber" }), "%response");
    return l(this, Xe) >= 0 && d(this, Xe, t), t;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(t) {
    return Ut(t, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(t) {
    if (t == null)
      return "latest";
    switch (t) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return t;
    }
    if (ot(t))
      return ot(t, 32) ? t : Pr(t);
    if (typeof t == "bigint" && (t = V(t, "blockTag")), typeof t == "number")
      return t >= 0 ? Pr(t) : l(this, Xe) >= 0 ? Pr(l(this, Xe) + t) : this.getBlockNumber().then((e) => Pr(e + t));
    y(!1, "invalid blockTag", "blockTag", t);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(t) {
    const e = (t.topics || []).map((c) => c == null ? null : Array.isArray(c) ? la(c.map((u) => u.toLowerCase())) : c.toLowerCase()), n = "blockHash" in t ? t.blockHash : void 0, s = (c, u, f) => {
      let h;
      switch (c.length) {
        case 0:
          break;
        case 1:
          h = c[0];
          break;
        default:
          c.sort(), h = c;
      }
      if (n && (u != null || f != null))
        throw new Error("invalid filter");
      const g = {};
      return h && (g.address = h), e.length && (g.topics = e), u && (g.fromBlock = u), f && (g.toBlock = f), n && (g.blockHash = n), g;
    };
    let i = [];
    if (t.address)
      if (Array.isArray(t.address))
        for (const c of t.address)
          i.push(this._getAddress(c));
      else
        i.push(this._getAddress(t.address));
    let o;
    "fromBlock" in t && (o = this._getBlockTag(t.fromBlock));
    let a;
    return "toBlock" in t && (a = this._getBlockTag(t.toBlock)), i.filter((c) => typeof c != "string").length || o != null && typeof o != "string" || a != null && typeof a != "string" ? Promise.all([Promise.all(i), o, a]).then((c) => s(c[0], c[1], c[2])) : s(i, o, a);
  }
  /**
   *  Returns or resovles to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(t) {
    const e = zi(t), n = [];
    if (["to", "from"].forEach((s) => {
      if (e[s] == null)
        return;
      const i = Ut(e[s], this);
      Ci(i) ? n.push(async function() {
        e[s] = await i;
      }()) : e[s] = i;
    }), e.blockTag != null) {
      const s = this._getBlockTag(e.blockTag);
      Ci(s) ? n.push(async function() {
        e.blockTag = await s;
      }()) : e.blockTag = s;
    }
    return n.length ? async function() {
      return await Promise.all(n), e;
    }() : e;
  }
  async getNetwork() {
    if (l(this, Kt) == null) {
      const s = this._detectNetwork().then((i) => (this.emit("network", i, null), i), (i) => {
        throw l(this, Kt) === s && d(this, Kt, null), i;
      });
      return d(this, Kt, s), (await s).clone();
    }
    const t = l(this, Kt), [e, n] = await Promise.all([
      t,
      this._detectNetwork()
      // The actual connected network
    ]);
    return e.chainId !== n.chainId && (l(this, qn) ? (this.emit("network", n, e), l(this, Kt) === t && d(this, Kt, Promise.resolve(n))) : P(!1, `network changed: ${e.chainId} => ${n.chainId} `, "NETWORK_ERROR", {
      event: "changed"
    })), e.clone();
  }
  async getFeeData() {
    const t = await this.getNetwork(), e = async () => {
      const { _block: s, gasPrice: i, priorityFee: o } = await Rt({
        _block: O(this, ui, da).call(this, "latest", !1),
        gasPrice: (async () => {
          try {
            const f = await O(this, Bt, Vt).call(this, { method: "getGasPrice" });
            return L(f, "%response");
          } catch {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const f = await O(this, Bt, Vt).call(this, { method: "getPriorityFee" });
            return L(f, "%response");
          } catch {
          }
          return null;
        })()
      });
      let a = null, c = null;
      const u = this._wrapBlock(s, t);
      return u && u.baseFeePerGas && (c = o ?? BigInt("1000000000"), a = u.baseFeePerGas * wg + c), new ru(i, a, c);
    }, n = t.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (n) {
      const s = new Rn(n.url), i = await n.processFunc(e, this, s);
      return new ru(i.gasPrice, i.maxFeePerGas, i.maxPriorityFeePerGas);
    }
    return await e();
  }
  async estimateGas(t) {
    let e = this._getTransactionRequest(t);
    return Ci(e) && (e = await e), L(await O(this, Bt, Vt).call(this, {
      method: "estimateGas",
      transaction: e
    }), "%response");
  }
  async call(t) {
    const { tx: e, blockTag: n } = await Rt({
      tx: this._getTransactionRequest(t),
      blockTag: this._getBlockTag(t.blockTag)
    });
    return await O(this, ci, ha).call(this, O(this, ai, fa).call(this, e, n, t.enableCcipRead ? 0 : -1));
  }
  async getBalance(t, e) {
    return L(await O(this, $n, Ss).call(this, { method: "getBalance" }, t, e), "%response");
  }
  async getTransactionCount(t, e) {
    return V(await O(this, $n, Ss).call(this, { method: "getTransactionCount" }, t, e), "%response");
  }
  async getCode(t, e) {
    return F(await O(this, $n, Ss).call(this, { method: "getCode" }, t, e));
  }
  async getStorage(t, e, n) {
    const s = L(e, "position");
    return F(await O(this, $n, Ss).call(this, { method: "getStorage", position: s }, t, n));
  }
  // Write
  async broadcastTransaction(t) {
    const { blockNumber: e, hash: n, network: s } = await Rt({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: t
      }),
      network: this.getNetwork()
    }), i = Ji.from(t);
    if (i.hash !== n)
      throw new Error("@TODO: the returned hash did not match");
    return this._wrapTransactionResponse(i, s).replaceableTransaction(e);
  }
  // Queries
  async getBlock(t, e) {
    const { network: n, params: s } = await Rt({
      network: this.getNetwork(),
      params: O(this, ui, da).call(this, t, !!e)
    });
    return s == null ? null : this._wrapBlock(s, n);
  }
  async getTransaction(t) {
    const { network: e, params: n } = await Rt({
      network: this.getNetwork(),
      params: O(this, Bt, Vt).call(this, { method: "getTransaction", hash: t })
    });
    return n == null ? null : this._wrapTransactionResponse(n, e);
  }
  async getTransactionReceipt(t) {
    const { network: e, params: n } = await Rt({
      network: this.getNetwork(),
      params: O(this, Bt, Vt).call(this, { method: "getTransactionReceipt", hash: t })
    });
    if (n == null)
      return null;
    if (n.gasPrice == null && n.effectiveGasPrice == null) {
      const s = await O(this, Bt, Vt).call(this, { method: "getTransaction", hash: t });
      if (s == null)
        throw new Error("report this; could not find tx or effectiveGasPrice");
      n.effectiveGasPrice = s.gasPrice;
    }
    return this._wrapTransactionReceipt(n, e);
  }
  async getTransactionResult(t) {
    const { result: e } = await Rt({
      network: this.getNetwork(),
      result: O(this, Bt, Vt).call(this, { method: "getTransactionResult", hash: t })
    });
    return e == null ? null : F(e);
  }
  // Bloom-filter Queries
  async getLogs(t) {
    let e = this._getFilter(t);
    Ci(e) && (e = await e);
    const { network: n, params: s } = await Rt({
      network: this.getNetwork(),
      params: O(this, Bt, Vt).call(this, { method: "getLogs", filter: e })
    });
    return s.map((i) => this._wrapLog(i, n));
  }
  // ENS
  _getProvider(t) {
    P(!1, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(t) {
    return await Wi.fromName(this, t);
  }
  async getAvatar(t) {
    const e = await this.getResolver(t);
    return e ? await e.getAvatar() : null;
  }
  async resolveName(t) {
    const e = await this.getResolver(t);
    return e ? await e.getAddress() : null;
  }
  async lookupAddress(t) {
    t = W(t);
    const e = ra(t.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const n = await Wi.getEnsAddress(this), i = await new In(n, [
        "function resolver(bytes32) view returns (address)"
      ], this).resolver(e);
      if (i == null || i === Xo)
        return null;
      const a = await new In(i, [
        "function name(bytes32) view returns (string)"
      ], this).name(e);
      return await this.resolveName(a) !== t ? null : a;
    } catch (n) {
      if (oe(n, "BAD_DATA") && n.value === "0x" || oe(n, "CALL_EXCEPTION"))
        return null;
      throw n;
    }
    return null;
  }
  async waitForTransaction(t, e, n) {
    const s = e ?? 1;
    return s === 0 ? this.getTransactionReceipt(t) : new Promise(async (i, o) => {
      let a = null;
      const c = async (u) => {
        try {
          const f = await this.getTransactionReceipt(t);
          if (f != null && u - f.blockNumber + 1 >= s) {
            i(f), a && (clearTimeout(a), a = null);
            return;
          }
        } catch (f) {
          console.log("EEE", f);
        }
        this.once("block", c);
      };
      n != null && (a = setTimeout(() => {
        a != null && (a = null, this.off("block", c), o(dt("timeout", "TIMEOUT", { reason: "timeout" })));
      }, n)), c(await this.getBlockNumber());
    });
  }
  async waitForBlock(t) {
    P(!1, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(t) {
    const e = l(this, re).get(t);
    e && (e.timer && clearTimeout(e.timer), l(this, re).delete(t));
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(t, e) {
    e == null && (e = 0);
    const n = Cs(this, oi)._++, s = () => {
      l(this, re).delete(n), t();
    };
    if (this.paused)
      l(this, re).set(n, { timer: null, func: s, time: e });
    else {
      const i = setTimeout(s, e);
      l(this, re).set(n, { timer: i, func: s, time: Ho() });
    }
    return n;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(t) {
    for (const e of l(this, Pt).values())
      t(e.subscriber);
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(t) {
    switch (t.type) {
      case "debug":
      case "error":
      case "network":
        return new $l(t.type);
      case "block": {
        const e = new pg(this);
        return e.pollingInterval = this.pollingInterval, e;
      }
      case "safe":
      case "finalized":
        return new gg(this, t.type);
      case "event":
        return new Ha(this, t.filter);
      case "transaction":
        return new mg(this, t.hash);
      case "orphan":
        return new yg(this, t.filter);
    }
    throw new Error(`unsupported event: ${t.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(t, e) {
    for (const n of l(this, Pt).values())
      if (n.subscriber === t) {
        n.started && n.subscriber.stop(), n.subscriber = e, n.started && e.start(), l(this, Nt) != null && e.pause(l(this, Nt));
        break;
      }
  }
  async on(t, e) {
    const n = await O(this, ds, Fi).call(this, t);
    return n.listeners.push({ listener: e, once: !1 }), n.started || (n.subscriber.start(), n.started = !0, l(this, Nt) != null && n.subscriber.pause(l(this, Nt))), this;
  }
  async once(t, e) {
    const n = await O(this, ds, Fi).call(this, t);
    return n.listeners.push({ listener: e, once: !0 }), n.started || (n.subscriber.start(), n.started = !0, l(this, Nt) != null && n.subscriber.pause(l(this, Nt))), this;
  }
  async emit(t, ...e) {
    const n = await O(this, tr, Us).call(this, t, e);
    if (!n || n.listeners.length === 0)
      return !1;
    const s = n.listeners.length;
    return n.listeners = n.listeners.filter(({ listener: i, once: o }) => {
      const a = new vu(this, o ? null : i, t);
      try {
        i.call(this, ...e, a);
      } catch {
      }
      return !o;
    }), n.listeners.length === 0 && (n.started && n.subscriber.stop(), l(this, Pt).delete(n.tag)), s > 0;
  }
  async listenerCount(t) {
    if (t) {
      const n = await O(this, tr, Us).call(this, t);
      return n ? n.listeners.length : 0;
    }
    let e = 0;
    for (const { listeners: n } of l(this, Pt).values())
      e += n.length;
    return e;
  }
  async listeners(t) {
    if (t) {
      const n = await O(this, tr, Us).call(this, t);
      return n ? n.listeners.map(({ listener: s }) => s) : [];
    }
    let e = [];
    for (const { listeners: n } of l(this, Pt).values())
      e = e.concat(n.map(({ listener: s }) => s));
    return e;
  }
  async off(t, e) {
    const n = await O(this, tr, Us).call(this, t);
    if (!n)
      return this;
    if (e) {
      const s = n.listeners.map(({ listener: i }) => i).indexOf(e);
      s >= 0 && n.listeners.splice(s, 1);
    }
    return (!e || n.listeners.length === 0) && (n.started && n.subscriber.stop(), l(this, Pt).delete(n.tag)), this;
  }
  async removeAllListeners(t) {
    if (t) {
      const { tag: e, started: n, subscriber: s } = await O(this, ds, Fi).call(this, t);
      n && s.stop(), l(this, Pt).delete(e);
    } else
      for (const [e, { started: n, subscriber: s }] of l(this, Pt))
        n && s.stop(), l(this, Pt).delete(e);
    return this;
  }
  // Alias for "on"
  async addListener(t, e) {
    return await this.on(t, e);
  }
  // Alias for "off"
  async removeListener(t, e) {
    return this.off(t, e);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return l(this, ls);
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const t of l(this, re).keys())
      this._clearTimeout(t);
    d(this, ls, !0);
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return l(this, Nt) != null;
  }
  set paused(t) {
    !!t !== this.paused && (this.paused ? this.resume() : this.pause(!1));
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(t) {
    if (d(this, Xe, -1), l(this, Nt) != null) {
      if (l(this, Nt) == !!t)
        return;
      P(!1, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((e) => e.pause(t)), d(this, Nt, !!t);
    for (const e of l(this, re).values())
      e.timer && clearTimeout(e.timer), e.time = Ho() - e.time;
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (l(this, Nt) != null) {
      this._forEachSubscriber((t) => t.resume()), d(this, Nt, null);
      for (const t of l(this, re).values()) {
        let e = t.time;
        e < 0 && (e = 0), t.time = Ho(), setTimeout(t.func, e);
      }
    }
  }
}
Pt = new WeakMap(), Pn = new WeakMap(), Nt = new WeakMap(), ls = new WeakMap(), Kt = new WeakMap(), qn = new WeakMap(), Nn = new WeakMap(), Xe = new WeakMap(), oi = new WeakMap(), re = new WeakMap(), fs = new WeakMap(), hs = new WeakMap(), Bt = new WeakSet(), Vt = async function(t) {
  const e = l(this, hs).cacheTimeout;
  if (e < 0)
    return await this._perform(t);
  const n = Di(t.method, t);
  let s = l(this, Nn).get(n);
  return s || (s = this._perform(t), l(this, Nn).set(n, s), setTimeout(() => {
    l(this, Nn).get(n) === s && l(this, Nn).delete(n);
  }, e)), await s;
}, ai = new WeakSet(), fa = async function(t, e, n) {
  P(n < Ag, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
    reason: "TOO_MANY_REDIRECTS",
    transaction: Object.assign({}, t, { blockTag: e, enableCcipRead: !0 })
  });
  const s = zi(t);
  try {
    return F(await this._perform({ method: "call", transaction: s, blockTag: e }));
  } catch (i) {
    if (!this.disableCcipRead && ba(i) && i.data && n >= 0 && e === "latest" && s.to != null && at(i.data, 0, 4) === "0x556f1830") {
      const o = i.data, a = await Ut(s.to, this);
      let c;
      try {
        c = Tg(at(i.data, 4));
      } catch (h) {
        P(!1, h.message, "OFFCHAIN_FAULT", {
          reason: "BAD_DATA",
          transaction: s,
          info: { data: o }
        });
      }
      P(c.sender.toLowerCase() === a.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
        action: "call",
        data: o,
        reason: "OffchainLookup",
        transaction: s,
        invocation: null,
        revert: {
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          name: "OffchainLookup",
          args: c.errorArgs
        }
      });
      const u = await this.ccipReadFetch(s, c.calldata, c.urls);
      P(u != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
        reason: "FETCH_FAILED",
        transaction: s,
        info: { data: i.data, errorArgs: c.errorArgs }
      });
      const f = {
        to: a,
        data: pt([c.selector, Cg([u, c.extraData])])
      };
      this.emit("debug", { action: "sendCcipReadCall", transaction: f });
      try {
        const h = await O(this, ai, fa).call(this, f, e, n + 1);
        return this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, f), result: h }), h;
      } catch (h) {
        throw this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, f), error: h }), h;
      }
    }
    throw i;
  }
}, ci = new WeakSet(), ha = async function(t) {
  const { value: e } = await Rt({
    network: this.getNetwork(),
    value: t
  });
  return e;
}, $n = new WeakSet(), Ss = async function(t, e, n) {
  let s = this._getAddress(e), i = this._getBlockTag(n);
  return (typeof s != "string" || typeof i != "string") && ([s, i] = await Promise.all([s, i])), await O(this, ci, ha).call(this, O(this, Bt, Vt).call(this, Object.assign(t, { address: s, blockTag: i })));
}, ui = new WeakSet(), da = async function(t, e) {
  if (ot(t, 32))
    return await O(this, Bt, Vt).call(this, {
      method: "getBlock",
      blockHash: t,
      includeTransactions: e
    });
  let n = this._getBlockTag(t);
  return typeof n != "string" && (n = await n), await O(this, Bt, Vt).call(this, {
    method: "getBlock",
    blockTag: n,
    includeTransactions: e
  });
}, tr = new WeakSet(), Us = async function(t, e) {
  let n = await Qo(t, this);
  return n.type === "event" && e && e.length > 0 && e[0].removed === !0 && (n = await Qo({ orphan: "drop-log", log: e[0] }, this)), l(this, Pt).get(n.tag) || null;
}, ds = new WeakSet(), Fi = async function(t) {
  const e = await Qo(t, this), n = e.tag;
  let s = l(this, Pt).get(n);
  return s || (s = { subscriber: this._getSubscriber(e), tag: n, addressableMap: /* @__PURE__ */ new WeakMap(), nameMap: /* @__PURE__ */ new Map(), started: !1, listeners: [] }, l(this, Pt).set(n, s)), s;
};
function xg(r, t) {
  try {
    const e = pa(r, t);
    if (e)
      return va(e);
  } catch {
  }
  return null;
}
function pa(r, t) {
  if (r === "0x")
    return null;
  try {
    const e = V(at(r, t, t + 32)), n = V(at(r, e, e + 32));
    return at(r, e + 32, e + 32 + n);
  } catch {
  }
  return null;
}
function fu(r) {
  const t = Yt(r);
  if (t.length > 32)
    throw new Error("internal; should not happen");
  const e = new Uint8Array(32);
  return e.set(t, 32 - t.length), e;
}
function Pg(r) {
  if (r.length % 32 === 0)
    return r;
  const t = new Uint8Array(Math.ceil(r.length / 32) * 32);
  return t.set(r), t;
}
const Ng = new Uint8Array([]);
function Cg(r) {
  const t = [];
  let e = 0;
  for (let n = 0; n < r.length; n++)
    t.push(Ng), e += 32;
  for (let n = 0; n < r.length; n++) {
    const s = X(r[n]);
    t[n] = fu(e), t.push(fu(s.length)), t.push(Pg(s)), e += 32 + Math.ceil(s.length / 32) * 32;
  }
  return pt(t);
}
const hu = "0x0000000000000000000000000000000000000000000000000000000000000000";
function Tg(r) {
  const t = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  P(Ir(r) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const e = at(r, 0, 32);
  P(at(e, 0, 12) === at(hu, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  }), t.sender = at(e, 12);
  try {
    const n = [], s = V(at(r, 32, 64)), i = V(at(r, s, s + 32)), o = at(r, s + 32);
    for (let a = 0; a < i; a++) {
      const c = xg(o, a * 32);
      if (c == null)
        throw new Error("abort");
      n.push(c);
    }
    t.urls = n;
  } catch {
    P(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const n = pa(r, 64);
    if (n == null)
      throw new Error("abort");
    t.calldata = n;
  } catch {
    P(!1, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  P(at(r, 100, 128) === at(hu, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  }), t.selector = at(r, 96, 100);
  try {
    const n = pa(r, 128);
    if (n == null)
      throw new Error("abort");
    t.extraData = n;
  } catch {
    P(!1, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  return t.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((n) => t[n]), t;
}
function mr(r, t) {
  if (r.provider)
    return r.provider;
  P(!1, "missing provider", "UNSUPPORTED_OPERATION", { operation: t });
}
async function du(r, t) {
  let e = zi(t);
  if (e.to != null && (e.to = Ut(e.to, r)), e.from != null) {
    const n = e.from;
    e.from = Promise.all([
      r.getAddress(),
      Ut(n, r)
    ]).then(([s, i]) => (y(s.toLowerCase() === i.toLowerCase(), "transaction from mismatch", "tx.from", i), s));
  } else
    e.from = r.getAddress();
  return await Rt(e);
}
class Og {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(t) {
    /**
     *  The provider this signer is connected to.
     */
    A(this, "provider");
    M(this, { provider: t || null });
  }
  async getNonce(t) {
    return mr(this, "getTransactionCount").getTransactionCount(await this.getAddress(), t);
  }
  async populateCall(t) {
    return await du(this, t);
  }
  async populateTransaction(t) {
    const e = mr(this, "populateTransaction"), n = await du(this, t);
    n.nonce == null && (n.nonce = await this.getNonce("pending")), n.gasLimit == null && (n.gasLimit = await this.estimateGas(n));
    const s = await this.provider.getNetwork();
    if (n.chainId != null) {
      const o = L(n.chainId);
      y(o === s.chainId, "transaction chainId mismatch", "tx.chainId", t.chainId);
    } else
      n.chainId = s.chainId;
    const i = n.maxFeePerGas != null || n.maxPriorityFeePerGas != null;
    if (n.gasPrice != null && (n.type === 2 || i) ? y(!1, "eip-1559 transaction do not support gasPrice", "tx", t) : (n.type === 0 || n.type === 1) && i && y(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", t), (n.type === 2 || n.type == null) && n.maxFeePerGas != null && n.maxPriorityFeePerGas != null)
      n.type = 2;
    else if (n.type === 0 || n.type === 1) {
      const o = await e.getFeeData();
      P(o.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      }), n.gasPrice == null && (n.gasPrice = o.gasPrice);
    } else {
      const o = await e.getFeeData();
      if (n.type == null)
        if (o.maxFeePerGas != null && o.maxPriorityFeePerGas != null)
          if (n.type = 2, n.gasPrice != null) {
            const a = n.gasPrice;
            delete n.gasPrice, n.maxFeePerGas = a, n.maxPriorityFeePerGas = a;
          } else
            n.maxFeePerGas == null && (n.maxFeePerGas = o.maxFeePerGas), n.maxPriorityFeePerGas == null && (n.maxPriorityFeePerGas = o.maxPriorityFeePerGas);
        else
          o.gasPrice != null ? (P(!i, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          }), n.gasPrice == null && (n.gasPrice = o.gasPrice), n.type = 0) : P(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
      else
        n.type === 2 && (n.maxFeePerGas == null && (n.maxFeePerGas = o.maxFeePerGas), n.maxPriorityFeePerGas == null && (n.maxPriorityFeePerGas = o.maxPriorityFeePerGas));
    }
    return await Rt(n);
  }
  async estimateGas(t) {
    return mr(this, "estimateGas").estimateGas(await this.populateCall(t));
  }
  async call(t) {
    return mr(this, "call").call(await this.populateCall(t));
  }
  async resolveName(t) {
    return await mr(this, "resolveName").resolveName(t);
  }
  async sendTransaction(t) {
    const e = mr(this, "sendTransaction"), n = await this.populateTransaction(t);
    delete n.from;
    const s = Ji.from(n);
    return await e.broadcastTransaction(await this.signTransaction(s));
  }
}
function Ig(r) {
  return JSON.parse(JSON.stringify(r));
}
var Lt, Oe, er, Cn, nr, ps, li, ga, fi, ya;
class tf {
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(t) {
    b(this, li);
    b(this, fi);
    b(this, Lt, void 0);
    b(this, Oe, void 0);
    b(this, er, void 0);
    b(this, Cn, void 0);
    b(this, nr, void 0);
    b(this, ps, void 0);
    d(this, Lt, t), d(this, Oe, null), d(this, er, O(this, li, ga).bind(this)), d(this, Cn, !1), d(this, nr, null), d(this, ps, !1);
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(t) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(t, e) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(t) {
    throw new Error("subclasses must override this");
  }
  start() {
    l(this, Cn) || (d(this, Cn, !0), O(this, li, ga).call(this, -2));
  }
  stop() {
    l(this, Cn) && (d(this, Cn, !1), d(this, ps, !0), O(this, fi, ya).call(this), l(this, Lt).off("block", l(this, er)));
  }
  pause(t) {
    t && O(this, fi, ya).call(this), l(this, Lt).off("block", l(this, er));
  }
  resume() {
    this.start();
  }
}
Lt = new WeakMap(), Oe = new WeakMap(), er = new WeakMap(), Cn = new WeakMap(), nr = new WeakMap(), ps = new WeakMap(), li = new WeakSet(), ga = async function(t) {
  try {
    l(this, Oe) == null && d(this, Oe, this._subscribe(l(this, Lt)));
    let e = null;
    try {
      e = await l(this, Oe);
    } catch (i) {
      if (!oe(i, "UNSUPPORTED_OPERATION") || i.operation !== "eth_newFilter")
        throw i;
    }
    if (e == null) {
      d(this, Oe, null), l(this, Lt)._recoverSubscriber(this, this._recover(l(this, Lt)));
      return;
    }
    const n = await l(this, Lt).getNetwork();
    if (l(this, nr) || d(this, nr, n), l(this, nr).chainId !== n.chainId)
      throw new Error("chaid changed");
    if (l(this, ps))
      return;
    const s = await l(this, Lt).send("eth_getFilterChanges", [e]);
    await this._emitResults(l(this, Lt), s);
  } catch (e) {
    console.log("@TODO", e);
  }
  l(this, Lt).once("block", l(this, er));
}, fi = new WeakSet(), ya = function() {
  const t = l(this, Oe);
  t && (d(this, Oe, null), t.then((e) => {
    l(this, Lt).send("eth_uninstallFilter", [e]);
  }));
};
var rr;
class Bg extends tf {
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(e, n) {
    super(e);
    b(this, rr, void 0);
    d(this, rr, Ig(n));
  }
  _recover(e) {
    return new Ha(e, l(this, rr));
  }
  async _subscribe(e) {
    return await e.send("eth_newFilter", [l(this, rr)]);
  }
  async _emitResults(e, n) {
    for (const s of n)
      e.emit(l(this, rr), e._wrapLog(s, e._network));
  }
}
rr = new WeakMap();
class Rg extends tf {
  async _subscribe(t) {
    return await t.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(t, e) {
    for (const n of e)
      t.emit("pending", n);
  }
}
const kg = "bigint,boolean,function,number,string,symbol".split(/,/g);
function Li(r) {
  if (r == null || kg.indexOf(typeof r) >= 0 || typeof r.getAddress == "function")
    return r;
  if (Array.isArray(r))
    return r.map(Li);
  if (typeof r == "object")
    return Object.keys(r).reduce((t, e) => (t[e] = r[e], t), {});
  throw new Error(`should not happen: ${r} (${typeof r})`);
}
function Sg(r) {
  return new Promise((t) => {
    setTimeout(t, r);
  });
}
function wr(r) {
  return r && r.toLowerCase();
}
function pu(r) {
  return r && typeof r.pollingInterval == "number";
}
const Ug = {
  polling: !1,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class _o extends Og {
  constructor(e, n) {
    super(e);
    A(this, "address");
    n = W(n), M(this, { address: n });
  }
  connect(e) {
    P(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(e) {
    return await this.populateCall(e);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(e) {
    const n = Li(e), s = [];
    if (n.from) {
      const o = n.from;
      s.push((async () => {
        const a = await Ut(o, this.provider);
        y(a != null && a.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", e), n.from = a;
      })());
    } else
      n.from = this.address;
    if (n.gasLimit == null && s.push((async () => {
      n.gasLimit = await this.provider.estimateGas({ ...n, from: this.address });
    })()), n.to != null) {
      const o = n.to;
      s.push((async () => {
        n.to = await Ut(o, this.provider);
      })());
    }
    s.length && await Promise.all(s);
    const i = this.provider.getRpcTransaction(n);
    return this.provider.send("eth_sendTransaction", [i]);
  }
  async sendTransaction(e) {
    const n = await this.provider.getBlockNumber(), s = await this.sendUncheckedTransaction(e);
    return await new Promise((i, o) => {
      const a = [1e3, 100], c = async () => {
        const u = await this.provider.getTransaction(s);
        if (u != null) {
          i(u.replaceableTransaction(n));
          return;
        }
        this.provider._setTimeout(() => {
          c();
        }, a.pop() || 4e3);
      };
      c();
    });
  }
  async signTransaction(e) {
    const n = Li(e);
    if (n.from) {
      const i = await Ut(n.from, this.provider);
      y(i != null && i.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", e), n.from = i;
    } else
      n.from = this.address;
    const s = this.provider.getRpcTransaction(n);
    return await this.provider.send("eth_signTransaction", [s]);
  }
  async signMessage(e) {
    const n = typeof e == "string" ? en(e) : e;
    return await this.provider.send("personal_sign", [
      F(n),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(e, n, s) {
    const i = Li(s), o = await ji.resolveNames(e, n, i, async (a) => {
      const c = await Ut(a);
      return y(c != null, "TypedData does not support null address", "value", a), c;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(ji.getPayload(o.domain, n, o.value))
    ]);
  }
  async unlock(e) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      e,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(e) {
    const n = typeof e == "string" ? en(e) : e;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      F(n)
    ]);
  }
}
var sr, gs, qe, Ie, ye, se, Wt, hi, ma;
class Dg extends vg {
  constructor(e, n) {
    super(e, n);
    b(this, hi);
    b(this, sr, void 0);
    // The next ID to use for the JSON-RPC ID field
    b(this, gs, void 0);
    // Payloads are queued and triggered in batches using the drainTimer
    b(this, qe, void 0);
    b(this, Ie, void 0);
    b(this, ye, void 0);
    b(this, se, void 0);
    b(this, Wt, void 0);
    d(this, gs, 1), d(this, sr, Object.assign({}, Ug, n || {})), d(this, qe, []), d(this, Ie, null), d(this, se, null), d(this, Wt, null);
    {
      let i = null;
      const o = new Promise((a) => {
        i = a;
      });
      d(this, ye, { promise: o, resolve: i });
    }
    const s = this._getOption("staticNetwork");
    typeof s == "boolean" ? (y(!s || e !== "any", "staticNetwork cannot be used on special network 'any'", "options", n), s && e != null && d(this, se, ke.from(e))) : s && (y(e == null || s.matches(e), "staticNetwork MUST match network object", "options", n), d(this, se, s));
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(e) {
    return l(this, sr)[e];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    return P(l(this, se), "network is not available yet", "NETWORK_ERROR"), l(this, se);
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(e) {
    if (e.method === "call" || e.method === "estimateGas") {
      let s = e.transaction;
      if (s && s.type != null && L(s.type) && s.maxFeePerGas == null && s.maxPriorityFeePerGas == null) {
        const i = await this.getFeeData();
        i.maxFeePerGas == null && i.maxPriorityFeePerGas == null && (e = Object.assign({}, e, {
          transaction: Object.assign({}, s, { type: void 0 })
        }));
      }
    }
    const n = this.getRpcRequest(e);
    return n != null ? await this.send(n.method, n.args) : super._perform(e);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const e = this._getOption("staticNetwork");
    if (e)
      if (e === !0) {
        if (l(this, se))
          return l(this, se);
      } else
        return e;
    return l(this, Wt) ? await l(this, Wt) : this.ready ? (d(this, Wt, (async () => {
      const n = ke.from(L(await this.send("eth_chainId", [])));
      return d(this, Wt, null), n;
    })()), await l(this, Wt)) : (d(this, Wt, (async () => {
      const n = {
        id: Cs(this, gs)._++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload: n });
      let s;
      try {
        s = (await this._send(n))[0], d(this, Wt, null);
      } catch (i) {
        throw d(this, Wt, null), this.emit("debug", { action: "receiveRpcError", error: i }), i;
      }
      if (this.emit("debug", { action: "receiveRpcResult", result: s }), "result" in s)
        return ke.from(L(s.result));
      throw this.getRpcError(n, s);
    })()), await l(this, Wt));
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    l(this, ye) == null || l(this, ye).resolve == null || (l(this, ye).resolve(), d(this, ye, null), (async () => {
      for (; l(this, se) == null && !this.destroyed; )
        try {
          d(this, se, await this._detectNetwork());
        } catch (e) {
          if (this.destroyed)
            break;
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"), this.emit("error", dt("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error: e } })), await Sg(1e3);
        }
      O(this, hi, ma).call(this);
    })());
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (l(this, ye) != null)
      return await l(this, ye).promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(e) {
    return e.type === "pending" ? new Rg(this) : e.type === "event" ? this._getOption("polling") ? new Ha(this, e.filter) : new Bg(this, e.filter) : e.type === "orphan" && e.filter.orphan === "drop-log" ? new $l("orphan") : super._getSubscriber(e);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return l(this, ye) == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(e) {
    const n = {};
    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((s) => {
      if (e[s] == null)
        return;
      let i = s;
      s === "gasLimit" && (i = "gas"), n[i] = Pr(L(e[s], `tx.${s}`));
    }), ["from", "to", "data"].forEach((s) => {
      e[s] != null && (n[s] = F(e[s]));
    }), e.accessList && (n.accessList = hr(e.accessList)), n;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(e) {
    switch (e.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [wr(e.address), e.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [wr(e.address), e.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [wr(e.address), e.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            wr(e.address),
            "0x" + e.position.toString(16),
            e.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [e.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in e)
          return {
            method: "eth_getBlockByNumber",
            args: [e.blockTag, !!e.includeTransactions]
          };
        if ("blockHash" in e)
          return {
            method: "eth_getBlockByHash",
            args: [e.blockHash, !!e.includeTransactions]
          };
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [e.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [e.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(e.transaction), e.blockTag]
        };
      case "estimateGas":
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(e.transaction)]
        };
      case "getLogs":
        return e.filter && e.filter.address != null && (Array.isArray(e.filter.address) ? e.filter.address = e.filter.address.map(wr) : e.filter.address = wr(e.filter.address)), { method: "eth_getLogs", args: [e.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(e, n) {
    const { method: s } = e, { error: i } = n;
    if (s === "eth_estimateGas" && i.message) {
      const c = i.message;
      if (!c.match(/revert/i) && c.match(/insufficient funds/i))
        return dt("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: e.params[0],
          info: { payload: e, error: i }
        });
    }
    if (s === "eth_call" || s === "eth_estimateGas") {
      const c = wa(i), u = Ks.getBuiltinCallException(s === "eth_call" ? "call" : "estimateGas", e.params[0], c ? c.data : null);
      return u.info = { error: i, payload: e }, u;
    }
    const o = JSON.stringify(Lg(i));
    if (typeof i.message == "string" && i.message.match(/user denied|ethers-user-denied/i))
      return dt("user rejected action", "ACTION_REJECTED", {
        action: {
          eth_sign: "signMessage",
          personal_sign: "signMessage",
          eth_signTypedData_v4: "signTypedData",
          eth_signTransaction: "signTransaction",
          eth_sendTransaction: "sendTransaction",
          eth_requestAccounts: "requestAccess",
          wallet_requestAccounts: "requestAccess"
        }[s] || "unknown",
        reason: "rejected",
        info: { payload: e, error: i }
      });
    if (s === "eth_sendRawTransaction" || s === "eth_sendTransaction") {
      const c = e.params[0];
      if (o.match(/insufficient funds|base fee exceeds gas limit/i))
        return dt("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction: c,
          info: { error: i }
        });
      if (o.match(/nonce/i) && o.match(/too low/i))
        return dt("nonce has already been used", "NONCE_EXPIRED", { transaction: c, info: { error: i } });
      if (o.match(/replacement transaction/i) && o.match(/underpriced/i))
        return dt("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction: c, info: { error: i } });
      if (o.match(/only replay-protected/i))
        return dt("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: s,
          info: { transaction: c, info: { error: i } }
        });
    }
    let a = !!o.match(/the method .* does not exist/i);
    return a || i && i.details && i.details.startsWith("Unauthorized method:") && (a = !0), a ? dt("unsupported operation", "UNSUPPORTED_OPERATION", {
      operation: e.method,
      info: { error: i, payload: e }
    }) : dt("could not coalesce error", "UNKNOWN_ERROR", { error: i, payload: e });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(e, n) {
    if (this.destroyed)
      return Promise.reject(dt("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: e }));
    const s = Cs(this, gs)._++, i = new Promise((o, a) => {
      l(this, qe).push({
        resolve: o,
        reject: a,
        payload: { method: e, params: n, id: s, jsonrpc: "2.0" }
      });
    });
    return O(this, hi, ma).call(this), i;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(e) {
    e == null && (e = 0);
    const n = this.send("eth_accounts", []);
    if (typeof e == "number") {
      const i = await n;
      if (e >= i.length)
        throw new Error("no such account");
      return new _o(this, i[e]);
    }
    const { accounts: s } = await Rt({
      network: this.getNetwork(),
      accounts: n
    });
    e = W(e);
    for (const i of s)
      if (W(i) === e)
        return new _o(this, e);
    throw new Error("invalid account");
  }
  async listAccounts() {
    return (await this.send("eth_accounts", [])).map((n) => new _o(this, n));
  }
  destroy() {
    l(this, Ie) && (clearTimeout(l(this, Ie)), d(this, Ie, null));
    for (const { payload: e, reject: n } of l(this, qe))
      n(dt("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: e.method }));
    d(this, qe, []), super.destroy();
  }
}
sr = new WeakMap(), gs = new WeakMap(), qe = new WeakMap(), Ie = new WeakMap(), ye = new WeakMap(), se = new WeakMap(), Wt = new WeakMap(), hi = new WeakSet(), ma = function() {
  if (l(this, Ie))
    return;
  const e = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
  d(this, Ie, setTimeout(() => {
    d(this, Ie, null);
    const n = l(this, qe);
    for (d(this, qe, []); n.length; ) {
      const s = [n.shift()];
      for (; n.length && s.length !== l(this, sr).batchMaxCount; )
        if (s.push(n.shift()), JSON.stringify(s.map((o) => o.payload)).length > l(this, sr).batchMaxSize) {
          n.unshift(s.pop());
          break;
        }
      (async () => {
        const i = s.length === 1 ? s[0].payload : s.map((o) => o.payload);
        this.emit("debug", { action: "sendRpcPayload", payload: i });
        try {
          const o = await this._send(i);
          this.emit("debug", { action: "receiveRpcResult", result: o });
          for (const { resolve: a, reject: c, payload: u } of s) {
            if (this.destroyed) {
              c(dt("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: u.method }));
              continue;
            }
            const f = o.filter((h) => h.id === u.id)[0];
            if (f == null) {
              const h = dt("missing response for request", "BAD_DATA", {
                value: o,
                info: { payload: u }
              });
              this.emit("error", h), c(h);
              continue;
            }
            if ("error" in f) {
              c(this.getRpcError(u, f));
              continue;
            }
            a(f.result);
          }
        } catch (o) {
          this.emit("debug", { action: "receiveRpcError", error: o });
          for (const { reject: a } of s)
            a(o);
        }
      })();
    }
  }, e));
};
var Tn;
class Fg extends Dg {
  constructor(e, n) {
    super(e, n);
    b(this, Tn, void 0);
    d(this, Tn, 4e3);
  }
  _getSubscriber(e) {
    const n = super._getSubscriber(e);
    return pu(n) && (n.pollingInterval = l(this, Tn)), n;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return l(this, Tn);
  }
  set pollingInterval(e) {
    if (!Number.isInteger(e) || e < 0)
      throw new Error("invalid interval");
    d(this, Tn, e), this._forEachSubscriber((n) => {
      pu(n) && (n.pollingInterval = l(this, Tn));
    });
  }
}
Tn = new WeakMap();
function wa(r) {
  if (r == null)
    return null;
  if (typeof r.message == "string" && r.message.match(/revert/i) && ot(r.data))
    return { message: r.message, data: r.data };
  if (typeof r == "object") {
    for (const t in r) {
      const e = wa(r[t]);
      if (e)
        return e;
    }
    return null;
  }
  if (typeof r == "string")
    try {
      return wa(JSON.parse(r));
    } catch {
    }
  return null;
}
function Aa(r, t) {
  if (r != null) {
    if (typeof r.message == "string" && t.push(r.message), typeof r == "object")
      for (const e in r)
        Aa(r[e], t);
    if (typeof r == "string")
      try {
        return Aa(JSON.parse(r), t);
      } catch {
      }
  }
}
function Lg(r) {
  const t = [];
  return Aa(r, t), t;
}
var ys;
class Mg extends Fg {
  /**
   *  Connnect to the %%ethereum%% provider, optionally forcing the
   *  %%network%%.
   */
  constructor(e, n) {
    super(n, { batchMaxCount: 1 });
    b(this, ys, void 0);
    d(this, ys, async (s, i) => {
      const o = { method: s, params: i };
      this.emit("debug", { action: "sendEip1193Request", payload: o });
      try {
        const a = await e.request(o);
        return this.emit("debug", { action: "receiveEip1193Result", result: a }), a;
      } catch (a) {
        const c = new Error(a.message);
        throw c.code = a.code, c.data = a.data, c.payload = o, this.emit("debug", { action: "receiveEip1193Error", error: c }), c;
      }
    });
  }
  async send(e, n) {
    return await this._start(), await super.send(e, n);
  }
  async _send(e) {
    y(!Array.isArray(e), "EIP-1193 does not support batch request", "payload", e);
    try {
      const n = await l(this, ys).call(this, e.method, e.params || []);
      return [{ id: e.id, result: n }];
    } catch (n) {
      return [{
        id: e.id,
        error: { code: n.code, data: n.data, message: n.message }
      }];
    }
  }
  getRpcError(e, n) {
    switch (n = JSON.parse(JSON.stringify(n)), n.error.code || -1) {
      case 4001:
        n.error.message = `ethers-user-denied: ${n.error.message}`;
        break;
      case 4200:
        n.error.message = `ethers-unsupported: ${n.error.message}`;
        break;
    }
    return super.getRpcError(e, n);
  }
  /**
   *  Resolves to ``true`` if the provider manages the %%address%%.
   */
  async hasSigner(e) {
    e == null && (e = 0);
    const n = await this.send("eth_accounts", []);
    return typeof e == "number" ? n.length > e : (e = e.toLowerCase(), n.filter((s) => s.toLowerCase() === e).length !== 0);
  }
  async getSigner(e) {
    if (e == null && (e = 0), !await this.hasSigner(e))
      try {
        await l(this, ys).call(this, "eth_requestAccounts", []);
      } catch (n) {
        const s = n.payload;
        throw this.getRpcError(s, { id: s.id, error: n });
      }
    return await super.getSigner(e);
  }
}
ys = new WeakMap();
const wo = new Mg(window.ethereum);
let Ti, Oi;
async function Ys() {
  return Ti ? Promise.resolve(Ti) : Oi || (Oi = new Promise(async (r) => {
    await window.ethereum.enable(), Ti = await wo.getSigner(), r(Ti);
  }), Oi);
}
function Gg({
  activating: r,
  activationFunctions: t,
  selectedFunctionId: e,
  balance: n
}) {
  return console.log(t, e), /* @__PURE__ */ q.jsxs(q.Fragment, { children: [
    /* @__PURE__ */ q.jsx(
      "div",
      {
        className: r === "unactivated" ? "opacity-100" : "opacity-0",
        children: /* @__PURE__ */ q.jsxs("p", { className: "text-sm text-center", children: [
          t[e].context,
          /* @__PURE__ */ q.jsx("br", {}),
          /* @__PURE__ */ q.jsx("br", {}),
          t[e].description,
          /* @__PURE__ */ q.jsx("br", {}),
          /* @__PURE__ */ q.jsx("br", {}),
          "Reward:",
          " ",
          String(
            t[e].multiplier * t[e].weightInWatt
          ),
          " ",
          "Verification WATT"
        ] })
      }
    ),
    r === "activating" && /* @__PURE__ */ q.jsx(
      "img",
      {
        src: "./assets/loading.png",
        alt: "Loading...",
        className: "absolute top-16 w-20 h-20"
      }
    ),
    r === "activated" && /* @__PURE__ */ q.jsxs("div", { children: [
      "activated $",
      n,
      " WATTS"
    ] })
  ] });
}
const Qg = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_poC",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint256",
        name: "activationFunctionId",
        type: "uint256"
      }
    ],
    name: "ActivationFunctionApproved",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint256",
        name: "activationFunctionId",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "address",
        name: "developer",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "string",
        name: "context",
        type: "string"
      }
    ],
    name: "ActivationFunctionRegistered",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "addr",
        type: "address"
      }
    ],
    name: "DebugAddress",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "activationFunctionId",
        type: "uint256"
      }
    ],
    name: "activate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "activationFunctions",
    outputs: [
      {
        internalType: "address",
        name: "issuer",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      },
      {
        internalType: "enum NewcoinEncoder.WattType",
        name: "wattType",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "multiplier",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "contextId",
        type: "bytes32"
      },
      {
        internalType: "string",
        name: "context",
        type: "string"
      },
      {
        internalType: "string",
        name: "description",
        type: "string"
      },
      {
        internalType: "address",
        name: "addrss",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "weightInWatt",
        type: "uint256"
      },
      {
        internalType: "bool",
        name: "isAsync",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "activationFunctionId",
        type: "uint256"
      }
    ],
    name: "approveActivationFunction",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "activationFunctionId",
        type: "uint256"
      }
    ],
    name: "canMint",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getApprovedActivationFunctions",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "issuer",
            type: "address"
          },
          {
            internalType: "bool",
            name: "approved",
            type: "bool"
          },
          {
            internalType: "enum NewcoinEncoder.WattType",
            name: "wattType",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "multiplier",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "contextId",
            type: "bytes32"
          },
          {
            internalType: "string",
            name: "context",
            type: "string"
          },
          {
            internalType: "string",
            name: "description",
            type: "string"
          },
          {
            internalType: "address",
            name: "addrss",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "weightInWatt",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "isAsync",
            type: "bool"
          }
        ],
        internalType: "struct NewcoinEncoder.ActivationFunction[]",
        name: "",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "conditionMet",
        type: "bool"
      },
      {
        internalType: "uint256",
        name: "activationFunctionId",
        type: "uint256"
      }
    ],
    name: "oracleResponse",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "poC",
    outputs: [
      {
        internalType: "contract EnergyMinterMock",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum NewcoinEncoder.WattType",
        name: "_wattType",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "_multiplier",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "_contextId",
        type: "bytes32"
      },
      {
        internalType: "string",
        name: "_context",
        type: "string"
      },
      {
        internalType: "string",
        name: "_description",
        type: "string"
      },
      {
        internalType: "address",
        name: "_addrss",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_weightInWatt",
        type: "uint256"
      },
      {
        internalType: "bool",
        name: "_isAsync",
        type: "bool"
      }
    ],
    name: "registerActivationFunction",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
], Hg = "0x84387e3ad062D683BFc7eD2Eeaf2C30B27Bd3d05", ef = new In(
  Hg,
  Qg,
  wo
), _g = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "bytes32",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "ChainlinkCancelled",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "bytes32",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "ChainlinkFulfilled",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "bytes32",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "ChainlinkRequested",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "OwnershipTransferRequested",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "requester",
        type: "address"
      }
    ],
    name: "RequestFulfilled",
    type: "event"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_activationFunctionId",
        type: "uint256"
      }
    ],
    name: "activate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "requestId",
        type: "bytes32"
      },
      {
        internalType: "bool",
        name: "data",
        type: "bool"
      }
    ],
    name: "fulfill",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getFeeInHundredthsOfLink",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getJobId",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getOracleAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "passportHolders",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "request",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    name: "requesters",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "response",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_feeInHundredthsOfLink",
        type: "uint256"
      }
    ],
    name: "setFeeInHundredthsOfLink",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_feeInJuels",
        type: "uint256"
      }
    ],
    name: "setFeeInJuels",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_jobId",
        type: "string"
      }
    ],
    name: "setJobId",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_oracleAddress",
        type: "address"
      }
    ],
    name: "setOracleAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "withdrawLink",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], Vg = "0xf192Ee5a9fB9AE3A8dee79669CFd2BA8C8441d9c", Jg = new In(
  Vg,
  _g,
  wo
), jg = [
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint8",
        name: "id",
        type: "uint8"
      }
    ],
    name: "balanceOfEnergy",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOfWatts",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint8",
        name: "id",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "mint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    name: "neuralTokenBalances",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "wattBalances",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
], zg = "0xf272Fe62eEdCBCf7221D8451a68a85c3AF4fAcFe", Kg = new In(
  zg,
  jg,
  wo
);
function Yi(r, t, e) {
  const [n, s] = Un(e);
  return yu(() => {
    let i = !1;
    const o = r();
    if (o != null)
      return o.then((a) => {
        i || s(a);
      }), () => {
        i = !0;
      };
  }, t), n;
}
const nf = ({
  setActivating: r,
  setBalance: t,
  selectedFunctionId: e,
  contractType: n,
  contractAddress: s
}) => {
  const i = async (a) => {
    const c = await Ys();
    let {
      // eslint-disable-next-line prefer-const
      selectedFunctionId: u,
      contractType: f,
      contractAddress: h
      // params
    } = a || {};
    f = f || n || "guildAFContract", h = h || s || "";
    const g = typeof u < "u" ? u : e;
    try {
      await Jg.connect(
        c
      ).request(), setTimeout(async () => {
        try {
          await (await ef.connect(
            c
          ).activate(g)).wait(), o();
        } catch (E) {
          console.log("Error during activation: ", E);
        }
      }, 6e4);
    } catch (w) {
      console.log("Error during request: ", w);
    }
    r("activating");
  }, o = async () => {
    const a = Yi(Ys, []), c = Kg.connect(
      a
    );
    try {
      const u = await a.getAddress(), f = await c.balanceOfWatts(u);
      console.log("Balance of Watts: ", f.toString()), t(f.toString()), r("activated");
    } catch (u) {
      console.log("Error fetching balance: ", u);
    }
  };
  return {
    activate: i
  };
};
function Wg({
  activating: r,
  setActivating: t,
  setBalance: e,
  selectedFunctionId: n,
  render: s
}) {
  const i = Yi(Ys, []), { activate: o } = nf({
    activating: r,
    setActivating: t,
    setBalance: e,
    selectedFunctionId: n
  }), a = s || ((c) => /* @__PURE__ */ q.jsx("button", { ...c }));
  return i ? /* @__PURE__ */ q.jsx(
    a,
    {
      onClick: () => o(),
      className: `py-2 px-4 text-white rounded-full w-40 ${r === "activating" ? "bg-gray-400" : "bg-black"}`,
      disabled: r === "activating",
      children: r === "activating" ? "Activating" : "Activate"
    }
  ) : /* @__PURE__ */ q.jsx(q.Fragment, { children: "Wait..." });
}
function Yg({
  activationFunctions: r,
  setSelectedFunctionId: t,
  selectedFunctionId: e
}) {
  const n = (s) => {
    const i = Number(s.target.value);
    t(i);
  };
  return yu(() => {
    console.log(e);
  }, [e]), /* @__PURE__ */ q.jsxs(
    "select",
    {
      onChange: n,
      value: e,
      className: `py-2 px-4 text-xs text-black rounded-full w-40 border border-black ${e ? "bg-gray-200" : "bg-white"}`,
      children: [
        /* @__PURE__ */ q.jsx("option", { value: "", disabled: !0, children: "Select an activation function" }),
        r.map((s, i) => /* @__PURE__ */ q.jsxs("option", { value: i, children: [
          s.context,
          " ",
          s.id
        ] }, s.id))
      ]
    }
  );
}
const Zg = (r, t) => {
  const [e, n] = Un("unactivated"), [s, i] = Un("0"), [o, a] = Un(0), [c, u] = Un(!1), [f, h] = Un(!1), [g, w] = Un(!1), E = () => u(!0), m = Yi(async () => {
    if (!(c || t))
      return Promise.resolve();
    h(!0);
    const D = await Ys();
    return window.alert(D), h(!1), w(!!D), D;
  }, [c, t]), v = Yi(
    async () => {
      const D = await Ys();
      if (!D)
        return;
      const nt = await ef.connect(
        D
      ).getApprovedActivationFunctions();
      return console.log(nt), nt;
    },
    [m, r],
    []
  ) || [], B = /* @__PURE__ */ q.jsx(
    Yg,
    {
      selectedFunctionId: o,
      setSelectedFunctionId: a,
      activationFunctions: v
    }
  ), T = /* @__PURE__ */ q.jsx(
    Gg,
    {
      activating: e,
      activationFunctions: v,
      selectedFunctionId: o,
      balance: s
    }
  ), H = {
    activating: e,
    setActivating: n,
    balance: s,
    setBalance: i,
    selectedFunctionId: o
  }, G = /* @__PURE__ */ q.jsx(
    Wg,
    {
      ...H
    }
  ), { activate: U } = nf(H);
  return {
    activate: U,
    activationFunctions: v,
    setActivating: n,
    activating: e,
    selectedFunctionId: o,
    setSelectedFunctionId: a,
    balance: s,
    setBalance: i,
    button: G,
    panel: T,
    dropDown: B,
    connect: E,
    isConnecting: f,
    isConnected: g,
    signer: m
  };
};
function Xg() {
  const {
    activationFunctions: r,
    activating: t,
    connect: e,
    button: n,
    panel: s,
    dropDown: i,
    isConnected: o
  } = Zg("0x84387e3ad062D683BFc7eD2Eeaf2C30B27Bd3d05");
  return /* @__PURE__ */ q.jsx("div", { className: "min-h-screen flex items-center justify-center", children: /* @__PURE__ */ q.jsxs("div", { className: "relative flex flex-col items-center justify-between pl-2 pr-2 pt-8 pb-8 border border-black w-64 h-96", children: [
    !o && /* @__PURE__ */ q.jsx("button", { onClick: () => e(), children: "connect" }),
    /* @__PURE__ */ q.jsx("br", {}),
    /* @__PURE__ */ q.jsx("br", {}),
    r.length > 0 && /* @__PURE__ */ q.jsx(q.Fragment, { children: /* @__PURE__ */ q.jsxs(q.Fragment, { children: [
      t != "activating" && i,
      s,
      n
    ] }) })
  ] }) });
}
const ny = Xg;
export {
  ny as ActivationByContractAddress,
  Xg as default,
  Zg as useActivationFunctions,
  nf as useButton
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWYtd2lkZ2V0LmpzIiwic291cmNlcyI6WyIuLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1ydW50aW1lLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL192ZXJzaW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3Byb3BlcnRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXJyb3JzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2RhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvbWF0aHMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTU4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2Jhc2U2NC1icm93c2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2V2ZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy91dGY4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2dldHVybC1icm93c2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2ZldGNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3JscC1kZWNvZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcmxwLWVuY29kZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8va2VjY2FrLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29uc3RhbnRzL2FkZHJlc3Nlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvaGFzaGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9zaWduYXR1cmUuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25pbmcta2V5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FkZHJlc3MvYWRkcmVzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2NvbnRyYWN0LWFkZHJlc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9jaGVja3MuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL3R5cGVkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYWRkcmVzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2Fub255bW91cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYm9vbGVhbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2J5dGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvZml4ZWQtYnl0ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udWxsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvbnVtYmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvc3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvdHVwbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9pZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AYWRyYWZmeS9lbnMtbm9ybWFsaXplL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvbmFtZWhhc2guanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYWNjZXNzbGlzdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9hZGRyZXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvdHlwZWQtZGF0YS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvZnJhZ21lbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9hYmktY29kZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ludGVyZmFjZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3Qvd3JhcHBlcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3QvY29udHJhY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Vucy1yZXNvbHZlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvZm9ybWF0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wbHVnaW5zLW5ldHdvcmsuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL25ldHdvcmsuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3N1YnNjcmliZXItcG9sbGluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXNpZ25lci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc3Vic2NyaWJlci1maWx0ZXJpZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItanNvbnJwYy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItYnJvd3Nlci5qcyIsIi4uL3NyYy9jb250cmFjdHMvZXRoZXJzUHJvdmlkZXIudHMiLCIuLi9zcmMvY29tcG9uZW50cy9QYW5lbC50c3giLCIuLi9zcmMvY29udHJhY3RzL0VuY29kZXJDb250cmFjdC9hYmkudHMiLCIuLi9zcmMvY29udHJhY3RzL0VuY29kZXJDb250cmFjdC9jb250cmFjdC50cyIsIi4uL3NyYy9jb250cmFjdHMvZ3VpbGRBRkNvbnRyYWN0L2FiaS50cyIsIi4uL3NyYy9jb250cmFjdHMvZ3VpbGRBRkNvbnRyYWN0L2NvbnRyYWN0LnRzIiwiLi4vc3JjL2NvbnRyYWN0cy93YXR0c0NvbnRyYWN0L2FiaS50cyIsIi4uL3NyYy9jb250cmFjdHMvd2F0dHNDb250cmFjdC9jb250cmFjdC50cyIsIi4uL3NyYy91dGlscy91c2VBc3luY01lbW8udHMiLCIuLi9zcmMvY29tcG9uZW50cy9CdXR0b24udHN4IiwiLi4vc3JjL2NvbXBvbmVudHMvRHJvcGRvd24udHN4IiwiLi4vc3JjL0FwcC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXG4gKiByZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7cmVxdWlyZShcIm9iamVjdC1hc3NpZ25cIik7dmFyIGY9cmVxdWlyZShcInJlYWN0XCIpLGc9NjAxMDM7ZXhwb3J0cy5GcmFnbWVudD02MDEwNztpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yKXt2YXIgaD1TeW1ib2wuZm9yO2c9aChcInJlYWN0LmVsZW1lbnRcIik7ZXhwb3J0cy5GcmFnbWVudD1oKFwicmVhY3QuZnJhZ21lbnRcIil9dmFyIG09Zi5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lcixuPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkscD17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuZnVuY3Rpb24gcShjLGEsayl7dmFyIGIsZD17fSxlPW51bGwsbD1udWxsO3ZvaWQgMCE9PWsmJihlPVwiXCIrayk7dm9pZCAwIT09YS5rZXkmJihlPVwiXCIrYS5rZXkpO3ZvaWQgMCE9PWEucmVmJiYobD1hLnJlZik7Zm9yKGIgaW4gYSluLmNhbGwoYSxiKSYmIXAuaGFzT3duUHJvcGVydHkoYikmJihkW2JdPWFbYl0pO2lmKGMmJmMuZGVmYXVsdFByb3BzKWZvcihiIGluIGE9Yy5kZWZhdWx0UHJvcHMsYSl2b2lkIDA9PT1kW2JdJiYoZFtiXT1hW2JdKTtyZXR1cm57JCR0eXBlb2Y6Zyx0eXBlOmMsa2V5OmUscmVmOmwscHJvcHM6ZCxfb3duZXI6bS5jdXJyZW50fX1leHBvcnRzLmpzeD1xO2V4cG9ydHMuanN4cz1xO1xuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjJcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG4vLyBldmVuIHdpdGggdGhlIHByb2QgdHJhbnNmb3JtLiBUaGlzIG1lYW5zIHRoYXQganN4REVWIGlzIHB1cmVseVxuLy8gb3B0LWluIGJlaGF2aW9yIGZvciBiZXR0ZXIgbWVzc2FnZXMgYnV0IHRoYXQgd2Ugd29uJ3Qgc3RvcFxuLy8gZ2l2aW5nIHlvdSB3YXJuaW5ncyBpZiB5b3UgdXNlIHByb2R1Y3Rpb24gYXBpcy5cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25TdGF0aWModHlwZSwgcHJvcHMsIGtleSkge1xuICB7XG4gICAgcmV0dXJuIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWModHlwZSwgcHJvcHMsIGtleSkge1xuICB7XG4gICAgcmV0dXJuIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGZhbHNlKTtcbiAgfVxufVxuXG52YXIganN4ID0gIGpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyA7IC8vIHdlIG1heSB3YW50IHRvIHNwZWNpYWwgY2FzZSBqc3hzIGludGVybmFsbHkgdG8gdGFrZSBhZHZhbnRhZ2Ugb2Ygc3RhdGljIGNoaWxkcmVuLlxuLy8gZm9yIG5vdyB3ZSBjYW4gc2hpcCBpZGVudGljYWwgcHJvZCBmdW5jdGlvbnNcblxudmFyIGpzeHMgPSAganN4V2l0aFZhbGlkYXRpb25TdGF0aWMgO1xuXG5leHBvcnRzLmpzeCA9IGpzeDtcbmV4cG9ydHMuanN4cyA9IGpzeHM7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qIERvIE5PVCBtb2RpZnkgdGhpcyBmaWxlOyBzZWUgL3NyYy50cy9fYWRtaW4vdXBkYXRlLXZlcnNpb24udHMgKi9cbi8qKlxuICogIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgRXRoZXJzLlxuICovXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiNi45LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCIsIi8qKlxuICogIFByb3BlcnR5IGhlbHBlciBmdW5jdGlvbnMuXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6UHJvcGVydGllcyAgW2Fib3V0LXByb3BlcnRpZXNdXG4gKi9cbmZ1bmN0aW9uIGNoZWNrVHlwZSh2YWx1ZSwgdHlwZSwgbmFtZSkge1xuICAgIGNvbnN0IHR5cGVzID0gdHlwZS5zcGxpdChcInxcIikubWFwKHQgPT4gdC50cmltKCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYW55XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaW52YWxpZCB2YWx1ZSBmb3IgdHlwZSAke3R5cGV9YCk7XG4gICAgZXJyb3IuY29kZSA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiO1xuICAgIGVycm9yLmFyZ3VtZW50ID0gYHZhbHVlLiR7bmFtZX1gO1xuICAgIGVycm9yLnZhbHVlID0gdmFsdWU7XG4gICAgdGhyb3cgZXJyb3I7XG59XG4vKipcbiAqICBSZXNvbHZlcyB0byBhIG5ldyBvYmplY3QgdGhhdCBpcyBhIGNvcHkgb2YgJSV2YWx1ZSUlLCBidXQgd2l0aCBhbGxcbiAqICB2YWx1ZXMgcmVzb2x2ZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlUHJvcGVydGllcyh2YWx1ZSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGtleXMubWFwKChrKSA9PiBQcm9taXNlLnJlc29sdmUodmFsdWVba10pKSk7XG4gICAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKChhY2N1bSwgdiwgaW5kZXgpID0+IHtcbiAgICAgICAgYWNjdW1ba2V5c1tpbmRleF1dID0gdjtcbiAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIHt9KTtcbn1cbi8qKlxuICogIEFzc2lnbnMgdGhlICUldmFsdWVzJSUgdG8gJSV0YXJnZXQlJSBhcyByZWFkLW9ubHkgdmFsdWVzLlxuICpcbiAqICBJdCAlJXR5cGVzJSUgaXMgc3BlY2lmaWVkLCB0aGUgdmFsdWVzIGFyZSBjaGVja2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHZhbHVlcywgdHlwZXMpIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gdmFsdWVzKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHZhbHVlc1trZXldO1xuICAgICAgICBjb25zdCB0eXBlID0gKHR5cGVzID8gdHlwZXNba2V5XSA6IG51bGwpO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgY2hlY2tUeXBlKHZhbHVlLCB0eXBlLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZSwgd3JpdGFibGU6IGZhbHNlIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnRpZXMuanMubWFwIiwiLyoqXG4gKiAgQWxsIGVycm9ycyBpbiBldGhlcnMgaW5jbHVkZSBwcm9wZXJ0aWVzIHRvIGVuc3VyZSB0aGV5IGFyZSBib3RoXG4gKiAgaHVtYW4tcmVhZGFibGUgKGkuZS4gYGAubWVzc2FnZWBgKSBhbmQgbWFjaGluZS1yZWFkYWJsZSAoaS5lLiBgYC5jb2RlYGApLlxuICpcbiAqICBUaGUgW1tpc0Vycm9yXV0gZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gY2hlY2sgdGhlIGVycm9yIGBgY29kZWBgIGFuZFxuICogIHByb3ZpZGUgYSB0eXBlIGd1YXJkIGZvciB0aGUgcHJvcGVydGllcyBwcmVzZW50IG9uIHRoYXQgZXJyb3IgaW50ZXJmYWNlLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS91dGlscy9lcnJvcnM6RXJyb3JzICBbYWJvdXQtZXJyb3JzXVxuICovXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL192ZXJzaW9uLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiWyBcIiArICh2YWx1ZS5tYXAoc3RyaW5naWZ5KSkuam9pbihcIiwgXCIpICsgXCIgXVwiO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGNvbnN0IEhFWCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gSEVYW3ZhbHVlW2ldID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IEhFWFt2YWx1ZVtpXSAmIDB4Zl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiAodmFsdWUudG9KU09OKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkodmFsdWUudG9KU09OKCkpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgICAgICBrZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBcInsgXCIgKyBrZXlzLm1hcCgoaykgPT4gYCR7c3RyaW5naWZ5KGspfTogJHtzdHJpbmdpZnkodmFsdWVba10pfWApLmpvaW4oXCIsIFwiKSArIFwiIH1cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYFsgQ09VTEQgTk9UIFNFUklBTElaRSBdYDtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgJSVlcnJvciUlIG1hdGNoZXMgYW4gZXJyb3IgdGhyb3duIGJ5IGV0aGVyc1xuICogIHRoYXQgbWF0Y2hlcyB0aGUgZXJyb3IgJSVjb2RlJSUuXG4gKlxuICogIEluIFR5cGVTY3JpcHQgZW52aXJvbm1lbnRzLCB0aGlzIGNhbiBiZSB1c2VkIHRvIGNoZWNrIHRoYXQgJSVlcnJvciUlXG4gKiAgbWF0Y2hlcyBhbiBFdGhlcnNFcnJvciB0eXBlLCB3aGljaCBtZWFucyB0aGUgZXhwZWN0ZWQgcHJvcGVydGllcyB3aWxsXG4gKiAgYmUgc2V0LlxuICpcbiAqICBAU2VlIFtFcnJvckNvZGVzXShhcGk6RXJyb3JDb2RlKVxuICogIEBleGFtcGxlXG4gKiAgICB0cnkge1xuICogICAgICAvLyBjb2RlLi4uLlxuICogICAgfSBjYXRjaCAoZSkge1xuICogICAgICBpZiAoaXNFcnJvcihlLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gKiAgICAgICAgICAvLyBUaGUgVHlwZSBHdWFyZCBoYXMgdmFsaWRhdGVkIHRoaXMgb2JqZWN0XG4gKiAgICAgICAgICBjb25zb2xlLmxvZyhlLmRhdGEpO1xuICogICAgICB9XG4gKiAgICB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Vycm9yKGVycm9yLCBjb2RlKSB7XG4gICAgcmV0dXJuIChlcnJvciAmJiBlcnJvci5jb2RlID09PSBjb2RlKTtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJWVycm9yJSUgaXMgYSBbW0NhbGxFeGNlcHRpb25FcnJvcl0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NhbGxFeGNlcHRpb24oZXJyb3IpIHtcbiAgICByZXR1cm4gaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKTtcbn1cbi8qKlxuICogIFJldHVybnMgYSBuZXcgRXJyb3IgY29uZmlndXJlZCB0byB0aGUgZm9ybWF0IGV0aGVycyBlbWl0cyBlcnJvcnMsIHdpdGhcbiAqICB0aGUgJSVtZXNzYWdlJSUsIFtbYXBpOkVycm9yQ29kZV1dICUlY29kZSUlIGFuZCBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqICBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgRXRoZXJzRXJyb3IuXG4gKlxuICogIEVhY2ggZXJyb3IgaW4gZXRoZXJzIGluY2x1ZGVzIHRoZSB2ZXJzaW9uIG9mIGV0aGVycywgYVxuICogIG1hY2hpbmUtcmVhZGFibGUgW1tFcnJvckNvZGVdXSwgYW5kIGRlcGVuZGluZyBvbiAlJWNvZGUlJSwgYWRkaXRpb25hbFxuICogIHJlcXVpcmVkIHByb3BlcnRpZXMuIFRoZSBlcnJvciBtZXNzYWdlIHdpbGwgYWxzbyBpbmNsdWRlIHRoZSAlJW1lc3NhZ2UlJSxcbiAqICBldGhlcnMgdmVyc2lvbiwgJSVjb2RlJSUgYW5kIGFsbCBhZGRpdGlvbmFsIHByb3BlcnRpZXMsIHNlcmlhbGl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgaW5mbykge1xuICAgIGxldCBzaG9ydE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IFtdO1xuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgaWYgKFwibWVzc2FnZVwiIGluIGluZm8gfHwgXCJjb2RlXCIgaW4gaW5mbyB8fCBcIm5hbWVcIiBpbiBpbmZvKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YWx1ZSB3aWxsIG92ZXJ3cml0ZSBwb3B1bGF0ZWQgdmFsdWVzOiAke3N0cmluZ2lmeShpbmZvKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcInNob3J0TWVzc2FnZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IChpbmZvW2tleV0pO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTU1NXCIsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLnB1c2goa2V5ICsgXCI9W2NvdWxkIG5vdCBzZXJpYWxpemUgb2JqZWN0XVwiKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWlscy5wdXNoKGBjb2RlPSR7Y29kZX1gKTtcbiAgICAgICAgZGV0YWlscy5wdXNoKGB2ZXJzaW9uPSR7dmVyc2lvbn1gKTtcbiAgICAgICAgaWYgKGRldGFpbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChcIiArIGRldGFpbHMuam9pbihcIiwgXCIpICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGVycm9yO1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIFwiSU5WQUxJRF9BUkdVTUVOVFwiOlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgVHlwZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJOVU1FUklDX0ZBVUxUXCI6XG4gICAgICAgIGNhc2UgXCJCVUZGRVJfT1ZFUlJVTlwiOlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgUmFuZ2VFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIGRlZmluZVByb3BlcnRpZXMoZXJyb3IsIHsgY29kZSB9KTtcbiAgICBpZiAoaW5mbykge1xuICAgICAgICBPYmplY3QuYXNzaWduKGVycm9yLCBpbmZvKTtcbiAgICB9XG4gICAgaWYgKGVycm9yLnNob3J0TWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoZXJyb3IsIHsgc2hvcnRNZXNzYWdlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59XG4vKipcbiAqICBUaHJvd3MgYW4gRXRoZXJzRXJyb3Igd2l0aCAlJW1lc3NhZ2UlJSwgJSVjb2RlJSUgYW5kIGFkZGl0aW9uYWwgZXJyb3JcbiAqICAlJWluZm8lJSB3aGVuICUlY2hlY2slJSBpcyBmYWxzaXNoLi5cbiAqXG4gKiAgQHNlZSBbW2FwaTptYWtlRXJyb3JdXVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGNoZWNrLCBtZXNzYWdlLCBjb2RlLCBpbmZvKSB7XG4gICAgaWYgKCFjaGVjaykge1xuICAgICAgICB0aHJvdyBtYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgaW5mbyk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBzaW1wbGUgaGVscGVyIHRvIHNpbXBseSBlbnN1cmluZyBwcm92aWRlZCBhcmd1bWVudHMgbWF0Y2ggZXhwZWN0ZWRcbiAqICBjb25zdHJhaW50cywgdGhyb3dpbmcgaWYgbm90LlxuICpcbiAqICBJbiBUeXBlU2NyaXB0IGVudmlyb25tZW50cywgdGhlICUlY2hlY2slJSBoYXMgYmVlbiBhc3NlcnRlZCB0cnVlLCBzb1xuICogIGFueSBmdXJ0aGVyIGNvZGUgZG9lcyBub3QgbmVlZCBhZGRpdGlvbmFsIGNvbXBpbGUtdGltZSBjaGVja3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBcmd1bWVudChjaGVjaywgbWVzc2FnZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBhc3NlcnQoY2hlY2ssIG1lc3NhZ2UsIFwiSU5WQUxJRF9BUkdVTUVOVFwiLCB7IGFyZ3VtZW50OiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0QXJndW1lbnRDb3VudChjb3VudCwgZXhwZWN0ZWRDb3VudCwgbWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIjogXCIgKyBtZXNzYWdlO1xuICAgIH1cbiAgICBhc3NlcnQoY291bnQgPj0gZXhwZWN0ZWRDb3VudCwgXCJtaXNzaW5nIGFyZ3VlbW50XCIgKyBtZXNzYWdlLCBcIk1JU1NJTkdfQVJHVU1FTlRcIiwge1xuICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICB9KTtcbiAgICBhc3NlcnQoY291bnQgPD0gZXhwZWN0ZWRDb3VudCwgXCJ0b28gbWFueSBhcmd1ZW1udHNcIiArIG1lc3NhZ2UsIFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiLCB7XG4gICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgIH0pO1xufVxuY29uc3QgX25vcm1hbGl6ZUZvcm1zID0gW1wiTkZEXCIsIFwiTkZDXCIsIFwiTkZLRFwiLCBcIk5GS0NcIl0ucmVkdWNlKChhY2N1bSwgZm9ybSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEdlbmVyYWwgdGVzdCBmb3Igbm9ybWFsaXplXG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoXCJ0ZXN0XCIubm9ybWFsaXplKGZvcm0pICE9PSBcInRlc3RcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkXCIpO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKGZvcm0gPT09IFwiTkZEXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGU5KS5ub3JtYWxpemUoXCJORkRcIik7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg2NSwgMHgwMzAxKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKGNoZWNrICE9PSBleHBlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJyb2tlblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIH1cbiAgICAgICAgYWNjdW0ucHVzaChmb3JtKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gYWNjdW07XG59LCBbXSk7XG4vKipcbiAqICBUaHJvd3MgaWYgdGhlIG5vcm1hbGl6YXRpb24gJSVmb3JtJSUgaXMgbm90IHN1cHBvcnRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5vcm1hbGl6ZShmb3JtKSB7XG4gICAgYXNzZXJ0KF9ub3JtYWxpemVGb3Jtcy5pbmRleE9mKGZvcm0pID49IDAsIFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBpbmZvOiB7IGZvcm0gfVxuICAgIH0pO1xufVxuLyoqXG4gKiAgTWFueSBjbGFzc2VzIHVzZSBmaWxlLXNjb3BlZCB2YWx1ZXMgdG8gZ3VhcmQgdGhlIGNvbnN0cnVjdG9yLFxuICogIG1ha2luZyBpdCBlZmZlY3RpdmVseSBwcml2YXRlLiBUaGlzIGZhY2lsaXRhdGVzIHRoYXQgcGF0dGVyblxuICogIGJ5IGVuc3VyaW5nIHRoZSAlJWdpdmVuR2F1cmQlJSBtYXRjaGVzIHRoZSBmaWxlLXNjb3BlZCAlJWd1YXJkJSUsXG4gKiAgdGhyb3dpbmcgaWYgbm90LCBpbmRpY2F0aW5nIHRoZSAlJWNsYXNzTmFtZSUlIGlmIHByb3ZpZGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UHJpdmF0ZShnaXZlbkd1YXJkLCBndWFyZCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGNsYXNzTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IFwiXCI7XG4gICAgfVxuICAgIGlmIChnaXZlbkd1YXJkICE9PSBndWFyZCkge1xuICAgICAgICBsZXQgbWV0aG9kID0gY2xhc3NOYW1lLCBvcGVyYXRpb24gPSBcIm5ld1wiO1xuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gXCIuXCI7XG4gICAgICAgICAgICBvcGVyYXRpb24gKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgcHJpdmF0ZSBjb25zdHJ1Y3RvcjsgdXNlICR7bWV0aG9kfWZyb20qIG1ldGhvZHNgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCIsIi8qKlxuICogIFNvbWUgZGF0YSBoZWxwZXJzLlxuICpcbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpEYXRhIEhlbHBlcnMgIFthYm91dC1kYXRhXVxuICovXG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5mdW5jdGlvbiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIGNvcHkpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLm1hdGNoKC9eMHgoWzAtOWEtZl1bMC05YS1mXSkqJC9pKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgodmFsdWUubGVuZ3RoIC0gMikgLyAyKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgKyAyKSwgMTYpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBCeXRlc0xpa2UgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIEdldCBhIHR5cGVkIFVpbnQ4QXJyYXkgZm9yICUldmFsdWUlJS4gSWYgYWxyZWFkeSBhIFVpbnQ4QXJyYXlcbiAqICB0aGUgb3JpZ2luYWwgJSV2YWx1ZSUlIGlzIHJldHVybmVkOyBpZiBhIGNvcHkgaXMgcmVxdWlyZWQgdXNlXG4gKiAgW1tnZXRCeXRlc0NvcHldXS5cbiAqXG4gKiAgQHNlZTogZ2V0Qnl0ZXNDb3B5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCeXRlcyh2YWx1ZSwgbmFtZSkge1xuICAgIHJldHVybiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIGZhbHNlKTtcbn1cbi8qKlxuICogIEdldCBhIHR5cGVkIFVpbnQ4QXJyYXkgZm9yICUldmFsdWUlJSwgY3JlYXRpbmcgYSBjb3B5IGlmIG5lY2Vzc2FyeVxuICogIHRvIHByZXZlbnQgYW55IG1vZGlmaWNhdGlvbnMgb2YgdGhlIHJldHVybmVkIHZhbHVlIGZyb20gYmVpbmdcbiAqICByZWZsZWN0ZWQgZWxzZXdoZXJlLlxuICpcbiAqICBAc2VlOiBnZXRCeXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qnl0ZXNDb3B5KHZhbHVlLCBuYW1lKSB7XG4gICAgcmV0dXJuIF9nZXRCeXRlcyh2YWx1ZSwgbmFtZSwgdHJ1ZSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgW1tIZXhTdHJpbmddXS5cbiAqXG4gKiAgSWYgJSVsZW5ndGglJSBpcyBgYHRydWVgYCBvciBhIC8vbnVtYmVyLy8sIGl0IGFsc28gY2hlY2tzIHRoYXRcbiAqICAlJXZhbHVlJSUgaXMgYSB2YWxpZCBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWxlbmd0aCUlIChpZiBhIC8vbnVtYmVyLy8pXG4gKiAgYnl0ZXMgb2YgZGF0YSAoZS5nLiBgYDB4MTIzNGBgIGlzIDIgYnl0ZXMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKGxlbmd0aCkgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPT09IHRydWUgJiYgKHZhbHVlLmxlbmd0aCAlIDIpICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYXJiaXRyYXJ5XG4gKiAgZGF0YSAoaS5lLiBhIHZhbGlkIFtbRGF0YUhleFN0cmluZ11dIG9yIGEgVWludDhBcnJheSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzTGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaXNIZXhTdHJpbmcodmFsdWUsIHRydWUpIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKTtcbn1cbmNvbnN0IEhleENoYXJhY3RlcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qKlxuICogIFJldHVybnMgYSBbW0RhdGFIZXhTdHJpbmddXSByZXByZXNlbnRhdGlvbiBvZiAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleGxpZnkoZGF0YSkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHYgPSBieXRlc1tpXTtcbiAgICAgICAgcmVzdWx0ICs9IEhleENoYXJhY3RlcnNbKHYgJiAweGYwKSA+PiA0XSArIEhleENoYXJhY3RlcnNbdiAmIDB4MGZdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIGJ5IGNvbmNhdGVuYXRpbmcgYWxsIHZhbHVlc1xuICogIHdpdGhpbiAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdChkYXRhcykge1xuICAgIHJldHVybiBcIjB4XCIgKyBkYXRhcy5tYXAoKGQpID0+IGhleGxpZnkoZCkuc3Vic3RyaW5nKDIpKS5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLCBpbiBieXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGFMZW5ndGgoZGF0YSkge1xuICAgIGlmIChpc0hleFN0cmluZyhkYXRhLCB0cnVlKSkge1xuICAgICAgICByZXR1cm4gKGRhdGEubGVuZ3RoIC0gMikgLyAyO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Qnl0ZXMoZGF0YSkubGVuZ3RoO1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIGJ5IHNsaWNpbmcgJSVkYXRhJSUgZnJvbSB0aGUgJSVzdGFydCUlXG4gKiAgb2Zmc2V0IHRvIHRoZSAlJWVuZCUlIG9mZnNldC5cbiAqXG4gKiAgQnkgZGVmYXVsdCAlJXN0YXJ0JSUgaXMgMCBhbmQgJSVlbmQlJSBpcyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0YVNsaWNlKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgIGlmIChlbmQgIT0gbnVsbCAmJiBlbmQgPiBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNhbm5vdCBzbGljZSBiZXlvbmQgZGF0YSBib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6IGJ5dGVzLCBsZW5ndGg6IGJ5dGVzLmxlbmd0aCwgb2Zmc2V0OiBlbmRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzLnNsaWNlKChzdGFydCA9PSBudWxsKSA/IDAgOiBzdGFydCwgKGVuZCA9PSBudWxsKSA/IGJ5dGVzLmxlbmd0aCA6IGVuZCkpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSByZXN1bHQgYnkgc3RyaXBwaW5nIGFsbCAqKmxlYWRpbmcqKlxuICoqIHplcm8gYnl0ZXMgZnJvbSAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwWmVyb3NMZWZ0KGRhdGEpIHtcbiAgICBsZXQgYnl0ZXMgPSBoZXhsaWZ5KGRhdGEpLnN1YnN0cmluZygyKTtcbiAgICB3aGlsZSAoYnl0ZXMuc3RhcnRzV2l0aChcIjAwXCIpKSB7XG4gICAgICAgIGJ5dGVzID0gYnl0ZXMuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgYnl0ZXM7XG59XG5mdW5jdGlvbiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgbGVmdCkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgYXNzZXJ0KGxlbmd0aCA+PSBieXRlcy5sZW5ndGgsIFwicGFkZGluZyBleGNlZWRzIGRhdGEgbGVuZ3RoXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICBidWZmZXI6IG5ldyBVaW50OEFycmF5KGJ5dGVzKSxcbiAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgIG9mZnNldDogbGVuZ3RoICsgMVxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgcmVzdWx0LmZpbGwoMCk7XG4gICAgaWYgKGxlZnQpIHtcbiAgICAgICAgcmVzdWx0LnNldChieXRlcywgbGVuZ3RoIC0gYnl0ZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5zZXQoYnl0ZXMsIDApO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWRhdGElJSBwYWRkZWQgb24gdGhlICoqbGVmdCoqXG4gKiAgdG8gJSVsZW5ndGglJSBieXRlcy5cbiAqXG4gKiAgSWYgJSVkYXRhJSUgYWxyZWFkeSBleGNlZWRzICUlbGVuZ3RoJSUsIGEgW1tCdWZmZXJPdmVycnVuRXJyb3JdXSBpc1xuICogIHRocm93bi5cbiAqXG4gKiAgVGhpcyBwYWRzIGRhdGEgdGhlIHNhbWUgYXMgKip2YWx1ZXMqKiBhcmUgaW4gU29saWRpdHlcbiAqICAoZS5nLiBgYHVpbnQxMjhgYCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvUGFkVmFsdWUoZGF0YSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCB0cnVlKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVkYXRhJSUgcGFkZGVkIG9uIHRoZSAqKnJpZ2h0KipcbiAqICB0byAlJWxlbmd0aCUlIGJ5dGVzLlxuICpcbiAqICBJZiAlJWRhdGElJSBhbHJlYWR5IGV4Y2VlZHMgJSVsZW5ndGglJSwgYSBbW0J1ZmZlck92ZXJydW5FcnJvcl1dIGlzXG4gKiAgdGhyb3duLlxuICpcbiAqICBUaGlzIHBhZHMgZGF0YSB0aGUgc2FtZSBhcyAqKmJ5dGVzKiogYXJlIGluIFNvbGlkaXR5XG4gKiAgKGUuZy4gYGBieXRlczE2YGApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gemVyb1BhZEJ5dGVzKGRhdGEsIGxlbmd0aCkge1xuICAgIHJldHVybiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgZmFsc2UpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS5qcy5tYXAiLCIvKipcbiAqICBTb21lIG1hdGhlbWF0aWMgb3BlcmF0aW9ucy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvdXRpbHM6TWF0aCBIZWxwZXJzICBbYWJvdXQtbWF0aHNdXG4gKi9cbmltcG9ydCB7IGhleGxpZnksIGlzQnl0ZXNMaWtlIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG4vL2NvbnN0IEJOX01heDI1NiA9IChCTl8xIDw8IEJpZ0ludCgyNTYpKSAtIEJOXzE7XG4vLyBJRUVFIDc1NCBzdXBwb3J0IDUzLWJpdHMgb2YgbWFudGlzc2FcbmNvbnN0IG1heFZhbHVlID0gMHgxZmZmZmZmZmZmZmZmZjtcbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIGZyb20gYSB0d29zLWNvbXBsaW1lbnQgcmVwcmVzZW50YXRpb24gb2YgJSV3aWR0aCUlXG4gKiAgYml0cyB0byBpdHMgdmFsdWUuXG4gKlxuICogIElmIHRoZSBoaWdoZXN0IGJpdCBpcyBgYDFgYCwgdGhlIHJlc3VsdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikpO1xuICAgIGFzc2VydCgodmFsdWUgPj4gd2lkdGgpID09PSBCTl8wLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgfSk7XG4gICAgLy8gVG9wIGJpdCBzZXQ7IHRyZWF0IGFzIGEgbmVnYXRpdmUgdmFsdWVcbiAgICBpZiAodmFsdWUgPj4gKHdpZHRoIC0gQk5fMSkpIHtcbiAgICAgICAgY29uc3QgbWFzayA9IChCTl8xIDw8IHdpZHRoKSAtIEJOXzE7XG4gICAgICAgIHJldHVybiAtKCgofnZhbHVlKSAmIG1hc2spICsgQk5fMSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIHRvIGEgdHdvcy1jb21wbGltZW50IHJlcHJlc2VudGF0aW9uIG9mXG4gKiAgJSV3aWR0aCUlIGJpdHMuXG4gKlxuICogIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgcG9zaXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBsZXQgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikpO1xuICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgIGlmICh2YWx1ZSA8IEJOXzApIHtcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgICAgIGFzc2VydCh2YWx1ZSA8PSBsaW1pdCwgXCJ0b28gbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9Ud29zXCIsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1hc2sgPSAoQk5fMSA8PCB3aWR0aCkgLSBCTl8xO1xuICAgICAgICByZXR1cm4gKCh+dmFsdWUpICYgbWFzaykgKyBCTl8xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlIDwgbGltaXQsIFwidG9vIGhpZ2hcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b1R3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiAgTWFzayAlJXZhbHVlJSUgd2l0aCBhIGJpdG1hc2sgb2YgJSViaXRzJSUgb25lcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hc2soX3ZhbHVlLCBfYml0cykge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3QgYml0cyA9IEJpZ0ludChnZXROdW1iZXIoX2JpdHMsIFwiYml0c1wiKSk7XG4gICAgcmV0dXJuIHZhbHVlICYgKChCTl8xIDw8IGJpdHMpIC0gQk5fMSk7XG59XG4vKipcbiAqICBHZXRzIGEgQmlnSW50IGZyb20gJSV2YWx1ZSUlLiBJZiBpdCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvclxuICogIGEgQmlnSW50LCB0aGVuIGFuIEFyZ3VtZW50RXJyb3Igd2lsbCBiZSB0aHJvd24gZm9yICUlbmFtZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmlnSW50KHZhbHVlLCBuYW1lKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6IHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwidW5kZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIgJiYgdmFsdWVbMV0gIT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtQmlnSW50KHZhbHVlLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgQmlnTnVtYmVyaXNoIHN0cmluZzogJHtlLm1lc3NhZ2V9YCwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBCaWdOdW1iZXJpc2ggdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIFJldHVybnMgJSV2YWx1ZSUlIGFzIGEgYmlnaW50LCB2YWxpZGF0aW5nIGl0IGlzIHZhbGlkIGFzIGEgYmlnaW50XG4gKiAgdmFsdWUgYW5kIHRoYXQgaXQgaXMgcG9zaXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaW50KHZhbHVlLCBuYW1lKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZ2V0QmlnSW50KHZhbHVlLCBuYW1lKTtcbiAgICBhc3NlcnQocmVzdWx0ID49IEJOXzAsIFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIGZhdWx0OiBcIm92ZXJmbG93XCIsIG9wZXJhdGlvbjogXCJnZXRVaW50XCIsIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IE5pYmJsZXMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qXG4gKiBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWdJbnQuIElmICUldmFsdWUlJSBpcyBhIFVpbnQ4QXJyYXksIGl0XG4gKiBpcyB0cmVhdGVkIGFzIEJpZyBFbmRpYW4gZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmlnSW50KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweDBcIjtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gTmliYmxlc1t2ID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiAmIDB4MGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnQocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSk7XG59XG4vKipcbiAqICBHZXRzIGEgLy9udW1iZXIvLyBmcm9tICUldmFsdWUlJS4gSWYgaXQgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3JcbiAqICBhIC8vbnVtYmVyLy8sIHRoZW4gYW4gQXJndW1lbnRFcnJvciB3aWxsIGJlIHRocm93biBmb3IgJSVuYW1lJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1iZXIodmFsdWUsIG5hbWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcInVuZGVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gLW1heFZhbHVlICYmIHZhbHVlIDw9IG1heFZhbHVlLCBcIm92ZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE51bWJlcihCaWdJbnQodmFsdWUpLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIG51bWVyaWMgc3RyaW5nOiAke2UubWVzc2FnZX1gLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIG51bWVyaWMgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIG51bWJlci4gSWYgJSV2YWx1ZSUlIGlzIGEgVWludDhBcnJheSwgaXRcbiAqICBpcyB0cmVhdGVkIGFzIEJpZyBFbmRpYW4gZGF0YS4gVGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3Qgc2FmZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdldE51bWJlcih0b0JpZ0ludCh2YWx1ZSkpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnIEVuZGlhbiBoZXhzdHJpbmcsIG9wdGlvbmFsbHkgcGFkZGVkIHRvXG4gKiAgJSV3aWR0aCUlIGJ5dGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CZUhleChfdmFsdWUsIF93aWR0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoX3dpZHRoID09IG51bGwpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSB2YWx1ZSBpcyBvZiBldmVuIGxlbmd0aFxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB3aWR0aCA9IGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIik7XG4gICAgICAgIGFzc2VydCh3aWR0aCAqIDIgPj0gcmVzdWx0Lmxlbmd0aCwgYHZhbHVlIGV4Y2VlZHMgd2lkdGggKCR7d2lkdGh9IGJ5dGVzKWAsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9CZUhleFwiLFxuICAgICAgICAgICAgZmF1bHQ6IFwib3ZlcmZsb3dcIixcbiAgICAgICAgICAgIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFBhZCB0aGUgdmFsdWUgdG8gdGhlIHJlcXVpcmVkIHdpZHRoXG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgKHdpZHRoICogMikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWcgRW5kaWFuIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JlQXJyYXkoX3ZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBpZiAodmFsdWUgPT09IEJOXzApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtdKTtcbiAgICB9XG4gICAgbGV0IGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogMjtcbiAgICAgICAgcmVzdWx0W2ldID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIDIpLCAxNik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tIZXhTdHJpbmddXSBmb3IgJSV2YWx1ZSUlIHNhZmUgdG8gdXNlIGFzIGEgLy9RdWFudGl0eS8vLlxuICpcbiAqICBBIC8vUXVhbnRpdHkvLyBkb2VzIG5vdCBoYXZlIGFuZCBsZWFkaW5nIDAgdmFsdWVzIHVubGVzcyB0aGUgdmFsdWUgaXNcbiAqICB0aGUgbGl0ZXJhbCB2YWx1ZSBgMHgwYC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgZm9yIEpTU09OLVJQQ1xuICogIG51bWVyaWMgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9RdWFudGl0eSh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSBoZXhsaWZ5KGlzQnl0ZXNMaWtlKHZhbHVlKSA/IHZhbHVlIDogdG9CZUFycmF5KHZhbHVlKSkuc3Vic3RyaW5nKDIpO1xuICAgIHdoaWxlIChyZXN1bHQuc3RhcnRzV2l0aChcIjBcIikpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCA9PT0gXCJcIikge1xuICAgICAgICByZXN1bHQgPSBcIjBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGhzLmpzLm1hcCIsIi8qKlxuICogIFRoZSBbQmFzZTU4IEVuY29kaW5nXShsaW5rLWJhc2U1OCkgc2NoZW1lIGFsbG93cyBhICoqbnVtZXJpYyoqIHZhbHVlXG4gKiAgdG8gYmUgZW5jb2RlZCBhcyBhIGNvbXBhY3Qgc3RyaW5nIHVzaW5nIGEgcmFkaXggb2YgNTggdXNpbmcgb25seVxuICogIGFscGhhLW51bWVyaWMgY2hhcmFjdGVycy4gQ29uZnVzaW5nbHkgc2ltaWxhciBjaGFyYWN0ZXJzIGFyZSBvbWl0dGVkXG4gKiAgKGkuZS4gYGBcImwwT1wiYGApLlxuICpcbiAqICBOb3RlIHRoYXQgQmFzZTU4IGVuY29kZXMgYSAqKm51bWVyaWMqKiB2YWx1ZSwgbm90IGFyYml0cmFyeSBieXRlcyxcbiAqICBzaW5jZSBhbnkgemVyby1ieXRlcyBvbiB0aGUgbGVmdCB3b3VsZCBnZXQgcmVtb3ZlZC4gVG8gbWl0aWdhdGUgdGhpc1xuICogIGlzc3VlIG1vc3Qgc2NoZW1lcyB0aGF0IHVzZSBCYXNlNTggY2hvb3NlIHNwZWNpZmljIGhpZ2gtb3JkZXIgdmFsdWVzXG4gKiAgdG8gZW5zdXJlIG5vbi16ZXJvIHByZWZpeGVzLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS91dGlsczpCYXNlNTggRW5jb2RpbmcgW2Fib3V0LWJhc2U1OF1cbiAqL1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgdG9CaWdJbnQgfSBmcm9tIFwiLi9tYXRocy5qc1wiO1xuY29uc3QgQWxwaGFiZXQgPSBcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIjtcbmxldCBMb29rdXAgPSBudWxsO1xuZnVuY3Rpb24gZ2V0QWxwaGEobGV0dGVyKSB7XG4gICAgaWYgKExvb2t1cCA9PSBudWxsKSB7XG4gICAgICAgIExvb2t1cCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFscGhhYmV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBMb29rdXBbQWxwaGFiZXRbaV1dID0gQmlnSW50KGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IExvb2t1cFtsZXR0ZXJdO1xuICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdCAhPSBudWxsLCBgaW52YWxpZCBiYXNlNTggdmFsdWVgLCBcImxldHRlclwiLCBsZXR0ZXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fNTggPSBCaWdJbnQoNTgpO1xuLyoqXG4gKiAgRW5jb2RlICUldmFsdWUlJSBhcyBhIEJhc2U1OC1lbmNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJhc2U1OChfdmFsdWUpIHtcbiAgICBsZXQgdmFsdWUgPSB0b0JpZ0ludChnZXRCeXRlcyhfdmFsdWUpKTtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0ID0gQWxwaGFiZXRbTnVtYmVyKHZhbHVlICUgQk5fNTgpXSArIHJlc3VsdDtcbiAgICAgICAgdmFsdWUgLz0gQk5fNTg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBEZWNvZGUgdGhlIEJhc2U1OC1lbmNvZGVkICUldmFsdWUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJhc2U1OCh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSBCTl8wO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICo9IEJOXzU4O1xuICAgICAgICByZXN1bHQgKz0gZ2V0QWxwaGEodmFsdWVbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTU4LmpzLm1hcCIsIi8vIHV0aWxzL2Jhc2U2NC1icm93c2VyXG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCYXNlNjQodGV4dERhdGEpIHtcbiAgICB0ZXh0RGF0YSA9IGF0b2IodGV4dERhdGEpO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0ZXh0RGF0YS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSA9IHRleHREYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBnZXRCeXRlcyhkYXRhKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVCYXNlNjQoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEpO1xuICAgIGxldCB0ZXh0RGF0YSA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRleHREYXRhICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVtpXSk7XG4gICAgfVxuICAgIHJldHVybiBidG9hKHRleHREYXRhKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U2NC1icm93c2VyLmpzLm1hcCIsIi8qKlxuICogIEV2ZW50cyBhbGxvdyBmb3IgYXBwbGljYXRpb25zIHRvIHVzZSB0aGUgb2JzZXJ2ZXIgcGF0dGVybiwgd2hpY2hcbiAqICBhbGxvd3Mgc3Vic2NyaWJpbmcgYW5kIHB1Ymxpc2hpbmcgZXZlbnRzLCBvdXRzaWRlIHRoZSBub3JtYWxcbiAqICBleGVjdXRpb24gcGF0aHMuXG4gKlxuICogIEBfc2VjdGlvbiBhcGkvdXRpbHMvZXZlbnRzOkV2ZW50cyAgW2Fib3V0LWV2ZW50c11cbiAqL1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuL3Byb3BlcnRpZXMuanNcIjtcbi8qKlxuICogIFdoZW4gYW4gW1tFdmVudEVtaXR0ZXJhYmxlXV0gdHJpZ2dlcnMgYSBbW0xpc3RlbmVyXV0sIHRoZVxuICogIGNhbGxiYWNrIGFsd2F5cyBhaGFzIG9uZSBhZGRpdGlvbmFsIGFyZ3VtZW50IHBhc3NlZCwgd2hpY2ggaXNcbiAqICBhbiAqKkV2ZW50UGF5bG9hZCoqLlxuICovXG5leHBvcnQgY2xhc3MgRXZlbnRQYXlsb2FkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGV2ZW50IGZpbHRlci5cbiAgICAgKi9cbiAgICBmaWx0ZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSAqKkV2ZW50RW1pdHRlcmFibGUqKi5cbiAgICAgKi9cbiAgICBlbWl0dGVyO1xuICAgICNsaXN0ZW5lcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqRXZlbnRQYXlsb2FkKiogZm9yICUlZW1pdHRlciUlIHdpdGhcbiAgICAgKiAgdGhlICUlbGlzdGVuZXIlJSBhbmQgZm9yICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZW1pdHRlciwgbGlzdGVuZXIsIGZpbHRlcikge1xuICAgICAgICB0aGlzLiNsaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZW1pdHRlciwgZmlsdGVyIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVW5yZWdpc3RlciB0aGUgdHJpZ2dlcmVkIGxpc3RlbmVyIGZvciBmdXR1cmUgZXZlbnRzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUxpc3RlbmVyKCkge1xuICAgICAgICBpZiAodGhpcy4jbGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuZW1pdHRlci5vZmYodGhpcy5maWx0ZXIsIHRoaXMuI2xpc3RlbmVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudHMuanMubWFwIiwiLyoqXG4gKiAgVXNpbmcgc3RyaW5ncyBpbiBFdGhlcmV1bSAob3IgYW55IHNlY3VyaXR5LWJhc2Qgc3lzdGVtKSByZXF1aXJlc1xuICogIGFkZGl0aW9uYWwgY2FyZS4gVGhlc2UgdXRpbGl0aWVzIGF0dGVtcHQgdG8gbWl0aWdhdGUgc29tZSBvZiB0aGVcbiAqICBzYWZldHkgaXNzdWVzIGFzIHdlbGwgYXMgcHJvdmlkZSB0aGUgYWJpbGl0eSB0byByZWNvdmVyIGFuZCBhbmFseXNlXG4gKiAgc3RyaW5ncy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpTdHJpbmdzIGFuZCBVVEYtOCAgW2Fib3V0LXN0cmluZ3NdXG4gKi9cbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQsIGFzc2VydE5vcm1hbGl6ZSB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZnVuY3Rpb24gZXJyb3JGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgY29kZXBvaW50IGF0IG9mZnNldCAke29mZnNldH07ICR7cmVhc29ufWAsIFwiYnl0ZXNcIiwgYnl0ZXMpO1xufVxuZnVuY3Rpb24gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gaW52YWxpZCBwcmVmaXggKGluY2x1ZGluZyBzdHJheSBjb250aW51YXRpb24pLCBza2lwIGFueSBhZGRpdGlvbmFsIGNvbnRpbnVhdGlvbiBieXRlc1xuICAgIGlmIChyZWFzb24gPT09IFwiQkFEX1BSRUZJWFwiIHx8IHJlYXNvbiA9PT0gXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCIpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBvID0gb2Zmc2V0ICsgMTsgbyA8IGJ5dGVzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXNbb10gPj4gNiAhPT0gMHgwMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICAvLyBUaGlzIGJ5dGUgcnVucyB1cyBwYXN0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc28ganVzdCBqdW1wIHRvIHRoZSBlbmRcbiAgICAvLyAoYnV0IHRoZSBmaXJzdCBieXRlIHdhcyByZWFkIGFscmVhZHkgcmVhZCBhbmQgdGhlcmVmb3JlIHNraXBwZWQpXG4gICAgaWYgKHJlYXNvbiA9PT0gXCJPVkVSUlVOXCIpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLmxlbmd0aCAtIG9mZnNldCAtIDE7XG4gICAgfVxuICAgIC8vIE5vdGhpbmcgdG8gc2tpcFxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gcmVwbGFjZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIE92ZXJsb25nIHJlcHJlc2VudGF0aW9ucyBhcmUgb3RoZXJ3aXNlIFwidmFsaWRcIiBjb2RlIHBvaW50czsganVzdCBub24tZGVpc3Rpbmd0aXNoZWRcbiAgICBpZiAocmVhc29uID09PSBcIk9WRVJMT05HXCIpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChiYWRDb2RlcG9pbnQpID09PSBcIm51bWJlclwiLCBcImludmFsaWQgYmFkIGNvZGUgcG9pbnQgZm9yIHJlcGxhY2VtZW50XCIsIFwiYmFkQ29kZXBvaW50XCIsIGJhZENvZGVwb2ludCk7XG4gICAgICAgIG91dHB1dC5wdXNoKGJhZENvZGVwb2ludCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLyBQdXQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpbnRvIHRoZSBvdXRwdXRcbiAgICBvdXRwdXQucHVzaCgweGZmZmQpO1xuICAgIC8vIE90aGVyd2lzZSwgcHJvY2VzcyBhcyBpZiBpZ25vcmluZyBlcnJvcnNcbiAgICByZXR1cm4gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KTtcbn1cbi8qKlxuICogIEEgaGFuZGZ1bCBvZiBwb3B1bGFyLCBidWlsdC1pbiBVVEYtOCBlcnJvciBoYW5kbGluZyBzdHJhdGVnaWVzLlxuICpcbiAqICAqKmBgXCJlcnJvclwiYGAqKiAtIHRocm93cyBvbiBBTlkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZSBvclxuICogIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzICh0aGlzIGlzIHRoZSBkZWZhdWx0KVxuICpcbiAqICAqKmBgXCJpZ25vcmVcImBgKiogLSBzaWxlbnRseSBkcm9wcyBhbnkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZVxuICogIGFuZCBhY2NlcHRzIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzXG4gKlxuICogICoqYGBcInJlcGxhY2VcImBgKiogLSByZXBsYWNlIGFueSBpbGxlZ2FsIFVURi04IHNlcXVlbmNlIHdpdGggdGhlXG4gKiAgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyIChpLmUuIGBgXCJcXFxcdWZmZmRcImBgKSBhbmQgYWNjZXB0c1xuICogIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzXG4gKlxuICogIEByZXR1cm5zOiBSZWNvcmQ8XCJlcnJvclwiIHwgXCJpZ25vcmVcIiB8IFwicmVwbGFjZVwiLCBVdGY4RXJyb3JGdW5jPlxuICovXG5leHBvcnQgY29uc3QgVXRmOEVycm9yRnVuY3MgPSBPYmplY3QuZnJlZXplKHtcbiAgICBlcnJvcjogZXJyb3JGdW5jLFxuICAgIGlnbm9yZTogaWdub3JlRnVuYyxcbiAgICByZXBsYWNlOiByZXBsYWNlRnVuY1xufSk7XG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzMzU2NDkzL2RlY29kZS11dGYtOC13aXRoLWphdmFzY3JpcHQjMTM2OTE0OTlcbmZ1bmN0aW9uIGdldFV0ZjhDb2RlUG9pbnRzKF9ieXRlcywgb25FcnJvcikge1xuICAgIGlmIChvbkVycm9yID09IG51bGwpIHtcbiAgICAgICAgb25FcnJvciA9IFV0ZjhFcnJvckZ1bmNzLmVycm9yO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKF9ieXRlcywgXCJieXRlc1wiKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gSW52YWxpZCBieXRlcyBhcmUgaWdub3JlZFxuICAgIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGMgPSBieXRlc1tpKytdO1xuICAgICAgICAvLyAweHh4IHh4eHhcbiAgICAgICAgaWYgKGMgPj4gNyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aWJ5dGU7IGhvdyBtYW55IGJ5dGVzIGxlZnQgZm9yIHRoaXMgY2hhcmFjdGVyP1xuICAgICAgICBsZXQgZXh0cmFMZW5ndGggPSBudWxsO1xuICAgICAgICBsZXQgb3ZlcmxvbmdNYXNrID0gbnVsbDtcbiAgICAgICAgLy8gMTEweCB4eHh4IDEweHggeHh4eFxuICAgICAgICBpZiAoKGMgJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAxO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZjtcbiAgICAgICAgICAgIC8vIDExMTAgeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAyO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZmY7XG4gICAgICAgICAgICAvLyAxMTExIDB4eHggMTB4eCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDM7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweGZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKGMgJiAweGMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIlVORVhQRUNURURfQ09OVElOVUVcIiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiQkFEX1BSRUZJWFwiLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB3ZSBoYXZlIGVub3VnaCBieXRlcyBpbiBvdXIgZGF0YT9cbiAgICAgICAgaWYgKGkgLSAxICsgZXh0cmFMZW5ndGggPj0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVkVSUlVOXCIsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGVuZ3RoIHByZWZpeCBmcm9tIHRoZSBjaGFyXG4gICAgICAgIGxldCByZXMgPSBjICYgKCgxIDw8ICg4IC0gZXh0cmFMZW5ndGggLSAxKSkgLSAxKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBleHRyYUxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dENoYXIgPSBieXRlc1tpXTtcbiAgICAgICAgICAgIC8vIEludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgICAgIGlmICgobmV4dENoYXIgJiAweGMwKSAhPSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiTUlTU0lOR19DT05USU5VRVwiLCBpLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgcmVzID0gKHJlcyA8PCA2KSB8IChuZXh0Q2hhciAmIDB4M2YpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBhYm92ZSBsb29wIGZvciBpbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heGltdW0gY29kZSBwb2ludFxuICAgICAgICBpZiAocmVzID4gMHgxMGZmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk9VVF9PRl9SQU5HRVwiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIFVURi0xNiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgIGlmIChyZXMgPj0gMHhkODAwICYmIHJlcyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIlVURjE2X1NVUlJPR0FURVwiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJsb25nIHNlcXVlbmNlcyAobW9yZSBieXRlcyB0aGFuIG5lZWRlZClcbiAgICAgICAgaWYgKHJlcyA8PSBvdmVybG9uZ01hc2spIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk9WRVJMT05HXCIsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODcyOTQwNS9ob3ctdG8tY29udmVydC11dGY4LXN0cmluZy10by1ieXRlLWFycmF5XG4vKipcbiAqICBSZXR1cm5zIHRoZSBVVEYtOCBieXRlIHJlcHJlc2VudGF0aW9uIG9mICUlc3RyJSUuXG4gKlxuICogIElmICUlZm9ybSUlIGlzIHNwZWNpZmllZCwgdGhlIHN0cmluZyBpcyBub3JtYWxpemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4Qnl0ZXMoc3RyLCBmb3JtKSB7XG4gICAgaWYgKGZvcm0gIT0gbnVsbCkge1xuICAgICAgICBhc3NlcnROb3JtYWxpemUoZm9ybSk7XG4gICAgICAgIHN0ciA9IHN0ci5ub3JtYWxpemUoZm9ybSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiA2KSB8IDB4YzApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmYzAwKSA9PSAweGQ4MDApIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnN0IGMyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpIDwgc3RyLmxlbmd0aCAmJiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSwgXCJpbnZhbGlkIHN1cnJvZ2F0ZSBwYWlyXCIsIFwic3RyXCIsIHN0cik7XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgICAgICAgY29uc3QgcGFpciA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciA+PiAxOCkgfCAweGYwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiAxMikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChwYWlyID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChwYWlyICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDEyKSB8IDB4ZTApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChjID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbn1cbjtcbi8vZXhwb3J0IFxuZnVuY3Rpb24gX3RvVXRmOFN0cmluZyhjb2RlUG9pbnRzKSB7XG4gICAgcmV0dXJuIGNvZGVQb2ludHMubWFwKChjb2RlUG9pbnQpID0+IHtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApLCAoKGNvZGVQb2ludCAmIDB4M2ZmKSArIDB4ZGMwMCkpO1xuICAgIH0pLmpvaW4oXCJcIik7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50ZWQgYnkgdGhlIFVURi04IGRhdGEgJSVieXRlcyUlLlxuICpcbiAqICBXaGVuICUlb25FcnJvciUlIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgaXQgaXMgY2FsbGVkIG9uIFVURi04XG4gKiAgZXJyb3JzIGFsbG93aW5nIHJlY292ZXJ5IHVzaW5nIHRoZSBbW1V0ZjhFcnJvckZ1bmNdXSBBUEkuXG4gKiAgKGRlZmF1bHQ6IFtlcnJvcl0oVXRmOEVycm9yRnVuY3MpKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4U3RyaW5nKGJ5dGVzLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuIF90b1V0ZjhTdHJpbmcoZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIFVURi04IGNvZGUtcG9pbnRzIGZvciAlJXN0ciUlLlxuICpcbiAqICBJZiAlJWZvcm0lJSBpcyBzcGVjaWZpZWQsIHRoZSBzdHJpbmcgaXMgbm9ybWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOENvZGVQb2ludHMoc3RyLCBmb3JtKSB7XG4gICAgcmV0dXJuIGdldFV0ZjhDb2RlUG9pbnRzKHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRmOC5qcy5tYXAiLCJpbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbi8vIEBUT0RPOiB0aW1lb3V0IGlzIGNvbXBsZXRlbHkgaWdub3JlZDsgc3RhcnQgYSBQcm9taXNlLmFueSB3aXRoIGEgcmVqZWN0P1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUdldFVybChvcHRpb25zKSB7XG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0VXJsKHJlcSwgX3NpZ25hbCkge1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHJlcS51cmwuc3BsaXQoXCI6XCIpWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGFzc2VydChwcm90b2NvbCA9PT0gXCJodHRwXCIgfHwgcHJvdG9jb2wgPT09IFwiaHR0cHNcIiwgYHVuc3VwcG9ydGVkIHByb3RvY29sICR7cHJvdG9jb2x9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgaW5mbzogeyBwcm90b2NvbCB9LFxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlcXVlc3RcIlxuICAgICAgICB9KTtcbiAgICAgICAgYXNzZXJ0KHByb3RvY29sID09PSBcImh0dHBzXCIgfHwgIXJlcS5jcmVkZW50aWFscyB8fCByZXEuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uLCBcImluc2VjdXJlIGF1dGhvcml6ZWQgY29ubmVjdGlvbnMgdW5zdXBwb3J0ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlcXVlc3RcIlxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHNpZ25hbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKF9zaWduYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgICBzaWduYWwgPSBjb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgICAgIF9zaWduYWwuYWRkTGlzdGVuZXIoKCkgPT4geyBjb250cm9sbGVyLmFib3J0KCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluaXQgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IHJlcS5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhBcnJheS5mcm9tKHJlcSkpLFxuICAgICAgICAgICAgYm9keTogcmVxLmJvZHkgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2lnbmFsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBmZXRjaChyZXEudXJsLCBpbml0KTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICByZXNwLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BCb2R5ID0gYXdhaXQgcmVzcC5hcnJheUJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBib2R5ID0gKHJlc3BCb2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KHJlc3BCb2R5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3Auc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZTogcmVzcC5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgaGVhZGVycywgYm9keVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZ2V0VXJsO1xufVxuLy8gQFRPRE86IHJlbW92ZSBpbiB2NzsgcHJvdmlkZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRcbmNvbnN0IGRlZmF1bHRHZXRVcmwgPSBjcmVhdGVHZXRVcmwoe30pO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVybChyZXEsIF9zaWduYWwpIHtcbiAgICByZXR1cm4gZGVmYXVsdEdldFVybChyZXEsIF9zaWduYWwpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0dXJsLWJyb3dzZXIuanMubWFwIiwiLyoqXG4gKiAgRmV0Y2hpbmcgY29udGVudCBmcm9tIHRoZSB3ZWIgaXMgZW52aXJvbm1lbnQtc3BlY2lmaWMsIHNvIEV0aGVyc1xuICogIHByb3ZpZGVzIGFuIGFic3RyYWN0aW9uIHRoYXQgZWFjaCBlbnZpcm9ubWVudCBjYW4gaW1wbGVtZW50IHRvIHByb3ZpZGVcbiAqICB0aGlzIHNlcnZpY2UuXG4gKlxuICogIE9uIFtOb2RlLmpzXShsaW5rLW5vZGUpLCB0aGUgYGBodHRwYGAgYW5kIGBgaHR0cHNgYCBsaWJzIGFyZSB1c2VkIHRvXG4gKiAgY3JlYXRlIGEgcmVxdWVzdCBvYmplY3QsIHJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVycyBhbmQgcHJvY2VzcyBkYXRhXG4gKiAgYW5kIHBvcHVsYXRlIHRoZSBbW0ZldGNoUmVzcG9uc2VdXS5cbiAqXG4gKiAgSW4gYSBicm93c2VyLCB0aGUgW0RPTSBmZXRjaF0obGluay1qcy1mZXRjaCkgaXMgdXNlZCwgYW5kIHRoZSByZXN1bHRpbmdcbiAqICBgYFByb21pc2VgYCBpcyB3YWl0ZWQgb24gdG8gcmV0cmlldmUgdGhlIHBheWxvYWQuXG4gKlxuICogIFRoZSBbW0ZldGNoUmVxdWVzdF1dIGlzIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyBtYW55IGNvbW1vbiBzaXR1YXRpb25zLFxuICogIHN1Y2ggYXMgcmVkaXJlY3RzLCBzZXJ2ZXIgdGhyb3R0bGluZywgYXV0aGVudGljYXRpb24sIGV0Yy5cbiAqXG4gKiAgSXQgYWxzbyBoYW5kbGVzIGNvbW1vbiBnYXRld2F5cywgc3VjaCBhcyBJUEZTIGFuZCBkYXRhIFVSSXMuXG4gKlxuICogIEBfc2VjdGlvbiBhcGkvdXRpbHMvZmV0Y2hpbmc6RmV0Y2hpbmcgV2ViIENvbnRlbnQgIFthYm91dC1mZXRjaF1cbiAqL1xuaW1wb3J0IHsgZGVjb2RlQmFzZTY0LCBlbmNvZGVCYXNlNjQgfSBmcm9tIFwiLi9iYXNlNjQuanNcIjtcbmltcG9ydCB7IGhleGxpZnkgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xuaW1wb3J0IHsgdG9VdGY4Qnl0ZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCIuL3V0ZjguanNcIjtcbmltcG9ydCB7IGNyZWF0ZUdldFVybCB9IGZyb20gXCIuL2dldHVybC5qc1wiO1xuY29uc3QgTUFYX0FUVEVNUFRTID0gMTI7XG5jb25zdCBTTE9UX0lOVEVSVkFMID0gMjUwO1xuLy8gVGhlIGdsb2JhbCBGZXRjaEdldFVybEZ1bmMgaW1wbGVtZW50YXRpb24uXG5sZXQgZGVmYXVsdEdldFVybEZ1bmMgPSBjcmVhdGVHZXRVcmwoKTtcbmNvbnN0IHJlRGF0YSA9IG5ldyBSZWdFeHAoXCJeZGF0YTooW147Ol0qKT8oO2Jhc2U2NCk/LCguKikkXCIsIFwiaVwiKTtcbmNvbnN0IHJlSXBmcyA9IG5ldyBSZWdFeHAoXCJeaXBmczovXFwvKGlwZnMvKT8oLiopJFwiLCBcImlcIik7XG4vLyBJZiBsb2NrZWQsIG5ldyBHYXRld2F5cyBjYW5ub3QgYmUgYWRkZWRcbmxldCBsb2NrZWQgPSBmYWxzZTtcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQmFzaWNzX29mX0hUVFAvRGF0YV9VUkxzXG5hc3luYyBmdW5jdGlvbiBkYXRhR2F0ZXdheUZ1bmModXJsLCBzaWduYWwpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaChyZURhdGEpO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGRhdGFcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlc3BvbnNlKDIwMCwgXCJPS1wiLCB7XG4gICAgICAgICAgICBcImNvbnRlbnQtdHlwZVwiOiAobWF0Y2hbMV0gfHwgXCJ0ZXh0L3BsYWluXCIpLFxuICAgICAgICB9LCAobWF0Y2hbMl0gPyBkZWNvZGVCYXNlNjQobWF0Y2hbM10pIDogdW5wZXJjZW50KG1hdGNoWzNdKSkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlc3BvbnNlKDU5OSwgXCJCQUQgUkVRVUVTVCAoaW52YWxpZCBkYXRhOiBVUkkpXCIsIHt9LCBudWxsLCBuZXcgRmV0Y2hSZXF1ZXN0KHVybCkpO1xuICAgIH1cbn1cbi8qKlxuICogIFJldHVybnMgYSBbW0ZldGNoR2F0ZXdheUZ1bmNdXSBmb3IgZmV0Y2hpbmcgY29udGVudCBmcm9tIGEgc3RhbmRhcmRcbiAqICBJUEZTIGdhdGV3YXkgaG9zdGVkIGF0ICUlYmFzZVVybCUlLlxuICovXG5mdW5jdGlvbiBnZXRJcGZzR2F0ZXdheUZ1bmMoYmFzZVVybCkge1xuICAgIGFzeW5jIGZ1bmN0aW9uIGdhdGV3YXlJcGZzKHVybCwgc2lnbmFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaChyZUlwZnMpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgbGlua1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXF1ZXN0KGAke2Jhc2VVcmx9JHttYXRjaFsyXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZSg1OTksIFwiQkFEIFJFUVVFU1QgKGludmFsaWQgSVBGUyBVUkkpXCIsIHt9LCBudWxsLCBuZXcgRmV0Y2hSZXF1ZXN0KHVybCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnYXRld2F5SXBmcztcbn1cbmNvbnN0IEdhdGV3YXlzID0ge1xuICAgIFwiZGF0YVwiOiBkYXRhR2F0ZXdheUZ1bmMsXG4gICAgXCJpcGZzXCI6IGdldElwZnNHYXRld2F5RnVuYyhcImh0dHBzOi9cXC9nYXRld2F5LmlwZnMuaW8vaXBmcy9cIilcbn07XG5jb25zdCBmZXRjaFNpZ25hbHMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIEZldGNoQ2FuY2VsU2lnbmFsIHtcbiAgICAjbGlzdGVuZXJzO1xuICAgICNjYW5jZWxsZWQ7XG4gICAgY29uc3RydWN0b3IocmVxdWVzdCkge1xuICAgICAgICB0aGlzLiNsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy4jY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIGZldGNoU2lnbmFscy5zZXQocmVxdWVzdCwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2NhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuI2xpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyBsaXN0ZW5lcigpOyB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2xpc3RlbmVycyA9IFtdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgYXNzZXJ0KCF0aGlzLiNjYW5jZWxsZWQsIFwic2luZ2FsIGFscmVhZHkgY2FuY2VsbGVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmZXRjaENhbmNlbFNpZ25hbC5hZGRDYW5jZWxMaXN0ZW5lclwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIGdldCBjYW5jZWxsZWQoKSB7IHJldHVybiB0aGlzLiNjYW5jZWxsZWQ7IH1cbiAgICBjaGVja1NpZ25hbCgpIHtcbiAgICAgICAgYXNzZXJ0KCF0aGlzLmNhbmNlbGxlZCwgXCJjYW5jZWxsZWRcIiwgXCJDQU5DRUxMRURcIiwge30pO1xuICAgIH1cbn1cbi8vIENoZWNrIHRoZSBzaWduYWwsIHRocm93aW5nIGlmIGl0IGlzIGNhbmNlbGxlZFxuZnVuY3Rpb24gY2hlY2tTaWduYWwoc2lnbmFsKSB7XG4gICAgaWYgKHNpZ25hbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgc2lnbmFsOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICB9XG4gICAgc2lnbmFsLmNoZWNrU2lnbmFsKCk7XG4gICAgcmV0dXJuIHNpZ25hbDtcbn1cbi8qKlxuICogIFJlcHJlc2VudHMgYSByZXF1ZXN0IGZvciBhIHJlc291cmNlIHVzaW5nIGEgVVJJLlxuICpcbiAqICBCeSBkZWZhdWx0LCB0aGUgc3VwcG9ydGVkIHNjaGVtZXMgYXJlIGBgSFRUUGBgLCBgYEhUVFBTYGAsIGBgZGF0YTpgYCxcbiAqICBhbmQgYGBJUEZTOmBgLlxuICpcbiAqICBBZGRpdGlvbmFsIHNjaGVtZXMgY2FuIGJlIGFkZGVkIGdsb2JhbGx5IHVzaW5nIFtbcmVnaXN0ZXJHYXRld2F5XV0uXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgcmVxID0gbmV3IEZldGNoUmVxdWVzdChcImh0dHBzOi8vd3d3LnJpY21vby5jb21cIilcbiAqICAgIHJlc3AgPSBhd2FpdCByZXEuc2VuZCgpXG4gKiAgICByZXNwLmJvZHkubGVuZ3RoXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaFJlcXVlc3Qge1xuICAgICNhbGxvd0luc2VjdXJlO1xuICAgICNnemlwO1xuICAgICNoZWFkZXJzO1xuICAgICNtZXRob2Q7XG4gICAgI3RpbWVvdXQ7XG4gICAgI3VybDtcbiAgICAjYm9keTtcbiAgICAjYm9keVR5cGU7XG4gICAgI2NyZWRzO1xuICAgIC8vIEhvb2tzXG4gICAgI3ByZWZsaWdodDtcbiAgICAjcHJvY2VzcztcbiAgICAjcmV0cnk7XG4gICAgI3NpZ25hbDtcbiAgICAjdGhyb3R0bGU7XG4gICAgI2dldFVybEZ1bmM7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZXRjaCBVUkwgdG8gcmVxdWVzdC5cbiAgICAgKi9cbiAgICBnZXQgdXJsKCkgeyByZXR1cm4gdGhpcy4jdXJsOyB9XG4gICAgc2V0IHVybCh1cmwpIHtcbiAgICAgICAgdGhpcy4jdXJsID0gU3RyaW5nKHVybCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZmV0Y2ggYm9keSwgaWYgYW55LCB0byBzZW5kIGFzIHRoZSByZXF1ZXN0IGJvZHkuIC8vKGRlZmF1bHQ6IG51bGwpLy9cbiAgICAgKlxuICAgICAqICBXaGVuIHNldHRpbmcgYSBib2R5LCB0aGUgaW50cmluc2ljIGBgQ29udGVudC1UeXBlYGAgaXMgYXV0b21hdGljYWxseVxuICAgICAqICBzZXQgYW5kIHdpbGwgYmUgdXNlZCBpZiAqKm5vdCBvdmVycmlkZGVuKiogYnkgc2V0dGluZyBhIGN1c3RvbVxuICAgICAqICBoZWFkZXIuXG4gICAgICpcbiAgICAgKiAgSWYgJSVib2R5JSUgaXMgbnVsbCwgdGhlIGJvZHkgaXMgY2xlYXJlZCAoYWxvbmcgd2l0aCB0aGVcbiAgICAgKiAgaW50cmluc2ljIGBgQ29udGVudC1UeXBlYGApLlxuICAgICAqXG4gICAgICogIElmICUlYm9keSUlIGlzIGEgc3RyaW5nLCB0aGUgaW50cmluc2ljIGBgQ29udGVudC1UeXBlYGAgaXMgc2V0IHRvXG4gICAgICogIGBgdGV4dC9wbGFpbmBgLlxuICAgICAqXG4gICAgICogIElmICUlYm9keSUlIGlzIGEgVWludDhBcnJheSwgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzIHNldCB0b1xuICAgICAqICBgYGFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbWBgLlxuICAgICAqXG4gICAgICogIElmICUlYm9keSUlIGlzIGFueSBvdGhlciBvYmplY3QsIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpc1xuICAgICAqICBzZXQgdG8gYGBhcHBsaWNhdGlvbi9qc29uYGAuXG4gICAgICovXG4gICAgZ2V0IGJvZHkoKSB7XG4gICAgICAgIGlmICh0aGlzLiNib2R5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLiNib2R5KTtcbiAgICB9XG4gICAgc2V0IGJvZHkoYm9keSkge1xuICAgICAgICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiNib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy4jYm9keVR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChib2R5KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy4jYm9keSA9IHRvVXRmOEJ5dGVzKGJvZHkpO1xuICAgICAgICAgICAgdGhpcy4jYm9keVR5cGUgPSBcInRleHQvcGxhaW5cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgdGhpcy4jYm9keSA9IGJvZHk7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChib2R5KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhpcy4jYm9keSA9IHRvVXRmOEJ5dGVzKEpTT04uc3RyaW5naWZ5KGJvZHkpKTtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJvZHlcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVxdWVzdCBoYXMgYSBib2R5LlxuICAgICAqL1xuICAgIGhhc0JvZHkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jYm9keSAhPSBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBIVFRQIG1ldGhvZCB0byB1c2Ugd2hlbiByZXF1ZXN0aW5nIHRoZSBVUkkuIElmIG5vIG1ldGhvZFxuICAgICAqICBoYXMgYmVlbiBleHBsaWNpdGx5IHNldCwgdGhlbiBgYEdFVGBgIGlzIHVzZWQgaWYgdGhlIGJvZHkgaXNcbiAgICAgKiAgbnVsbCBhbmQgYGBQT1NUYGAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGdldCBtZXRob2QoKSB7XG4gICAgICAgIGlmICh0aGlzLiNtZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNtZXRob2Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzQm9keSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJQT1NUXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiR0VUXCI7XG4gICAgfVxuICAgIHNldCBtZXRob2QobWV0aG9kKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNtZXRob2QgPSBTdHJpbmcobWV0aG9kKS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGhlYWRlcnMgdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiByZXF1ZXN0aW5nIHRoZSBVUkkuIEFsbFxuICAgICAqICBrZXlzIGFyZSBsb3dlci1jYXNlLlxuICAgICAqXG4gICAgICogIFRoaXMgb2JqZWN0IGlzIGEgY29weSwgc28gYW55IGNoYW5nZXMgd2lsbCAqKk5PVCoqIGJlIHJlZmxlY3RlZFxuICAgICAqICBpbiB0aGUgYGBGZXRjaFJlcXVlc3RgYC5cbiAgICAgKlxuICAgICAqICBUbyBzZXQgYSBoZWFkZXIgZW50cnksIHVzZSB0aGUgYGBzZXRIZWFkZXJgYCBtZXRob2QuXG4gICAgICovXG4gICAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuI2NyZWRzKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiYXV0aG9yaXphdGlvblwiXSA9IGBCYXNpYyAke2VuY29kZUJhc2U2NCh0b1V0ZjhCeXRlcyh0aGlzLiNjcmVkcykpfWA7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBpZiAodGhpcy5hbGxvd0d6aXApIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJhY2NlcHQtZW5jb2RpbmdcIl0gPSBcImd6aXBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9PSBudWxsICYmIHRoaXMuI2JvZHlUeXBlKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID0gdGhpcy4jYm9keVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm9keSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtbGVuZ3RoXCJdID0gU3RyaW5nKHRoaXMuYm9keS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBoZWFkZXIgZm9yICUla2V5JSUsIGlnbm9yaW5nIGNhc2UuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFNldCB0aGUgaGVhZGVyIGZvciAlJWtleSUlIHRvICUldmFsdWUlJS4gQWxsIHZhbHVlcyBhcmUgY29lcmNlZFxuICAgICAqICB0byBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBzZXRIZWFkZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLiNoZWFkZXJzW1N0cmluZyhrZXkpLnRvTG93ZXJDYXNlKCldID0gU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENsZWFyIGFsbCBoZWFkZXJzLCByZXNldHRpbmcgYWxsIGludHJpbnNpYyBoZWFkZXJzLlxuICAgICAqL1xuICAgIGNsZWFySGVhZGVycygpIHtcbiAgICAgICAgdGhpcy4jaGVhZGVycyA9IHt9O1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuaGVhZGVycztcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW2tleSwgaGVhZGVyc1trZXldXSwgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHZhbHVlIHRoYXQgd2lsbCBiZSBzZW50IGZvciB0aGUgYGBBdXRob3JpemF0aW9uYGAgaGVhZGVyLlxuICAgICAqXG4gICAgICogIFRvIHNldCB0aGUgY3JlZGVudGlhbHMsIHVzZSB0aGUgYGBzZXRDcmVkZW50aWFsc2BgIG1ldGhvZC5cbiAgICAgKi9cbiAgICBnZXQgY3JlZGVudGlhbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjcmVkcyB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU2V0cyBhbiBgYEF1dGhvcml6YXRpb25gYCBmb3IgJSV1c2VybmFtZSUlIHdpdGggJSVwYXNzd29yZCUlLlxuICAgICAqL1xuICAgIHNldENyZWRlbnRpYWxzKHVzZXJuYW1lLCBwYXNzd29yZCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCghdXNlcm5hbWUubWF0Y2goLzovKSwgXCJpbnZhbGlkIGJhc2ljIGF1dGhlbnRpY2F0aW9uIHVzZXJuYW1lXCIsIFwidXNlcm5hbWVcIiwgXCJbUkVEQUNURURdXCIpO1xuICAgICAgICB0aGlzLiNjcmVkcyA9IGAke3VzZXJuYW1lfToke3Bhc3N3b3JkfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmFibGUgYW5kIHJlcXVlc3QgZ3ppcC1lbmNvZGVkIHJlc3BvbnNlcy4gVGhlIHJlc3BvbnNlIHdpbGxcbiAgICAgKiAgYXV0b21hdGljYWxseSBiZSBkZWNvbXByZXNzZWQuIC8vKGRlZmF1bHQ6IHRydWUpLy9cbiAgICAgKi9cbiAgICBnZXQgYWxsb3dHemlwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ3ppcDtcbiAgICB9XG4gICAgc2V0IGFsbG93R3ppcCh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNnemlwID0gISF2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFsbG93IGBgQXV0aGVudGljYXRpb25gYCBjcmVkZW50aWFscyB0byBiZSBzZW50IG92ZXIgaW5zZWN1cmVcbiAgICAgKiAgY2hhbm5lbHMuIC8vKGRlZmF1bHQ6IGZhbHNlKS8vXG4gICAgICovXG4gICAgZ2V0IGFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4jYWxsb3dJbnNlY3VyZTtcbiAgICB9XG4gICAgc2V0IGFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLiNhbGxvd0luc2VjdXJlID0gISF2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0aW1lb3V0IChpbiBtaWxsaXNlY29uZHMpIHRvIHdhaXQgZm9yIGEgY29tcGxldGUgcmVzcG9uc2UuXG4gICAgICogIC8vKGRlZmF1bHQ6IDUgbWludXRlcykvL1xuICAgICAqL1xuICAgIGdldCB0aW1lb3V0KCkgeyByZXR1cm4gdGhpcy4jdGltZW91dDsgfVxuICAgIHNldCB0aW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodGltZW91dCA+PSAwLCBcInRpbWVvdXQgbXVzdCBiZSBub24temVyb1wiLCBcInRpbWVvdXRcIiwgdGltZW91dCk7XG4gICAgICAgIHRoaXMuI3RpbWVvdXQgPSB0aW1lb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgcHJpb3IgdG8gZWFjaCByZXF1ZXN0LCBmb3IgZXhhbXBsZVxuICAgICAqICBkdXJpbmcgYSByZWRpcmVjdGlvbiBvciByZXRyeSBpbiBjYXNlIG9mIHNlcnZlciB0aHJvdHRsaW5nLlxuICAgICAqXG4gICAgICogIFRoaXMgb2ZmZXJzIGFuIG9wcG9ydHVuaXR5IHRvIHBvcHVsYXRlIGhlYWRlcnMgb3IgdXBkYXRlXG4gICAgICogIGNvbnRlbnQgYmVmb3JlIHNlbmRpbmcgYSByZXF1ZXN0LlxuICAgICAqL1xuICAgIGdldCBwcmVmbGlnaHRGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcHJlZmxpZ2h0IHx8IG51bGw7XG4gICAgfVxuICAgIHNldCBwcmVmbGlnaHRGdW5jKHByZWZsaWdodCkge1xuICAgICAgICB0aGlzLiNwcmVmbGlnaHQgPSBwcmVmbGlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciBlYWNoIHJlc3BvbnNlLCBvZmZlcmluZyBhblxuICAgICAqICBvcHBvcnR1bml0eSB0byBwcm92aWRlIGNsaWVudC1sZXZlbCB0aHJvdHRsaW5nIG9yIHVwZGF0aW5nXG4gICAgICogIHJlc3BvbnNlIGRhdGEuXG4gICAgICpcbiAgICAgKiAgQW55IGVycm9yIHRocm93biBpbiB0aGlzIGNhdXNlcyB0aGUgYGBzZW5kKClgYCB0byB0aHJvdy5cbiAgICAgKlxuICAgICAqICBUbyBzY2hlZHVsZSBhIHJldHJ5IGF0dGVtcHQgKGFzc3VtaW5nIHRoZSBtYXhpbXVtIHJldHJ5IGxpbWl0XG4gICAgICogIGhhcyBub3QgYmVlbiByZWFjaGVkKSwgdXNlIFtbcmVzcG9uc2UudGhyb3dUaHJvdHRsZUVycm9yXV0uXG4gICAgICovXG4gICAgZ2V0IHByb2Nlc3NGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcHJvY2VzcyB8fCBudWxsO1xuICAgIH1cbiAgICBzZXQgcHJvY2Vzc0Z1bmMocHJvY2Vzcykge1xuICAgICAgICB0aGlzLiNwcm9jZXNzID0gcHJvY2VzcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGVhY2ggcmV0cnkgYXR0ZW1wdC5cbiAgICAgKi9cbiAgICBnZXQgcmV0cnlGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcmV0cnkgfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0IHJldHJ5RnVuYyhyZXRyeSkge1xuICAgICAgICB0aGlzLiNyZXRyeSA9IHJldHJ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgdG8gZmV0Y2ggY29udGVudCBmcm9tIEhUVFAgYW5kXG4gICAgICogIEhUVFBTIFVSTHMgYW5kIGlzIHBsYXRmb3JtIHNwZWNpZmljIChlLmcuIG5vZGVqcyB2c1xuICAgICAqICBicm93c2VycykuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBieSBkZWZhdWx0IHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBnbG9iYWwgZ2V0VXJsXG4gICAgICogIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgY2hhbmdlZCB1c2luZyBbW3JlZ2lzdGVyR2V0VXJsXV0uXG4gICAgICogIElmIHRoaXMgaGFzIGJlZW4gc2V0LCBzZXR0aW5nIGlzIHRvIGBgbnVsbGBgIHdpbGwgY2F1c2VcbiAgICAgKiAgdGhpcyBGZXRjaFJlcXVlc3QgKGFuZCBhbnkgZnV0dXJlIGNsb25lcykgdG8gcmV2ZXJ0IGJhY2sgdG9cbiAgICAgKiAgdXNpbmcgdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIGdsb2JhbCBnZXRVcmwgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAgU2V0dGluZyB0aGlzIGlzIGdlbmVyYWxseSBub3QgbmVjZXNzYXJ5LCBidXQgbWF5IGJlIHVzZWZ1bFxuICAgICAqICBmb3IgZGV2ZWxvcGVycyB0aGF0IHdpc2ggdG8gaW50ZXJjZXB0IHJlcXVlc3RzIG9yIHRvXG4gICAgICogIGNvbmZpZ3VyZWdlIGEgcHJveHkgb3Igb3RoZXIgYWdlbnQuXG4gICAgICovXG4gICAgZ2V0IGdldFVybEZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnZXRVcmxGdW5jIHx8IGRlZmF1bHRHZXRVcmxGdW5jO1xuICAgIH1cbiAgICBzZXQgZ2V0VXJsRnVuYyh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNnZXRVcmxGdW5jID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgRmV0Y2hSZXF1ZXN0IGluc3RhbmNlIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAgT25jZSBjcmVhdGVkLCBlYWNoIHByb3BlcnR5IG1heSBiZSBzZXQgYmVmb3JlIGlzc3VpbmcgYVxuICAgICAqICBgYC5zZW5kKClgYCB0byBtYWtlIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCkge1xuICAgICAgICB0aGlzLiN1cmwgPSBTdHJpbmcodXJsKTtcbiAgICAgICAgdGhpcy4jYWxsb3dJbnNlY3VyZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNnemlwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jaGVhZGVycyA9IHt9O1xuICAgICAgICB0aGlzLiNtZXRob2QgPSBcIlwiO1xuICAgICAgICB0aGlzLiN0aW1lb3V0ID0gMzAwMDAwO1xuICAgICAgICB0aGlzLiN0aHJvdHRsZSA9IHtcbiAgICAgICAgICAgIHNsb3RJbnRlcnZhbDogU0xPVF9JTlRFUlZBTCxcbiAgICAgICAgICAgIG1heEF0dGVtcHRzOiBNQVhfQVRURU1QVFNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4jZ2V0VXJsRnVuYyA9IG51bGw7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYDxGZXRjaFJlcXVlc3QgbWV0aG9kPSR7SlNPTi5zdHJpbmdpZnkodGhpcy5tZXRob2QpfSB1cmw9JHtKU09OLnN0cmluZ2lmeSh0aGlzLnVybCl9IGhlYWRlcnM9JHtKU09OLnN0cmluZ2lmeSh0aGlzLmhlYWRlcnMpfSBib2R5PSR7dGhpcy4jYm9keSA/IGhleGxpZnkodGhpcy4jYm9keSkgOiBcIm51bGxcIn0+YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFVwZGF0ZSB0aGUgdGhyb3R0bGUgcGFyYW1ldGVycyB1c2VkIHRvIGRldGVybWluZSBtYXhpbXVtXG4gICAgICogIGF0dGVtcHRzIGFuZCBleHBvbmVudGlhbC1iYWNrb2ZmIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgc2V0VGhyb3R0bGVQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuc2xvdEludGVydmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI3Rocm90dGxlLnNsb3RJbnRlcnZhbCA9IHBhcmFtcy5zbG90SW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5tYXhBdHRlbXB0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiN0aHJvdHRsZS5tYXhBdHRlbXB0cyA9IHBhcmFtcy5tYXhBdHRlbXB0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAjc2VuZChhdHRlbXB0LCBleHBpcmVzLCBkZWxheSwgX3JlcXVlc3QsIF9yZXNwb25zZSkge1xuICAgICAgICBpZiAoYXR0ZW1wdCA+PSB0aGlzLiN0aHJvdHRsZS5tYXhBdHRlbXB0cykge1xuICAgICAgICAgICAgcmV0dXJuIF9yZXNwb25zZS5tYWtlU2VydmVyRXJyb3IoXCJleGNlZWRlZCBtYXhpbXVtIHJldHJ5IGxpbWl0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChnZXRUaW1lKCkgPD0gZXhwaXJlcywgXCJ0aW1lb3V0XCIsIFwiVElNRU9VVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdC5zZW5kXCIsIHJlYXNvbjogXCJ0aW1lb3V0XCIsIHJlcXVlc3Q6IF9yZXF1ZXN0XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCB3YWl0KGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVxID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBjb25zdCBzY2hlbWUgPSAocmVxLnVybC5zcGxpdChcIjpcIilbMF0gfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gUHJvY2VzcyBhbnkgR2F0ZXdheXNcbiAgICAgICAgaWYgKHNjaGVtZSBpbiBHYXRld2F5cykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgR2F0ZXdheXNbc2NoZW1lXShyZXEudXJsLCBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRmV0Y2hSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzRnVuYykge1xuICAgICAgICAgICAgICAgICAgICBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm9jZXNzRnVuYyhyZXEsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBwcm9jZXNzaW5nOyB0aHJvdyBhIDV4eCBzZXJ2ZXIgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci50aHJvdHRsZSA9PSBudWxsIHx8IHR5cGVvZiAoZXJyb3Iuc3RhbGwpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UubWFrZVNlcnZlckVycm9yKFwiZXJyb3IgaW4gcG9zdC1wcm9jZXNzaW5nIGZ1bmN0aW9uXCIsIGVycm9yKS5hc3NlcnRPaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHRocm90dGxpbmdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXEgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBhIHByZWZsaWdodCBmdW5jdGlvbjsgdXBkYXRlIHRoZSByZXF1ZXN0XG4gICAgICAgIGlmICh0aGlzLnByZWZsaWdodEZ1bmMpIHtcbiAgICAgICAgICAgIHJlcSA9IGF3YWl0IHRoaXMucHJlZmxpZ2h0RnVuYyhyZXEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmdldFVybEZ1bmMocmVxLCBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IG5ldyBGZXRjaFJlc3BvbnNlKHJlc3Auc3RhdHVzQ29kZSwgcmVzcC5zdGF0dXNNZXNzYWdlLCByZXNwLmhlYWRlcnMsIHJlc3AuYm9keSwgX3JlcXVlc3QpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMikge1xuICAgICAgICAgICAgLy8gUmVkaXJlY3RcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5yZWRpcmVjdChsb2NhdGlvbikuI3NlbmQoYXR0ZW1wdCArIDEsIGV4cGlyZXMsIDAsIF9yZXF1ZXN0LCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgLy8gVGhpbmdzIHdvbid0IGdldCBhbnkgYmV0dGVyIG9uIGFub3RoZXIgYXR0ZW1wdDsgYWJvcnRcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MjkpIHtcbiAgICAgICAgICAgIC8vIFRocm90dGxlXG4gICAgICAgICAgICBpZiAodGhpcy5yZXRyeUZ1bmMgPT0gbnVsbCB8fCAoYXdhaXQgdGhpcy5yZXRyeUZ1bmMocmVxLCByZXNwb25zZSwgYXR0ZW1wdCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnNbXCJyZXRyeS1hZnRlclwiXTtcbiAgICAgICAgICAgICAgICBsZXQgZGVsYXkgPSB0aGlzLiN0aHJvdHRsZS5zbG90SW50ZXJ2YWwgKiBNYXRoLnRydW5jKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocmV0cnlBZnRlcikgPT09IFwic3RyaW5nXCIgJiYgcmV0cnlBZnRlci5tYXRjaCgvXlsxLTldWzAtOV0qJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gcGFyc2VJbnQocmV0cnlBZnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXEuY2xvbmUoKS4jc2VuZChhdHRlbXB0ICsgMSwgZXhwaXJlcywgZGVsYXksIF9yZXF1ZXN0LCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvY2Vzc0Z1bmMocmVxLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgcHJvY2Vzc2luZzsgdGhyb3cgYSA1eHggc2VydmVyIGVycm9yXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnRocm90dGxlID09IG51bGwgfHwgdHlwZW9mIChlcnJvci5zdGFsbCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UubWFrZVNlcnZlckVycm9yKFwiZXJyb3IgaW4gcG9zdC1wcm9jZXNzaW5nIGZ1bmN0aW9uXCIsIGVycm9yKS5hc3NlcnRPaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaHJvdHRsZVxuICAgICAgICAgICAgICAgIGxldCBkZWxheSA9IHRoaXMuI3Rocm90dGxlLnNsb3RJbnRlcnZhbCAqIE1hdGgudHJ1bmMoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKTtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnN0YWxsID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBlcnJvci5zdGFsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5jbG9uZSgpLiNzZW5kKGF0dGVtcHQgKyAxLCBleHBpcmVzLCBkZWxheSwgX3JlcXVlc3QsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmVzcG9uc2UgYnkgc2VuZGluZyB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBzZW5kKCkge1xuICAgICAgICBhc3NlcnQodGhpcy4jc2lnbmFsID09IG51bGwsIFwicmVxdWVzdCBhbHJlYWR5IHNlbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZmV0Y2hSZXF1ZXN0LnNlbmRcIiB9KTtcbiAgICAgICAgdGhpcy4jc2lnbmFsID0gbmV3IEZldGNoQ2FuY2VsU2lnbmFsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy4jc2VuZCgwLCBnZXRUaW1lKCkgKyB0aGlzLnRpbWVvdXQsIDAsIHRoaXMsIG5ldyBGZXRjaFJlc3BvbnNlKDAsIFwiXCIsIHt9LCBudWxsLCB0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDYW5jZWxzIHRoZSBpbmZsaWdodCByZXNwb25zZSwgY2F1c2luZyBhIGBgQ0FOQ0VMTEVEYGBcbiAgICAgKiAgZXJyb3IgdG8gYmUgcmVqZWN0ZWQgZnJvbSB0aGUgW1tzZW5kXV0uXG4gICAgICovXG4gICAgY2FuY2VsKCkge1xuICAgICAgICBhc3NlcnQodGhpcy4jc2lnbmFsICE9IG51bGwsIFwicmVxdWVzdCBoYXMgbm90IGJlZW4gc2VudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmZXRjaFJlcXVlc3QuY2FuY2VsXCIgfSk7XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IGZldGNoU2lnbmFscy5nZXQodGhpcyk7XG4gICAgICAgIGlmICghc2lnbmFsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHNpZ25hbDsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmFsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRmV0Y2hSZXF1ZXN0XV0gdGhhdCByZXByZXNlbnRzIHRoZSByZWRpcmVjdGlvblxuICAgICAqICB0byAlJWxvY2F0aW9uJSUuXG4gICAgICovXG4gICAgcmVkaXJlY3QobG9jYXRpb24pIHtcbiAgICAgICAgLy8gUmVkaXJlY3Rpb247IGZvciBub3cgd2Ugb25seSBzdXBwb3J0IGFic29sdXRlIGxvY2F0aW9uc1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy51cmwuc3BsaXQoXCI6XCIpWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGxvY2F0aW9uLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBEb24ndCBhbGxvdyByZWRpcmVjdGluZzpcbiAgICAgICAgLy8gLSBub24tR0VUIHJlcXVlc3RzXG4gICAgICAgIC8vIC0gZG93bmdyYWRpbmcgdGhlIHNlY3VyaXR5IChlLmcuIGh0dHBzID0+IGh0dHApXG4gICAgICAgIC8vIC0gdG8gbm9uLUhUVFAgKG9yIG5vbi1IVFRQUykgcHJvdG9jb2xzIFt0aGlzIGNvdWxkIGJlIHJlbGF4ZWQ/XVxuICAgICAgICBhc3NlcnQodGhpcy5tZXRob2QgPT09IFwiR0VUXCIgJiYgKGN1cnJlbnQgIT09IFwiaHR0cHNcIiB8fCB0YXJnZXQgIT09IFwiaHR0cFwiKSAmJiBsb2NhdGlvbi5tYXRjaCgvXmh0dHBzPzovKSwgYHVuc3VwcG9ydGVkIHJlZGlyZWN0YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBgcmVkaXJlY3QoJHt0aGlzLm1ldGhvZH0gJHtKU09OLnN0cmluZ2lmeSh0aGlzLnVybCl9ID0+ICR7SlNPTi5zdHJpbmdpZnkobG9jYXRpb24pfSlgXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgcmVxdWVzdCwgd2l0aCBhIG5ldyBVUkxcbiAgICAgICAgY29uc3QgcmVxID0gbmV3IEZldGNoUmVxdWVzdChsb2NhdGlvbik7XG4gICAgICAgIHJlcS5tZXRob2QgPSBcIkdFVFwiO1xuICAgICAgICByZXEuYWxsb3dHemlwID0gdGhpcy5hbGxvd0d6aXA7XG4gICAgICAgIHJlcS50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgICByZXEuI2hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuI2JvZHkpIHtcbiAgICAgICAgICAgIHJlcS4jYm9keSA9IG5ldyBVaW50OEFycmF5KHRoaXMuI2JvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJlcS4jYm9keVR5cGUgPSB0aGlzLiNib2R5VHlwZTtcbiAgICAgICAgLy8gRG8gbm90IGZvcndhcmQgY3JlZGVudGlhbHMgdW5sZXNzIG9uIHRoZSBzYW1lIGRvbWFpbjsgb25seSBhYnNvbHV0ZVxuICAgICAgICAvL3JlcS5hbGxvd0luc2VjdXJlID0gZmFsc2U7XG4gICAgICAgIC8vIHBhdGhzIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkOyBtYXkgd2FudCBhIHdheSB0byBzcGVjaWZ5IHRvIGZvcndhcmQ/XG4gICAgICAgIC8vc2V0U3RvcmUocmVxLiNwcm9wcywgXCJjcmVkc1wiLCBnZXRTdG9yZSh0aGlzLiNwcm9zLCBcImNyZWRzXCIpKTtcbiAgICAgICAgcmV0dXJuIHJlcTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBjb3B5IG9mIHRoaXMgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgRmV0Y2hSZXF1ZXN0KHRoaXMudXJsKTtcbiAgICAgICAgLy8gUHJlc2VydmUgXCJkZWZhdWx0IG1ldGhvZFwiIChpLmUuIG51bGwpXG4gICAgICAgIGNsb25lLiNtZXRob2QgPSB0aGlzLiNtZXRob2Q7XG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBib2R5XCIgd2l0aCB0eXBlLCBjb3B5aW5nIHRoZSBVaW50OEFycmF5IGlzIHByZXNlbnRcbiAgICAgICAgaWYgKHRoaXMuI2JvZHkpIHtcbiAgICAgICAgICAgIGNsb25lLiNib2R5ID0gdGhpcy4jYm9keTtcbiAgICAgICAgfVxuICAgICAgICBjbG9uZS4jYm9keVR5cGUgPSB0aGlzLiNib2R5VHlwZTtcbiAgICAgICAgLy8gUHJlc2VydmUgXCJkZWZhdWx0IGhlYWRlcnNcIlxuICAgICAgICBjbG9uZS4jaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpO1xuICAgICAgICAvLyBDcmVkZW50aWFscyBpcyByZWFkb25seSwgc28gd2UgY29weSBpbnRlcm5hbGx5XG4gICAgICAgIGNsb25lLiNjcmVkcyA9IHRoaXMuI2NyZWRzO1xuICAgICAgICBpZiAodGhpcy5hbGxvd0d6aXApIHtcbiAgICAgICAgICAgIGNsb25lLmFsbG93R3ppcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmUudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKSB7XG4gICAgICAgICAgICBjbG9uZS5hbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNsb25lLiNwcmVmbGlnaHQgPSB0aGlzLiNwcmVmbGlnaHQ7XG4gICAgICAgIGNsb25lLiNwcm9jZXNzID0gdGhpcy4jcHJvY2VzcztcbiAgICAgICAgY2xvbmUuI3JldHJ5ID0gdGhpcy4jcmV0cnk7XG4gICAgICAgIGNsb25lLiNnZXRVcmxGdW5jID0gdGhpcy4jZ2V0VXJsRnVuYztcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgTG9ja3MgYWxsIHN0YXRpYyBjb25maWd1cmF0aW9uIGZvciBnYXRld2F5cyBhbmQgRmV0Y2hHZXRVcmxGdW5jXG4gICAgICogIHJlZ2lzdHJhdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgbG9ja0NvbmZpZygpIHtcbiAgICAgICAgbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgY3VycmVudCBHYXRld2F5IGZ1bmN0aW9uIGZvciAlJXNjaGVtZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRHYXRld2F5KHNjaGVtZSkge1xuICAgICAgICByZXR1cm4gR2F0ZXdheXNbc2NoZW1lLnRvTG93ZXJDYXNlKCldIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVc2UgdGhlICUlZnVuYyUlIHdoZW4gZmV0Y2hpbmcgVVJJcyB1c2luZyAlJXNjaGVtZSUlLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGFmZmVjdHMgYWxsIHJlcXVlc3RzIGdsb2JhbGx5LlxuICAgICAqXG4gICAgICogIElmIFtbbG9ja0NvbmZpZ11dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2hhbmdlIGlzIG1hZGUgYW5kIHRoaXNcbiAgICAgKiAgdGhyb3dzLlxuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlckdhdGV3YXkoc2NoZW1lLCBmdW5jKSB7XG4gICAgICAgIHNjaGVtZSA9IHNjaGVtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc2NoZW1lID09PSBcImh0dHBcIiB8fCBzY2hlbWUgPT09IFwiaHR0cHNcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgaW50ZXJjZXB0ICR7c2NoZW1lfTsgdXNlIHJlZ2lzdGVyR2V0VXJsYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2F0ZXdheXMgbG9ja2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIEdhdGV3YXlzW3NjaGVtZV0gPSBmdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVXNlICUlZ2V0VXJsJSUgd2hlbiBmZXRjaGluZyBVUklzIG92ZXIgSFRUUCBhbmQgSFRUUFMgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgYWZmZWN0cyBhbGwgcmVxdWVzdHMgZ2xvYmFsbHkuXG4gICAgICpcbiAgICAgKiAgSWYgW1tsb2NrQ29uZmlnXV0gaGFzIGJlZW4gY2FsbGVkLCBubyBjaGFuZ2UgaXMgbWFkZSBhbmQgdGhpc1xuICAgICAqICB0aHJvd3MuXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyR2V0VXJsKGdldFVybCkge1xuICAgICAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnYXRld2F5cyBsb2NrZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdEdldFVybEZ1bmMgPSBnZXRVcmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgZ2V0VXJsIGZ1bmN0aW9uIHRoYXQgZmV0Y2hlcyBjb250ZW50IGZyb20gSFRUUCBhbmRcbiAgICAgKiAgSFRUUFMgVVJMcy5cbiAgICAgKlxuICAgICAqICBUaGUgYXZhaWxhYmxlICUlb3B0aW9ucyUlIGFyZSBkZXBlbmRlbnQgb24gdGhlIHBsYXRmb3JtXG4gICAgICogIGltcGxlbWVudGF0aW9uIG9mIHRoZSBkZWZhdWx0IGdldFVybCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBnZW5lcmFsbHkgc29tZXRoaW5nIHRoYXQgaXMgbmVlZGVkLCBidXQgaXMgdXNlZnVsXG4gICAgICogIHdoZW4gdHJ5aW5nIHRvIGN1c3RvbWl6ZSBzaW1wbGUgYmVoYXZpb3VyIHdoZW4gZmV0Y2hpbmcgSFRUUFxuICAgICAqICBjb250ZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVHZXRVcmxGdW5jKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUdldFVybChvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBcImZldGNoXCIgZGF0YSBVUklzLlxuICAgICAqXG4gICAgICogIE5vdGUgdGhhdCB0aGlzIGlzIGF1dG9tYXRpY2FsbHkgZG9uZSBpbnRlcm5hbGx5IHRvIHN1cHBvcnRcbiAgICAgKiAgZGF0YSBVUklzLCBzbyBpdCBpcyBub3QgbmVjZXNzYXJ5IHRvIHJlZ2lzdGVyIGl0LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgbm90IGdlbmVyYWxseSBzb21ldGhpbmcgdGhhdCBpcyBuZWVkZWQsIGJ1dCBtYXlcbiAgICAgKiAgYmUgdXNlZnVsIGluIGEgd3JhcHBlciB0byBwZXJmb20gY3VzdG9tIGRhdGEgVVJJIGZ1bmN0aW9uYWxpdHkuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZURhdGFHYXRld2F5KCkge1xuICAgICAgICByZXR1cm4gZGF0YUdhdGV3YXlGdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBmZXRjaCBJUEZTICh1bnZhbGlkYXRlZCkgZnJvbVxuICAgICAqICBhIGN1c3RvbSBnYXRld2F5IGJhc2VVcmwuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlZmF1bHQgSVBGUyBnYXRld2F5IHVzZWQgaW50ZXJuYWxseSBpc1xuICAgICAqICBgYFwiaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzL1wiYGAuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUlwZnNHYXRld2F5RnVuYyhiYXNlVXJsKSB7XG4gICAgICAgIHJldHVybiBnZXRJcGZzR2F0ZXdheUZ1bmMoYmFzZVVybCk7XG4gICAgfVxufVxuO1xuLyoqXG4gKiAgVGhlIHJlc3BvbnNlIGZvciBhIEZldGNoUmVxdWVzdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEZldGNoUmVzcG9uc2Uge1xuICAgICNzdGF0dXNDb2RlO1xuICAgICNzdGF0dXNNZXNzYWdlO1xuICAgICNoZWFkZXJzO1xuICAgICNib2R5O1xuICAgICNyZXF1ZXN0O1xuICAgICNlcnJvcjtcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGA8RmV0Y2hSZXNwb25zZSBzdGF0dXM9JHt0aGlzLnN0YXR1c0NvZGV9IGJvZHk9JHt0aGlzLiNib2R5ID8gaGV4bGlmeSh0aGlzLiNib2R5KSA6IFwibnVsbFwifT5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIHN0YXR1cyBjb2RlLlxuICAgICAqL1xuICAgIGdldCBzdGF0dXNDb2RlKCkgeyByZXR1cm4gdGhpcy4jc3RhdHVzQ29kZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2Ugc3RhdHVzIG1lc3NhZ2UuXG4gICAgICovXG4gICAgZ2V0IHN0YXR1c01lc3NhZ2UoKSB7IHJldHVybiB0aGlzLiNzdGF0dXNNZXNzYWdlOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBoZWFkZXJzLiBBbGwga2V5cyBhcmUgbG93ZXItY2FzZS5cbiAgICAgKi9cbiAgICBnZXQgaGVhZGVycygpIHsgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBib2R5LCBvciBgYG51bGxgYCBpZiB0aGVyZSB3YXMgbm8gYm9keS5cbiAgICAgKi9cbiAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KHRoaXMuI2JvZHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGJvZHkgYXMgYSBVVEYtOCBlbmNvZGVkIHN0cmluZywgb3IgdGhlIGVtcHR5XG4gICAgICogIHN0cmluZyAoaS5lLiBgYFwiXCJgYCkgaWYgdGhlcmUgd2FzIG5vIGJvZHkuXG4gICAgICpcbiAgICAgKiAgQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBib2R5IGlzIGludmFsaWQgVVRGLTggZGF0YS5cbiAgICAgKi9cbiAgICBnZXQgYm9keVRleHQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgPT0gbnVsbCkgPyBcIlwiIDogdG9VdGY4U3RyaW5nKHRoaXMuI2JvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInJlc3BvbnNlIGJvZHkgaXMgbm90IHZhbGlkIFVURi04IGRhdGFcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJib2R5VGV4dFwiLCBpbmZvOiB7IHJlc3BvbnNlOiB0aGlzIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgYm9keSwgZGVjb2RlZCBhcyBKU09OLlxuICAgICAqXG4gICAgICogIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgYm9keSBpcyBpbnZhbGlkIEpTT04tZW5jb2RlZCBkYXRhXG4gICAgICogIG9yIGlmIHRoZXJlIHdhcyBubyBib2R5LlxuICAgICAqL1xuICAgIGdldCBib2R5SnNvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuYm9keVRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInJlc3BvbnNlIGJvZHkgaXMgbm90IHZhbGlkIEpTT05cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJib2R5SnNvblwiLCBpbmZvOiB7IHJlc3BvbnNlOiB0aGlzIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5oZWFkZXJzO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycyk7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBba2V5LCBoZWFkZXJzW2tleV1dLCBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMsIGJvZHksIHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy4jc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICAgIHRoaXMuI3N0YXR1c01lc3NhZ2UgPSBzdGF0dXNNZXNzYWdlO1xuICAgICAgICB0aGlzLiNoZWFkZXJzID0gT2JqZWN0LmtleXMoaGVhZGVycykucmVkdWNlKChhY2N1bSwgaykgPT4ge1xuICAgICAgICAgICAgYWNjdW1bay50b0xvd2VyQ2FzZSgpXSA9IFN0cmluZyhoZWFkZXJzW2tdKTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLiNib2R5ID0gKChib2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KGJvZHkpKTtcbiAgICAgICAgdGhpcy4jcmVxdWVzdCA9IChyZXF1ZXN0IHx8IG51bGwpO1xuICAgICAgICB0aGlzLiNlcnJvciA9IHsgbWVzc2FnZTogXCJcIiB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgUmVzcG9uc2Ugd2l0aCBtYXRjaGluZyBoZWFkZXJzIGFuZCBib2R5LCBidXQgd2l0aFxuICAgICAqICBhbiBlcnJvciBzdGF0dXMgY29kZSAoaS5lLiA1OTkpIGFuZCAlJW1lc3NhZ2UlJSB3aXRoIGFuXG4gICAgICogIG9wdGlvbmFsICUlZXJyb3IlJS5cbiAgICAgKi9cbiAgICBtYWtlU2VydmVyRXJyb3IobWVzc2FnZSwgZXJyb3IpIHtcbiAgICAgICAgbGV0IHN0YXR1c01lc3NhZ2U7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGAke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9YDtcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2UgPSBgQ0xJRU5UIEVTQ0FMQVRFRCBTRVJWRVIgRVJST1IgKCR7bWVzc2FnZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2UgPSBgQ0xJRU5UIEVTQ0FMQVRFRCBTRVJWRVIgRVJST1IgKCR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX07ICR7bWVzc2FnZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBGZXRjaFJlc3BvbnNlKDU5OSwgc3RhdHVzTWVzc2FnZSwgdGhpcy5oZWFkZXJzLCB0aGlzLmJvZHksIHRoaXMuI3JlcXVlc3QgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmVzcG9uc2UuI2Vycm9yID0geyBtZXNzYWdlLCBlcnJvciB9O1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiBjYWxsZWQgd2l0aGluIGEgW3JlcXVlc3QucHJvY2Vzc0Z1bmNdKEZldGNoUmVxdWVzdC1wcm9jZXNzRnVuYylcbiAgICAgKiAgY2FsbCwgY2F1c2VzIHRoZSByZXF1ZXN0IHRvIHJldHJ5IGFzIGlmIHRocm90dGxlZCBmb3IgJSVzdGFsbCUlXG4gICAgICogIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICB0aHJvd1Rocm90dGxlRXJyb3IobWVzc2FnZSwgc3RhbGwpIHtcbiAgICAgICAgaWYgKHN0YWxsID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YWxsID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKHN0YWxsKSAmJiBzdGFsbCA+PSAwLCBcImludmFsaWQgc3RhbGwgdGltZW91dFwiLCBcInN0YWxsXCIsIHN0YWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlIHx8IFwidGhyb3R0bGluZyByZXF1ZXN0c1wiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBzdGFsbCwgdGhyb3R0bGU6IHRydWUgfSk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBoZWFkZXIgdmFsdWUgZm9yICUla2V5JSUsIGlnbm9yaW5nIGNhc2UuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVzcG9uc2UgaGFzIGEgYm9keS5cbiAgICAgKi9cbiAgICBoYXNCb2R5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVxdWVzdCBtYWRlIGZvciB0aGlzIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIGdldCByZXF1ZXN0KCkgeyByZXR1cm4gdGhpcy4jcmVxdWVzdDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyByZXNwb25zZSB3YXMgYSBzdWNjZXNzIHN0YXR1c0NvZGUuXG4gICAgICovXG4gICAgb2soKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jZXJyb3IubWVzc2FnZSA9PT0gXCJcIiAmJiB0aGlzLnN0YXR1c0NvZGUgPj0gMjAwICYmIHRoaXMuc3RhdHVzQ29kZSA8IDMwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaHJvd3MgYSBgYFNFUlZFUl9FUlJPUmBgIGlmIHRoaXMgcmVzcG9uc2UgaXMgbm90IG9rLlxuICAgICAqL1xuICAgIGFzc2VydE9rKCkge1xuICAgICAgICBpZiAodGhpcy5vaygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgbWVzc2FnZSwgZXJyb3IgfSA9IHRoaXMuI2Vycm9yO1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGBzZXJ2ZXIgcmVzcG9uc2UgJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBtZXNzYWdlLCBcIlNFUlZFUl9FUlJPUlwiLCB7XG4gICAgICAgICAgICByZXF1ZXN0OiAodGhpcy5yZXF1ZXN0IHx8IFwidW5rbm93biByZXF1ZXN0XCIpLCByZXNwb25zZTogdGhpcywgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VGltZSgpIHsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7IH1cbmZ1bmN0aW9uIHVucGVyY2VudCh2YWx1ZSkge1xuICAgIHJldHVybiB0b1V0ZjhCeXRlcyh2YWx1ZS5yZXBsYWNlKC8lKFswLTlhLWZdWzAtOWEtZl0pL2dpLCAoYWxsLCBjb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGNvZGUsIDE2KSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gd2FpdChkZWxheSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2guanMubWFwIiwiLy9TZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvUkxQXG5pbXBvcnQgeyBoZXhsaWZ5IH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5mdW5jdGlvbiBoZXhsaWZ5Qnl0ZSh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuZnVuY3Rpb24gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IChyZXN1bHQgKiAyNTYpICsgZGF0YVtvZmZzZXQgKyBpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIGNoaWxkT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAoY2hpbGRPZmZzZXQgPCBvZmZzZXQgKyAxICsgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBfZGVjb2RlKGRhdGEsIGNoaWxkT2Zmc2V0KTtcbiAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZC5yZXN1bHQpO1xuICAgICAgICBjaGlsZE9mZnNldCArPSBkZWNvZGVkLmNvbnN1bWVkO1xuICAgICAgICBhc3NlcnQoY2hpbGRPZmZzZXQgPD0gb2Zmc2V0ICsgMSArIGxlbmd0aCwgXCJjaGlsZCBkYXRhIHRvbyBzaG9ydFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgICAgIGJ1ZmZlcjogZGF0YSwgbGVuZ3RoLCBvZmZzZXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG59XG4vLyByZXR1cm5zIHsgY29uc3VtZWQ6IG51bWJlciwgcmVzdWx0OiBPYmplY3QgfVxuZnVuY3Rpb24gX2RlY29kZShkYXRhLCBvZmZzZXQpIHtcbiAgICBhc3NlcnQoZGF0YS5sZW5ndGggIT09IDAsIFwiZGF0YSB0b28gc2hvcnRcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgIGJ1ZmZlcjogZGF0YSwgbGVuZ3RoOiAwLCBvZmZzZXQ6IDFcbiAgICB9KTtcbiAgICBjb25zdCBjaGVja09mZnNldCA9IChvZmZzZXQpID0+IHtcbiAgICAgICAgYXNzZXJ0KG9mZnNldCA8PSBkYXRhLmxlbmd0aCwgXCJkYXRhIHNob3J0IHNlZ21lbnQgdG9vIHNob3J0XCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGg6IGRhdGEubGVuZ3RoLCBvZmZzZXRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBBcnJheSB3aXRoIGV4dHJhIGxlbmd0aCBwcmVmaXhcbiAgICBpZiAoZGF0YVtvZmZzZXRdID49IDB4ZjgpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoTGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhmNztcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCArIDEsIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCwgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YzApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhjMDtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBvZmZzZXQgKyAxLCBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhiOCkge1xuICAgICAgICBjb25zdCBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGI3O1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweDgwKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4ODA7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBoZXhsaWZ5KGRhdGEuc2xpY2Uob2Zmc2V0ICsgMSwgb2Zmc2V0ICsgMSArIGxlbmd0aCkpO1xuICAgICAgICByZXR1cm4geyBjb25zdW1lZDogKDEgKyBsZW5ndGgpLCByZXN1bHQ6IHJlc3VsdCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBjb25zdW1lZDogMSwgcmVzdWx0OiBoZXhsaWZ5Qnl0ZShkYXRhW29mZnNldF0pIH07XG59XG4vKipcbiAqICBEZWNvZGVzICUlZGF0YSUlIGludG8gdGhlIHN0cnVjdHVyZWQgZGF0YSBpdCByZXByZXNlbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlUmxwKF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XG4gICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgMCk7XG4gICAgYXNzZXJ0QXJndW1lbnQoZGVjb2RlZC5jb25zdW1lZCA9PT0gZGF0YS5sZW5ndGgsIFwidW5leHBlY3RlZCBqdW5rIGFmdGVyIHJscCBwYXlsb2FkXCIsIFwiZGF0YVwiLCBfZGF0YSk7XG4gICAgcmV0dXJuIGRlY29kZWQucmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmxwLWRlY29kZS5qcy5tYXAiLCIvL1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9STFBcbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuZnVuY3Rpb24gYXJyYXlpZnlJbnRlZ2VyKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG4gICAgICAgIHZhbHVlID4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2VuY29kZShvYmplY3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGxldCBwYXlsb2FkID0gW107XG4gICAgICAgIG9iamVjdC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcGF5bG9hZCA9IHBheWxvYWQuY29uY2F0KF9lbmNvZGUoY2hpbGQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXlsb2FkLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICAgICAgcGF5bG9hZC51bnNoaWZ0KDB4YzAgKyBwYXlsb2FkLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheWlmeUludGVnZXIocGF5bG9hZC5sZW5ndGgpO1xuICAgICAgICBsZW5ndGgudW5zaGlmdCgweGY3ICsgbGVuZ3RoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBsZW5ndGguY29uY2F0KHBheWxvYWQpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZ2V0Qnl0ZXMob2JqZWN0LCBcIm9iamVjdFwiKSk7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAxICYmIGRhdGFbMF0gPD0gMHg3Zikge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YS5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgZGF0YS51bnNoaWZ0KDB4ODAgKyBkYXRhLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGggPSBhcnJheWlmeUludGVnZXIoZGF0YS5sZW5ndGgpO1xuICAgIGxlbmd0aC51bnNoaWZ0KDB4YjcgKyBsZW5ndGgubGVuZ3RoKTtcbiAgICByZXR1cm4gbGVuZ3RoLmNvbmNhdChkYXRhKTtcbn1cbmNvbnN0IG5pYmJsZXMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qKlxuICogIEVuY29kZXMgJSVvYmplY3QlJSBhcyBhbiBSTFAtZW5jb2RlZCBbW0RhdGFIZXhTdHJpbmddXS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVJscChvYmplY3QpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgIGZvciAoY29uc3QgdiBvZiBfZW5jb2RlKG9iamVjdCkpIHtcbiAgICAgICAgcmVzdWx0ICs9IG5pYmJsZXNbdiA+PiA0XTtcbiAgICAgICAgcmVzdWx0ICs9IG5pYmJsZXNbdiAmIDB4Zl07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ybHAtZW5jb2RlLmpzLm1hcCIsImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGNvbmNhdCwgZ2V0Qnl0ZXNDb3B5LCBnZXROdW1iZXIsIGhleGxpZnksIHRvQmVBcnJheSwgdG9CaWdJbnQsIHRvTnVtYmVyLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG4vKipcbiAqIEBfaWdub3JlOlxuICovXG5leHBvcnQgY29uc3QgV29yZFNpemUgPSAzMjtcbmNvbnN0IFBhZGRpbmcgPSBuZXcgVWludDhBcnJheShXb3JkU2l6ZSk7XG4vLyBQcm9wZXJ0aWVzIHVzZWQgdG8gaW1tZWRpYXRlIHBhc3MgdGhyb3VnaCB0byB0aGUgdW5kZXJseWluZyBvYmplY3Rcbi8vIC0gYHRoZW5gIGlzIHVzZWQgdG8gZGV0ZWN0IGlmIGFuIG9iamVjdCBpcyBhIFByb21pc2UgZm9yIGF3YWl0XG5jb25zdCBwYXNzUHJvcGVydGllcyA9IFtcInRoZW5cIl07XG5jb25zdCBfZ3VhcmQgPSB7fTtcbmZ1bmN0aW9uIHRocm93RXJyb3IobmFtZSwgZXJyb3IpIHtcbiAgICBjb25zdCB3cmFwcGVkID0gbmV3IEVycm9yKGBkZWZlcnJlZCBlcnJvciBkdXJpbmcgQUJJIGRlY29kaW5nIHRyaWdnZXJlZCBhY2Nlc3NpbmcgJHtuYW1lfWApO1xuICAgIHdyYXBwZWQuZXJyb3IgPSBlcnJvcjtcbiAgICB0aHJvdyB3cmFwcGVkO1xufVxuLyoqXG4gKiAgQSBbW1Jlc3VsdF1dIGlzIGEgc3ViLWNsYXNzIG9mIEFycmF5LCB3aGljaCBhbGxvd3MgYWNjZXNzaW5nIGFueVxuICogIG9mIGl0cyB2YWx1ZXMgZWl0aGVyIHBvc2l0aW9uYWxseSBieSBpdHMgaW5kZXggb3IsIGlmIGtleXMgYXJlXG4gKiAgcHJvdmlkZWQgYnkgaXRzIG5hbWUuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvYWJpXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXN1bHQgZXh0ZW5kcyBBcnJheSB7XG4gICAgI25hbWVzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gVG8gcHJvcGVybHkgc3ViLWNsYXNzIEFycmF5IHNvIHRoZSBvdGhlciBidWlsdC1pblxuICAgICAgICAvLyBmdW5jdGlvbnMgd29yaywgdGhlIGNvbnN0cnVjdG9yIGhhcyB0byBiZWhhdmUgZmFpcmx5XG4gICAgICAgIC8vIHdlbGwuIFNvLCBpbiB0aGUgZXZlbnQgd2UgYXJlIGNyZWF0ZWQgdmlhIGZyb21JdGVtcygpXG4gICAgICAgIC8vIHdlIGJ1aWxkIHRoZSByZWFkLW9ubHkgUmVzdWx0IG9iamVjdCB3ZSB3YW50LCBidXQgb25cbiAgICAgICAgLy8gYW55IG90aGVyIGlucHV0LCB3ZSB1c2UgdGhlIGRlZmF1bHQgY29uc3RydWN0b3JcbiAgICAgICAgLy8gY29uc3RydWN0b3IoZ3VhcmQ6IGFueSwgaXRlbXM6IEFycmF5PGFueT4sIGtleXM/OiBBcnJheTxudWxsIHwgc3RyaW5nPik7XG4gICAgICAgIGNvbnN0IGd1YXJkID0gYXJnc1swXTtcbiAgICAgICAgbGV0IGl0ZW1zID0gYXJnc1sxXTtcbiAgICAgICAgbGV0IG5hbWVzID0gKGFyZ3NbMl0gfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGxldCB3cmFwID0gdHJ1ZTtcbiAgICAgICAgaWYgKGd1YXJkICE9PSBfZ3VhcmQpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gYXJncztcbiAgICAgICAgICAgIG5hbWVzID0gW107XG4gICAgICAgICAgICB3cmFwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FuJ3QganVzdCBwYXNzIGluIC4uLml0ZW1zIHNpbmNlIGFuIGFycmF5IG9mIGxlbmd0aCAxXG4gICAgICAgIC8vIGlzIGEgc3BlY2lhbCBjYXNlIGluIHRoZSBzdXBlci5cbiAgICAgICAgc3VwZXIoaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHsgdGhpc1tpbmRleF0gPSBpdGVtOyB9KTtcbiAgICAgICAgLy8gRmluZCBhbGwgdW5pcXVlIGtleXNcbiAgICAgICAgY29uc3QgbmFtZUNvdW50cyA9IG5hbWVzLnJlZHVjZSgoYWNjdW0sIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYWNjdW0uc2V0KG5hbWUsIChhY2N1bS5nZXQobmFtZSkgfHwgMCkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwgKG5ldyBNYXAoKSkpO1xuICAgICAgICAvLyBSZW1vdmUgYW55IGtleSB0aGF0cyBub3QgdW5pcXVlXG4gICAgICAgIHRoaXMuI25hbWVzID0gT2JqZWN0LmZyZWV6ZShpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiBuYW1lQ291bnRzLmdldChuYW1lKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKCF3cmFwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSB3cmFwcGVkIFJlc3VsdCBpcyBpbW11dGFibGVcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgLy8gUHJveHkgaW5kaWNlcyBhbmQgbmFtZXMgc28gd2UgY2FuIHRyYXAgZGVmZXJyZWQgZXJyb3JzXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluZGV4IGFjY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldE51bWJlcihwcm9wLCBcIiVpbmRleFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByZXN1bHQgcmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGFyZ2V0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2luZGV4fWAsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyBpbXBvcnRhbnQgY2hlY2tzIChsaWtlIGB0aGVuYCBmb3IgUHJvbWlzZSkgdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICBpZiAocGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0YXJnZXRbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgZnVuY3Rpb25zIHdvcmsgd2l0aCBwcml2YXRlIHZhcmlhYmxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eSNub19wcml2YXRlX3Byb3BlcnR5X2ZvcndhcmRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSgodGhpcyA9PT0gcmVjZWl2ZXIpID8gdGFyZ2V0IDogdGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEocHJvcCBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NzaWJsZSBuYW1lIGFjY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmdldFZhbHVlLmFwcGx5KCh0aGlzID09PSByZWNlaXZlcikgPyB0YXJnZXQgOiB0aGlzLCBbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBSZXN1bHQgYXMgYSBub3JtYWwgQXJyYXkuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIHRoZXJlIGFyZSBhbnkgb3V0c3RhbmRpbmcgZGVmZXJyZWRcbiAgICAgKiAgZXJyb3JzLlxuICAgICAqL1xuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpbmRleH1gLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIFJlc3VsdCBhcyBhbiBPYmplY3Qgd2l0aCBlYWNoIG5hbWUtdmFsdWUgcGFpci5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgaWYgYW55IHZhbHVlIGlzIHVubmFtZWQsIG9yIGlmIHRoZXJlIGFyZVxuICAgICAqICBhbnkgb3V0c3RhbmRpbmcgZGVmZXJyZWQgZXJyb3JzLlxuICAgICAqL1xuICAgIHRvT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbmFtZXMucmVkdWNlKChhY2N1bSwgbmFtZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGFzc2VydChuYW1lICE9IG51bGwsIFwidmFsdWUgYXQgaW5kZXggJHsgaW5kZXggfSB1bm5hbWVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwidG9PYmplY3QoKVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFkZCB2YWx1ZXMgZm9yIG5hbWVzIHRoYXQgZG9uJ3QgY29uZmxpY3RcbiAgICAgICAgICAgIGlmICghKG5hbWUgaW4gYWNjdW0pKSB7XG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSB0aGlzLmdldFZhbHVlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZVxuICAgICAqL1xuICAgIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCArPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICAgICAgZW5kICs9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgICAgICAgICBlbmQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW10sIG5hbWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzW2ldKTtcbiAgICAgICAgICAgIG5hbWVzLnB1c2godGhpcy4jbmFtZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KF9ndWFyZCwgcmVzdWx0LCBuYW1lcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZVxuICAgICAqL1xuICAgIGZpbHRlcihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXSwgbmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2l9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBpdGVtLCBpLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIG5hbWVzLnB1c2godGhpcy4jbmFtZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KF9ndWFyZCwgcmVzdWx0LCBuYW1lcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZVxuICAgICAqL1xuICAgIG1hcChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2l9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGl0ZW0sIGksIHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdmFsdWUgZm9yICUlbmFtZSUlLlxuICAgICAqXG4gICAgICogIFNpbmNlIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgYSBrZXkgd2hvc2UgbmFtZSBjb25mbGljdHMgd2l0aFxuICAgICAqICBhIG1ldGhvZCBvbiBhIFtbUmVzdWx0XV0gb3IgaXRzIHN1cGVyY2xhc3MgQXJyYXksIG9yIGFueVxuICAgICAqICBKYXZhU2NyaXB0IGtleXdvcmQsIHRoaXMgZW5zdXJlcyBhbGwgbmFtZWQgdmFsdWVzIGFyZSBzdGlsbFxuICAgICAqICBhY2Nlc3NpYmxlIGJ5IG5hbWUuXG4gICAgICovXG4gICAgZ2V0VmFsdWUobmFtZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuI25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgdmFsdWUuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tSZXN1bHRdXSBmb3IgJSVpdGVtcyUlIHdpdGggZWFjaCBlbnRyeVxuICAgICAqICBhbHNvIGFjY2Vzc2libGUgYnkgaXRzIGNvcnJlc3BvbmRpbmcgbmFtZSBpbiAlJWtleXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUl0ZW1zKGl0ZW1zLCBrZXlzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KF9ndWFyZCwgaXRlbXMsIGtleXMpO1xuICAgIH1cbn1cbi8qKlxuICogIFJldHVybnMgYWxsIGVycm9ycyBmb3VuZCBpbiBhIFtbUmVzdWx0XV0uXG4gKlxuICogIFNpbmNlIGNlcnRhaW4gZXJyb3JzIGVuY291bnRlcmVkIHdoZW4gY3JlYXRpbmcgYSBbW1Jlc3VsdF1dIGRvXG4gKiAgbm90IGltcGFjdCB0aGUgYWJpbGl0eSB0byBjb250aW51ZSBwYXJzaW5nIGRhdGEsIHRoZXkgYXJlXG4gKiAgZGVmZXJyZWQgdW50aWwgdGhleSBhcmUgYWN0dWFsbHkgYWNjZXNzZWQuIEhlbmNlIGEgZmF1bHR5IHN0cmluZ1xuICogIGluIGFuIEV2ZW50IHRoYXQgaXMgbmV2ZXIgdXNlZCBkb2VzIG5vdCBpbXBhY3QgdGhlIHByb2dyYW0gZmxvdy5cbiAqXG4gKiAgSG93ZXZlciwgc29tZXRpbWVzIGl0IG1heSBiZSB1c2VmdWwgdG8gYWNjZXNzLCBpZGVudGlmeSBvclxuICogIHZhbGlkYXRlIGNvcnJlY3RuZXNzIG9mIGEgW1tSZXN1bHRdXS5cbiAqXG4gKiAgQF9kb2Nsb2MgYXBpL2FiaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZXN1bHRFcnJvcnMocmVzdWx0KSB7XG4gICAgLy8gRmluZCB0aGUgZmlyc3QgZXJyb3IgKGlmIGFueSlcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCBjaGVja0Vycm9ycyA9IGZ1bmN0aW9uIChwYXRoLCBvYmplY3QpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoLnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZFBhdGgucHVzaChrZXkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGVja0Vycm9ycyhjaGlsZFBhdGgsIG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgcGF0aDogY2hpbGRQYXRoLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNoZWNrRXJyb3JzKFtdLCByZXN1bHQpO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGxldCBieXRlcyA9IHRvQmVBcnJheSh2YWx1ZSk7XG4gICAgYXNzZXJ0KGJ5dGVzLmxlbmd0aCA8PSBXb3JkU2l6ZSwgXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwgeyBidWZmZXI6IGJ5dGVzLCBsZW5ndGg6IFdvcmRTaXplLCBvZmZzZXQ6IGJ5dGVzLmxlbmd0aCB9KTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBXb3JkU2l6ZSkge1xuICAgICAgICBieXRlcyA9IGdldEJ5dGVzQ29weShjb25jYXQoW1BhZGRpbmcuc2xpY2UoYnl0ZXMubGVuZ3RoICUgV29yZFNpemUpLCBieXRlc10pKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIENvZGVyIHtcbiAgICAvLyBUaGUgY29kZXIgbmFtZTpcbiAgICAvLyAgIC0gYWRkcmVzcywgdWludDI1NiwgdHVwbGUsIGFycmF5LCBldGMuXG4gICAgbmFtZTtcbiAgICAvLyBUaGUgZnVsbHkgZXhwYW5kZWQgdHlwZSwgaW5jbHVkaW5nIGNvbXBvc2l0ZSB0eXBlczpcbiAgICAvLyAgIC0gYWRkcmVzcywgdWludDI1NiwgdHVwbGUoYWRkcmVzcyxieXRlcyksIHVpbnQyNTZbM11bNF1bXSwgIGV0Yy5cbiAgICB0eXBlO1xuICAgIC8vIFRoZSBsb2NhbE5hbWUgYm91bmQgaW4gdGhlIHNpZ25hdHVyZSwgaW4gdGhpcyBleGFtcGxlIGl0IGlzIFwiYmF6XCI6XG4gICAgLy8gICAtIHR1cGxlKGFkZHJlc3MgZm9vLCB1aW50IGJhcikgYmF6XG4gICAgbG9jYWxOYW1lO1xuICAgIC8vIFdoZXRoZXIgdGhpcyB0eXBlIGlzIGR5bmFtaWM6XG4gICAgLy8gIC0gRHluYW1pYzogYnl0ZXMsIHN0cmluZywgYWRkcmVzc1tdLCB0dXBsZShib29sZWFuW10pLCBldGMuXG4gICAgLy8gIC0gTm90IER5bmFtaWM6IGFkZHJlc3MsIHVpbnQyNTYsIGJvb2xlYW5bM10sIHR1cGxlKGFkZHJlc3MsIHVpbnQ4KVxuICAgIGR5bmFtaWM7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJzdHJpbmdcIiwgdHlwZTogXCJzdHJpbmdcIiwgbG9jYWxOYW1lOiBcInN0cmluZ1wiLCBkeW5hbWljOiBcImJvb2xlYW5cIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Rocm93RXJyb3IobWVzc2FnZSwgdmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIG1lc3NhZ2UsIHRoaXMubG9jYWxOYW1lLCB2YWx1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIFdyaXRlciB7XG4gICAgLy8gQW4gYXJyYXkgb2YgV29yZFNpemUgbGVuZ3RoZWQgb2JqZWN0cyB0byBjb25jYXRlbmF0aW9uXG4gICAgI2RhdGE7XG4gICAgI2RhdGFMZW5ndGg7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuI2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy4jZGF0YUxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KHRoaXMuI2RhdGEpO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jZGF0YUxlbmd0aDsgfVxuICAgICN3cml0ZURhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLiNkYXRhLnB1c2goZGF0YSk7XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgYXBwZW5kV3JpdGVyKHdyaXRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy4jd3JpdGVEYXRhKGdldEJ5dGVzQ29weSh3cml0ZXIuZGF0YSkpO1xuICAgIH1cbiAgICAvLyBBcnJheWlzaCBpdGVtOyBwYWQgb24gdGhlIHJpZ2h0IHRvICpuZWFyZXN0KiBXb3JkU2l6ZVxuICAgIHdyaXRlQnl0ZXModmFsdWUpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KHZhbHVlKTtcbiAgICAgICAgY29uc3QgcGFkZGluZ09mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIFdvcmRTaXplO1xuICAgICAgICBpZiAocGFkZGluZ09mZnNldCkge1xuICAgICAgICAgICAgYnl0ZXMgPSBnZXRCeXRlc0NvcHkoY29uY2F0KFtieXRlcywgUGFkZGluZy5zbGljZShwYWRkaW5nT2Zmc2V0KV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jd3JpdGVEYXRhKGJ5dGVzKTtcbiAgICB9XG4gICAgLy8gTnVtZXJpYyBpdGVtOyBwYWQgb24gdGhlIGxlZnQgKnRvKiBXb3JkU2l6ZVxuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShnZXRWYWx1ZSh2YWx1ZSkpO1xuICAgIH1cbiAgICAvLyBJbnNlcnRzIGEgbnVtZXJpYyBwbGFjZS1ob2xkZXIsIHJldHVybmluZyBhIGNhbGxiYWNrIHRoYXQgY2FuXG4gICAgLy8gYmUgdXNlZCB0byBhc2p1c3QgdGhlIHZhbHVlIGxhdGVyXG4gICAgd3JpdGVVcGRhdGFibGVWYWx1ZSgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy4jZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMuI2RhdGEucHVzaChQYWRkaW5nKTtcbiAgICAgICAgdGhpcy4jZGF0YUxlbmd0aCArPSBXb3JkU2l6ZTtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jZGF0YVtvZmZzZXRdID0gZ2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWFkZXIge1xuICAgIC8vIEFsbG93cyBpbmNvbXBsZXRlIHVucGFkZGVkIGRhdGEgdG8gYmUgcmVhZDsgb3RoZXJ3aXNlIGFuIGVycm9yXG4gICAgLy8gaXMgcmFpc2VkIGlmIGF0dGVtcHRpbmcgdG8gb3ZlcnJ1biB0aGUgYnVmZmVyLiBUaGlzIGlzIHJlcXVpcmVkXG4gICAgLy8gdG8gZGVhbCB3aXRoIGFuIG9sZCBTb2xpZGl0eSBidWcsIGluIHdoaWNoIGV2ZW50IGRhdGEgZm9yXG4gICAgLy8gZXh0ZXJuYWwgKG5vdCBwdWJsaWMgdGhvZ3VoKSB3YXMgdGlnaHRseSBwYWNrZWQuXG4gICAgYWxsb3dMb29zZTtcbiAgICAjZGF0YTtcbiAgICAjb2Zmc2V0O1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGFsbG93TG9vc2UpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFsbG93TG9vc2U6ICEhYWxsb3dMb29zZSB9KTtcbiAgICAgICAgdGhpcy4jZGF0YSA9IGdldEJ5dGVzQ29weShkYXRhKTtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7IHJldHVybiBoZXhsaWZ5KHRoaXMuI2RhdGEpOyB9XG4gICAgZ2V0IGRhdGFMZW5ndGgoKSB7IHJldHVybiB0aGlzLiNkYXRhLmxlbmd0aDsgfVxuICAgIGdldCBjb25zdW1lZCgpIHsgcmV0dXJuIHRoaXMuI29mZnNldDsgfVxuICAgIGdldCBieXRlcygpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuI2RhdGEpOyB9XG4gICAgI3BlZWtCeXRlcyhvZmZzZXQsIGxlbmd0aCwgbG9vc2UpIHtcbiAgICAgICAgbGV0IGFsaWduZWRMZW5ndGggPSBNYXRoLmNlaWwobGVuZ3RoIC8gV29yZFNpemUpICogV29yZFNpemU7XG4gICAgICAgIGlmICh0aGlzLiNvZmZzZXQgKyBhbGlnbmVkTGVuZ3RoID4gdGhpcy4jZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93TG9vc2UgJiYgbG9vc2UgJiYgdGhpcy4jb2Zmc2V0ICsgbGVuZ3RoIDw9IHRoaXMuI2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYWxpZ25lZExlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJkYXRhIG91dC1vZi1ib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogZ2V0Qnl0ZXNDb3B5KHRoaXMuI2RhdGEpLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHRoaXMuI2RhdGEubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jZGF0YS5zbGljZSh0aGlzLiNvZmZzZXQsIHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBzdWItcmVhZGVyIHdpdGggdGhlIHNhbWUgdW5kZXJseWluZyBkYXRhLCBidXQgb2Zmc2V0XG4gICAgc3ViUmVhZGVyKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlYWRlcih0aGlzLiNkYXRhLnNsaWNlKHRoaXMuI29mZnNldCArIG9mZnNldCksIHRoaXMuYWxsb3dMb29zZSk7XG4gICAgfVxuICAgIC8vIFJlYWQgYnl0ZXNcbiAgICByZWFkQnl0ZXMobGVuZ3RoLCBsb29zZSkge1xuICAgICAgICBsZXQgYnl0ZXMgPSB0aGlzLiNwZWVrQnl0ZXMoMCwgbGVuZ3RoLCAhIWxvb3NlKTtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgLy8gQFRPRE86IE1ha2Ugc3VyZSB0aGUgbGVuZ3RoLi5lbmQgYnl0ZXMgYXJlIGFsbCAwP1xuICAgICAgICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gUmVhZCBhIG51bWVyaWMgdmFsdWVzXG4gICAgcmVhZFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdG9CaWdJbnQodGhpcy5yZWFkQnl0ZXMoV29yZFNpemUpKTtcbiAgICB9XG4gICAgcmVhZEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdG9OdW1iZXIodGhpcy5yZWFkQnl0ZXMoV29yZFNpemUpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1jb2Rlci5qcy5tYXAiLCJmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmZ1bmN0aW9uIGhhc2goaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydCB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCIsImV4cG9ydCBjb25zdCBjcnlwdG8gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCIsIi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuZXhwb3J0IGNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBpZiAoIXU4YShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBVaW50OEFycmF5LCBnb3QgJHt0eXBlb2YgZGF0YX1gKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmxlbmd0aCwgMCkpO1xuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gICAgYXJyYXlzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaWYgKCF1OGEoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByO1xufVxuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmV4cG9ydCBjbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmNvbnN0IHRvU3RyID0ge30udG9TdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiB0b1N0ci5jYWxsKG9wdHMpICE9PSAnW29iamVjdCBPYmplY3RdJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsImltcG9ydCB7IGhhc2ggYXMgYXNzZXJ0SGFzaCwgYnl0ZXMgYXMgYXNzZXJ0Qnl0ZXMsIGV4aXN0cyBhcyBhc3NlcnRFeGlzdHMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gSE1BQyAoUkZDIDIxMDQpXG5leHBvcnQgY2xhc3MgSE1BQyBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIF9rZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICBhc3NlcnRIYXNoKGhhc2gpO1xuICAgICAgICBjb25zdCBrZXkgPSB0b0J5dGVzKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIHBhZC5maWxsKDApO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgIGFzc2VydEV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFzc2VydEV4aXN0cyh0aGlzKTtcbiAgICAgICAgYXNzZXJ0Qnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCIsImltcG9ydCB7IGV4aXN0cywgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIGNyZWF0ZVZpZXcsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBCYXNlIFNIQTIgY2xhc3MgKFJGQyA2MjM0KVxuZXhwb3J0IGNsYXNzIFNIQTIgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIG91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gY3JlYXRlVmlldyhvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaGEyLmpzLm1hcCIsImltcG9ydCB7IFNIQTIgfSBmcm9tICcuL19zaGEyLmpzJztcbmltcG9ydCB7IHJvdHIsIHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMi0yNTYgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzIHRvIGV4ZWN1dGUgYmlydGhkYXkgYXR0YWNrLlxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5jb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IElWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IElWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBJVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IElWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBJVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IElWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gcm90cihXMTUsIDcpIF4gcm90cihXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSByb3RyKEUsIDYpIF4gcm90cihFLCAxMSkgXiByb3RyKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSByb3RyKEEsIDIpIF4gcm90cihBLCAxMykgXiByb3RyKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn1cbi8vIENvbnN0YW50cyBmcm9tIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGZcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiLCJjb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB7IGZyb21CaWcsIHNwbGl0LCB0b0JpZywgc2hyU0gsIHNoclNMLCByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsIHJvdHIzMkgsIHJvdHIzMkwsIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCwgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLCB9O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIiwiaW1wb3J0IHsgYnl0ZXMsIGV4aXN0cywgbnVtYmVyLCBvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgcm90bEJILCByb3RsQkwsIHJvdGxTSCwgcm90bFNMLCBzcGxpdCB9IGZyb20gJy4vX3U2NC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB1MzIsIHRvQnl0ZXMsIHdyYXBDb25zdHJ1Y3Rvciwgd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBTSEEzIChrZWNjYWspIGlzIGJhc2VkIG9uIGEgbmV3IGRlc2lnbjogYmFzaWNhbGx5LCB0aGUgaW50ZXJuYWwgc3RhdGUgaXMgYmlnZ2VyIHRoYW4gb3V0cHV0IHNpemUuXG4vLyBJdCdzIGNhbGxlZCBhIHNwb25nZSBmdW5jdGlvbi5cbi8vIFZhcmlvdXMgcGVyIHJvdW5kIGNvbnN0YW50cyBjYWxjdWxhdGlvbnNcbmNvbnN0IFtTSEEzX1BJLCBTSEEzX1JPVEwsIF9TSEEzX0lPVEFdID0gW1tdLCBbXSwgW11dO1xuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpO1xuY29uc3QgXzduID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg3KTtcbmNvbnN0IF8yNTZuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyNTYpO1xuY29uc3QgXzB4NzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgweDcxKTtcbmZvciAobGV0IHJvdW5kID0gMCwgUiA9IF8xbiwgeCA9IDEsIHkgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgLy8gUGlcbiAgICBbeCwgeV0gPSBbeSwgKDIgKiB4ICsgMyAqIHkpICUgNV07XG4gICAgU0hBM19QSS5wdXNoKDIgKiAoNSAqIHkgKyB4KSk7XG4gICAgLy8gUm90YXRpb25hbFxuICAgIFNIQTNfUk9UTC5wdXNoKCgoKHJvdW5kICsgMSkgKiAocm91bmQgKyAyKSkgLyAyKSAlIDY0KTtcbiAgICAvLyBJb3RhXG4gICAgbGV0IHQgPSBfMG47XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgUiA9ICgoUiA8PCBfMW4pIF4gKChSID4+IF83bikgKiBfMHg3MW4pKSAlIF8yNTZuO1xuICAgICAgICBpZiAoUiAmIF8ybilcbiAgICAgICAgICAgIHQgXj0gXzFuIDw8ICgoXzFuIDw8IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoaikpIC0gXzFuKTtcbiAgICB9XG4gICAgX1NIQTNfSU9UQS5wdXNoKHQpO1xufVxuY29uc3QgW1NIQTNfSU9UQV9ILCBTSEEzX0lPVEFfTF0gPSAvKiBAX19QVVJFX18gKi8gc3BsaXQoX1NIQTNfSU9UQSwgdHJ1ZSk7XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkgoaCwgbCwgcykgOiByb3RsU0goaCwgbCwgcykpO1xuY29uc3Qgcm90bEwgPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/IHJvdGxCTChoLCBsLCBzKSA6IHJvdGxTTChoLCBsLCBzKSk7XG4vLyBTYW1lIGFzIGtlY2Nha2YxNjAwLCBidXQgYWxsb3dzIHRvIHNraXAgc29tZSByb3VuZHNcbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWtQKHMsIHJvdW5kcyA9IDI0KSB7XG4gICAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheSg1ICogMik7XG4gICAgLy8gTk9URTogYWxsIGluZGljZXMgYXJlIHgyIHNpbmNlIHdlIHN0b3JlIHN0YXRlIGFzIHUzMiBpbnN0ZWFkIG9mIHU2NCAoYmlnaW50cyB0byBzbG93IGluIGpzKVxuICAgIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAgICAgLy8gVGhldGEgzrhcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgQlt4XSA9IHNbeF0gXiBzW3ggKyAxMF0gXiBzW3ggKyAyMF0gXiBzW3ggKyAzMF0gXiBzW3ggKyA0MF07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHggKz0gMikge1xuICAgICAgICAgICAgY29uc3QgaWR4MSA9ICh4ICsgOCkgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IGlkeDAgPSAoeCArIDIpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBCMCA9IEJbaWR4MF07XG4gICAgICAgICAgICBjb25zdCBCMSA9IEJbaWR4MCArIDFdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChCMCwgQjEsIDEpIF4gQltpZHgxXTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoQjAsIEIxLCAxKSBeIEJbaWR4MSArIDFdO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgICAgIHNbeCArIHldIF49IFRoO1xuICAgICAgICAgICAgICAgIHNbeCArIHkgKyAxXSBePSBUbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSaG8gKM+BKSBhbmQgUGkgKM+AKVxuICAgICAgICBsZXQgY3VySCA9IHNbMl07XG4gICAgICAgIGxldCBjdXJMID0gc1szXTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaGlmdCA9IFNIQTNfUk9UTFt0XTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBQSSA9IFNIQTNfUElbdF07XG4gICAgICAgICAgICBjdXJIID0gc1tQSV07XG4gICAgICAgICAgICBjdXJMID0gc1tQSSArIDFdO1xuICAgICAgICAgICAgc1tQSV0gPSBUaDtcbiAgICAgICAgICAgIHNbUEkgKyAxXSA9IFRsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoaSAoz4cpXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBCW3hdID0gc1t5ICsgeF07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgc1t5ICsgeF0gXj0gfkJbKHggKyAyKSAlIDEwXSAmIEJbKHggKyA0KSAlIDEwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJb3RhICjOuSlcbiAgICAgICAgc1swXSBePSBTSEEzX0lPVEFfSFtyb3VuZF07XG4gICAgICAgIHNbMV0gXj0gU0hBM19JT1RBX0xbcm91bmRdO1xuICAgIH1cbiAgICBCLmZpbGwoMCk7XG59XG5leHBvcnQgY2xhc3MgS2VjY2FrIGV4dGVuZHMgSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICBudW1iZXIob3V0cHV0TGVuKTtcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xuICAgICAgICBpZiAoMCA+PSB0aGlzLmJsb2NrTGVuIHx8IHRoaXMuYmxvY2tMZW4gPj0gMjAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGEzIHN1cHBvcnRzIG9ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xuICAgICAgICB0aGlzLnN0YXRlMzIgPSB1MzIodGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIGtlY2NhaygpIHtcbiAgICAgICAga2VjY2FrUCh0aGlzLnN0YXRlMzIsIHRoaXMucm91bmRzKTtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2U7IGkrKylcbiAgICAgICAgICAgICAgICBzdGF0ZVt0aGlzLnBvcysrXSBePSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUsIHN1ZmZpeCwgcG9zLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgLy8gRG8gdGhlIHBhZGRpbmdcbiAgICAgICAgc3RhdGVbcG9zXSBePSBzdWZmaXg7XG4gICAgICAgIGlmICgoc3VmZml4ICYgMHg4MCkgIT09IDAgJiYgcG9zID09PSBibG9ja0xlbiAtIDEpXG4gICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICBzdGF0ZVtibG9ja0xlbiAtIDFdIF49IDB4ODA7XG4gICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgfVxuICAgIHdyaXRlSW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgYnl0ZXMob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgIG51bWJlcihieXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnhvZkludG8obmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgcm91bmRzLCBlbmFibGVYT0YgfSA9IHRoaXM7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xuICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0by5wb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcbiAgICAgICAgdG8ucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBTdWZmaXggY2FuIGNoYW5nZSBpbiBjU0hBS0VcbiAgICAgICAgdG8uc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5jb25zdCBnZW4gPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4pKTtcbmV4cG9ydCBjb25zdCBzaGEzXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICogU0hBMy0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhM18yNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDEzNiwgMjU2IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hhM18zODQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hhM181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfMjI0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBrZWNjYWstMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIFNIQTMtMjU2LlxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfMzg0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCAxMDQsIDM4NCAvIDgpO1xuZXhwb3J0IGNvbnN0IGtlY2Nha181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDcyLCA1MTIgLyA4KTtcbmNvbnN0IGdlblNoYWtlID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XG5leHBvcnQgY29uc3Qgc2hha2UxMjggPSAvKiBAX19QVVJFX18gKi8gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KTtcbmV4cG9ydCBjb25zdCBzaGFrZTI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW5TaGFrZSgweDFmLCAxMzYsIDI1NiAvIDgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMy5qcy5tYXAiLCIvKipcbiAqICBDcnlwdG9ncmFwaGljIGhhc2hpbmcgZnVuY3Rpb25zXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpIYXNoIEZ1bmN0aW9ucyBbYWJvdXQtY3J5cHRvLWhhc2hpbmddXG4gKi9cbmltcG9ydCB7IGtlY2Nha18yNTYgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX2tlY2NhazI1NiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIGtlY2Nha18yNTYoZGF0YSk7XG59O1xubGV0IF9fa2VjY2FrMjU2ID0gX2tlY2NhazI1Njtcbi8qKlxuICogIENvbXB1dGUgdGhlIGNyeXB0b2dyYXBoaWMgS0VDQ0FLMjU2IGhhc2ggb2YgJSVkYXRhJSUuXG4gKlxuICogIFRoZSAlJWRhdGElJSAqKm11c3QqKiBiZSBhIGRhdGEgcmVwcmVzZW50YXRpb24sIHRvIGNvbXB1dGUgdGhlXG4gKiAgaGFzaCBvZiBVVEYtOCBkYXRhIHVzZSB0aGUgW1tpZF1dIGZ1bmN0aW9uLlxuICpcbiAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBrZWNjYWsyNTYoXCIweFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIGtlY2NhazI1NihcIjB4MTMzN1wiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIGtlY2NhazI1NihuZXcgVWludDhBcnJheShbIDB4MTMsIDB4MzcgXSkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gU3RyaW5ncyBhcmUgYXNzdW1lZCB0byBiZSBEYXRhSGV4U3RyaW5nLCBvdGhlcndpc2UgaXQgd2lsbFxuICogICAgLy8gdGhyb3cuIFRvIGhhc2ggVVRGLTggZGF0YSwgc2VlIHRoZSBub3RlIGFib3ZlLlxuICogICAga2VjY2FrMjU2KFwiSGVsbG8gV29ybGRcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrMjU2KF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XG4gICAgcmV0dXJuIGhleGxpZnkoX19rZWNjYWsyNTYoZGF0YSkpO1xufVxua2VjY2FrMjU2Ll8gPSBfa2VjY2FrMjU2O1xua2VjY2FrMjU2LmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZCA9IHRydWU7IH07XG5rZWNjYWsyNTYucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtlY2NhazI1NiBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fa2VjY2FrMjU2ID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKGtlY2NhazI1Nik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZWNjYWsuanMubWFwIiwiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh1OGEoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGIxLCBiMikge1xuICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgdGltaW5nIGF0dGFja3MgaGVyZVxuICAgIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYjEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChiMVtpXSAhPT0gYjJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGJpdFNldCA9IChuLCBwb3MsIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgXCIke3R5cGV9XCIsIGV4cGVjdGVkIGZ1bmN0aW9uYCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSAke1N0cmluZyhmaWVsZE5hbWUpfT0ke3ZhbH0gKCR7dHlwZW9mIHZhbH0pLCBleHBlY3RlZCAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBVdGlsaXRpZXMgZm9yIG1vZHVsYXIgYXJpdGhtZXRpY3MgYW5kIGZpbml0ZSBmaWVsZHNcbmltcG9ydCB7IGJpdE1hc2ssIG51bWJlclRvQnl0ZXNCRSwgbnVtYmVyVG9CeXRlc0xFLCBieXRlc1RvTnVtYmVyQkUsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIHZhbGlkYXRlT2JqZWN0LCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF80biA9IEJpZ0ludCg0KSwgXzVuID0gQmlnSW50KDUpLCBfOG4gPSBCaWdJbnQoOCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF85biA9IEJpZ0ludCg5KSwgXzE2biA9IEJpZ0ludCgxNik7XG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcbmV4cG9ydCBmdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogQGV4YW1wbGVcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG4gKi9cbi8vIFRPRE86IHVzZSBmaWVsZCB2ZXJzaW9uICYmIHJlbW92ZVxuZXhwb3J0IGZ1bmN0aW9uIHBvdyhudW0sIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBpZiAobW9kdWxvIDw9IF8wbiB8fCBwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlci9tb2R1bG8gPiAwJyk7XG4gICAgaWYgKG1vZHVsbyA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gXzBuO1xuICAgIGxldCByZXMgPSBfMW47XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHJlcyA9IChyZXMgKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBudW0gPSAobnVtICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIERvZXMgeCBeICgyIF4gcG93ZXIpIG1vZCBwLiBwb3cyKDMwLCA0KSA9PSAzMCBeICgyIF4gNClcbmV4cG9ydCBmdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gSW52ZXJzZXMgbnVtYmVyIG92ZXIgbW9kdWxvXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuIHx8IG1vZHVsbyA8PSBfMG4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJzLCBnb3Qgbj0ke251bWJlcn0gbW9kPSR7bW9kdWxvfWApO1xuICAgIH1cbiAgICAvLyBFdWNsaWRlYW4gR0NEIGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vXG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG4vKipcbiAqIFRvbmVsbGktU2hhbmtzIHNxdWFyZSByb290IHNlYXJjaCBhbGdvcml0aG0uXG4gKiAxLiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTIpXG4gKiAyLiBTcXVhcmUgUm9vdHMgZnJvbSAxOyAyNCwgNTEsIDEwIHRvIERhbiBTaGFua3NcbiAqIFdpbGwgc3RhcnQgYW4gaW5maW5pdGUgbG9vcCBpZiBmaWVsZCBvcmRlciBQIGlzIG5vdCBwcmltZS5cbiAqIEBwYXJhbSBQIGZpZWxkIG9yZGVyXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHRha2VzIGZpZWxkIEZwIChjcmVhdGVkIGZyb20gUCkgYW5kIG51bWJlciBuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b25lbGxpU2hhbmtzKFApIHtcbiAgICAvLyBMZWdlbmRyZSBjb25zdGFudDogdXNlZCB0byBjYWxjdWxhdGUgTGVnZW5kcmUgc3ltYm9sIChhIHwgcCksXG4gICAgLy8gd2hpY2ggZGVub3RlcyB0aGUgdmFsdWUgb2YgYV4oKHAtMSkvMikgKG1vZCBwKS5cbiAgICAvLyAoYSB8IHApIOKJoSAxICAgIGlmIGEgaXMgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gICAgY29uc3QgbGVnZW5kcmVDID0gKFAgLSBfMW4pIC8gXzJuO1xuICAgIGxldCBRLCBTLCBaO1xuICAgIC8vIFN0ZXAgMTogQnkgZmFjdG9yaW5nIG91dCBwb3dlcnMgb2YgMiBmcm9tIHAgLSAxLFxuICAgIC8vIGZpbmQgcSBhbmQgcyBzdWNoIHRoYXQgcCAtIDEgPSBxKigyXnMpIHdpdGggcSBvZGRcbiAgICBmb3IgKFEgPSBQIC0gXzFuLCBTID0gMDsgUSAlIF8ybiA9PT0gXzBuOyBRIC89IF8ybiwgUysrKVxuICAgICAgICA7XG4gICAgLy8gU3RlcCAyOiBTZWxlY3QgYSBub24tc3F1YXJlIHogc3VjaCB0aGF0ICh6IHwgcCkg4omhIC0xIGFuZCBzZXQgYyDiiaEgenFcbiAgICBmb3IgKFogPSBfMm47IFogPCBQICYmIHBvdyhaLCBsZWdlbmRyZUMsIFApICE9PSBQIC0gXzFuOyBaKyspXG4gICAgICAgIDtcbiAgICAvLyBGYXN0LXBhdGhcbiAgICBpZiAoUyA9PT0gMSkge1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpRmFzdChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gU2xvdy1wYXRoXG4gICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpU2xvdyhGcCwgbikge1xuICAgICAgICAvLyBTdGVwIDA6IENoZWNrIHRoYXQgbiBpcyBpbmRlZWQgYSBzcXVhcmU6IChuIHwgcCkgc2hvdWxkIG5vdCBiZSDiiaEgLTFcbiAgICAgICAgaWYgKEZwLnBvdyhuLCBsZWdlbmRyZUMpID09PSBGcC5uZWcoRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgbGV0IHIgPSBTO1xuICAgICAgICAvLyBUT0RPOiB3aWxsIGZhaWwgYXQgRnAyL2V0Y1xuICAgICAgICBsZXQgZyA9IEZwLnBvdyhGcC5tdWwoRnAuT05FLCBaKSwgUSk7IC8vIHdpbGwgdXBkYXRlIGJvdGggeCBhbmQgYlxuICAgICAgICBsZXQgeCA9IEZwLnBvdyhuLCBRMWRpdjIpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgc3F1YXJlIHJvb3RcbiAgICAgICAgbGV0IGIgPSBGcC5wb3cobiwgUSk7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3JcbiAgICAgICAgd2hpbGUgKCFGcC5lcWwoYiwgRnAuT05FKSkge1xuICAgICAgICAgICAgaWYgKEZwLmVxbChiLCBGcC5aRVJPKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnAuWkVSTzsgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9uZWxsaSVFMiU4MCU5M1NoYW5rc19hbGdvcml0aG0gKDQuIElmIHQgPSAwLCByZXR1cm4gciA9IDApXG4gICAgICAgICAgICAvLyBGaW5kIG0gc3VjaCBiXigyXm0pPT0xXG4gICAgICAgICAgICBsZXQgbSA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCB0MiA9IEZwLnNxcihiKTsgbSA8IHI7IG0rKykge1xuICAgICAgICAgICAgICAgIGlmIChGcC5lcWwodDIsIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHQyID0gRnAuc3FyKHQyKTsgLy8gdDIgKj0gdDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEU6IHItbS0xIGNhbiBiZSBiaWdnZXIgdGhhbiAzMiwgbmVlZCB0byBjb252ZXJ0IHRvIGJpZ2ludCBiZWZvcmUgc2hpZnQsIG90aGVyd2lzZSB0aGVyZSB3aWxsIGJlIG92ZXJmbG93XG4gICAgICAgICAgICBjb25zdCBnZSA9IEZwLnBvdyhnLCBfMW4gPDwgQmlnSW50KHIgLSBtIC0gMSkpOyAvLyBnZSA9IDJeKHItbS0xKVxuICAgICAgICAgICAgZyA9IEZwLnNxcihnZSk7IC8vIGcgPSBnZSAqIGdlXG4gICAgICAgICAgICB4ID0gRnAubXVsKHgsIGdlKTsgLy8geCAqPSBnZVxuICAgICAgICAgICAgYiA9IEZwLm11bChiLCBnKTsgLy8gYiAqPSBnXG4gICAgICAgICAgICByID0gbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgLy8gTk9URTogZGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuICAgIC8vIEZvciBleGFtcGxlIHRoZXJlIGlzIEZwU3FydE9kZC9GcFNxcnRFdmVuIHRvIGNob2ljZSByb290IGJhc2VkIG9uIG9kZG5lc3MgKHVzZWQgZm9yIGhhc2gtdG8tY3VydmUpLlxuICAgIC8vIFAg4omhIDMgKG1vZCA0KVxuICAgIC8vIOKImm4gPSBuXigoUCsxKS80KVxuICAgIGlmIChQICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gTm90IGFsbCByb290cyBwb3NzaWJsZSFcbiAgICAgICAgLy8gY29uc3QgT1JERVIgPVxuICAgICAgICAvLyAgIDB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFibjtcbiAgICAgICAgLy8gY29uc3QgTlVNID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0M21vZDQoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIC8vIFRocm93IGlmIHJvb3QqKjIgIT0gblxuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQXRraW4gYWxnb3JpdGhtIGZvciBxIOKJoSA1IChtb2QgOCksIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMClcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKSB7XG4gICAgICAgIGNvbnN0IGMxID0gKFAgLSBfNW4pIC8gXzhuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xuICAgICAgICAgICAgY29uc3QgdiA9IEZwLnBvdyhuMiwgYzEpO1xuICAgICAgICAgICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gICAgICAgICAgICBjb25zdCBpID0gRnAubXVsKEZwLm11bChudiwgXzJuKSwgdik7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQIOKJoSA5IChtb2QgMTYpXG4gICAgaWYgKFAgJSBfMTZuID09PSBfOW4pIHtcbiAgICAgICAgLy8gTk9URTogdG9uZWxsaSBpcyB0b28gc2xvdyBmb3IgYmxzLUZwMiBjYWxjdWxhdGlvbnMgZXZlbiBvbiBzdGFydFxuICAgICAgICAvLyBNZWFucyB3ZSBjYW5ub3QgdXNlIHNxcnQgZm9yIGNvbnN0YW50cyBhdCBhbGwhXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGNvbnN0IGMxID0gRnAuc3FydChGcC5uZWdhdGUoRnAuT05FKSk7IC8vICAxLiBjMSA9IHNxcnQoLTEpIGluIEYsIGkuZS4sIChjMV4yKSA9PSAtMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMyID0gRnAuc3FydChjMSk7ICAgICAgICAgICAgICAgIC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMzID0gRnAuc3FydChGcC5uZWdhdGUoYzEpKTsgICAgIC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzQgPSAoUCArIF83bikgLyBfMTZuOyAgICAgICAgICAgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICAvLyBzcXJ0ID0gKHgpID0+IHtcbiAgICAgICAgLy8gICBsZXQgdHYxID0gRnAucG93KHgsIGM0KTsgICAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcbiAgICAgICAgLy8gICBsZXQgdHYyID0gRnAubXVsKGMxLCB0djEpOyAgICAgICAgICAgLy8gIDIuIHR2MiA9IGMxICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgdHYzID0gRnAubXVsKGMyLCB0djEpOyAgICAgICAgIC8vICAzLiB0djMgPSBjMiAqIHR2MVxuICAgICAgICAvLyAgIGxldCB0djQgPSBGcC5tdWwoYzMsIHR2MSk7ICAgICAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCBlMSA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMiA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYzKSwgeCk7IC8vICA2LiAgZTIgPSAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7IC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMyA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA5LiAgZTMgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICByZXR1cm4gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAgMTAuICB6ID0gQ01PVih0djEsIHR2MiwgZTMpICAjIFNlbGVjdCB0aGUgc3FydCBmcm9tIHR2MSBhbmQgdHYyXG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgLy8gT3RoZXIgY2FzZXM6IFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICAgIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xufVxuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bSwgbW9kdWxvKSA9PiAobW9kKG51bSwgbW9kdWxvKSAmIF8xbikgPT09IF8xbjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRklFTERfRklFTERTID0gW1xuICAgICdjcmVhdGUnLCAnaXNWYWxpZCcsICdpczAnLCAnbmVnJywgJ2ludicsICdzcXJ0JywgJ3NxcicsXG4gICAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcbl07XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICAgIE9SREVSOiAnYmlnaW50JyxcbiAgICAgICAgTUFTSzogJ2JpZ2ludCcsXG4gICAgICAgIEJZVEVTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIEJJVFM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KGZpZWxkLCBvcHRzKTtcbn1cbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG4vKipcbiAqIFNhbWUgYXMgYHBvd2AgYnV0IGZvciBGcDogbm9uLWNvbnN0YW50LXRpbWUuXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFBvdyhmLCBudW0sIHBvd2VyKSB7XG4gICAgLy8gU2hvdWxkIGhhdmUgc2FtZSBzcGVlZCBhcyBwb3cgZm9yIGJpZ2ludHNcbiAgICAvLyBUT0RPOiBiZW5jaG1hcmshXG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyID4gMCcpO1xuICAgIGlmIChwb3dlciA9PT0gXzBuKVxuICAgICAgICByZXR1cm4gZi5PTkU7XG4gICAgaWYgKHBvd2VyID09PSBfMW4pXG4gICAgICAgIHJldHVybiBudW07XG4gICAgbGV0IHAgPSBmLk9ORTtcbiAgICBsZXQgZCA9IG51bTtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcCA9IGYubXVsKHAsIGQpO1xuICAgICAgICBkID0gZi5zcXIoZCk7XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSBpbnZlcnQgYW4gYXJyYXkgb2YgRmllbGQgZWxlbWVudHMuXG4gKiBgaW52KDApYCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBoZXJlOiBtYWtlIHN1cmUgdG8gdGhyb3cgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcEludmVydEJhdGNoKGYsIG51bXMpIHtcbiAgICBjb25zdCB0bXAgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBmLk9ORSk7XG4gICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxuICAgIGNvbnN0IGludmVydGVkID0gZi5pbnYobGFzdE11bHRpcGxpZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHRtcDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcERpdihmLCBsaHMsIHJocykge1xuICAgIHJldHVybiBmLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gaW52ZXJ0KHJocywgZi5PUkRFUikgOiBmLmludihyaHMpKTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZXhwb3J0IGZ1bmN0aW9uIEZwSXNTcXVhcmUoZikge1xuICAgIGNvbnN0IGxlZ2VuZHJlQ29uc3QgPSAoZi5PUkRFUiAtIF8xbikgLyBfMm47IC8vIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIHJldHVybiAoeCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gZi5wb3coeCwgbGVnZW5kcmVDb25zdCk7XG4gICAgICAgIHJldHVybiBmLmVxbChwLCBmLlpFUk8pIHx8IGYuZXFsKHAsIGYuT05FKTtcbiAgICB9O1xufVxuLy8gQ1VSVkUubiBsZW5ndGhzXG5leHBvcnQgZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XG4gICAgLy8gQml0IHNpemUsIGJ5dGUgc2l6ZSBvZiBDVVJWRS5uXG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBmaW5pdGUgZmllbGQgb3ZlciBwcmltZS4gKipOb24tcHJpbWVzIGFyZSBub3Qgc3VwcG9ydGVkLioqXG4gKiBEbyBub3QgaW5pdCBpbiBsb29wOiBzbG93LiBWZXJ5IGZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBNYWpvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zOlxuICogKiBhKSBkZW5vcm1hbGl6ZWQgb3BlcmF0aW9ucyBsaWtlIG11bE4gaW5zdGVhZCBvZiBtdWxcbiAqICogYikgc2FtZSBvYmplY3Qgc2hhcGU6IG5ldmVyIGFkZCBvciByZW1vdmUga2V5c1xuICogKiBjKSBPYmplY3QuZnJlZXplXG4gKiBAcGFyYW0gT1JERVIgcHJpbWUgcG9zaXRpdmUgYmlnaW50XG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmOiBmYWxzZSkgaWYgZW5jb2RpbmcgLyBkZWNvZGluZyBzaG91bGQgYmUgaW4gbGl0dGxlLWVuZGlhblxuICogQHBhcmFtIHJlZGVmIG9wdGlvbmFsIGZhc3RlciByZWRlZmluaXRpb25zIG9mIHNxcnQgYW5kIG90aGVyIG1ldGhvZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZpZWxkKE9SREVSLCBiaXRMZW4sIGlzTEUgPSBmYWxzZSwgcmVkZWYgPSB7fSkge1xuICAgIGlmIChPUkRFUiA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgRmllbGQgT1JERVIgPiAwLCBnb3QgJHtPUkRFUn1gKTtcbiAgICBjb25zdCB7IG5CaXRMZW5ndGg6IEJJVFMsIG5CeXRlTGVuZ3RoOiBCWVRFUyB9ID0gbkxlbmd0aChPUkRFUiwgYml0TGVuKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkIGxlbmd0aHMgb3ZlciAyMDQ4IGJ5dGVzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgY29uc3Qgc3FydFAgPSBGcFNxcnQoT1JERVIpO1xuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiBiaXRNYXNrKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAke3R5cGVvZiBudW19YCk7XG4gICAgICAgICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICAgICAgICB9LFxuICAgICAgICBpczA6IChudW0pID0+IG51bSA9PT0gXzBuLFxuICAgICAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcbiAgICAgICAgbmVnOiAobnVtKSA9PiBtb2QoLW51bSwgT1JERVIpLFxuICAgICAgICBlcWw6IChsaHMsIHJocykgPT4gbGhzID09PSByaHMsXG4gICAgICAgIHNxcjogKG51bSkgPT4gbW9kKG51bSAqIG51bSwgT1JERVIpLFxuICAgICAgICBhZGQ6IChsaHMsIHJocykgPT4gbW9kKGxocyArIHJocywgT1JERVIpLFxuICAgICAgICBzdWI6IChsaHMsIHJocykgPT4gbW9kKGxocyAtIHJocywgT1JERVIpLFxuICAgICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0sIHBvd2VyKSxcbiAgICAgICAgZGl2OiAobGhzLCByaHMpID0+IG1vZChsaHMgKiBpbnZlcnQocmhzLCBPUkRFUiksIE9SREVSKSxcbiAgICAgICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXG4gICAgICAgIHNxck46IChudW0pID0+IG51bSAqIG51bSxcbiAgICAgICAgYWRkTjogKGxocywgcmhzKSA9PiBsaHMgKyByaHMsXG4gICAgICAgIHN1Yk46IChsaHMsIHJocykgPT4gbGhzIC0gcmhzLFxuICAgICAgICBtdWxOOiAobGhzLCByaHMpID0+IGxocyAqIHJocyxcbiAgICAgICAgaW52OiAobnVtKSA9PiBpbnZlcnQobnVtLCBPUkRFUiksXG4gICAgICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHwgKChuKSA9PiBzcXJ0UChmLCBuKSksXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFRPRE86IGRvIHdlIHJlYWxseSBuZWVkIGNvbnN0YW50IGNtb3Y/XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgY29uc3QtdGltZSBiaWdpbnRzIGFueXdheSwgc28gcHJvYmFibHkgd2lsbCBiZSBub3QgdmVyeSB1c2VmdWxcbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/IG51bWJlclRvQnl0ZXNMRShudW0sIEJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0sIEJZVEVTKSksXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBCWVRFUylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZwLmZyb21CeXRlczogZXhwZWN0ZWQgJHtCWVRFU30sIGdvdCAke2J5dGVzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHJldHVybiBpc0xFID8gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSA6IGJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRFdmVuKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogU2FtZSBhcyBtYXBLZXlUb0ZpZWxkLCBidXQgYWNjZXB0cyBsZXNzIGJ5dGVzICg0MCBpbnN0ZWFkIG9mIDQ4IGZvciAzMi1ieXRlIGZpZWxkKS5cbiAqIFdoaWNoIG1ha2VzIGl0IHNsaWdodGx5IG1vcmUgYmlhc2VkLCBsZXNzIHNlY3VyZS5cbiAqIEBkZXByZWNhdGVkIHVzZSBtYXBLZXlUb0ZpZWxkIGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hUb1ByaXZhdGVTY2FsYXIoaGFzaCwgZ3JvdXBPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgaGFzaCA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlSGFzaCcsIGhhc2gpO1xuICAgIGNvbnN0IGhhc2hMZW4gPSBoYXNoLmxlbmd0aDtcbiAgICBjb25zdCBtaW5MZW4gPSBuTGVuZ3RoKGdyb3VwT3JkZXIpLm5CeXRlTGVuZ3RoICsgODtcbiAgICBpZiAobWluTGVuIDwgMjQgfHwgaGFzaExlbiA8IG1pbkxlbiB8fCBoYXNoTGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBoYXNoVG9Qcml2YXRlU2NhbGFyOiBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7aGFzaExlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckxFKGhhc2gpIDogYnl0ZXNUb051bWJlckJFKGhhc2gpO1xuICAgIHJldHVybiBtb2QobnVtLCBncm91cE9yZGVyIC0gXzFuKSArIF8xbjtcbn1cbi8qKlxuICogUmV0dXJucyB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgY29uc3VtZWQgYnkgdGhlIGZpZWxkIGVsZW1lbnQuXG4gKiBGb3IgZXhhbXBsZSwgMzIgYnl0ZXMgZm9yIHVzdWFsIDI1Ni1iaXQgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgZmllbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGlmICh0eXBlb2YgZmllbGRPcmRlciAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnQnKTtcbiAgICBjb25zdCBiaXRMZW5ndGggPSBmaWVsZE9yZGVyLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGJpdExlbmd0aCAvIDgpO1xufVxuLyoqXG4gKiBSZXR1cm5zIG1pbmltYWwgYW1vdW50IG9mIGJ5dGVzIHRoYXQgY2FuIGJlIHNhZmVseSByZWR1Y2VkXG4gKiBieSBmaWVsZCBvcmRlci5cbiAqIFNob3VsZCBiZSAyXi0xMjggZm9yIDEyOC1iaXQgY3VydmUgc3VjaCBhcyBQMjU2LlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIHRhcmdldCBoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIHJldHVybiBsZW5ndGggKyBNYXRoLmNlaWwobGVuZ3RoIC8gMik7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIENhbiB0YWtlIChuICsgbi8yKSBvciBtb3JlIGJ5dGVzIG9mIHVuaWZvcm0gaW5wdXQgZS5nLiBmcm9tIENTUFJORyBvciBLREZcbiAqIGFuZCBjb252ZXJ0IHRoZW0gaW50byBwcml2YXRlIHNjYWxhciwgd2l0aCB0aGUgbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAqIE5lZWRzIGF0IGxlYXN0IDQ4IGJ5dGVzIG9mIGlucHV0IGZvciAzMi1ieXRlIHByaXZhdGUga2V5LlxuICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXG4gKiBGSVBTIDE4Ni01LCBBLjIgaHR0cHM6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9kZXRhaWwvZmlwcy8xODYvNS9maW5hbFxuICogUkZDIDkzODAsIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNVxuICogQHBhcmFtIGhhc2ggaGFzaCBvdXRwdXQgZnJvbSBTSEEzIG9yIGEgc2ltaWxhciBmdW5jdGlvblxuICogQHBhcmFtIGdyb3VwT3JkZXIgc2l6ZSBvZiBzdWJncm91cCAtIChlLmcuIHNlY3AyNTZrMS5DVVJWRS5uKVxuICogQHBhcmFtIGlzTEUgaW50ZXJwcmV0IGhhc2ggYnl0ZXMgYXMgTEUgbnVtXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwSGFzaFRvRmllbGQoa2V5LCBmaWVsZE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIGNvbnN0IGZpZWxkTGVuID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICBjb25zdCBtaW5MZW4gPSBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIC8vIE5vIHNtYWxsIG51bWJlcnM6IG5lZWQgdG8gdW5kZXJzdGFuZCBiaWFzIHN0b3J5LiBObyBodWdlIG51bWJlcnM6IGVhc2llciB0byBkZXRlY3QgSlMgdGltaW5ncy5cbiAgICBpZiAobGVuIDwgMTYgfHwgbGVuIDwgbWluTGVuIHx8IGxlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2xlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckJFKGtleSkgOiBieXRlc1RvTnVtYmVyTEUoa2V5KTtcbiAgICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4gICAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICAgIHJldHVybiBpc0xFID8gbnVtYmVyVG9CeXRlc0xFKHJlZHVjZWQsIGZpZWxkTGVuKSA6IG51bWJlclRvQnl0ZXNCRShyZWR1Y2VkLCBmaWVsZExlbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGFyLmpzLm1hcCIsIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIEFiZWxpYW4gZ3JvdXAgdXRpbGl0aWVzXG5pbXBvcnQgeyB2YWxpZGF0ZUZpZWxkLCBuTGVuZ3RoIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG4vLyBFbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBvZiBQb2ludCBieSBzY2FsYXIuIEZyYWdpbGUuXG4vLyBTY2FsYXJzIHNob3VsZCBhbHdheXMgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyOiB0aGlzIHNob3VsZCBiZSBjaGVja2VkIGluc2lkZSBvZiBhIGN1cnZlIGl0c2VsZi5cbi8vIENyZWF0ZXMgcHJlY29tcHV0YXRpb24gdGFibGVzIGZvciBmYXN0IG11bHRpcGxpY2F0aW9uOlxuLy8gLSBwcml2YXRlIHNjYWxhciBpcyBzcGxpdCBieSBmaXhlZCBzaXplIHdpbmRvd3Mgb2YgVyBiaXRzXG4vLyAtIGV2ZXJ5IHdpbmRvdyBwb2ludCBpcyBjb2xsZWN0ZWQgZnJvbSB3aW5kb3cncyB0YWJsZSAmIGFkZGVkIHRvIGFjY3VtdWxhdG9yXG4vLyAtIHNpbmNlIHdpbmRvd3MgYXJlIGRpZmZlcmVudCwgc2FtZSBwb2ludCBpbnNpZGUgdGFibGVzIHdvbid0IGJlIGFjY2Vzc2VkIG1vcmUgdGhhbiBvbmNlIHBlciBjYWxjXG4vLyAtIGVhY2ggbXVsdGlwbGljYXRpb24gaXMgJ01hdGguY2VpbChDVVJWRV9PUkRFUiAvIPCdkYopICsgMScgcG9pbnQgYWRkaXRpb25zIChmaXhlZCBmb3IgYW55IHNjYWxhcilcbi8vIC0gKzEgd2luZG93IGlzIG5lY2Nlc3NhcnkgZm9yIHdOQUZcbi8vIC0gd05BRiByZWR1Y2VzIHRhYmxlIHNpemU6IDJ4IGxlc3MgbWVtb3J5ICsgMnggZmFzdGVyIGdlbmVyYXRpb24sIGJ1dCAxMCUgc2xvd2VyIG11bHRpcGxpY2F0aW9uXG4vLyBUT0RPOiBSZXNlYXJjaCByZXR1cm5pbmcgMmQgSlMgYXJyYXkgb2Ygd2luZG93cywgaW5zdGVhZCBvZiBhIHNpbmdsZSB3aW5kb3cuIFRoaXMgd291bGQgYWxsb3dcbi8vIHdpbmRvd3MgdG8gYmUgaW4gZGlmZmVyZW50IG1lbW9yeSBsb2NhdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiB3TkFGKGMsIGJpdHMpIHtcbiAgICBjb25zdCBjb25zdFRpbWVOZWdhdGUgPSAoY29uZGl0aW9uLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyBuZWcgOiBpdGVtO1xuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IChXKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoYml0cyAvIFcpICsgMTsgLy8gKzEsIGJlY2F1c2VcbiAgICAgICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgcmV0dXJuIHsgd2luZG93cywgd2luZG93U2l6ZSB9O1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxuICAgICAgICAvLyBub24tY29uc3QgdGltZSBtdWx0aXBsaWNhdGlvbiBsYWRkZXJcbiAgICAgICAgdW5zYWZlTGFkZGVyKGVsbSwgbikge1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZCA9IGVsbTtcbiAgICAgICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICAgICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAgICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgICAgICogMl4o8J2RiuKIkjEpICogKE1hdGguY2VpbCjwnZGbIC8g8J2RiikgKyAxKSwgd2hlcmU6XG4gICAgICAgICAqIC0g8J2RiiBpcyB0aGUgd2luZG93IHNpemVcbiAgICAgICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAgICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAgICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGVXaW5kb3coZWxtLCBXKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBwID0gZWxtO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBwO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICAvLyA9MSwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gYmFzZS5kb3VibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIGVjIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcbiAgICAgICAgICogQHBhcmFtIG4gc2NhbGFyICh3ZSBkb24ndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcbiAgICAgICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgd05BRihXLCBwcmVjb21wdXRlcywgbikge1xuICAgICAgICAgICAgLy8gVE9ETzogbWF5YmUgY2hlY2sgdGhhdCBzY2FsYXIgaXMgbGVzcyB0aGFuIGdyb3VwIG9yZGVyPyB3TkFGIGJlaGF2aW91cyBpcyB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBCdXQgbmVlZCB0byBjYXJlZnVsbHkgcmVtb3ZlIG90aGVyIGNoZWNrcyBiZWZvcmUgd05BRi4gT1JERVIgPT0gYml0cyBoZXJlXG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBmID0gYy5CQVNFO1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTsgLy8gQ3JlYXRlIG1hc2sgd2l0aCBXIG9uZXM6IDBiMTExMSBmb3IgVz00IGV0Yy5cbiAgICAgICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgICAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJpdHMgYXJlIGJpZ2dlciB0aGFuIG1heCBzaXplLCB3ZSdsbCBzcGxpdCB0aG9zZS5cbiAgICAgICAgICAgICAgICAvLyArMjI0ID0+IDI1NiAtIDMyXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgb250byBaZXJvIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIEFkZCByYW5kb20gcG9pbnQgaW5zaWRlIGN1cnJlbnQgd2luZG93IHRvIGYuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleVxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBKSVQtY29tcGlsZXIgc2hvdWxkIG5vdCBlbGltaW5hdGUgZiBoZXJlLCBzaW5jZSBpdCB3aWxsIGxhdGVyIGJlIHVzZWQgaW4gbm9ybWFsaXplWigpXG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB2YXJpYWJsZSBpcyBzdGlsbCB1bnVzZWQsIHRoZXJlIGFyZSBzb21lIGNoZWNrcyB3aGljaCB3aWxsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGNvbXBpbGVyIG5lZWRzIHRvIHByb3ZlIHRoZXkgd29uJ3QgaGFwcGVuLCB3aGljaCBpcyBoYXJkLlxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZChQLCBwcmVjb21wdXRlc01hcCwgbiwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBXID0gUC5fV0lORE9XX1NJWkUgfHwgMTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgICAgICAgbGV0IGNvbXAgPSBwcmVjb21wdXRlc01hcC5nZXQoUCk7XG4gICAgICAgICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KFAsIFcpO1xuICAgICAgICAgICAgICAgIGlmIChXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNvbXB1dGVzTWFwLnNldChQLCB0cmFuc2Zvcm0oY29tcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgY29tcCwgbik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGN1cnZlKSB7XG4gICAgdmFsaWRhdGVGaWVsZChjdXJ2ZS5GcCk7XG4gICAgdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgbjogJ2JpZ2ludCcsXG4gICAgICAgIGg6ICdiaWdpbnQnLFxuICAgICAgICBHeDogJ2ZpZWxkJyxcbiAgICAgICAgR3k6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBuQml0TGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIG5CeXRlTGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAuLi5uTGVuZ3RoKGN1cnZlLm4sIGN1cnZlLm5CaXRMZW5ndGgpLFxuICAgICAgICAuLi5jdXJ2ZSxcbiAgICAgICAgLi4ueyBwOiBjdXJ2ZS5GcC5PUkRFUiB9LFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VydmUuanMubWFwIiwiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gU2hvcnQgV2VpZXJzdHJhc3MgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGJcbmltcG9ydCAqIGFzIG1vZCBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0ICogYXMgdXQgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVCeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgd05BRiwgdmFsaWRhdGVCYXNpYyB9IGZyb20gJy4vY3VydmUuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kb21vcnBoaXNtIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZG8gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG4vLyBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzXG5jb25zdCB7IGJ5dGVzVG9OdW1iZXJCRTogYjJuLCBoZXhUb0J5dGVzOiBoMmIgfSA9IHV0O1xuZXhwb3J0IGNvbnN0IERFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgICAgICAgICBzdXBlcihtKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3BhcnNlSW50KGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9PSAweDAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnJyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgICAgIGNvbnN0IHJlcyA9IGRhdGEuc3ViYXJyYXkoMiwgbGVuICsgMik7XG4gICAgICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGgnKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAgICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgICAgICBpZiAocmVzWzBdICYgMGIxMDAwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICBpZiAocmVzWzBdID09PSAweDAwICYmICEocmVzWzFdICYgMGIxMDAwMDAwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgIHJldHVybiB7IGQ6IGIybihyZXMpLCBsOiBkYXRhLnN1YmFycmF5KGxlbiArIDIpIH07IC8vIGQgaXMgZGF0YSwgbCBpcyBsZWZ0XG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoMmIoaGV4KSA6IGhleDtcbiAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1aThhIGV4cGVjdGVkJyk7XG4gICAgICAgIGxldCBsID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsIDwgMiB8fCBkYXRhWzBdICE9IDB4MzApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgdGFnJyk7XG4gICAgICAgIGlmIChkYXRhWzFdICE9PSBsIC0gMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogaW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgICAgICBjb25zdCB7IGQ6IHIsIGw6IHNCeXRlcyB9ID0gREVSLl9wYXJzZUludChkYXRhLnN1YmFycmF5KDIpKTtcbiAgICAgICAgY29uc3QgeyBkOiBzLCBsOiByQnl0ZXNMZWZ0IH0gPSBERVIuX3BhcnNlSW50KHNCeXRlcyk7XG4gICAgICAgIGlmIChyQnl0ZXNMZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHIsIHMgfTtcbiAgICB9LFxuICAgIGhleEZyb21TaWcoc2lnKSB7XG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm8gaWYgZmlyc3QgYnl0ZSBoYXMgbmVnYXRpdmUgYml0IGVuYWJsZWQuIE1vcmUgZGV0YWlscyBpbiAnX3BhcnNlSW50J1xuICAgICAgICBjb25zdCBzbGljZSA9IChzKSA9PiAoTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSAmIDBiMTAwMCA/ICcwMCcgKyBzIDogcyk7XG4gICAgICAgIGNvbnN0IGggPSAobnVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzID0gc2xpY2UoaChzaWcucykpO1xuICAgICAgICBjb25zdCByID0gc2xpY2UoaChzaWcucikpO1xuICAgICAgICBjb25zdCBzaGwgPSBzLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHJobCA9IHIubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc2wgPSBoKHNobCk7XG4gICAgICAgIGNvbnN0IHJsID0gaChyaGwpO1xuICAgICAgICByZXR1cm4gYDMwJHtoKHJobCArIHNobCArIDQpfTAyJHtybH0ke3J9MDIke3NsfSR7c31gO1xuICAgIH0sXG59O1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxuICAgICAgICAoKF9jLCBwb2ludCwgX2lzQ29tcHJlc3NlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuY29uY2F0Qnl0ZXMoVWludDhBcnJheS5mcm9tKFsweDA0XSksIEZwLnRvQnl0ZXMoYS54KSwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgZnJvbUJ5dGVzID0gQ1VSVkUuZnJvbUJ5dGVzIHx8XG4gICAgICAgICgoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIGlmIChoZWFkICE9PSAweDA0KSB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbm9uLWNvbXByZXNzZWQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH0pO1xuICAgIC8qKlxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYVxuICAgICAqIEByZXR1cm5zIHnCslxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4MiAqIHhcbiAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4MyArIGEgKiB4ICsgYlxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cbiAgICAvLyBXZSBjaGVjayBpZiBjdXJ2ZSBlcXVhdGlvbiB3b3JrcyBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIC8vIGBhc3NlcnRWYWxpZGl0eSgpYCB3b24ndCB3b3JrOiBgaXNUb3JzaW9uRnJlZSgpYCBpcyBub3QgYXZhaWxhYmxlIGF0IHRoaXMgcG9pbnQgaW4gYmxzMTItMzgxLlxuICAgIC8vIFByb2plY3RpdmVQb2ludCBjbGFzcyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxuICAgIGlmICghRnAuZXFsKEZwLnNxcihDVVJWRS5HeSksIHdlaWVyc3RyYXNzRXF1YXRpb24oQ1VSVkUuR3gpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgZ2VuZXJhdG9yIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdiaWdpbnQnICYmIF8wbiA8IG51bSAmJiBudW0gPCBDVVJWRS5uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRHRShudW0pIHtcbiAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgYmlnaW50OiAwIDwgYmlnaW50IDwgY3VydmUubicpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZXMgaWYgcHJpdiBrZXkgaXMgdmFsaWQgYW5kIGNvbnZlcnRzIGl0IHRvIGJpZ2ludC5cbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgICAgICBrZXkgPSB1dC5ieXRlc1RvSGV4KGtleSk7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgIWxlbmd0aHMuaW5jbHVkZXMoa2V5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID1cbiAgICAgICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgICAgICAgICA6IHV0LmJ5dGVzVG9OdW1iZXJCRShlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtuQnl0ZUxlbmd0aH0gYnl0ZXMsIGhleCBvciBiaWdpbnQsIG5vdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kLm1vZChudW0sIG4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgYXNzZXJ0R0UobnVtKTsgLy8gbnVtIGluIHJhbmdlIFsxLi5OLTFdXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOiAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgdGhpcy5weCA9IHB4O1xuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuICAgICAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSkge1xuICAgICAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXG4gICAgICAgICAgICAgICAgLy8gSW4gQkxTLCBaRVJPIGNhbiBiZSBzZXJpYWxpemVkLCBzbyB3ZSBhbGxvdyBpdC5cbiAgICAgICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgd3JvbmcgcmVwcmVzZW50YXRpb24gb2YgWkVSTyBhbmQgaXMgYWx3YXlzIGludmFsaWQuXG4gICAgICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHRoaXMucHkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgaWYgKCFGcC5lcWwobGVmdCwgcmlnaHQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBwb2ludFByZWNvbXB1dGVzLCBuLCAoY29tcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2goY29tcC5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUobikge1xuICAgICAgICAgICAgY29uc3QgSSA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgYXNzZXJ0R0Uobik7IC8vIFdpbGwgdGhyb3cgb24gMFxuICAgICAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoIWVuZG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICAgICAgLy8gQXBwbHkgZW5kb21vcnBoaXNtXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGFzc2VydEdFKHNjYWxhcik7XG4gICAgICAgICAgICBsZXQgbiA9IHNjYWxhcjtcbiAgICAgICAgICAgIGxldCBwb2ludCwgZmFrZTsgLy8gRmFrZSBwb2ludCBpcyB1c2VkIHRvIGNvbnN0LXRpbWUgbXVsdFxuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuaXMwKCk7XG4gICAgICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgICAgIGlmIChpczApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICAgICAgfVxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgaXNUb3JzaW9uRnJlZSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gc3ViZ3JvdXBzLCBhbHdheXMgdG9yc2lvbi1mcmVlXG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhckNvZmFjdG9yKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpO1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTtcbiAgICBjb25zdCBfYml0cyA9IENVUlZFLm5CaXRMZW5ndGg7XG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIENVUlZFLmVuZG8gPyBNYXRoLmNlaWwoX2JpdHMgLyAyKSA6IF9iaXRzKTtcbiAgICAvLyBWYWxpZGF0ZSBpZiBnZW5lcmF0b3IgcG9pbnQgaXMgb24gY3VydmVcbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcbiAgICAgICAgaXNXaXRoaW5DdXJ2ZU9yZGVyLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkRmllbGRFbGVtZW50KG51bSkge1xuICAgICAgICByZXR1cm4gXzBuIDwgbnVtICYmIG51bSA8IEZwLk9SREVSOyAvLyAwIGlzIGJhbm5lZCBzaW5jZSBpdCdzIG5vdCBpbnZlcnRpYmxlIEZFXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLm1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludk4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLmludmVydChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBQb2ludCwgbm9ybVByaXZhdGVLZXlUb1NjYWxhciwgd2VpZXJzdHJhc3NFcXVhdGlvbiwgaXNXaXRoaW5DdXJ2ZU9yZGVyLCB9ID0gd2VpZXJzdHJhc3NQb2ludHMoe1xuICAgICAgICAuLi5DVVJWRSxcbiAgICAgICAgdG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAudG9CeXRlcyhhLngpO1xuICAgICAgICAgICAgY29uc3QgY2F0ID0gdXQuY29uY2F0Qnl0ZXM7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oW3BvaW50Lmhhc0V2ZW5ZKCkgPyAweDAyIDogMHgwM10pLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFsweDA0XSksIHgsIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcbiAgICAgICAgICAgIGlmIChsZW4gPT09IGNvbXByZXNzZWRMZW4gJiYgKGhlYWQgPT09IDB4MDIgfHwgaGVhZCA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gdXQuYnl0ZXNUb051bWJlckJFKHRhaWwpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEZpZWxkRWxlbWVudCh4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHnCsiA9IHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgICAgIGxldCB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignciBtdXN0IGJlIDAgPCByIDwgQ1VSVkUubicpO1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAwIDwgcyA8IENVUlZFLm4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICBjb25zdCBzdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAyICogY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IDIgKiB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXG4gICAgICogQ29tcHV0ZXMgc2hhcmVkIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleS5cbiAgICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwcml2YXRlQSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBzaGFyZWQgcHVibGljIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpOyAvLyBjaGVjayBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cbiAgICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IHV0LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIENVUlZFLm5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IHV0LmJpdE1hc2soQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBleHBlY3RlZCcpO1xuICAgICAgICBpZiAoIShfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSX01BU0spKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsIHRoaXMgd2lsbCBiZSB3cm9uZyBhdCBsZWFzdCBmb3IgUDUyMS5cbiAgICAvLyBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgbGF0ZXIgY2FsbCBiaXRzMm9jdGV0cywgc2luY2UgbmVzdGVkIGJpdHMyaW50IGlzIGJyb2tlbiBmb3IgY3VydmVzXG4gICAgICAgIC8vIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgZCA9IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgICAgIC8vIGV4dHJhRW50cm9weS4gUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKS5cbiAgICAgICAgaWYgKGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlcyhGcC5CWVRFUykgOiBlbnQ7IC8vIGdlbmVyYXRlIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoIH0gPSBvcHRzO1xuICAgICAgICBsZXQgX3NpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IFA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCBzZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgbW9kLnZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiLCIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbmltcG9ydCB7IGNvbmNhdEJ5dGVzLCByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiBobWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIiwiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IEZpZWxkLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgbWFwVG9DdXJ2ZVNpbXBsZVNXVSB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBpc29nZW55TWFwIH0gZnJvbSAnLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzJztcbmltcG9ydCB7IGNyZWF0ZUN1cnZlIH0gZnJvbSAnLi9fc2hvcnR3X3V0aWxzLmpzJztcbmNvbnN0IHNlY3AyNTZrMVAgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpO1xuY29uc3Qgc2VjcDI1NmsxTiA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuLyoqXG4gKiDiiJpuID0gbl4oKHArMSkvNCkgZm9yIGZpZWxkcyBwID0gMyBtb2QgNC4gV2UgdW53cmFwIHRoZSBsb29wIGFuZCBtdWx0aXBseSBiaXQtYnktYml0LlxuICogKFArMW4vNG4pLnRvU3RyaW5nKDIpIHdvdWxkIHByb2R1Y2UgYml0cyBbMjIzeCAxLCAwLCAyMnggMSwgNHggMCwgMTEsIDAwXVxuICovXG5mdW5jdGlvbiBzcXJ0TW9kKHkpIHtcbiAgICBjb25zdCBQID0gc2VjcDI1NmsxUDtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfM24gPSBCaWdJbnQoMyksIF82biA9IEJpZ0ludCg2KSwgXzExbiA9IEJpZ0ludCgxMSksIF8yMm4gPSBCaWdJbnQoMjIpO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8yM24gPSBCaWdJbnQoMjMpLCBfNDRuID0gQmlnSW50KDQ0KSwgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeSAqIHkgKiB5KSAlIFA7IC8vIHheMywgMTFcbiAgICBjb25zdCBiMyA9IChiMiAqIGIyICogeSkgJSBQOyAvLyB4XjdcbiAgICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuLCBQKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4biwgUCkgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82biwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJvb3QgPSBwb3cyKHQyLCBfMm4sIFApO1xuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwID0gRmllbGQoc2VjcDI1NmsxUCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgc3FydDogc3FydE1vZCB9KTtcbmV4cG9ydCBjb25zdCBzZWNwMjU2azEgPSBjcmVhdGVDdXJ2ZSh7XG4gICAgYTogQmlnSW50KDApLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBGcCxcbiAgICBuOiBzZWNwMjU2azFOLFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IHRydWUsXG4gICAgLyoqXG4gICAgICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAgICAgKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAgICAgKiBGb3IgcHJlY29tcHV0ZWQgd05BRiBpdCB0cmFkZXMgb2ZmIDEvMiBpbml0IHRpbWUgJiAxLzMgcmFtIGZvciAyMCUgcGVyZiBoaXQuXG4gICAgICogRXhwbGFuYXRpb246IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NlxuICAgICAqL1xuICAgIGVuZG86IHtcbiAgICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gc2VjcDI1NmsxTjtcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcbiAgICAgICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBhMTtcbiAgICAgICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTsgLy8gKDJuKioxMjhuKS50b1N0cmluZygxNilcbiAgICAgICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgICAgICAgICAgbGV0IGsxID0gbW9kKGsgLSBjMSAqIGExIC0gYzIgKiBhMiwgbik7XG4gICAgICAgICAgICBsZXQgazIgPSBtb2QoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBjb25zdCBrMm5lZyA9IGsyID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxID0gbiAtIGsxO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICAgICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhcjogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgICAgICB9LFxuICAgIH0sXG59LCBzaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBmZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxUDtcbmNvbnN0IGdlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFOO1xuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcbmZ1bmN0aW9uIHRhZ2dlZEhhc2godGFnLCAuLi5tZXNzYWdlcykge1xuICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRhZ0ggPSBzaGEyNTYoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgIH1cbiAgICByZXR1cm4gc2hhMjU2KGNvbmNhdEJ5dGVzKHRhZ1AsIC4uLm1lc3NhZ2VzKSk7XG59XG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludCkgPT4gcG9pbnQudG9SYXdCeXRlcyh0cnVlKS5zbGljZSgxKTtcbmNvbnN0IG51bVRvMzJiID0gKG4pID0+IG51bWJlclRvQnl0ZXNCRShuLCAzMik7XG5jb25zdCBtb2RQID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFQKTtcbmNvbnN0IG1vZE4gPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMU4pO1xuY29uc3QgUG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50O1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgaWYgKCFmZSh4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgeDogbmVlZCAwIDwgeCA8IHAnKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxuICAgIGNvbnN0IHh4ID0gbW9kUCh4ICogeCk7XG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKHkgJSBfMm4gIT09IF8wbilcbiAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbik7IC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gcmFuZG9tQnl0ZXMoMzIpKSB7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gZW5zdXJlQnl0ZXMoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTihieXRlc1RvTnVtYmVyQkUocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3goYnl0ZXNUb051bWJlckJFKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9IGJ5dGVzVG9OdW1iZXJCRShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoIWZlKHIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFnZShzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZSA9IGNoYWxsZW5nZShudW1UbzMyYihyKSwgcG9pbnRUb0J5dGVzKFApLCBtKTsgLy8gaW50KGNoYWxsZW5nZShieXRlcyhyKXx8Ynl0ZXMoUCl8fG0pKSVuXG4gICAgICAgIGNvbnN0IFIgPSBHbXVsQWRkKFAsIHMsIG1vZE4oLWUpKTsgLy8gUiA9IHPii4VHIC0gZeKLhVBcbiAgICAgICAgaWYgKCFSIHx8ICFSLmhhc0V2ZW5ZKCkgfHwgUi50b0FmZmluZSgpLnggIT09IHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIC1lUCA9PSAobi1lKVBcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEZhaWwgaWYgaXNfaW5maW5pdGUoUikgLyBub3QgaGFzX2V2ZW5feShSKSAvIHgoUikg4omgIHIuXG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpc29nZW55TWFwKEZwLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCB7XG4gICAgQTogQmlnSW50KCcweDNmODczMWFiZGQ2NjFhZGNhMDhhNTU1OGYwZjVkMjcyZTk1M2QzNjNjYjZmMGU1ZDQwNTQ0N2MwMWE0NDQ1MzMnKSxcbiAgICBCOiBCaWdJbnQoJzE3NzEnKSxcbiAgICBaOiBGcC5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbmNvbnN0IGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nixcbn0pKSgpO1xuZXhwb3J0IGNvbnN0IGhhc2hUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azEuanMubWFwIiwiLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIHplcm8gYWRkcmVzcy5cbiAqXG4gKiAgKCoqaS5lLioqIGBgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcImBgKVxuICovXG5leHBvcnQgY29uc3QgWmVyb0FkZHJlc3MgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzc2VzLmpzLm1hcCIsIi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSB6ZXJvIGhhc2guXG4gKlxuICogICgqKmkuZS4qKiBgYFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJgYClcbiAqL1xuZXhwb3J0IGNvbnN0IFplcm9IYXNoID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2hlcy5qcy5tYXAiLCJpbXBvcnQgeyBaZXJvSGFzaCB9IGZyb20gXCIuLi9jb25zdGFudHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YUxlbmd0aCwgZ2V0QmlnSW50LCBnZXRCeXRlcywgZ2V0TnVtYmVyLCBoZXhsaWZ5LCB0b0JlQXJyYXksIGlzSGV4U3RyaW5nLCB6ZXJvUGFkVmFsdWUsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRQcml2YXRlIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vLyBDb25zdGFudHNcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcbmNvbnN0IEJOXzI3ID0gQmlnSW50KDI3KTtcbmNvbnN0IEJOXzI4ID0gQmlnSW50KDI4KTtcbmNvbnN0IEJOXzM1ID0gQmlnSW50KDM1KTtcbmNvbnN0IF9ndWFyZCA9IHt9O1xuZnVuY3Rpb24gdG9VaW50MjU2KHZhbHVlKSB7XG4gICAgcmV0dXJuIHplcm9QYWRWYWx1ZSh0b0JlQXJyYXkodmFsdWUpLCAzMik7XG59XG4vKipcbiAqICBBIFNpZ25hdHVyZSAgQFRPRE9cbiAqXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOlNpZ25pbmdcbiAqL1xuZXhwb3J0IGNsYXNzIFNpZ25hdHVyZSB7XG4gICAgI3I7XG4gICAgI3M7XG4gICAgI3Y7XG4gICAgI25ldHdvcmtWO1xuICAgIC8qKlxuICAgICAqICBUaGUgYGByYGAgdmFsdWUgZm9yIGEgc2lnbmF1dHJlLlxuICAgICAqXG4gICAgICogIFRoaXMgcmVwcmVzZW50cyB0aGUgYGB4YGAgY29vcmRpbmF0ZSBvZiBhIFwicmVmZXJlbmNlXCIgb3JcbiAgICAgKiAgY2hhbGxlbmdlIHBvaW50LCBmcm9tIHdoaWNoIHRoZSBgYHlgYCBjYW4gYmUgY29tcHV0ZWQuXG4gICAgICovXG4gICAgZ2V0IHIoKSB7IHJldHVybiB0aGlzLiNyOyB9XG4gICAgc2V0IHIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aCh2YWx1ZSkgPT09IDMyLCBcImludmFsaWQgclwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgdGhpcy4jciA9IGhleGxpZnkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgc2BgIHZhbHVlIGZvciBhIHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBnZXQgcygpIHsgcmV0dXJuIHRoaXMuI3M7IH1cbiAgICBzZXQgcyhfdmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aChfdmFsdWUpID09PSAzMiwgXCJpbnZhbGlkIHNcIiwgXCJ2YWx1ZVwiLCBfdmFsdWUpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGhleGxpZnkoX3ZhbHVlKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKDAsIDMpKSA8IDgsIFwibm9uLWNhbm9uaWNhbCBzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB0aGlzLiNzID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGB2YGAgdmFsdWUgZm9yIGEgc2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogIFNpbmNlIGEgZ2l2ZW4gYGB4YGAgdmFsdWUgZm9yIGBgcmBgIGhhcyB0d28gcG9zc2libGUgdmFsdWVzIGZvclxuICAgICAqICBpdHMgY29ycmVzcG9uZGluIGBgeWBgLCB0aGUgYGB2YGAgaW5kaWNhdGVzIHdoaWNoIG9mIHRoZSB0d28gYGB5YGBcbiAgICAgKiAgdmFsdWVzIHRvIHVzZS5cbiAgICAgKlxuICAgICAqICBJdCBpcyBub3JtYWxpemVkIHRvIHRoZSB2YWx1ZXMgYGAyN2BgIG9yIGBgMjhgYCBmb3IgbGVnYWN5XG4gICAgICogIHB1cnBvc2VzLlxuICAgICAqL1xuICAgIGdldCB2KCkgeyByZXR1cm4gdGhpcy4jdjsgfVxuICAgIHNldCB2KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHYgPSBnZXROdW1iZXIodmFsdWUsIFwidmFsdWVcIik7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHYgPT09IDI3IHx8IHYgPT09IDI4LCBcImludmFsaWQgdlwiLCBcInZcIiwgdmFsdWUpO1xuICAgICAgICB0aGlzLiN2ID0gdjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBFSVAtMTU1IGBgdmBgIGZvciBsZWdhY3kgdHJhbnNhY3Rpb25zLiBGb3Igbm9uLWxlZ2FjeVxuICAgICAqICB0cmFuc2FjdGlvbnMsIHRoaXMgdmFsdWUgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IG5ldHdvcmtWKCkgeyByZXR1cm4gdGhpcy4jbmV0d29ya1Y7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElEIGZvciBFSVAtMTU1IGxlZ2FjeSB0cmFuc2FjdGlvbnMuIEZvciBub24tbGVnYWN5XG4gICAgICogIHRyYW5zYWN0aW9ucywgdGhpcyB2YWx1ZSBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbGVnYWN5Q2hhaW5JZCgpIHtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMubmV0d29ya1Y7XG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuZ2V0Q2hhaW5JZCh2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHlQYXJpdHlgYCBmb3IgdGhlIHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqICBTZWUgYGB2YGAgZm9yIG1vcmUgZGV0YWlscyBvbiBob3cgdGhpcyB2YWx1ZSBpcyB1c2VkLlxuICAgICAqL1xuICAgIGdldCB5UGFyaXR5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudiA9PT0gMjcpID8gMCA6IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yMDk4XV0gY29tcGFjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYGB5UGFyaXR5YGBcbiAgICAgKiAgYW5kIGBgc2BgIGNvbXBhY3RlZCBpbnRvIGEgc2luZ2xlIGBgYnl0ZXMzMmBgLlxuICAgICAqL1xuICAgIGdldCB5UGFyaXR5QW5kUygpIHtcbiAgICAgICAgLy8gVGhlIEVJUC0yMDk4IGNvbXBhY3QgcmVwcmVzZW50YXRpb25cbiAgICAgICAgY29uc3QgeVBhcml0eUFuZFMgPSBnZXRCeXRlcyh0aGlzLnMpO1xuICAgICAgICBpZiAodGhpcy55UGFyaXR5KSB7XG4gICAgICAgICAgICB5UGFyaXR5QW5kU1swXSB8PSAweDgwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHlQYXJpdHlBbmRTKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTIwOThdXSBjb21wYWN0IHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIGdldCBjb21wYWN0U2VyaWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbdGhpcy5yLCB0aGlzLnlQYXJpdHlBbmRTXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgc2VyaWFsaXplZCByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgc2VyaWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbdGhpcy5yLCB0aGlzLnMsICh0aGlzLnlQYXJpdHkgPyBcIjB4MWNcIiA6IFwiMHgxYlwiKV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgciwgcywgdikge1xuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiU2lnbmF0dXJlXCIpO1xuICAgICAgICB0aGlzLiNyID0gcjtcbiAgICAgICAgdGhpcy4jcyA9IHM7XG4gICAgICAgIHRoaXMuI3YgPSB2O1xuICAgICAgICB0aGlzLiNuZXR3b3JrViA9IG51bGw7XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICAgICAgcmV0dXJuIGBTaWduYXR1cmUgeyByOiBcIiR7dGhpcy5yfVwiLCBzOiBcIiR7dGhpcy5zfVwiLCB5UGFyaXR5OiAke3RoaXMueVBhcml0eX0sIG5ldHdvcmtWOiAke3RoaXMubmV0d29ya1Z9IH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBpZGVudGljYWwgW1tTaWduYXR1cmVdXS5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgdGhpcy5yLCB0aGlzLnMsIHRoaXMudik7XG4gICAgICAgIGlmICh0aGlzLm5ldHdvcmtWKSB7XG4gICAgICAgICAgICBjbG9uZS4jbmV0d29ya1YgPSB0aGlzLm5ldHdvcmtWO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSByZXByZXNlbnRhdGlvbiB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCBgYEpTT04uc3RyaW5naWZ5YGAuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrViA9IHRoaXMubmV0d29ya1Y7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJzaWduYXR1cmVcIixcbiAgICAgICAgICAgIG5ldHdvcmtWOiAoKG5ldHdvcmtWICE9IG51bGwpID8gbmV0d29ya1YudG9TdHJpbmcoKSA6IG51bGwpLFxuICAgICAgICAgICAgcjogdGhpcy5yLCBzOiB0aGlzLnMsIHY6IHRoaXMudixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGNoYWluIElEIGZyb20gdGhlIGBgdmBgIGluIGEgbGVnYWN5IEVJUC0xNTUgdHJhbnNhY3Rpb25zLlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkKDQ1KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkKDQ2KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hhaW5JZCh2KSB7XG4gICAgICAgIGNvbnN0IGJ2ID0gZ2V0QmlnSW50KHYsIFwidlwiKTtcbiAgICAgICAgLy8gVGhlIHYgaXMgbm90IGFuIEVJUC0xNTUgdiwgc28gaXQgaXMgdGhlIHVuc3BlY2lmaWVkIGNoYWluIElEXG4gICAgICAgIGlmICgoYnYgPT0gQk5fMjcpIHx8IChidiA9PSBCTl8yOCkpIHtcbiAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhZCB2YWx1ZSBmb3IgYW4gRUlQLTE1NSB2XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ2ID49IEJOXzM1LCBcImludmFsaWQgRUlQLTE1NSB2XCIsIFwidlwiLCB2KTtcbiAgICAgICAgcmV0dXJuIChidiAtIEJOXzM1KSAvIEJOXzI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBgYHZgYCBmb3IgYSBjaGFpbiBJRCBmb3IgYSBsZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiAgTGVnYWN5IHRyYW5zYWN0aW9ucyB3aGljaCB1c2UgW1tsaW5rLWVpcC0xNTVdXSBoaWphY2sgdGhlIGBgdmBgXG4gICAgICogIHByb3BlcnR5IHRvIGluY2x1ZGUgdGhlIGNoYWluIElELlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkVig1LCAyNylcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZFYoNSwgMjgpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGdldENoYWluSWRWKGNoYWluSWQsIHYpIHtcbiAgICAgICAgcmV0dXJuIChnZXRCaWdJbnQoY2hhaW5JZCkgKiBCTl8yKSArIEJpZ0ludCgzNSArIHYgLSAyNyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBub3JtYWxpemVkIGxlZ2FjeSB0cmFuc2FjdGlvbiBgYHZgYCBmcm9tIGEgYGB5UGFyaXJ0eWBgLFxuICAgICAqICBhIGxlZ2FjeSB0cmFuc2FjdGlvbiBgYHZgYCBvciBhIGxlZ2FjeSBbW2xpbmstZWlwLTE1NV1dIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIC8vIFRoZSB2YWx1ZXMgMCBhbmQgMSBpbXBseSB2IGlzIGFjdHVhbGx5IHlQYXJpdHlcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoMClcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBMZWdhY3kgbm9uLUVJUC0xNTU5IHRyYW5zYWN0aW9uIChpLmUuIDI3IG9yIDI4KVxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVigyNylcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBMZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbiAoaS5lLiA+PSAzNSlcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoNDYpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gSW52YWxpZCB2YWx1ZXMgdGhyb3dcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoNSlcbiAgICAgKiAgICAvL19lcnJvcjpcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Tm9ybWFsaXplZFYodikge1xuICAgICAgICBjb25zdCBidiA9IGdldEJpZ0ludCh2KTtcbiAgICAgICAgaWYgKGJ2ID09PSBCTl8wIHx8IGJ2ID09PSBCTl8yNykge1xuICAgICAgICAgICAgcmV0dXJuIDI3O1xuICAgICAgICB9XG4gICAgICAgIGlmIChidiA9PT0gQk5fMSB8fCBidiA9PT0gQk5fMjgpIHtcbiAgICAgICAgICAgIHJldHVybiAyODtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChidiA+PSBCTl8zNSwgXCJpbnZhbGlkIHZcIiwgXCJ2XCIsIHYpO1xuICAgICAgICAvLyBPdGhlcndpc2UsIEVJUC0xNTUgdiBtZWFucyBvZGQgaXMgMjcgYW5kIGV2ZW4gaXMgMjhcbiAgICAgICAgcmV0dXJuIChidiAmIEJOXzEpID8gMjcgOiAyODtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tTaWduYXR1cmVdXS5cbiAgICAgKlxuICAgICAqICBJZiBubyAlJXNpZyUlIGlzIHByb3ZpZGVkLCBhIG5ldyBbW1NpZ25hdHVyZV1dIGlzIGNyZWF0ZWRcbiAgICAgKiAgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICBJZiAlJXNpZyUlIGlzIGEgc3RyaW5nLCBpdCBpcyBwYXJzZWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20oc2lnKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFzc2VydEVycm9yKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChjaGVjaywgbWVzc2FnZSwgXCJzaWduYXR1cmVcIiwgc2lnKTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGlmIChzaWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoX2d1YXJkLCBaZXJvSGFzaCwgWmVyb0hhc2gsIDI3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChzaWcpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHNpZywgXCJzaWduYXR1cmVcIik7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDMyKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGJ5dGVzLnNsaWNlKDMyLCA2NCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IChzWzBdICYgMHg4MCkgPyAyOCA6IDI3O1xuICAgICAgICAgICAgICAgIHNbMF0gJj0gMHg3ZjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHIsIGhleGxpZnkocyksIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBieXRlcy5zbGljZSgzMiwgNjQpO1xuICAgICAgICAgICAgICAgIGFzc2VydEVycm9yKChzWzBdICYgMHg4MCkgPT09IDAsIFwibm9uLWNhbm9uaWNhbCBzXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoYnl0ZXNbNjRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHIsIGhleGxpZnkocyksIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwiaW52YWxpZCByYXcgc2lnbmF0dXJlIGxlbmd0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnIGluc3RhbmNlb2YgU2lnbmF0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2lnLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHJcbiAgICAgICAgY29uc3QgX3IgPSBzaWcucjtcbiAgICAgICAgYXNzZXJ0RXJyb3IoX3IgIT0gbnVsbCwgXCJtaXNzaW5nIHJcIik7XG4gICAgICAgIGNvbnN0IHIgPSB0b1VpbnQyNTYoX3IpO1xuICAgICAgICAvLyBHZXQgczsgYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAod2UgY2hlY2sgY29uc2lzdGVuY3kgYmVsb3cpXG4gICAgICAgIGNvbnN0IHMgPSAoZnVuY3Rpb24gKHMsIHlQYXJpdHlBbmRTKSB7XG4gICAgICAgICAgICBpZiAocyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvVWludDI1NihzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5UGFyaXR5QW5kUyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoaXNIZXhTdHJpbmcoeVBhcml0eUFuZFMsIDMyKSwgXCJpbnZhbGlkIHlQYXJpdHlBbmRTXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoeVBhcml0eUFuZFMpO1xuICAgICAgICAgICAgICAgIGJ5dGVzWzBdICY9IDB4N2Y7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwibWlzc2luZyBzXCIpO1xuICAgICAgICB9KShzaWcucywgc2lnLnlQYXJpdHlBbmRTKTtcbiAgICAgICAgYXNzZXJ0RXJyb3IoKGdldEJ5dGVzKHMpWzBdICYgMHg4MCkgPT0gMCwgXCJub24tY2Fub25pY2FsIHNcIik7XG4gICAgICAgIC8vIEdldCB2OyBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh3ZSBjaGVjayBjb25zaXN0ZW5jeSBiZWxvdylcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrViwgdiB9ID0gKGZ1bmN0aW9uIChfdiwgeVBhcml0eUFuZFMsIHlQYXJpdHkpIHtcbiAgICAgICAgICAgIGlmIChfdiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IGdldEJpZ0ludChfdik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya1Y6ICgodiA+PSBCTl8zNSkgPyB2IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgdjogU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKHYpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5UGFyaXR5QW5kUyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoaXNIZXhTdHJpbmcoeVBhcml0eUFuZFMsIDMyKSwgXCJpbnZhbGlkIHlQYXJpdHlBbmRTXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHY6ICgoZ2V0Qnl0ZXMoeVBhcml0eUFuZFMpWzBdICYgMHg4MCkgPyAyOCA6IDI3KSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlQYXJpdHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZ2V0TnVtYmVyKHlQYXJpdHksIFwic2lnLnlQYXJpdHlcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4geyB2OiAyNyB9O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiB7IHY6IDI4IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcImludmFsaWQgeVBhcml0eVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcIm1pc3NpbmcgdlwiKTtcbiAgICAgICAgfSkoc2lnLnYsIHNpZy55UGFyaXR5QW5kUywgc2lnLnlQYXJpdHkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgcywgdik7XG4gICAgICAgIGlmIChuZXR3b3JrVikge1xuICAgICAgICAgICAgcmVzdWx0LiNuZXR3b3JrViA9IG5ldHdvcmtWO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG11bHRpcGxlIG9mIHYsIHlQYXJpdHksIHlQYXJpdHlBbmRTIHdlIGdpdmVuLCBjaGVjayB0aGV5IG1hdGNoXG4gICAgICAgIGFzc2VydEVycm9yKHNpZy55UGFyaXR5ID09IG51bGwgfHwgZ2V0TnVtYmVyKHNpZy55UGFyaXR5LCBcInNpZy55UGFyaXR5XCIpID09PSByZXN1bHQueVBhcml0eSwgXCJ5UGFyaXR5IG1pc21hdGNoXCIpO1xuICAgICAgICBhc3NlcnRFcnJvcihzaWcueVBhcml0eUFuZFMgPT0gbnVsbCB8fCBzaWcueVBhcml0eUFuZFMgPT09IHJlc3VsdC55UGFyaXR5QW5kUywgXCJ5UGFyaXR5QW5kUyBtaXNtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYXR1cmUuanMubWFwIiwiLyoqXG4gKiAgQWRkIGRldGFpbHMgYWJvdXQgc2lnbmluZyBoZXJlLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86U2lnbmluZyAgW2Fib3V0LXNpZ25pbmddXG4gKi9cbmltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhTGVuZ3RoLCBnZXRCeXRlcywgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5LCB0b0JlSGV4LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4vc2lnbmF0dXJlLmpzXCI7XG4vKipcbiAqICBBICoqU2lnbmluZ0tleSoqIHByb3ZpZGVzIGhpZ2gtbGV2ZWwgYWNjZXNzIHRvIHRoZSBlbGxpcHRpYyBjdXJ2ZVxuICogIGNyeXB0b2dyYXBoeSAoRUNDKSBvcGVyYXRpb25zIGFuZCBrZXkgbWFuYWdlbWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpZ25pbmdLZXkge1xuICAgICNwcml2YXRlS2V5O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqU2lnbmluZ0tleSoqIGZvciAlJXByaXZhdGVLZXklJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlS2V5KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgocHJpdmF0ZUtleSkgPT09IDMyLCBcImludmFsaWQgcHJpdmF0ZSBrZXlcIiwgXCJwcml2YXRlS2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgdGhpcy4jcHJpdmF0ZUtleSA9IGhleGxpZnkocHJpdmF0ZUtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHJpdmF0ZSBrZXkuXG4gICAgICovXG4gICAgZ2V0IHByaXZhdGVLZXkoKSB7IHJldHVybiB0aGlzLiNwcml2YXRlS2V5OyB9XG4gICAgLyoqXG4gICAgICogIFRoZSB1bmNvbXByZXNzZWQgcHVibGljIGtleS5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBhbHdheXMgYmVnaW4gd2l0aCB0aGUgcHJlZml4IGBgMHgwNGBgIGFuZCBiZSAxMzJcbiAgICAgKiBjaGFyYWN0ZXJzIGxvbmcgKHRoZSBgYDB4YGAgcHJlZml4IGFuZCAxMzAgaGV4YWRlY2ltYWwgbmliYmxlcykuXG4gICAgICovXG4gICAgZ2V0IHB1YmxpY0tleSgpIHsgcmV0dXJuIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleSh0aGlzLiNwcml2YXRlS2V5KTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCBhbHdheXMgYmVnaW4gd2l0aCBlaXRoZXIgdGhlIHByZWZpeCBgYDB4MDJgYCBvciBgYDB4MDNgYFxuICAgICAqICBhbmQgYmUgNjggY2hhcmFjdGVycyBsb25nICh0aGUgYGAweGBgIHByZWZpeCBhbmQgMzMgaGV4YWRlY2ltYWxcbiAgICAgKiAgbmliYmxlcylcbiAgICAgKi9cbiAgICBnZXQgY29tcHJlc3NlZFB1YmxpY0tleSgpIHsgcmV0dXJuIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleSh0aGlzLiNwcml2YXRlS2V5LCB0cnVlKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHNpZ25hdHVyZSBvZiB0aGUgc2lnbmVkICUlZGlnZXN0JSUuXG4gICAgICovXG4gICAgc2lnbihkaWdlc3QpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aChkaWdlc3QpID09PSAzMiwgXCJpbnZhbGlkIGRpZ2VzdCBsZW5ndGhcIiwgXCJkaWdlc3RcIiwgZGlnZXN0KTtcbiAgICAgICAgY29uc3Qgc2lnID0gc2VjcDI1NmsxLnNpZ24oZ2V0Qnl0ZXNDb3B5KGRpZ2VzdCksIGdldEJ5dGVzQ29weSh0aGlzLiNwcml2YXRlS2V5KSwge1xuICAgICAgICAgICAgbG93UzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tKHtcbiAgICAgICAgICAgIHI6IHRvQmVIZXgoc2lnLnIsIDMyKSxcbiAgICAgICAgICAgIHM6IHRvQmVIZXgoc2lnLnMsIDMyKSxcbiAgICAgICAgICAgIHY6IChzaWcucmVjb3ZlcnkgPyAweDFjIDogMHgxYilcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBbW2xpbmstd2lraS1lY2RoXV0gc2hhcmVkIHNlY3JldCBiZXR3ZWVuIHRoaXNcbiAgICAgKiAgcHJpdmF0ZSBrZXkgYW5kIHRoZSAlJW90aGVyJSUga2V5LlxuICAgICAqXG4gICAgICogIFRoZSAlJW90aGVyJSUga2V5IG1heSBiZSBhbnkgdHlwZSBvZiBrZXksIGEgcmF3IHB1YmxpYyBrZXksXG4gICAgICogIGEgY29tcHJlc3NlZC91bmNvbXByZXNzZWQgcHViaWMga2V5IG9yIGFwcml2YXRlIGtleS5cbiAgICAgKlxuICAgICAqICBCZXN0IHByYWN0aWNlIGlzIHVzdWFsbHkgdG8gdXNlIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIG9uIHRoZVxuICAgICAqICByZXR1cm5lZCB2YWx1ZSBiZWZvcmUgdXNpbmcgaXQgYXMgYSBzeW1ldHJpYyBzZWNyZXQuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgc2lnbjEgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0LTFcIikpXG4gICAgICogICAgc2lnbjIgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0LTJcIikpXG4gICAgICpcbiAgICAgKiAgICAvLyBOb3RpY2UgdGhhdCBwcml2QS5jb21wdXRlU2hhcmVkU2VjcmV0KHB1YkIpLi4uXG4gICAgICogICAgc2lnbjEuY29tcHV0ZVNoYXJlZFNlY3JldChzaWduMi5wdWJsaWNLZXkpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gLi4uaXMgZXF1YWwgdG8gcHJpdkIuY29tcHV0ZVNoYXJlZFNlY3JldChwdWJBKS5cbiAgICAgKiAgICBzaWduMi5jb21wdXRlU2hhcmVkU2VjcmV0KHNpZ24xLnB1YmxpY0tleSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICovXG4gICAgY29tcHV0ZVNoYXJlZFNlY3JldChvdGhlcikge1xuICAgICAgICBjb25zdCBwdWJLZXkgPSBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkob3RoZXIpO1xuICAgICAgICByZXR1cm4gaGV4bGlmeShzZWNwMjU2azEuZ2V0U2hhcmVkU2VjcmV0KGdldEJ5dGVzQ29weSh0aGlzLiNwcml2YXRlS2V5KSwgZ2V0Qnl0ZXMocHViS2V5KSwgZmFsc2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIHB1YmxpYyBrZXkgZm9yICUla2V5JSUsIG9wdGlvbmFsbHkgJSVjb21wcmVzc2VkJSUuXG4gICAgICpcbiAgICAgKiAgVGhlICUla2V5JSUgbWF5IGJlIGFueSB0eXBlIG9mIGtleSwgYSByYXcgcHVibGljIGtleSwgYVxuICAgICAqICBjb21wcmVzc2VkL3VuY29tcHJlc3NlZCBwdWJsaWMga2V5IG9yIHByaXZhdGUga2V5LlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIHNpZ24gPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0XCIpKTtcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHJpdmF0ZUtleSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wcml2YXRlS2V5LCB0cnVlKVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHVibGljS2V5LCBmYWxzZSk7XG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgQ29tcHJlc3NlZCBhIHB1YmxpYyBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wdWJsaWNLZXksIHRydWUpO1xuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcHV0ZVB1YmxpY0tleShrZXksIGNvbXByZXNzZWQpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gZ2V0Qnl0ZXMoa2V5LCBcImtleVwiKTtcbiAgICAgICAgLy8gcHJpdmF0ZSBrZXlcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YktleSA9IHNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoYnl0ZXMsICEhY29tcHJlc3NlZCk7XG4gICAgICAgICAgICByZXR1cm4gaGV4bGlmeShwdWJLZXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJhdyBwdWJsaWMga2V5OyB1c2UgdW5jb21wcmVzc2VkIGtleSB3aXRoIDB4MDQgcHJlZml4XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgICAgICBjb25zdCBwdWIgPSBuZXcgVWludDhBcnJheSg2NSk7XG4gICAgICAgICAgICBwdWJbMF0gPSAweDA0O1xuICAgICAgICAgICAgcHViLnNldChieXRlcywgMSk7XG4gICAgICAgICAgICBieXRlcyA9IHB1YjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChieXRlcyk7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHBvaW50LnRvUmF3Qnl0ZXMoY29tcHJlc3NlZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcHVibGljIGtleSBmb3IgdGhlIHByaXZhdGUga2V5IHdoaWNoIHByb2R1Y2VkIHRoZVxuICAgICAqICAlJXNpZ25hdHVyZSUlIGZvciB0aGUgZ2l2ZW4gJSVkaWdlc3QlJS5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBrZXkgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0XCIpKVxuICAgICAqICAgIGRpZ2VzdCA9IGlkKFwiaGVsbG8gd29ybGRcIilcbiAgICAgKiAgICBzaWcgPSBrZXkuc2lnbihkaWdlc3QpXG4gICAgICpcbiAgICAgKiAgICAvLyBOb3RpY2UgdGhlIHNpZ25lciBwdWJsaWMga2V5Li4uXG4gICAgICogICAga2V5LnB1YmxpY0tleVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIC4uLmlzIGVxdWFsIHRvIHRoZSByZWNvdmVyZWQgcHVibGljIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkucmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZylcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZ25hdHVyZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKGRpZ2VzdCkgPT09IDMyLCBcImludmFsaWQgZGlnZXN0IGxlbmd0aFwiLCBcImRpZ2VzdFwiLCBkaWdlc3QpO1xuICAgICAgICBjb25zdCBzaWcgPSBTaWduYXR1cmUuZnJvbShzaWduYXR1cmUpO1xuICAgICAgICBsZXQgc2VjcFNpZyA9IHNlY3AyNTZrMS5TaWduYXR1cmUuZnJvbUNvbXBhY3QoZ2V0Qnl0ZXNDb3B5KGNvbmNhdChbc2lnLnIsIHNpZy5zXSkpKTtcbiAgICAgICAgc2VjcFNpZyA9IHNlY3BTaWcuYWRkUmVjb3ZlcnlCaXQoc2lnLnlQYXJpdHkpO1xuICAgICAgICBjb25zdCBwdWJLZXkgPSBzZWNwU2lnLnJlY292ZXJQdWJsaWNLZXkoZ2V0Qnl0ZXNDb3B5KGRpZ2VzdCkpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwdWJLZXkgIT0gbnVsbCwgXCJpbnZhbGlkIHNpZ25hdXRyZSBmb3IgZGlnZXN0XCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwdWJLZXkudG9IZXgoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcG9pbnQgcmVzdWx0aW5nIGZyb20gYWRkaW5nIHRoZSBlbGxpcGljIGN1cnZlIHBvaW50c1xuICAgICAqICAlJXAwJSUgYW5kICUlcDElJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBhIGNvbW1vbiBmdW5jdGlvbiBtb3N0IGRldmVsb3BlcnMgc2hvdWxkIHJlcXVpcmUsIGJ1dFxuICAgICAqICBjYW4gYmUgdXNlZnVsIGZvciBjZXJ0YWluIHByaXZhY3ktc3BlY2lmaWMgdGVjaG5pcXVlcy5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgaXQgaXMgdXNlZCBieSBbW0hETm9kZVdhbGxldF1dIHRvIGNvbXB1dGUgY2hpbGRcbiAgICAgKiAgYWRkcmVzc2VzIGZyb20gcGFyZW50IHB1YmxpYyBrZXlzIGFuZCBjaGFpbiBjb2Rlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUG9pbnRzKHAwLCBwMSwgY29tcHJlc3NlZCkge1xuICAgICAgICBjb25zdCBwdWIwID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShwMCkuc3Vic3RyaW5nKDIpKTtcbiAgICAgICAgY29uc3QgcHViMSA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkocDEpLnN1YnN0cmluZygyKSk7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwdWIwLmFkZChwdWIxKS50b0hleCghIWNvbXByZXNzZWQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25pbmcta2V5LmpzLm1hcCIsImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzM2ID0gQmlnSW50KDM2KTtcbmZ1bmN0aW9uIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgLy8gICAgaWYgKCFpc0hleFN0cmluZyhhZGRyZXNzLCAyMCkpIHtcbiAgICAvLyAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgLy8gICAgfVxuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY2hhcnMgPSBhZGRyZXNzLnN1YnN0cmluZygyKS5zcGxpdChcIlwiKTtcbiAgICBjb25zdCBleHBhbmRlZCA9IG5ldyBVaW50OEFycmF5KDQwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpKyspIHtcbiAgICAgICAgZXhwYW5kZWRbaV0gPSBjaGFyc1tpXS5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZWQgPSBnZXRCeXRlcyhrZWNjYWsyNTYoZXhwYW5kZWQpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSA+PiA0KSA+PSA4KSB7XG4gICAgICAgICAgICBjaGFyc1tpXSA9IGNoYXJzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSAmIDB4MGYpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2kgKyAxXSA9IGNoYXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBjaGFycy5qb2luKFwiXCIpO1xufVxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcm5hdGlvbmFsX0JhbmtfQWNjb3VudF9OdW1iZXJcbi8vIENyZWF0ZSBsb29rdXAgdGFibGVcbmNvbnN0IGliYW5Mb29rdXAgPSB7fTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nKGkpXSA9IFN0cmluZyhpKTtcbn1cbmZvciAobGV0IGkgPSAwOyBpIDwgMjY7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIGkpXSA9IFN0cmluZygxMCArIGkpO1xufVxuLy8gSG93IG1hbnkgZGVjaW1hbCBkaWdpdHMgY2FuIHdlIHByb2Nlc3M/IChmb3IgNjQtYml0IGZsb2F0LCB0aGlzIGlzIDE1KVxuLy8gaS5lLiBNYXRoLmZsb29yKE1hdGgubG9nMTAoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKTtcbmNvbnN0IHNhZmVEaWdpdHMgPSAxNTtcbmZ1bmN0aW9uIGliYW5DaGVja3N1bShhZGRyZXNzKSB7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9VcHBlckNhc2UoKTtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy5zdWJzdHJpbmcoNCkgKyBhZGRyZXNzLnN1YnN0cmluZygwLCAyKSArIFwiMDBcIjtcbiAgICBsZXQgZXhwYW5kZWQgPSBhZGRyZXNzLnNwbGl0KFwiXCIpLm1hcCgoYykgPT4geyByZXR1cm4gaWJhbkxvb2t1cFtjXTsgfSkuam9pbihcIlwiKTtcbiAgICAvLyBKYXZhc2NyaXB0IGNhbiBoYW5kbGUgaW50ZWdlcnMgc2FmZWx5IHVwIHRvIDE1IChkZWNpbWFsKSBkaWdpdHNcbiAgICB3aGlsZSAoZXhwYW5kZWQubGVuZ3RoID49IHNhZmVEaWdpdHMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gZXhwYW5kZWQuc3Vic3RyaW5nKDAsIHNhZmVEaWdpdHMpO1xuICAgICAgICBleHBhbmRlZCA9IHBhcnNlSW50KGJsb2NrLCAxMCkgJSA5NyArIGV4cGFuZGVkLnN1YnN0cmluZyhibG9jay5sZW5ndGgpO1xuICAgIH1cbiAgICBsZXQgY2hlY2tzdW0gPSBTdHJpbmcoOTggLSAocGFyc2VJbnQoZXhwYW5kZWQsIDEwKSAlIDk3KSk7XG4gICAgd2hpbGUgKGNoZWNrc3VtLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgY2hlY2tzdW0gPSBcIjBcIiArIGNoZWNrc3VtO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tzdW07XG59XG47XG5jb25zdCBCYXNlMzYgPSAoZnVuY3Rpb24gKCkge1xuICAgIDtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM2OyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIltpXTtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBCaWdJbnQoaSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59KSgpO1xuZnVuY3Rpb24gZnJvbUJhc2UzNih2YWx1ZSkge1xuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgcmVzdWx0ID0gQk5fMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCAqIEJOXzM2ICsgQmFzZTM2W3ZhbHVlW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBub3JtYWxpemVkIGFuZCBjaGVja3N1bWVkIGFkZHJlc3MgZm9yICUlYWRkcmVzcyUlLlxuICogIFRoaXMgYWNjZXB0cyBub24tY2hlY2tzdW0gYWRkcmVzc2VzLCBjaGVja3N1bSBhZGRyZXNzZXMgYW5kXG4gKiAgW1tnZXRJY2FwQWRkcmVzc11dIGZvcm1hdHMuXG4gKlxuICogIFRoZSBjaGVja3N1bSBpbiBFdGhlcmV1bSB1c2VzIHRoZSBjYXBpdGFsaXphdGlvbiAodXBwZXItY2FzZVxuICogIHZzIGxvd2VyLWNhc2UpIG9mIHRoZSBjaGFyYWN0ZXJzIHdpdGhpbiBhbiBhZGRyZXNzIHRvIGVuY29kZVxuICogIGl0cyBjaGVja3N1bSwgd2hpY2ggb2ZmZXJzLCBvbiBhdmVyYWdlLCBhIGNoZWNrc3VtIG9mIDE1LWJpdHMuXG4gKlxuICogIElmICUlYWRkcmVzcyUlIGNvbnRhaW5zIGJvdGggdXBwZXItY2FzZSBhbmQgbG93ZXItY2FzZSwgaXQgaXNcbiAqICBhc3N1bWVkIHRvIGFscmVhZHkgYmUgYSBjaGVja3N1bSBhZGRyZXNzIGFuZCBpdHMgY2hlY2tzdW0gaXNcbiAqICB2YWxpZGF0ZWQsIGFuZCBpZiB0aGUgYWRkcmVzcyBmYWlscyBpdHMgZXhwZWN0ZWQgY2hlY2tzdW0gYW5cbiAqICBlcnJvciBpcyB0aHJvd24uXG4gKlxuICogIElmIHlvdSB3aXNoIHRoZSBjaGVja3N1bSBvZiAlJWFkZHJlc3MlJSB0byBiZSBpZ25vcmUsIGl0IHNob3VsZFxuICogIGJlIGNvbnZlcnRlZCB0byBsb3dlci1jYXNlIChpLmUuIGBgLnRvTG93ZXJjYXNlKClgYCkgYmVmb3JlXG4gKiAgYmVpbmcgcGFzc2VkIGluLiBUaGlzIHNob3VsZCBiZSBhIHZlcnkgcmFyZSBzaXR1YXRpb24gdGhvdWdoLFxuICogIHRoYXQgeW91IHdpc2ggdG8gYnlwYXNzIHRoZSBzYWZlZ2F1cmRzIGluIHBsYWNlIHRvIHByb3RlY3RcbiAqICBhZ2FpbnN0IGFuIGFkZHJlc3MgdGhhdCBoYXMgYmVlbiBpbmNvcnJlY3RseSBjb3BpZWQgZnJvbSBhbm90aGVyXG4gKiAgc291cmNlLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIEFkZHMgdGhlIGNoZWNrc3VtICh2aWEgdXBwZXItY2FzaW5nIHNwZWNpZmljIGxldHRlcnMpXG4gKiAgICBnZXRBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJkNDMyODAzMDEyNjQ1YWMxMzZkZGQ2NGRiYTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gQ29udmVydHMgSUNBUCBhZGRyZXNzIGFuZCBhZGRzIGNoZWNrc3VtXG4gKiAgICBnZXRBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzZcIik7XG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFuIGFkZHJlc3MgY29udGFpbnMgbWl4ZWQgY2FzZSxcbiAqICAgIC8vIGJ1dCB0aGUgY2hlY2tzdW0gZmFpbHNcbiAqICAgIGdldEFkZHJlc3MoXCIweDhCYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChhZGRyZXNzKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXXs0MH0kLykpIHtcbiAgICAgICAgLy8gTWlzc2luZyB0aGUgMHggcHJlZml4XG4gICAgICAgIGlmICghYWRkcmVzcy5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBcIjB4XCIgKyBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgLy8gSXQgaXMgYSBjaGVja3N1bW1lZCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWFkZHJlc3MubWF0Y2goLyhbQS1GXS4qW2EtZl0pfChbYS1mXS4qW0EtRl0pLykgfHwgcmVzdWx0ID09PSBhZGRyZXNzLCBcImJhZCBhZGRyZXNzIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gTWF5YmUgSUNBUD8gKHdlIG9ubHkgc3VwcG9ydCBkaXJlY3QgbW9kZSlcbiAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXlhFWzAtOV17Mn1bMC05QS1aYS16XXszMCwzMX0kLykpIHtcbiAgICAgICAgLy8gSXQgaXMgYW4gSUNBUCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWRkcmVzcy5zdWJzdHJpbmcoMiwgNCkgPT09IGliYW5DaGVja3N1bShhZGRyZXNzKSwgXCJiYWQgaWNhcCBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBmcm9tQmFzZTM2KGFkZHJlc3Muc3Vic3RyaW5nKDQpKS50b1N0cmluZygxNik7XG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgNDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRDaGVja3N1bUFkZHJlc3MoXCIweFwiICsgcmVzdWx0KTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbn1cbi8qKlxuICogIFRoZSBbSUNBUCBBZGRyZXNzIGZvcm1hdF0obGluay1pY2FwKSBmb3JtYXQgaXMgYW4gZWFybHkgY2hlY2tzdW1cbiAqICBmb3JtYXQgd2hpY2ggYXR0ZW1wdHMgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBiYW5raW5nXG4gKiAgaW5kdXN0cnkgW0lCQU4gZm9ybWF0XShsaW5rLXdpa2ktaWJhbikgZm9yIGJhbmsgYWNjb3VudHMuXG4gKlxuICogIEl0IGlzIG5vIGxvbmdlciBjb21tb24gb3IgYSByZWNvbW1lbmRlZCBmb3JtYXQuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgZ2V0SWNhcEFkZHJlc3MoXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIik7XG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgZ2V0SWNhcEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIElDQVAgY2hlY2tzdW0gaXMgd3JvbmdcbiAqICAgIGdldEljYXBBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzdcIik7XG4gKiAgICAvL19lcnJvcjpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEljYXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAvL2xldCBiYXNlMzYgPSBfYmFzZTE2VG8zNihnZXRBZGRyZXNzKGFkZHJlc3MpLnN1YnN0cmluZygyKSkudG9VcHBlckNhc2UoKTtcbiAgICBsZXQgYmFzZTM2ID0gQmlnSW50KGdldEFkZHJlc3MoYWRkcmVzcykpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHdoaWxlIChiYXNlMzYubGVuZ3RoIDwgMzApIHtcbiAgICAgICAgYmFzZTM2ID0gXCIwXCIgKyBiYXNlMzY7XG4gICAgfVxuICAgIHJldHVybiBcIlhFXCIgKyBpYmFuQ2hlY2tzdW0oXCJYRTAwXCIgKyBiYXNlMzYpICsgYmFzZTM2O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiLCJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRhdGFTbGljZSwgZ2V0QmlnSW50LCBnZXRCeXRlcywgZW5jb2RlUmxwLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuL2FkZHJlc3MuanNcIjtcbi8vIGh0dHA6Ly9ldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNzYwL2hvdy1pcy10aGUtYWRkcmVzcy1vZi1hbi1ldGhlcmV1bS1jb250cmFjdC1jb21wdXRlZFxuLyoqXG4gKiAgUmV0dXJucyB0aGUgYWRkcmVzcyB0aGF0IHdvdWxkIHJlc3VsdCBmcm9tIGEgYGBDUkVBVEVgYCBmb3IgJSV0eCUlLlxuICpcbiAqICBUaGlzIGNhbiBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGFkZHJlc3MgYSBjb250cmFjdCB3aWxsIGJlXG4gKiAgZGVwbG95ZWQgdG8gYnkgYW4gRU9BIHdoZW4gc2VuZGluZyBhIGRlcGxveW1lbnQgdHJhbnNhY3Rpb24gKGkuZS5cbiAqICB3aGVuIHRoZSBgYHRvYGAgYWRkcmVzcyBpcyBgYG51bGxgYCkuXG4gKlxuICogIFRoaXMgY2FuIGFsc28gYmUgdXNlZCB0byBjb21wdXRlIHRoZSBhZGRyZXNzIGEgY29udHJhY3Qgd2lsbCBiZVxuICogIGRlcGxveWVkIHRvIGJ5IGEgY29udHJhY3QsIGJ5IHVzaW5nIHRoZSBjb250cmFjdCdzIGFkZHJlc3MgYXMgdGhlXG4gKiAgYGB0b2BgIGFuZCB0aGUgY29udHJhY3QncyBub25jZS5cbiAqXG4gKiAgQGV4YW1wbGVcbiAqICAgIGZyb20gPSBcIjB4OGJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiO1xuICogICAgbm9uY2UgPSA1O1xuICpcbiAqICAgIGdldENyZWF0ZUFkZHJlc3MoeyBmcm9tLCBub25jZSB9KTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENyZWF0ZUFkZHJlc3ModHgpIHtcbiAgICBjb25zdCBmcm9tID0gZ2V0QWRkcmVzcyh0eC5mcm9tKTtcbiAgICBjb25zdCBub25jZSA9IGdldEJpZ0ludCh0eC5ub25jZSwgXCJ0eC5ub25jZVwiKTtcbiAgICBsZXQgbm9uY2VIZXggPSBub25jZS50b1N0cmluZygxNik7XG4gICAgaWYgKG5vbmNlSGV4ID09PSBcIjBcIikge1xuICAgICAgICBub25jZUhleCA9IFwiMHhcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9uY2VIZXgubGVuZ3RoICUgMikge1xuICAgICAgICBub25jZUhleCA9IFwiMHgwXCIgKyBub25jZUhleDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vbmNlSGV4ID0gXCIweFwiICsgbm9uY2VIZXg7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZGRyZXNzKGRhdGFTbGljZShrZWNjYWsyNTYoZW5jb2RlUmxwKFtmcm9tLCBub25jZUhleF0pKSwgMTIpKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIGFkZHJlc3MgdGhhdCB3b3VsZCByZXN1bHQgZnJvbSBhIGBgQ1JFQVRFMmBgIG9wZXJhdGlvblxuICogIHdpdGggdGhlIGdpdmVuICUlZnJvbSUlLCAlJXNhbHQlJSBhbmQgJSVpbml0Q29kZUhhc2glJS5cbiAqXG4gKiAgVG8gY29tcHV0ZSB0aGUgJSVpbml0Q29kZUhhc2glJSBmcm9tIGEgY29udHJhY3QncyBpbml0IGNvZGUsIHVzZVxuICogIHRoZSBbW2tlY2NhazI1Nl1dIGZ1bmN0aW9uLlxuICpcbiAqICBGb3IgYSBxdWljayBvdmVydmlldyBhbmQgZXhhbXBsZSBvZiBgYENSRUFURTJgYCwgc2VlIFtbbGluay1yaWNtb28td2lzcHNdXS5cbiAqXG4gKiAgQGV4YW1wbGVcbiAqICAgIC8vIFRoZSBhZGRyZXNzIG9mIHRoZSBjb250cmFjdFxuICogICAgZnJvbSA9IFwiMHg4YmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCJcbiAqXG4gKiAgICAvLyBUaGUgc2FsdFxuICogICAgc2FsdCA9IGlkKFwiSGVsbG9Xb3JsZFwiKVxuICpcbiAqICAgIC8vIFRoZSBoYXNoIG9mIHRoZSBpbml0Q29kZVxuICogICAgaW5pdENvZGUgPSBcIjB4NjM5NDE5OGRmMTYwMDA1MjYxMDNmZjYwMjA2MDA0NjAxYzMzNWFmYTYwNDA1MTYwNjBmM1wiO1xuICogICAgaW5pdENvZGVIYXNoID0ga2VjY2FrMjU2KGluaXRDb2RlKVxuICpcbiAqICAgIGdldENyZWF0ZTJBZGRyZXNzKGZyb20sIHNhbHQsIGluaXRDb2RlSGFzaClcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENyZWF0ZTJBZGRyZXNzKF9mcm9tLCBfc2FsdCwgX2luaXRDb2RlSGFzaCkge1xuICAgIGNvbnN0IGZyb20gPSBnZXRBZGRyZXNzKF9mcm9tKTtcbiAgICBjb25zdCBzYWx0ID0gZ2V0Qnl0ZXMoX3NhbHQsIFwic2FsdFwiKTtcbiAgICBjb25zdCBpbml0Q29kZUhhc2ggPSBnZXRCeXRlcyhfaW5pdENvZGVIYXNoLCBcImluaXRDb2RlSGFzaFwiKTtcbiAgICBhc3NlcnRBcmd1bWVudChzYWx0Lmxlbmd0aCA9PT0gMzIsIFwic2FsdCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwic2FsdFwiLCBfc2FsdCk7XG4gICAgYXNzZXJ0QXJndW1lbnQoaW5pdENvZGVIYXNoLmxlbmd0aCA9PT0gMzIsIFwiaW5pdENvZGVIYXNoIG11c3QgYmUgMzIgYnl0ZXNcIiwgXCJpbml0Q29kZUhhc2hcIiwgX2luaXRDb2RlSGFzaCk7XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoZGF0YVNsaWNlKGtlY2NhazI1Nihjb25jYXQoW1wiMHhmZlwiLCBmcm9tLCBzYWx0LCBpbml0Q29kZUhhc2hdKSksIDEyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cmFjdC1hZGRyZXNzLmpzLm1hcCIsImltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIG9iamVjdCB3aGljaCBpbXBsZW1lbnRzIHRoZVxuICogIFtbQWRkcmVzc2FibGVdXSBpbnRlcmZhY2UuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gV2FsbGV0cyBhbmQgQWJzdHJhY3RTaWduZXIgc3ViLWNsYXNzZXNcbiAqICAgIGlzQWRkcmVzc2FibGUoV2FsbGV0LmNyZWF0ZVJhbmRvbSgpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIENvbnRyYWN0c1xuICogICAgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoXCJkYWkudG9rZW5zLmV0aGVycy5ldGhcIiwgWyBdLCBwcm92aWRlcilcbiAqICAgIGlzQWRkcmVzc2FibGUoY29udHJhY3QpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FkZHJlc3NhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmdldEFkZHJlc3MpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIGFkZHJlc3MuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gVmFsaWQgYWRkcmVzc1xuICogICAgaXNBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVmFsaWQgSUNBUCBhZGRyZXNzXG4gKiAgICBpc0FkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEludmFsaWQgY2hlY2tzdW1cbiAqICAgIGlzQWRkcmVzcyhcIjB4OEJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQmE3MlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEludmFsaWQgSUNBUCBjaGVja3N1bVxuICogICAgaXNBZGRyZXNzKFwiMHg4QmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gTm90IGFuIGFkZHJlc3MgKGFuIEVOUyBuYW1lIHJlcXVpcmVzIGEgcHJvdmlkZWQgYW5kIGFuXG4gKiAgICAvLyBhc3luY2hyb25vdXMgQVBJIHRvIGFjY2VzcylcbiAqICAgIGlzQWRkcmVzcyhcInJpY21vby5ldGhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWRkcmVzcyh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGdldEFkZHJlc3ModmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5hc3luYyBmdW5jdGlvbiBjaGVja0FkZHJlc3ModGFyZ2V0LCBwcm9taXNlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcbiAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0ID09PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgKHRhcmdldCkgIT09IFwic3RyaW5nXCIsIFwidW5jb25maWd1cmVkIG5hbWVcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7IHZhbHVlOiB0YXJnZXQgfSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgQWRkcmVzc0xpa2UgdmFsdWU7IGRpZCBub3QgcmVzb2x2ZSB0byBhIHZhbHVlIGFkZHJlc3NcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3MocmVzdWx0KTtcbn1cbi8qKlxuICogIFJlc29sdmVzIHRvIGFuIGFkZHJlc3MgZm9yIHRoZSAlJXRhcmdldCUlLCB3aGljaCBtYXkgYmUgYW55XG4gKiAgc3VwcG9ydGVkIGFkZHJlc3MgdHlwZSwgYW4gW1tBZGRyZXNzYWJsZV1dIG9yIGEgUHJvbWlzZSB3aGljaFxuICogIHJlc29sdmVzIHRvIGFuIGFkZHJlc3MuXG4gKlxuICogIElmIGFuIEVOUyBuYW1lIGlzIHByb3ZpZGVkLCBidXQgdGhhdCBuYW1lIGhhcyBub3QgYmVlbiBjb3JyZWN0bHlcbiAqICBjb25maWd1cmVkIGEgW1tVbmNvbmZpZ3VyZWROYW1lRXJyb3JdXSBpcyB0aHJvd24uXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgYWRkciA9IFwiMHg2QjE3NTQ3NEU4OTA5NEM0NERhOThiOTU0RWVkZUFDNDk1MjcxZDBGXCJcbiAqXG4gKiAgICAvLyBBZGRyZXNzZXMgYXJlIHJldHVybiBzeW5jaHJvbm91c2x5XG4gKiAgICByZXNvbHZlQWRkcmVzcyhhZGRyLCBwcm92aWRlcilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBBZGRyZXNzIHByb21pc2VzIGFyZSByZXNvbHZlZCBhc3luY2hyb25vdXNseVxuICogICAgcmVzb2x2ZUFkZHJlc3MoUHJvbWlzZS5yZXNvbHZlKGFkZHIpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEVOUyBuYW1lcyBhcmUgcmVzb2x2ZWQgYXN5bmNocm9ub3VzbHlcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwiZGFpLnRva2Vucy5ldGhlcnMuZXRoXCIsIHByb3ZpZGVyKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEFkZHJlc3NhYmxlIG9iamVjdHMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XG4gKiAgICBjb250cmFjdCA9IG5ldyBDb250cmFjdChhZGRyLCBbIF0pXG4gKiAgICByZXNvbHZlQWRkcmVzcyhjb250cmFjdCwgcHJvdmlkZXIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVW5jb25maWd1cmVkIEVOUyBuYW1lcyByZWplY3RcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIiwgcHJvdmlkZXIpXG4gKiAgICAvL19lcnJvcjpcbiAqXG4gKiAgICAvLyBFTlMgbmFtZXMgcmVxdWlyZSBhIE5hbWVSZXNvbHZlciBvYmplY3QgcGFzc2VkIGluXG4gKiAgICAvLyAobm90aWNlIHRoZSBwcm92aWRlciB3YXMgb21pdHRlZClcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUFkZHJlc3ModGFyZ2V0LCByZXNvbHZlcikge1xuICAgIGlmICh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHRhcmdldC5tYXRjaCgvXjB4WzAtOWEtZl17NDB9JC9pKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQocmVzb2x2ZXIgIT0gbnVsbCwgXCJFTlMgcmVzb2x1dGlvbiByZXF1aXJlcyBhIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lXCIgfSk7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCByZXNvbHZlci5yZXNvbHZlTmFtZSh0YXJnZXQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBZGRyZXNzYWJsZSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCB0YXJnZXQuZ2V0QWRkcmVzcygpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGFyZ2V0ICYmIHR5cGVvZiAodGFyZ2V0LnRoZW4pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHRhcmdldCk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIGFkZHJlc3NhYmxlIHZhbHVlXCIsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3MuanMubWFwIiwiLyoqXG4gKiAgQSBUeXBlZCBvYmplY3QgYWxsb3dzIGEgdmFsdWUgdG8gaGF2ZSBpdHMgdHlwZSBleHBsaWNpdGx5XG4gKiAgc3BlY2lmaWVkLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaW4gU29saWRpdHksIHRoZSB2YWx1ZSBgYDQ1YGAgY291bGQgcmVwcmVzZW50IGFcbiAqICBgYHVpbnQ4YGAgb3IgYSBgYHVpbnQyNTZgYC4gVGhlIHZhbHVlIGBgMHgxMjM0YGAgY291bGQgcmVwcmVzZW50XG4gKiAgYSBgYGJ5dGVzMmBgIG9yIGBgYnl0ZXNgYC5cbiAqXG4gKiAgU2luY2UgSmF2YVNjcmlwdCBoYXMgbm8gbWVhbmluZ2Z1bCB3YXkgdG8gZXhwbGljaXRseSBpbmZvcm0gYW55XG4gKiAgQVBJcyB3aGljaCB3aGF0IHRoZSB0eXBlIGlzLCB0aGlzIGFsbG93cyB0cmFuc3BhcmVudCBpbnRlcm9wZXJhdGlvblxuICogIHdpdGggU29sZGl0eS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvYWJpOlR5cGVkIFZhbHVlc1xuICovXG5pbXBvcnQgeyBhc3NlcnRQcml2YXRlLCBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBfZ2F1cmQgPSB7fTtcbmZ1bmN0aW9uIG4odmFsdWUsIHdpZHRoKSB7XG4gICAgbGV0IHNpZ25lZCA9IGZhbHNlO1xuICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgd2lkdGggKj0gLTE7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBDaGVjayByYW5nZSBpcyB2YWxpZCBmb3IgdmFsdWVcbiAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgYCR7c2lnbmVkID8gXCJcIiA6IFwidVwifWludCR7d2lkdGh9YCwgdmFsdWUsIHsgc2lnbmVkLCB3aWR0aCB9KTtcbn1cbmZ1bmN0aW9uIGIodmFsdWUsIHNpemUpIHtcbiAgICAvLyBAVE9ETzogQ2hlY2sgcmFuZ2UgaXMgdmFsaWQgZm9yIHZhbHVlXG4gICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIGBieXRlcyR7KHNpemUpID8gc2l6ZSA6IFwiXCJ9YCwgdmFsdWUsIHsgc2l6ZSB9KTtcbn1cbmNvbnN0IF90eXBlZFN5bWJvbCA9IFN5bWJvbC5mb3IoXCJfZXRoZXJzX3R5cGVkXCIpO1xuLyoqXG4gKiAgVGhlICoqVHlwZWQqKiBjbGFzcyB0byB3cmFwIHZhbHVlcyBwcm92aWRpbmcgZXhwbGljaXQgdHlwZSBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFR5cGVkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGUsIGFzIGEgU29saWRpdHktY29tcGF0aWJsZSB0eXBlLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgdmFsdWUuXG4gICAgICovXG4gICAgdmFsdWU7XG4gICAgI29wdGlvbnM7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIF90eXBlZFN5bWJvbDtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2F1cmQsIHR5cGUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFByaXZhdGUoX2dhdXJkLCBnYXVyZCwgXCJUeXBlZFwiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IF90eXBlZFN5bWJvbCwgdHlwZSwgdmFsdWUgfSk7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAvLyBDaGVjayB0aGUgdmFsdWUgaXMgdmFsaWRcbiAgICAgICAgdGhpcy5mb3JtYXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEZvcm1hdCB0aGUgdHlwZSBhcyBhIEh1bWFuLVJlYWRhYmxlIHR5cGUuXG4gICAgICovXG4gICAgZm9ybWF0KCkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwiZHluYW1pY0FycmF5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIGB0dXBsZSgke3RoaXMudmFsdWUubWFwKCh2KSA9PiB2LmZvcm1hdCgpKS5qb2luKFwiLFwiKX0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgYnkgdGhpcyB0eXBlLlxuICAgICAqL1xuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWluaW11bSB2YWx1ZSBmb3IgbnVtZXJpYyB0eXBlcy5cbiAgICAgKi9cbiAgICBtaW5WYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB2YWx1ZSBmb3IgbnVtZXJpYyB0eXBlcy5cbiAgICAgKi9cbiAgICBtYXhWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaXMgdGhpcyBpcyBhIFtbVHlwZWRCaWdJbnRdXS5cbiAgICAgKi9cbiAgICBpc0JpZ0ludCgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMudHlwZS5tYXRjaCgvXnU/aW50WzAtOV0rJC8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpcyB0aGlzIGlzIGEgW1tUeXBlZERhdGFdXS5cbiAgICAgKi9cbiAgICBpc0RhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuc3RhcnRzV2l0aChcImJ5dGVzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlzIHRoaXMgaXMgYSBbW1R5cGVkU3RyaW5nXV0uXG4gICAgICovXG4gICAgaXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSBcInN0cmluZ1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHR1cGxlIG5hbWUsIGlmIHRoaXMgaXMgYSB0dXBsZS4gVGhyb3dzIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgdHVwbGVOYW1lKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIm5vdCBhIHR1cGxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNvcHRpb25zO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhpcyB0eXBlIGFzIGFuIGFycmF5XG4gICAgLy8gLSBgbnVsbGAgaW5kaWNhdGVzIHRoZSBsZW5ndGggaXMgdW5mb3JjZWQsIGl0IGNvdWxkIGJlIGR5bmFtaWNcbiAgICAvLyAtIGAtMWAgaW5kaWNhdGVzIHRoZSBsZW5ndGggaXMgZHluYW1pY1xuICAgIC8vIC0gYW55IG90aGVyIHZhbHVlIGluZGljYXRlcyBpdCBpcyBhIHN0YXRpYyBhcnJheSBhbmQgaXMgaXRzIGxlbmd0aFxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IHR5cGUgb3IgYGAtMWBgIGlmIGl0IGlzIGR5bmFtaWMuXG4gICAgICpcbiAgICAgKiAgVGhyb3dzIGlmIHRoZSB0eXBlIGlzIG5vdCBhbiBhcnJheS5cbiAgICAgKi9cbiAgICBnZXQgYXJyYXlMZW5ndGgoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI29wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipUeXBlZCoqIG9mICUldHlwZSUlIHdpdGggdGhlICUldmFsdWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0eXBlLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgdHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDgodikgeyByZXR1cm4gbih2LCA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2KHYpIHsgcmV0dXJuIG4odiwgMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQodikgeyByZXR1cm4gbih2LCAyNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQzMih2KSB7IHJldHVybiBuKHYsIDMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDQwKHYpIHsgcmV0dXJuIG4odiwgNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NDgodikgeyByZXR1cm4gbih2LCA0OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ1Nih2KSB7IHJldHVybiBuKHYsIDU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDY0KHYpIHsgcmV0dXJuIG4odiwgNjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ3MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NzIodikgeyByZXR1cm4gbih2LCA3Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDgwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ4MCh2KSB7IHJldHVybiBuKHYsIDgwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50ODhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDg4KHYpIHsgcmV0dXJuIG4odiwgODgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ5NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50OTYodikgeyByZXR1cm4gbih2LCA5Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEwNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTA0KHYpIHsgcmV0dXJuIG4odiwgMTA0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTEyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMTIodikgeyByZXR1cm4gbih2LCAxMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDEyMCh2KSB7IHJldHVybiBuKHYsIDEyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEyOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTI4KHYpIHsgcmV0dXJuIG4odiwgMTI4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMzYodikgeyByZXR1cm4gbih2LCAxMzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE0NCh2KSB7IHJldHVybiBuKHYsIDE0NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE1MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTUyKHYpIHsgcmV0dXJuIG4odiwgMTUyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTYwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNjAodikgeyByZXR1cm4gbih2LCAxNjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2OCh2KSB7IHJldHVybiBuKHYsIDE2OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE3NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTc2KHYpIHsgcmV0dXJuIG4odiwgMTc2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTg0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxODQodikgeyByZXR1cm4gbih2LCAxODQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxOTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE5Mih2KSB7IHJldHVybiBuKHYsIDE5Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIwMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjAwKHYpIHsgcmV0dXJuIG4odiwgMjAwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjA4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMDgodikgeyByZXR1cm4gbih2LCAyMDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIxNih2KSB7IHJldHVybiBuKHYsIDIxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjI0KHYpIHsgcmV0dXJuIG4odiwgMjI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMzIodikgeyByZXR1cm4gbih2LCAyMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDI0MCh2KSB7IHJldHVybiBuKHYsIDI0MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQ4KHYpIHsgcmV0dXJuIG4odiwgMjQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNTYodikgeyByZXR1cm4gbih2LCAyNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludCh2KSB7IHJldHVybiBuKHYsIDI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ4KHYpIHsgcmV0dXJuIG4odiwgLTgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2KHYpIHsgcmV0dXJuIG4odiwgLTE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNCh2KSB7IHJldHVybiBuKHYsIC0yNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MzIodikgeyByZXR1cm4gbih2LCAtMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDQwKHYpIHsgcmV0dXJuIG4odiwgLTQwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ0OCh2KSB7IHJldHVybiBuKHYsIC00OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NTYodikgeyByZXR1cm4gbih2LCAtNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDY0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDY0KHYpIHsgcmV0dXJuIG4odiwgLTY0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ3MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ3Mih2KSB7IHJldHVybiBuKHYsIC03Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50ODBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ODAodikgeyByZXR1cm4gbih2LCAtODApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDg4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDg4KHYpIHsgcmV0dXJuIG4odiwgLTg4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ5NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ5Nih2KSB7IHJldHVybiBuKHYsIC05Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTA0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEwNCh2KSB7IHJldHVybiBuKHYsIC0xMDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDExMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMTIodikgeyByZXR1cm4gbih2LCAtMTEyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTIwKHYpIHsgcmV0dXJuIG4odiwgLTEyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTI4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEyOCh2KSB7IHJldHVybiBuKHYsIC0xMjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDEzNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMzYodikgeyByZXR1cm4gbih2LCAtMTM2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTQ0KHYpIHsgcmV0dXJuIG4odiwgLTE0NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTUyKHYpIHsgcmV0dXJuIG4odiwgLTE1Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTYwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2MCh2KSB7IHJldHVybiBuKHYsIC0xNjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNjgodikgeyByZXR1cm4gbih2LCAtMTY4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNzZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTc2KHYpIHsgcmV0dXJuIG4odiwgLTE3Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTg0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE4NCh2KSB7IHJldHVybiBuKHYsIC0xODQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDkyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE5Mih2KSB7IHJldHVybiBuKHYsIC0xOTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIwMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMDAodikgeyByZXR1cm4gbih2LCAtMjAwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjA4KHYpIHsgcmV0dXJuIG4odiwgLTIwOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIxNih2KSB7IHJldHVybiBuKHYsIC0yMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMjQodikgeyByZXR1cm4gbih2LCAtMjI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjMyKHYpIHsgcmV0dXJuIG4odiwgLTIzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI0MCh2KSB7IHJldHVybiBuKHYsIC0yNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNDgodikgeyByZXR1cm4gbih2LCAtMjQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjU2KHYpIHsgcmV0dXJuIG4odiwgLTI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludCh2KSB7IHJldHVybiBuKHYsIC0yNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEodikgeyByZXR1cm4gYih2LCAxKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyKHYpIHsgcmV0dXJuIGIodiwgMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMyh2KSB7IHJldHVybiBiKHYsIDMpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczQodikgeyByZXR1cm4gYih2LCA0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczVgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM1KHYpIHsgcmV0dXJuIGIodiwgNSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNih2KSB7IHJldHVybiBiKHYsIDYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzN2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczcodikgeyByZXR1cm4gYih2LCA3KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM4KHYpIHsgcmV0dXJuIGIodiwgOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM5YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzOSh2KSB7IHJldHVybiBiKHYsIDkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMCh2KSB7IHJldHVybiBiKHYsIDEwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczExYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTEodikgeyByZXR1cm4gYih2LCAxMSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEyKHYpIHsgcmV0dXJuIGIodiwgMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMyh2KSB7IHJldHVybiBiKHYsIDEzKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTQodikgeyByZXR1cm4gYih2LCAxNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxNWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE1KHYpIHsgcmV0dXJuIGIodiwgMTUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNih2KSB7IHJldHVybiBiKHYsIDE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE3YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTcodikgeyByZXR1cm4gYih2LCAxNyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE4KHYpIHsgcmV0dXJuIGIodiwgMTgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTlgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxOSh2KSB7IHJldHVybiBiKHYsIDE5KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjAodikgeyByZXR1cm4gYih2LCAyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIxKHYpIHsgcmV0dXJuIGIodiwgMjEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMih2KSB7IHJldHVybiBiKHYsIDIyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjModikgeyByZXR1cm4gYih2LCAyMyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI0KHYpIHsgcmV0dXJuIGIodiwgMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjVgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyNSh2KSB7IHJldHVybiBiKHYsIDI1KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjYodikgeyByZXR1cm4gYih2LCAyNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyN2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI3KHYpIHsgcmV0dXJuIGIodiwgMjcpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyOCh2KSB7IHJldHVybiBiKHYsIDI4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI5YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjkodikgeyByZXR1cm4gYih2LCAyOSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczMwKHYpIHsgcmV0dXJuIGIodiwgMzApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMzFgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzMSh2KSB7IHJldHVybiBiKHYsIDMxKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMzIodikgeyByZXR1cm4gYih2LCAzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYWRkcmVzc2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRyZXNzKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwiYWRkcmVzc1wiLCB2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBib29sYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJvb2wodikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJib29sXCIsICEhdik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXModikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJieXRlc1wiLCB2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBzdHJpbmdgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwic3RyaW5nXCIsIHYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGFycmF5YGAgdHlwZSBmb3IgJSV2JSUsIGFsbG93aW5nICUlZHluYW1pYyUlIGxlbmd0aC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJyYXkodiwgZHluYW1pYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJhcnJheVwiLCB2LCBkeW5hbWljKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHR1cGxlYGAgdHlwZSBmb3IgJSV2JSUsIHdpdGggdGhlIG9wdGlvbmFsICUlbmFtZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB0dXBsZSh2LCBuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcInR1cGxlXCIsIHYsIG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgb3ZlcnJpZGVzKHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwib3ZlcnJpZGVzXCIsIE9iamVjdC5hc3NpZ24oe30sIHYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBvbmx5IGlmICUldmFsdWUlJSBpcyBhIFtbVHlwZWRdXSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNUeXBlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlXG4gICAgICAgICAgICAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgJiYgXCJfdHlwZWRTeW1ib2xcIiBpbiB2YWx1ZVxuICAgICAgICAgICAgJiYgdmFsdWUuX3R5cGVkU3ltYm9sID09PSBfdHlwZWRTeW1ib2wpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIHZhbHVlIGlzIGEgW1tUeXBlZF1dIGluc3RhbmNlLCB2YWxpZGF0ZXMgdGhlIHVuZGVybHlpbmcgdmFsdWVcbiAgICAgKiAgYW5kIHJldHVybnMgaXQsIG90aGVyd2lzZSByZXR1cm5zIHZhbHVlIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdXNlZnVsIGZvciBmdW5jdGlvbnMgdGhhdCB3aXRoIHRvIGFjY2VwdCBlaXRoZXIgYSBbW1R5cGVkXV1cbiAgICAgKiAgb2JqZWN0IG9yIHZhbHVlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVyZWZlcmVuY2UodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgaWYgKFR5cGVkLmlzVHlwZWQodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0eXBlOiBleHBlY2V0ZCAke3R5cGV9LCBnb3QgJHt2YWx1ZS50eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlZC5qcy5tYXAiLCJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uLy4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IHRvQmVIZXggfSBmcm9tIFwiLi4vLi4vdXRpbHMvbWF0aHMuanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQWRkcmVzc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInN0cmluZ1wiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dFcnJvcihlcnJvci5tZXNzYWdlLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModG9CZUhleChyZWFkZXIucmVhZFZhbHVlKCksIDIwKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiLCJpbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBDbG9uZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYW4gZXhpc3RpbmcgQ29kZXIsIGJ1dCB3aXRob3V0IGEgbG9jYWxOYW1lXG4gKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBBbm9ueW1vdXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb2RlcjtcbiAgICBjb25zdHJ1Y3Rvcihjb2Rlcikge1xuICAgICAgICBzdXBlcihjb2Rlci5uYW1lLCBjb2Rlci50eXBlLCBcIl9cIiwgY29kZXIuZHluYW1pYyk7XG4gICAgICAgIHRoaXMuY29kZXIgPSBjb2RlcjtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmRlY29kZShyZWFkZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFub255bW91cy5qcy5tYXAiLCJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBpc0Vycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRBcmd1bWVudENvdW50IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIsIFJlc3VsdCwgV29yZFNpemUsIFdyaXRlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBBbm9ueW1vdXNDb2RlciB9IGZyb20gXCIuL2Fub255bW91cy5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhY2sod3JpdGVyLCBjb2RlcnMsIHZhbHVlcykge1xuICAgIGxldCBhcnJheVZhbHVlcyA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgYXJyYXlWYWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlcyAmJiB0eXBlb2YgKHZhbHVlcykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbGV0IHVuaXF1ZSA9IHt9O1xuICAgICAgICBhcnJheVZhbHVlcyA9IGNvZGVycy5tYXAoKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgYXNzZXJ0KG5hbWUsIFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIG1pc3NpbmcgbmFtZXNcIiwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IFwidmFsdWVzXCIsIGluZm86IHsgY29kZXIgfSwgdmFsdWU6IHZhbHVlcyB9KTtcbiAgICAgICAgICAgIGFzc2VydCghdW5pcXVlW25hbWVdLCBcImNhbm5vdCBlbmNvZGUgb2JqZWN0IGZvciBzaWduYXR1cmUgd2l0aCBkdXBsaWNhdGUgbmFtZXNcIiwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IFwidmFsdWVzXCIsIGluZm86IHsgY29kZXIgfSwgdmFsdWU6IHZhbHVlcyB9KTtcbiAgICAgICAgICAgIHVuaXF1ZVtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzW25hbWVdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgdHVwbGUgdmFsdWVcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChjb2RlcnMubGVuZ3RoID09PSBhcnJheVZhbHVlcy5sZW5ndGgsIFwidHlwZXMvdmFsdWUgbGVuZ3RoIG1pc21hdGNoXCIsIFwidHVwbGVcIiwgdmFsdWVzKTtcbiAgICBsZXQgc3RhdGljV3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgIGxldCBkeW5hbWljV3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgIGxldCB1cGRhdGVGdW5jcyA9IFtdO1xuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gYXJyYXlWYWx1ZXNbaW5kZXhdO1xuICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgZHluYW1pYyBvZmZzZXQgKGZvciB0aGUgZnV0dXJlIHBvaW50ZXIpXG4gICAgICAgICAgICBsZXQgZHluYW1pY09mZnNldCA9IGR5bmFtaWNXcml0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgLy8gRW5jb2RlIHRoZSBkeW5hbWljIHZhbHVlIGludG8gdGhlIGR5bmFtaWNXcml0ZXJcbiAgICAgICAgICAgIGNvZGVyLmVuY29kZShkeW5hbWljV3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRvIHBvcHVsYXRlIHRoZSBjb3JyZWN0IG9mZnNldCBvbmNlIHdlIGFyZSBkb25lXG4gICAgICAgICAgICBsZXQgdXBkYXRlRnVuYyA9IHN0YXRpY1dyaXRlci53cml0ZVVwZGF0YWJsZVZhbHVlKCk7XG4gICAgICAgICAgICB1cGRhdGVGdW5jcy5wdXNoKChiYXNlT2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRnVuYyhiYXNlT2Zmc2V0ICsgZHluYW1pY09mZnNldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvZGVyLmVuY29kZShzdGF0aWNXcml0ZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEJhY2tmaWxsIGFsbCB0aGUgZHluYW1pYyBvZmZzZXRzLCBub3cgdGhhdCB3ZSBrbm93IHRoZSBzdGF0aWMgbGVuZ3RoXG4gICAgdXBkYXRlRnVuY3MuZm9yRWFjaCgoZnVuYykgPT4geyBmdW5jKHN0YXRpY1dyaXRlci5sZW5ndGgpOyB9KTtcbiAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLmFwcGVuZFdyaXRlcihzdGF0aWNXcml0ZXIpO1xuICAgIGxlbmd0aCArPSB3cml0ZXIuYXBwZW5kV3JpdGVyKGR5bmFtaWNXcml0ZXIpO1xuICAgIHJldHVybiBsZW5ndGg7XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrKHJlYWRlciwgY29kZXJzKSB7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBrZXlzID0gW107XG4gICAgLy8gQSByZWFkZXIgYW5jaG9yZWQgdG8gdGhpcyBiYXNlXG4gICAgbGV0IGJhc2VSZWFkZXIgPSByZWFkZXIuc3ViUmVhZGVyKDApO1xuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHJlYWRlci5yZWFkSW5kZXgoKTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRSZWFkZXIgPSBiYXNlUmVhZGVyLnN1YlJlYWRlcihvZmZzZXQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZGVyLmRlY29kZShvZmZzZXRSZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2Fubm90IHJlY292ZXIgZnJvbSB0aGlzXG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQlVGRkVSX09WRVJSVU5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9IGNvZGVyLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKHJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJCVUZGRVJfT1ZFUlJVTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZlc3RpZ2F0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIGtleXMucHVzaChjb2Rlci5sb2NhbE5hbWUgfHwgbnVsbCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFJlc3VsdC5mcm9tSXRlbXModmFsdWVzLCBrZXlzKTtcbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBBcnJheUNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvZGVyO1xuICAgIGxlbmd0aDtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlciwgbGVuZ3RoLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IChjb2Rlci50eXBlICsgXCJbXCIgKyAobGVuZ3RoID49IDAgPyBsZW5ndGggOiBcIlwiKSArIFwiXVwiKTtcbiAgICAgICAgY29uc3QgZHluYW1pYyA9IChsZW5ndGggPT09IC0xIHx8IGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICBzdXBlcihcImFycmF5XCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBjb2RlciwgbGVuZ3RoIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIC8vIFZlcmlmaWVzIHRoZSBjaGlsZCBjb2RlciBpcyB2YWxpZCAoZXZlbiBpZiB0aGUgYXJyYXkgaXMgZHluYW1pYyBvciAwLWxlbmd0aClcbiAgICAgICAgY29uc3QgZGVmYXVsdENoaWxkID0gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVmYXVsdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwiYXJyYXlcIik7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJleHBlY3RlZCBhcnJheSB2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvdW50ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudENvdW50KHZhbHVlLmxlbmd0aCwgY291bnQsIFwiY29kZXIgYXJyYXlcIiArICh0aGlzLmxvY2FsTmFtZSA/IChcIiBcIiArIHRoaXMubG9jYWxOYW1lKSA6IFwiXCIpKTtcbiAgICAgICAgbGV0IGNvZGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaCh0aGlzLmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAoY291bnQgPT09IC0xKSB7XG4gICAgICAgICAgICBjb3VudCA9IHJlYWRlci5yZWFkSW5kZXgoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlcmUgaXMgKnJvdWdobHkqIGVub3VnaCBkYXRhIHRvIGVuc3VyZVxuICAgICAgICAgICAgLy8gc3RyYXkgcmFuZG9tIGRhdGEgaXMgbm90IGJlaW5nIHJlYWQgYXMgYSBsZW5ndGguIEVhY2hcbiAgICAgICAgICAgIC8vIHNsb3QgcmVxdWlyZXMgYXQgbGVhc3QgMzIgYnl0ZXMgZm9yIHRoZWlyIHZhbHVlIChvciAzMlxuICAgICAgICAgICAgLy8gYnl0ZXMgYXMgYSBsaW5rIHRvIHRoZSBkYXRhKS4gVGhpcyBjb3VsZCB1c2UgYSBtdWNoXG4gICAgICAgICAgICAvLyB0aWdodGVyIGJvdW5kLCBidXQgd2UgYXJlIGVycm9yaW5nIG9uIHRoZSBzaWRlIG9mIHNhZmV0eS5cbiAgICAgICAgICAgIGFzc2VydChjb3VudCAqIFdvcmRTaXplIDw9IHJlYWRlci5kYXRhTGVuZ3RoLCBcImluc3VmZmljaWVudCBkYXRhIGxlbmd0aFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHsgYnVmZmVyOiByZWFkZXIuYnl0ZXMsIG9mZnNldDogY291bnQgKiBXb3JkU2l6ZSwgbGVuZ3RoOiByZWFkZXIuZGF0YUxlbmd0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29kZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29kZXJzLnB1c2gobmV3IEFub255bW91c0NvZGVyKHRoaXMuY29kZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5wYWNrKHJlYWRlciwgY29kZXJzKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiLCJpbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIEJvb2xlYW5Db2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJib29sXCIsIFwiYm9vbFwiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJib29sXCIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUgPyAxIDogMCk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuICEhcmVhZGVyLnJlYWRWYWx1ZSgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb2xlYW4uanMubWFwIiwiaW1wb3J0IHsgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgRHluYW1pY0J5dGVzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHR5cGUsIGxvY2FsTmFtZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiMHhcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBnZXRCeXRlc0NvcHkodmFsdWUpO1xuICAgICAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoICs9IHdyaXRlci53cml0ZUJ5dGVzKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRCeXRlcyhyZWFkZXIucmVhZEluZGV4KCksIHRydWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBCeXRlc0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJ5dGVzXCIsIGxvY2FsTmFtZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoc3VwZXIuZGVjb2RlKHJlYWRlcikpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCIsImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJ5dGVzQ29weSwgaGV4bGlmeSB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBGaXhlZEJ5dGVzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgc2l6ZTtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBcImJ5dGVzXCIgKyBTdHJpbmcoc2l6ZSk7XG4gICAgICAgIHN1cGVyKG5hbWUsIG5hbWUsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgc2l6ZSB9LCB7IHNpemU6IFwibnVtYmVyXCIgfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIChcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKS5zdWJzdHJpbmcoMCwgMiArIHRoaXMuc2l6ZSAqIDIpO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBnZXRCeXRlc0NvcHkoVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCB0aGlzLnR5cGUpKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJpbmNvcnJlY3QgZGF0YSBsZW5ndGhcIiwgX3ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlQnl0ZXMoZGF0YSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkocmVhZGVyLnJlYWRCeXRlcyh0aGlzLnNpemUpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXhlZC1ieXRlcy5qcy5tYXAiLCJpbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5jb25zdCBFbXB0eSA9IG5ldyBVaW50OEFycmF5KFtdKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBOdWxsQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwibnVsbFwiLCBcIlwiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJub3QgbnVsbFwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKEVtcHR5KTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZWFkZXIucmVhZEJ5dGVzKDApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWxsLmpzLm1hcCIsImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGZyb21Ud29zLCBnZXRCaWdJbnQsIG1hc2ssIHRvVHdvcyB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IENvZGVyLCBXb3JkU2l6ZSB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbmNvbnN0IEJOX01BWF9VSU5UMjU2ID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIE51bWJlckNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIHNpemU7XG4gICAgc2lnbmVkO1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIHNpZ25lZCwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAoKHNpZ25lZCA/IFwiaW50XCIgOiBcInVpbnRcIikgKyAoc2l6ZSAqIDgpKTtcbiAgICAgICAgc3VwZXIobmFtZSwgbmFtZSwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBzaXplLCBzaWduZWQgfSwgeyBzaXplOiBcIm51bWJlclwiLCBzaWduZWQ6IFwiYm9vbGVhblwiIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZ2V0QmlnSW50KFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgdGhpcy50eXBlKSk7XG4gICAgICAgIC8vIENoZWNrIGJvdW5kcyBhcmUgc2FmZSBmb3IgZW5jb2RpbmdcbiAgICAgICAgbGV0IG1heFVpbnRWYWx1ZSA9IG1hc2soQk5fTUFYX1VJTlQyNTYsIFdvcmRTaXplICogOCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgbGV0IGJvdW5kcyA9IG1hc2sobWF4VWludFZhbHVlLCAodGhpcy5zaXplICogOCkgLSAxKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IGJvdW5kcyB8fCB2YWx1ZSA8IC0oYm91bmRzICsgQk5fMSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBfdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSB0b1R3b3ModmFsdWUsIDggKiBXb3JkU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPCBCTl8wIHx8IHZhbHVlID4gbWFzayhtYXhVaW50VmFsdWUsIHRoaXMuc2l6ZSAqIDgpKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gbWFzayhyZWFkZXIucmVhZFZhbHVlKCksIHRoaXMuc2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZnJvbVR3b3ModmFsdWUsIHRoaXMuc2l6ZSAqIDgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuanMubWFwIiwiaW1wb3J0IHsgdG9VdGY4Qnl0ZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCIuLi8uLi91dGlscy91dGY4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgRHluYW1pY0J5dGVzQ29kZXIgfSBmcm9tIFwiLi9ieXRlcy5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmluZ0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcInN0cmluZ1wiLCBsb2NhbE5hbWUpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuY29kZSh3cml0ZXIsIHRvVXRmOEJ5dGVzKFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJzdHJpbmdcIikpKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gdG9VdGY4U3RyaW5nKHN1cGVyLmRlY29kZShyZWFkZXIpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmcuanMubWFwIiwiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuLi8uLi91dGlscy9wcm9wZXJ0aWVzLmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuaW1wb3J0IHsgcGFjaywgdW5wYWNrIH0gZnJvbSBcIi4vYXJyYXkuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBUdXBsZUNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvZGVycztcbiAgICBjb25zdHJ1Y3Rvcihjb2RlcnMsIGxvY2FsTmFtZSkge1xuICAgICAgICBsZXQgZHluYW1pYyA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0eXBlcyA9IFtdO1xuICAgICAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlcy5wdXNoKGNvZGVyLnR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHlwZSA9IChcInR1cGxlKFwiICsgdHlwZXMuam9pbihcIixcIikgKyBcIilcIik7XG4gICAgICAgIHN1cGVyKFwidHVwbGVcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGNvZGVyczogT2JqZWN0LmZyZWV6ZShjb2RlcnMuc2xpY2UoKSkgfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIHRoaXMuY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChjb2Rlci5kZWZhdWx0VmFsdWUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBvbmx5IG91dHB1dCBuYW1lZCBwcm9wZXJ0aWVzIGZvciB1bmlxdWVseSBuYW1lZCBjb2RlcnNcbiAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSB0aGlzLmNvZGVycy5yZWR1Y2UoKGFjY3VtLCBjb2RlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2N1bVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgLy8gQWRkIG5hbWVkIHZhbHVlc1xuICAgICAgICB0aGlzLmNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgaWYgKCFuYW1lIHx8IHVuaXF1ZU5hbWVzW25hbWVdICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJfbGVuZ3RoXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXNbbmFtZV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUodmFsdWVzKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInR1cGxlXCIpO1xuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIHRoaXMuY29kZXJzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHVucGFjayhyZWFkZXIsIHRoaXMuY29kZXJzKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10dXBsZS5qcy5tYXAiLCJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiAgQSBzaW1wbGUgaGFzaGluZyBmdW5jdGlvbiB3aGljaCBvcGVyYXRlcyBvbiBVVEYtOCBzdHJpbmdzIHRvXG4gKiAgY29tcHV0ZSBhbiAzMi1ieXRlIGlkZW50aWZpZXIuXG4gKlxuICogIFRoaXMgc2ltcGx5IGNvbXB1dGVzIHRoZSBbVVRGLTggYnl0ZXNdKHRvVXRmOEJ5dGVzKSBhbmQgY29tcHV0ZXNcbiAqICB0aGUgW1trZWNjYWsyNTZdXS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBpZChcImhlbGxvIHdvcmxkXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZCh2YWx1ZSkge1xuICAgIHJldHVybiBrZWNjYWsyNTYodG9VdGY4Qnl0ZXModmFsdWUpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCIsIi8vIGNyZWF0ZWQgMjAyMy0wOS0xMlQyMjowNToxNC4yMTFaXG4vLyBjb21wcmVzc2VkIGJhc2U2NC1lbmNvZGVkIGJsb2IgZm9yIGluY2x1ZGUtZW5zIGRhdGFcbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9ibG9iL21haW4vc3JjL21ha2UuanNcbi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcyNzZWN1cml0eVxuLy8gU0hBLTI1NjogMDU2NWVkMDQ5YjljZjE2MTRiYjllMTFiYTdkOGFjNmE2ZmI5NmM4OTMyNTNkODkwZjdlMmIyODg0YjlkZWQzMlxudmFyIENPTVBSRVNTRUQkMSA9ICdBRUVVZHdtZ0RTOEJ4UUtLQVA0Qk9nRGpBVEFBbmdEVUFJTUFvQUJvQU9BQWFnQ09BRVFBaEFCTUFISUFPd0E5QUNzQU5nQW1BR0lBSGdBdUFDZ0FKd0FYQUMwQUdnQWpBQjhBTHdBVUFDa0FFZ0FlQUFrQUd3QVJBQmtBRmdBNUFDZ0FMUUFyQURjQUZRQXBBQkFBSGdBaUFCQUFHZ0FlQUJNQUdBVWhCZThCRnhSRU44c0Yyd0M1QUs1SEFXOEFyUWtEelFDdWh6YzNOemNCUDY4TkVmTUFCUWRIQnV3NUJWOEZZQUE5TXprSTlyNFpCZzdReVFBV0E5Q2VPd0xOQ2pjQ2pxa0NodUEvbG0rUkFzWFRBb1A2QVNmbkVRRHl0UUZKQWpXVkNrZVhBT3NBNmdvZEFCL2N3ZEFVRTBXbEJDTi9BUVVDUVJqRkQvTVJCakh4RFFTSmJ3MGpCelVBc3dCeG1lK3RuSWNBWXdhYkF5c0c4UUFqQUVNTW14Y0RxZ1BLUXlEWENNTXhBN2tVUXdEM05YT3JBS21GSUFBZkJDMEQzeDRCSlFEQkdkVUZBaEVnVkQ4Sm53bVFKaU5XWVV6cmcwb0FHd0FVQUIwQUZuTmNBQ2tBRmdCUDloM2dQZnNET1dES25lWTJDaGdsWDFVRFlEMzBBQnNBRkFBZEFCWnpJR1JBbndERDh3QWpBRUVNelJiRHFnTUIyc0FGWXdYcUF0Q25Bc1M0QXdwVUpLUnRGSHNhZFV6OUFNTVZid0xwQUJNMU5KRVgwWmtDZ1lNQkV5TUF4UlZ2QXVrQUV6VUJVRkF0bVV3U0F5NERCVEVSMzNFZnRRSGZTd0I1TXhKL0Fqa1dLUUx6TDhFL2N3QkI2UUg5TFFEUER0TzlBU05yaVFDNURRQU5Bd0NLMjFFRkk5MXpId0NvTDlrQnFRY0hCd2NIS3pVRG93QnZBUW9oUHZVM2ZBUWdId0N5QWM4Q0tRTUE1ek1TZXpyN1VMZ0ZtRHAvTHpWUUJnRUdBaThGWVFWZ3Q4QUZjVHRsUWhwQ1dFbWZlNXRtWjZJQUV4c0R6UTh0K1g4ckJLdFRBbHRiQW4wanN5OEJsNnV0UFdNRFRSOEVpMmtSQU5rREJyTkhOeXNEQnpFQ1FXVUFjd0ZwSjNrQWl5VWhBSjBCVWI4QUwzRWZBYmZOQXo4MUtVc0ZXd0YzWVFadEFtMEErVkVmQXpFSkRRQlJTUUN6QVFCbEFIc0FNNzBHRC92M0laV0hCd0FSS1FBeEFMc2pUd0haQWVNUEV6bVhnSUh3QUJJQUdRQThBRVVBUUR0M2dkdklFR2NRWkFrR1RSRk1kRUlWRXdLMEQ2NEw3UkVkRE5rcTA5UGdBRFN4Qi9NRFd3ZnpBMXNEV3dmekIvTURXd2Z6QTFzRFd3TmJBMXNjRXZBaTI4Z1FadzlRQkhVRmxnV1RCTjRJaXlaUkVZa0hNQWphVkJWMEpoeFBBMDBCQkNNdFNTUTdtek1USlVwTUZFMExDQVEyU215dmZVQURUekd6VlAyUXFnUFRNbGM1ZEFrR0hua1NxQUF5RDNza05iMU9obnBQY2FnS1UwKzJ0WWRKYWs1dkFzWTZzRUFBQ2lrSm0yL0RkMVlHUlJBZko2a1Erd3czQWJrQlB3M3hTOXdFOVFZL0JNMGZnUmtkRDlHVm9BaXBMZUVNOFNibkxxV0FYaVA1S29jRjhVdjRQT0VMVVZGc0QxMExhUW5uT21lQlVnTWxBUkVpandyaERUMEljUkQzQ3MxdkRla1JTUWM5QTlsSm5nQ3BCd1VMRlIwNUZia21GR0t3Q3cwNWV3Yi9Hdm9Ma3lhekV5MTdBQVhYR2lVR1VRRXRHd01BMHk3cmhiUmFOVndnVDJNR0J3c3BJOHNVckZBa0RTbEF1M2hNR2g4SEdTV3RBcFZEZEVxTFVUb2VseUg2UEVFTmFpNFhVWUFIK1R3SkdWTUxoVHlpUnE5RkVoSFdQcEU5VENKTlREQUVPWU1zTXllUENkTVBpUXk5ZkhZQlhRa2xDYlVNZFJNMUVSczN5UWc5QngweGx5Z25HUWdsUnBsZ25nVDdvd1AzRTlVRER3VkRDVVVIRndPNUhERVRNaFV0QlJHQktOc0M5emJaTHJjQ2sxYUVBUnNGenc4cEgrTVFWRWZrRHUwSW53SnBBNGNsN3dBeEZTVUFHeUtmQ0VkbkFHT1AzRk1KTHM4SXkycHdJM2dEYXhUclpSRjNCNVVPV3dlckhEY1Z3eHpsY014ZUQ0WU1LS2V6Q1Y4QmVRbWRBV01FNXdnTk5WK01wQ0JGWjFlTFhCaWZJR1ZCUTE0QUFqVU1hUldqUk1HSGZBS1BEMjhTSHdFNUFYY0hQUTBGQW5zUjhSRnZFSmtJNzRZSU5ia3ovRG9wQkZNaGh5QVZDaXNEVTJ6U0N5c20vUXo4YlFHbkVtWURFRFJCZC9KbnIyQzZLQmdCQngweXlVRmtJZlVMbGsvUkRLQWF4UmhHVkRJWjZBZkRBL2NhOXlmdVFWc0dBd09uQnhjNlVUUHlCTUVMYlFpUENVTUFUUTZuR3dmYkdHNEtkWXpVQVRXUEFidWRBMXVWaHdKemt3WTdCdzhBYXcrTEJYM3BBQ0VDcXdpbkFBa0Ewd05iQUQwQ3NRZWhBQjBBaVVVQlFRTXJNd0VsNlFLVEE1Y0lOYzhCbVRNQjl5MEVIOGNNR1FEN08yNU9Bc08xQW9CdVpxWUY0VndDa2dKTk9RRlJLUVFKVWt0VkE3TjE1UURmQUU4R0YrTkxBUm12VHM4ZTUwY0I0M012QU1zQS93QUpPUWNKUlFIUkFmZHhBTHNCWXdzMUNhYTN1UUZSN1MwQWh3QVpid0hiQW8wQTRRQTVBSVAxQVZjQVVRVmQvUVhYQWxOTkFSVTFIQzliWlFHL0F5TUJOd0VSQUgwR3o1R3B6UXNqQkhFSDF3SVFIeFhsQXU4eUI3a0ZBeUxqRTlGQ3lRSzk0bGtBTWhvS1BBcXJDcXBnWDJRM0NqVjJQVlFBRWgrc1Bzcy9VZ1ZWTzFjN1hEdFhPMXc3Vnp0Y08xYzdYRHRYTzF3RG04UG13K1lLY0Y5SlllOE1xZzNZUk13NlRSUGZZRlZnTmhQTUxic1V4UlhTSlZvWlFSckFKd2tsNkZVTkR3Z3QxMlkwQ0RBMGVSZkFBRU1wYklORlk0b2VOQXBQSE90VGxWVDhMUjhBdFV1bU03TU5zQnNaUkVRRlMzWHhZaTRXRWdvbUFtU0ZBbUpHWDFHekFWODNKQUtoK3dKb25BSm1EUUtmaURnZkR3Sm1Qd0ptS2dSeUJJTURmeGNEZnBZNUNqbDdHem1HT2ljbkFtd2hBakk2T0E0Q2Jjc0NiYkx6amdNM2Ewa3ZBV3NBNGdEbEFFNEpCNXdNa1FFQ0Q4WUFFYmtDZHpNQ2RxWkRBbmxQUndKNHZpRmczMFd5UnZjQ2ZFTUNlc3dDZlEwQ2ZQUklCRWlCWnlnQUx4bEpYRXBmR1J0SzBBTFJCUUxRMEVzckE0aFRBNGZxUk1tUk5nTHlwVjBIQXdPeVM5Sk1NU2tIMDAxUVRiTUNpME1DaXR6Rkh3c2hSMnNKdXdLT093S09ZRVNiaFFLTzNRS09ZSHhSdUZNNUFRNVMyRlNKQXBQL0FwTVFBTzBBSUZVaVZiTlYxQW9zSHltWmlqTGxlR3BGUHowQ2w2TUM3N1pZSmF3QVhTa0NscE1DbG9DZ0FLMVpzRm9OaFZFQVB3S1d1UUtXVWx4SVhOVUNtYzhDbVdoY3psMExIUUtjbnpuR09xRUNuQm9DbjU4Q25yeU9BQ0VUTlM0VEFwMzFBcDZXQUxsQllUaGg4d0tlMXdLZ2NnR3RBcDZqSXdLZVVxbGp6R1FyS1M4Q0o3TUNKb0lDb1A4Q29GRGJBcVl6QXFYU0FxZ0RBSUVDcC9ab2dHaTFBQWROYWlCcTFRS3M1d0tzc2dLdGF3S3RCZ0pYSVFKVjRBS3g1ZHNESDFKc213S3l3UkVDc3V3YmJPUnRaMjFNWXdNbDBRSzJZRDlEYnBRREtVa0N1R0lDdVVzWkFya3VlM0E2Y09VQ3ZSMERMYllETWhVQ3ZveHlCZ016ZFFLK0huTW1jMU1Ddzg4Q3d3aHpoblJQT1VsMDVBTThxd0VEUEo0RFBjTUN4WUFDeGtzQ3hoU05Bc2h0VlFMSVNBTEpVd0xKTWdKa29RTGQxbmg5WlhpeWVTbEwxQU1ZcDJjR0FtSDRHZmVWS0hzUFhwWmV2eFVDejI4Q3ozQXpUMWZXOXhlakFNcXhBczkzQVMzdUEwNFdmazhKQXR3ckF0dU9BdEpUQTFKZ0ExTmpBUVVEVlpDQWpVTUV6eHJ4WkVsNUE0TFNnNUVDMnNzQzJlS0VGSVJOcDBBRGhxa0FNd05rRW9aMVhmMEFXUUxmYVFMZXZIZDdBdUl6N1JnQjh6UXJBZlNmQWZMV2l3THI5d0xwZEgwREF1cjlBdXJvQVAxTEFiMEM3bzBDNjZDV3JwY0hBdTVEQTRYa21IMXc1SEdsQXZNSEFHMERqaHFabHdMM0Z3T1JjZ09TaXdMM25BTDUzUUw0YXBvZ21xKy9PNXNpQTUySEF2NytBUjhBUFo4Z0FaKzNBd1dSQTZadUE2YmRBTlhKQXdadW9ZeWlDUTBEREUwQkV3RWpCM0VHWmIxckNRQy9CRy9ERlk4ZXR4RUFHM2s5QUNjRE54SlJBNDJEQVdjckpRQ004d0FsQU9hbkM2T1ZDTHNHSTZmSkJnQ3ZCUm5EQnZFbFJVWUZGb0FGY0Q5R1NETkNLVUs4WDNrWlg4UUFsczBGT2dDUVZDR2J3VHN1WURvWnV0Y09OeGpPR0pISi9nVmZCV0FGWHdWZ0JXc0ZZQVZmQldBRlh3VmdCVjhGWUFWZkJXQk9IUWpmalc4S0Nnb0tiRjd4TXdUUkE3a0dOOFBEQU1NRXI4TUE3MGd4RnJvRlRqNXhQbmhDUjBLK1gzMC9YL0FBV0JrenN3Q05Cc3h6ekFTbTcwYUNSUzRyRERNZUx6NDlmblhmY3NINUdjb3NjUUZ6MTNZNEh3Vm5CWExKeWNuQUNOZFJZd2dJQ0FxRVhvV1R4Z0E3UDRrQUN4YlpCdTIxS3cwQWpNc1RBd2tWQU9WdEpVVXNKMUpDdVVMRVNVQXJYeTlnUGk5QUt3bkpSUVlLVEQ5TFBvQStpVDU0UG5rQ2tVTEVVVXBEWDlOV1YzSlZFalFBYzF3M0EzSUJFM1luWCtnN1FpTUpiNk1LYWlzelJDVXVRck5DeERQTUNjd0VYOUVXSnpZUkVCRUVCd0lIS242bDMzSkNOVklmeWJQSnRBbHR5ZFBVQ21oQlp3L3RFS3NaQUpPVkpVMUNMUnV4YlVIT1FBbzdQMHMrZUVKSEhBOFNKVlJQZEdNME5WcnB2Qm9LaGZVbE0wSkhIR1VRVWhFV08xeExTajhNTzB1Y05BcUpJelZDUnh2OUVGc3FLeUE0T1FnTmoybndaZ3A1Wk5GZ0UyQTFLM1lIUzJBaFFRb2pKbUM3RGdwekdHMVdZRlVaQ1FZSFpPOWdIV0NkWUlWZ3UyQlRZSmx3Rmg4R3ZSYmNYYkc4WWd0REhyTUJ3elBWeVFvbkhRZ2tDeVlCZ1FKMEFqYzRuVnFJQXdHU0NzQlBJZ0RzSzNTV0V0SVZCYTVOOGdHakFvK2tWd1ZJWndEL0FFVVNDRHdlWDRJVHJSUXNKOEszVHdCWEZEd0VBQjBUdnpWY0F0b1RTMjBSSXdEZ1ZnWjlCQkltWWdBNUFMNENvaThMRm5lek9rQ25JUUZqQVk0S0JBUGg5UmNHc2daU0JzRUFKY3Rkc1dJUnUya1RrUXN0Unc3REFjTUJLZ3BQQkdJR01EQXdLQ1luS1RRYUxnNEFLUlNWQUZ3Q2RsK1lVWjBKZGljRkQzbFBBZHQxRjlaWktDR3h1RTN5QnhrRlZHY0Evd0JGRWdpQ0J3QU9MSFFTanhPdFFEZzF6N2RlRlJNQVo4UVRBR3RLYjFBcElpUEhBRGtBdmdLaUx5MURGdFlDbUJpREFsRERXTkIwZW83ZnBhTU8vYUVWUlJ2MEFURVFaQklPRHlNRUFjOEpRaENiRFJnekZENFRBRU1BdTlZQkNnQ3NBT2tBbTVJM0FCd0FZeHZPTm5SK01oWEpBeGdLUXl4TDIra2tKaE1iaFFLREJNa1NzdkYwQUQ5Qk5RNnVRQzdXcVNRSHd4RUFFRUl1MWhraEFIMno0aVFQd3lKUEhOV3BkeVlCUlNwbkpBTHpvQkFFVlBQc0gyME14QTBDQ0VRS1JnQUZ5QXRGQWxNTnd3akVEVVFKUkFyRUx0YXBNZzdERFpnSkl3K1RHdWtFSXd2REZrTUFxQXRERU1NTUJoaW9lK1FBTzNNTVJBQUNyZ25FQlNQWTlRMEZEbmJTQm9NQUI4TVNZeGtTeEFFSkFQSUpBQUI4RldNT0Z0TWMvSGNYd3hoREFDN0RBdk9vd3dBZXd3SmRLREtIQUFIREFBTHJGVVFWd3dBYnd5dnpwV01Xdjh3QS9BQnBBeSsrYmNZRFVLUEQwS2hEQ3dLbUoxTUFBbU1BNStVWnd4QWFnd2lwQlJML2VBRGZ3NmZER09NQ0dzT2prM2w2QndPcG80c0FFc01PR3hNQUE1c0FiY01PQUF2RHAwTUpHa01Ed2dpcG5OSVBBd2ZJcVVNR0FPR0RBQVB6QUJYREFBY0RBQW5EQUdtVEFCckRBQTdEQ2hqRGpuRVdBd0FCWXdBT2N3QXVVeVlBQnNNQUY4TUlLUUFOVWdDNnd5NEFBOE1BRHFNcTh3Q3lZZ0FjSXdBQjh3cXBBQVhPQ3gwVjR3QUhvd0JDd3dFS0FHbkRBQXVEQUIzREFBakRDYWtBQmRJQWJxY1ozUUNaQ0NrQUJkSUFBQUZEQUFmakFCMmpDQ2tBQnFJQUNZTUFHek1BYlNNQTVzT0lBQWhqQUFoREFCVERCQWtwQUFiU0FPT1RBQWxEQzZrT3pQdG5BQWREQUc2a1FGQUFUd0FLd3d3QUEwTUFDYlVEUHdBSEl3QVpnd0FDRTZjREFBb2pBQXBEQUFvRHAvTUd3d0FKSXdBREV3QVFRd2dBRkVNQUVYTUFENU1BRGZNQURjTUFHUk1PRmlNQUZVTUFicU1XdXdIREFNSUFFME1MQUdrekVnRGhVd0FDUXdBRVdnQVhnd1VqQUFiWUFCakRCU1lCZ3pCYUFFRk5BTGNRQnhVTWVnQXdNbmdCckEwSVpnSjBLeFFIQlJFUGQxTjBaektSSndhSUhBWnFOVDREcVFxOEJ3bmdBQjREQXd0MkFYNTZUMW9jS1FOWEFoMUdBVFFHQzN0T3hZTmFna2dBTVFBNUNRQURBUUVBV3hMakFJT1lOQUV6QUg3dEZSazZUZ2xTQUY4TkFBbFlBUStTMUFDQVF3UW9yUUJpQU40ZEFKMXdQeWVUQU5WenVRRFgzQUllRU1wOWV5TWdYaVVBRWRrQmtKaXpLbHRiVlZBYVJNcVJBQUVBaHlRL1NERXo2Qm1mVndCNkFURXNPQ2xLSVJjRE9GMEUvODMyQUZOdDVBQnlBbmtDUnhHQ09zOTROalhkQXdJTkdCb25EQndQQUxXMkF3SUNBZ0FBQUFBQUFBWURCUU1EQVJyVUF3QXRBQUFBQWdFR0JnWUdCZ1lGQlFVRkJRVUVCUVlIQ0FrRUJRVUZCUVFBQUFJQ0FBQUFJZ0NOQUpBQWxUMEE2Z0M3QU53QXBFUUF3Z0N5QUswQXFBRHVBS1lBMmdDakFPY0JDQUVEQU1jQWdRQmlBTklBMUFFREFONEE4Z0NRQUtrQk1RRHFBTjhBM0FzQkNROHlPOXJhMnRxOHh1TFQxdFJKT0IwQlVnRmNOVTBCV2dGcEFXZ0JXd0ZNVVVsTGJoTUJVeHNORUFzNlBoTU9BQ2NVS3kwdk1qNUFRRU5EUTBSRkZFWUdKRmRYVjFkWldWaFpMMXBiWFZ4Y0kyTm5aMlpvWnlwc2JuWjFlSGg0ZUhoNGVucDZlbnA2ZW5wNmVucDhmSDE4ZTJJQVJQSUFTUUNhQUhnQU1nQm0rQUNPQUZjQVZ3QTNBbmJ2QUlzQUJmajRBR1FBay9JQW53QlBBR0lBWlAvL3NBQ0ZBSVVBYVFCV0FMRUFKQUMyQUlNQ1FBSkRBUHdBNXdEK0FQNEE2QUQvQU9rQTZRRG9BT1lBTHdKN0FWRUJRQUUrQVZRQlBnRStBVDRCT1FFNEFUZ0JPQUVjQVZnWEFERVFDQUVBVXg4U0hnc2RIaFlBamdDV0FLWUFVUUJxSUFJeEFIWUFid0NYQXhVREp6SURJVWxHVHpFQWtRSlBBTWNDVndLa0FNQUNsZ0tXQXBZQ2xnS1dBcFlDaXdLV0FwWUNsZ0tXQXBZQ2xnS1ZBcFVDbUFLZ0FwY0NsZ0tXQXBRQ2xBS1VBcFFDa2dLVkFuVUIxQUtYQXA4Q2xnS1dBcFVlQUlFVEJRRCtEUU9mQW1FQ09oOEJWQmc5QXVJWkVqTWJBVTQvRzFXWkFYdXNSQUZwWVFFRkEwRlBBUVlBbVRFZUlKZHlBREZvQUhFQU5nQ1JBNXpNay9DMmpHSU53ak1XeWdJWkNhWGRmRElMQkNzNWRBRTdZblFCdWdEbGhvaUhob2lHaVlxS2hvdU9qSWFOa0k2SWo0cVFpcEdHa29hVGhwU1NsWWFXaHBlS21JYVpocHFHbTRhY2k1MlFub3FmaHVJQzRYVHBBdDkwQUlwMExIU29BSXNBZEhRRVF3UkFCRUlFUlFSREJFa0VSZ1JCQkVjRVNRUklCRVFFUmdSSkFKNXVkQUNyQTQ5MEFMeHVBUTEwQU5GWmRIUUExM1FDRkhRQS9tSjBBUDRCSVFEK0FQd0EvQUQ5QVB3RGhHWjAzQVNNSzIzSEFQNEEvQUQ4QVAwQS9DUjBkQUNSWW5RQS9nQ1JBU0VBL2dDUkF2UUEvZ0NSQTRSbWROd0VqQ3R0eHlSMEFQOWlkQUVoQVA0QS9nRDhBUHdBL1FEOEFQOEEvQUQ4QVAwQS9BT0VablRjQkl3cmJjY2tkSFFBa1dKMEFTRUEvZ0NSQVA0QWtRTDBBUDRBa1FPRVpuVGNCSXdyYmNja2RBSkxBVDUwQWxJQlFYUUNVOGwwZEFKZmRIUURwZ0wwQTZZRHBnT25BNmNEcHdPbkE0Um1kTndFakN0dHh5UjBkQUNSWW5RQklRT21BSkVEcGdDUkF2UURwZ0NSQTRSbWROd0VqQ3R0eHlSMEJEaDBBSkVFT1FDUkRwVTVkU2dDQURSMDNnVjJDd0FyZEFFRkFNNWlDblIwQUYxaUFBWWNPZ3AwZEFDUkNuUUFYQUVJd1daMENuUm1kSFFBa1daMENuUm1kRVhnQUZGMDNncDBkRVkwdGxUMnUzU09BUVR3c2N3aGpaWktyaFljQlNmRnA5WE5iS2lWRE9EMmIrY3BlNC9aMTdtUW5idHp6aGFlUXRFMkdHajBJRE5UalJVU3lUeHh3L1JQSFcvK3ZTN2QxTmZSdDl6OVFQWmc0WDdRRmZoQ25rdmdOUElJdE9zQzJlVjZoUGFublpOSGxaOXhyd1pYSU1PbHUzalNvUVNxNzhXRWp3TGp3MUVMU2xGMWFCdmZ6d2s1Wlg3QVV2UXpqUFFLYkR1UStzbTR3Tk9wNEE2QWRWdVJTMHQxeS9EWnBnNFI2bTdGTmpNOUhndlc3Qmk4OHphTWpPbzZsTTh3dEJCZGo4TFA0eWx2M3pDWFBoZWJNS0pjMDY2bzlzRjcxb0ZXLzhKWHU4NkhKYndESUQ1bHp3NUdXTFIvTGhUMFFxbnAySlF4TlpOZmNiTEl6UHkrWXlwcVJtL2xCbUdtZXgrODIrUGlzeFV1bVNlSmtBTElUNnJKZXp4TUgrQ1RKbVF0dDV1d1RWYkwzcHRtakRVUXpsU0l2V2k4VGw3bmcxTnB1Um4xTmc0bjE0UWMrM0lpbDdPd2t2TldvZ0xTUGtuM3BpaElGeXR5SUdtTWhPZTNuMXRXc3VNeTlCZEt5cUY0WjN2MlNnZ2dUTDlLVnZNWFBuQ2JSZStvT3VGRlAzSGVqQkcvdzlndm1mTll2ZzZKdVdpYTJsY1NTTjF1SWpCa3R6b0lhek9IUEpaN2tLSFB6OG1SV1ZkVzNsQThXR0Y5ZFFGNkJtNjczYm9vdjNCVVdEVTJKTmNhaFIyM0d0ZkhLTE96L3ZpWityWW5aRmFJem5YTzY3Q1lFSjFmWHVUUnBaaFlaa0tlNTR4ZW9hZ2tOR0xzK05UWkhFMHJYNDUvWHZRMlJHQURYNnZjQXZkeElVQlYyN3d4R20yempabzRYM0lMZ0Fsck9GaGV1WjZ3dHN2YUlqNHlMWTdxcWF3bGxpYUljcnoyRytjM3ZzY0FuQ2tDdU16TW1adk1mdTlsTHdUdmZYKzNjVlN5UGROOVp3Z0RaaGZqUmdOSmNMaUo2N2I5eHg4Skhzd3ByYmlFM3Y5VXBob3RBUElnblhWSU41S21NYzBwaVhoYzZjQ2hQbk4rTVJoRzlhZHRkdHRRVFR3U0lwbDhJNC9qLy9kM3N6MTMyNnFUQlRwUFJNL0hnaDNrenFFWHM4WkFrNEVyUWhOTzhoenJRMERMa1dNQS9OKzkxdG4yTWRPSm5XQzJGQ1plaGtRcnd6d2JLT2podlpzYk05NVFvZUw5c2tZeU1mNHNyVlBWSlNnZzdwT0xVdHIvbjllVDk5b2U5bkx0RlJwakE5b2tWMktqOGg5azVIYUMwb2l2UkQ4VnlYa0o4MXRjZDRmSE5YUENmbG9JUWFzeHN1TzE4LzQ2ZFIyamd1bC9VSWV0Mkcwa1J2bnlPTk1LaEhzNkoyNkZFb3FTcWQrcmZZamVFR3dIV1ZEcFgxZmgxakJCY0tHTXFSZXBqdTlZMDBtRFZIQytYZGlqL2o0NHJLZnZmakdpbk5zMWpPLzBGM2pCODNYQ0RJTk4vSEI4NGF4bFArM0Uva2xrdFJvK3ZsM1UvYWl5TUpiSW9kRTFYU3NEbjZVQXpJb010VU9iWTIray80Z1kvbCtBa1pKNVNqMnZRcmt5TG0zRm94amhEWCszMVVYQkZmOVhyQUgzMWZGcW9CbURFWnZodnZwblo4N04rb1pFdTdVOU8vbm5rK1FXajN4OHV5b1JiRW5mK081VU1yOWkwbkhQMzhJRjVBdnpyQlc4WVdCVVIwbUlBekl2bmRRcTlOM3YvSnRvM2FQalBYVVBsOEFTZFBQeUFwN2pFTmY4Yms3Vk1NOW9sOVhHbWxCbWVETXVHcXQrV3p1TDZDWEF4WGpJaENQTTV2QUNjaGdNSi84WEJHTE8vRDFpc1Z2R2h3d0hIcjFETGFJNW1uMkpyL2IxcFVEOTB1Y2lEYVM4Y1hORHpDV3ZObVQvUGhRZTVlOG5Ubm5ua3Q4RHMvU0lqaWJjdW0vZnFEaEtvcHhBWThBa1NyUG4rSUdERUtPTytVM1hPUDZkakZzMkg1Tjkrb3JoT2FoaVFrNUtuRVVXYStDemtWemhwOGJNSFJiZzgxcWhqalh1SUtiSGpTTFNJQktXcW9ja0d0S2luWSt6NC9SZEJVRjZwY2MzSm1ubHhWY05nckk0U0V6S1VaU3djRDJRQ3l4ekt2ZStnQW1nNlp1U1JrcFBGYTZtZlRodTdMSk51M0g1SzQydUNwTnZQQXNvZWRvbEtWL0xIZS9lSitCYmFHNU1HME5hU0dWUFJVbU5GTUZGU1NwWEVjWHdiVmg3VUVUT1padG9WTlJHT0liYmtpZzNNY0V0UjY4Y0cwUlpBb0pldldZbzdEZy9sWjFDUXpibFdlVXZWSG1yOGZZNE5xZDlKSmlIL3pFWDI0bUp2aUg2MGZBeUZyMEEzYzRiQzFqM3laVTYwVmdKeFhuOEpnSlhMVUlzaUJubUttTVl6Kzd5QlFGQnZxYjJlWW51VzU5am9aQmY1Ni93WHZXSVI0Ujh3VG1WODBpMW1aeStTNCtCVUVTK2h6amswdVhwQy8vL3ovSWxxSFoxbW9uemxYcDhhQ2ZoR0tNdGk3M0ZJMUtiTDFxNklLTzRmdUJ1WjU5Z2Fnam41eFU3OW11TXBIWGc2UytlK2dETS9VOUJLTEhibDlsNm84Y3pRS2w0UlVrSkppcWZ0UUcyaTNCTWcvVFFsVVlGa0pEWUJPT3ZBdWdZdXpZU0RuWmJERGQvYVNkOXgwT2U2RitiSmNIZmw5K2dwNkw1L1RnQStCZEZGb3ZiZkNyUTQwczV2TVB3ODg2NnBOWDh6eUZHZUZXZHhJcFBWcDlSZzFVUE9WRmJGWnJ2YUZxL1lBekhRZ3FNV3BhaE1ZZnFIcG13WGZITDEva3BZbUd1SEZ3VDU1bVF1MGR5bGZOdXEyT3EwaFRNQ1B3cWZ4bnVCSVBMWGZjaTRZMUFOeSsxQ1VpcFF4bGQvaXpWaDE2V3lHMlEwQ1FROU5xdEFueDFIQ0h3RGo3c1l4T1NCMHdvcFpTbk96eFFPY0V4bXhyVlRGMkJrT3RoVnBHZnVoYUdFQ2ZDSnBKS3BqbmloWSt4T1QyUUp4TjYxKzlLNlFTcXR2MlNocjgySTNqZ0pycUJnMHdFTEZaUGp2SHB2elR0YUpuTEs2VmI5N1luOTMza29PL3NhTjdmc2p3Tkt6cDRsMmxKVngyb3JqQ0d6Qy80Wkw0ekN2ZXI2YVFZdEM1c2RveWNodUZFNnVmT2lvZytWV2k1VURrYm12bXRhaC8zYUFyRUJJaTM5czVJTFVubEZMZ2lsY0d1ejlDUXNoRVk3Zncyb3VvSUxBWVBWVC9neUFJcTNURkFJd1ZzbCtrdGtSei9xR2ZuQ0RHcm01Z3NsL2w5UWR2Q1dHc2pQejNkVTdYdXFLZmRVcnIvNlhJZ2pwNHJleTZBSkJtQ21VSk1qSVRIVmRGYjVtMXArZExNQ0w4dDU1ekQ0MmNtZnRtTEVKQzBEYTA0WWlSQ1ZVQkxMYThEMDcxL041VUJOQlhEaDBMRnNtaFYvNUI1RXhPQjRqM1dWRy9TM2xmSzVvK1Y2RUxIdnk2UlI5bjRhYytWc0s0VkU0eXBoUHZWK2tHOUZlZ1RCSDRaUlhMMkh5dFVIQ2R1SmF6Qi9LeWtqZmV0WXhPWFRMd3MyNjdhR09kK0krSmhLUC8vK1ZuWG1TOTBPRC9qdkxjVnUwYXN5cWN1WU4xbVNiNlhUbENrcXYxdmlnWlBJWXdORi96cFdjVDFHUi82YUVJUmpraDB5aGc0TFhKZmFHb2JZSlRZNEpJNThLaUFLZ21tZ0FLV2RsNW5ZQ2VMcWF2UkpHUU51WXVadFpGR3grSWtJNHc0TlMyeHdiZXROTXVuT2pCdS9obUtDSS93N3RmaWl5VWQvLzRyYlRlV3Q0aXpCWThZdkdJTjZ2eUtZbVAvOFg4d0hLQ2VOK1dSY0tNNzArdFhLTkd5ZXZVOUgyRGc1QnNsam5UZjhZYnNKMVRtTXM3NENlMlhsSGlzbGVndWh5ZWc0NHJRT0hadXcvNkhUa2hubnVySzJkNjJxNnlTNzIxMFNzQUlhUitqWE1RQStzdmtyTHBzVVkrRjMwVXc4OXVPZEdBUjZ2bzRGSU1FMEVmVlZlSFR1NmVLaWNmaFNxT2VYSmhiZnRjZDA4c1dFbk5VTDFDOWZucHJUZ2Q4M0lNdXQ4b25WVUYwaHZxelpmSGR1UGpiandFWEljb1lteStQNnRjSlpIbWVPdjZWcnZFZGtIREplY2pIdUhlV0FOZTc5Vkc2NjJxVGpBL0hDdnVtVnYzcUwrTHJPY3BxR3BzMlpHd1FkRko3UFU0aXV5UmxCcndmTyt4blB5cjQ3czJjWFZiV3pBeXpuRGlCR2pDTTNrc3hqanFNNjJHRTlDOGY1VTM4a0IzVmp0YWJLcC9uUmR2TUVTUEdERzkwYldSTEF0MVFrNUR5THVhelJSMVl6ZEMxYytoWlh2QVdWOHhBNzJTNEE4QjY3dmpWaGJiYTNNTW9wMjkzRmVFWHBlN3pJdE1XckpHL0xPSDlCeU9YbVluTkpmam1mdVg5S2JycGdMT2JhNG5aK2ZsOEdiZHYvaWh2KzZ3RkdLSENZclZ3bWhGQzBKM1YyYm4ydElCMXdDYzFDU1QzZDNYMk95eGhndVhjczRzbTY3OVVuZ3pvZnVTZUJld01GSmJvSVFIYlVoL20ySmhXMmhHOURJdkcydDd5Wkl6S0JUejl3QnRuTkMrMnBDUlloU0l1UTFqOHhzejVWdnFueVVJdGh2dW95eXU3Zk5JcmcvS1FVVm1HUWFxa3Faay9WeDViMzMvZ3NFczh5WDdTQzFKK05WNGljejZidklFN0M1RzZNY0JhSThyVmc1NnE1UUJKV3huLzg3UTFzUEs0K3NRYThmTFU1Z1hvNHBhYXE0Y09jUTR3UjBWQkhQR2pLaCtVbFBDYkExbkxYeUVVWDQ1cVo4SjcvTG40RlBKRTJUZHpEMFo4TUxTTlFpeWtNTW1TeU9DaUZmeTg0UnE2MGVtWUIydkQwOUtqWXdzb0lwZURjQkRURWxCYlh4TkQ3MnloZDlwQy8xQ01pZC81SFVNdkFMMjdPdGNJSkR6TktwUlBOcVBPcHl0MmFQR3o5UVdJczloUTlMaVg1czhtOWhqVFV1L2Y3TXlJYXRqamQrdFNmUTN1Zlp4UHBtSmhUYUJ0WnRLTFVjZk9DVXFBRHVPK1FvSDhCOXY2VStQMEhWMUdMUW10b05GVGIzczc0aXZaZ2pFUzBxZksrOFJkR2dCYmNDTVN5OGVCdmg5OCtldDFLSUZxU2UxS1FQeVhVTEJNVHNJWW55c0l3aVpCSllkSTIwdnNlVit3dUprY3FHZW1laEtqYUFiOUw1N3habTNnMnpYMGJaMnhrL2ZVK2JDbzdUbG5iVzdKdUYxWWRVUm8vMkd3N1ZjbERHMVc3TE90YXMyTFg0dXBpZlovMjNyenBzblkvQUxmUmdyY1dQNWhZbVY5VnhWT1FBMWZadnA5RjJVTlUrN2Q3eFJ5Vm01d2lMcDMvMGRsVjd2ZHcxUE1pWnJiREFZeklWcUVqUlkyWVUwM3NKaFBubHdJUGNaVUc1bHRMNlM4WEN4VTFlWVM1Y2pyMzR2ZUJtWEF2eTd5TjRaakFySUcwZGZELzVVcEJObFgxWlBveEpPd3lxUmkzd1FXdE96ZDRvTktoMExrb1RtOGN3cWdJZktocXFHT2h3bzcxSSt6WG5NZW1UdjJCMkFVekFCV3lGenRHZ0dVTGpERHpXWXdKVVZCVGpLQ241SzJRR01LMUNRVDdTenppT2pvK0JoQW1xQmp6dWMzeFl5bTJlZWRHZU9JUkpWeVR3RHczN2lDTWU0ZzVWYm5zYjVaQmR4T0FuTVQ3SFU0REhweFdHdVE3R2VpWTMwQ3BidnpzczU1KzVLbTFZc2JENWVhM05JOVFOWUlYb2w1YXBnU3U5ZFo4Zjh4UzVkdEhwaWRvNUJjbER1TFdZNGxoaWswdGJKYTA3eUpoSDBCT3lFdXQvR1JiWVRTNlJmaVRZV0dNQ2tOcGZTSGk3SHZkaVRnbEVWSEtaWGFWaGV6SDRra1hpSXZLb3BZQWxQdXNmdHBFNGE1SVp3dncxeC9lTHZvREloL3pwbzlGaVFJbnNUYjJTQWtLSFY0MlhZQmpwSkRnNDM3NFhpVmIzd3M0cU0wczllU1E1SHpzTVU0T1pKS3VvcEZqQk0rZEFaRWw4UlVNeDV1VTJONDg2S3IxNDF0VnNHUWZHak9SWU1DSkFNc3hFTGVOVDRSbVdqUmNwZFRHQndjeDZYTjlkcldxUG1KemNyR3JINCtEUmM3K24xdzNrUFp3dTBCa05yNmhRcnFnbzdKVEI5QTVrZEovSDdQNGNXQk13c211aXhBekpCM3lyUXBuR0lxOTBseEFYTHpEQ2RuMUxQaWJzUnQ3ckhOamdRQmtsUmdQWjh2VGJqWGRnWHJUV1FzSzVNZHJYWFFWUHAwUmlucTNmcnpaS0owcUQ2UWhjNDBWekFyYVVYbG9iMWd2a2hLM3ZwbUhnSTZGUmxRWk54NmVScWtwMHp5NEFRbFg4MTNmQVB0TDNqTVJhaXRHRkZqbzB6bUVybG9DK2grWVlkVlE2azRGL2VweEFvRjBCbXFFb0tOVHQ2ajR2UVpOUTJCb3FGOVZqNTNUT0lvTm1EaXU5WHAxNVJrSWdRSUdjb0xwZm9JYmVuenBHVUF0cUZKcDVXK0xMbngzOGpIZUVDVEovbmF2S1kxTldmTjBzWTFUOC9wQjhrSUgzRFUzRFgrdTZXM1l3cHlwQk1ZT2hiU3hHanE4NFJaODRmV0pvdzhweUhxbjRTLzlKMTVFY0NNc1hxcmZ3eWQ5bWhpdTMrckVvOXBQcG9Ka2RacUhqcmE0TnZ6Rnd1VGhOS3k2aGFvL1NsTHczWkFEVWNVcDN3M1NSVmZXMnJobDgwek9nVFluS0UwSHMycXAxSjZIM3hxUHFJa3ZVRFJNRkRZeVJic0ZJM005TUV5b3ZQazhybHc3LzBhODFjRFZMbUJzUjJ6ZTJwQnVLYjIzZmJlWkMwdVhvSXZEcHBmVHdJRHhrMU9xMmRHZXNHYytvSlhXSkxHa09oYTNDWCtEVW56Z0FwOUhHSDlSc1BaTjYzSG40Uk1BNWVTVmhQSE8rOVJjUmIvSU9ndFczMVYxUTVJUEd0b3hQakMrTUVKYlZsSU1ZQURkOWFIWVdVSVFLb3B1UE9IbW9xU2t1Ym5BS256Z0tIcWdJT2ZXNVJkQWdvdE42Qk4rTzJaWUhrdWVtTG52UThVOVRIVnJTMVJ0TG1LYmNDN1BlZURzWXpudnF6ZWc2VkNOd21yMFl5eDF3bkxqeVQ4NEJaejNFSnlDcHREM3lldWVBeURXSXMwTDJxcy9WUTNIVXlxZnJqYTBWMUxkRHpxQWlrZVd1VjRzYzdSTElCNjlqRUlCakNreVplZG9VSHFDck92U2hWenlkNzNPZHJKVzBoUE91UXYycU9vSERjOXhWYjZZdTZ1cTNYcXAyWmFINDZBN2x6ZXZieFFFbWZyenZBWVNKdVo0V0RrMUh6M1FYMUxWZGlVSzBFdmxBR0FZbEczTWQzMHI3ZGNQTjYzeXFCQ0lqMjVwcnB2WlAwbkk0K0VnV29GRzk1VjU5NkN1clhwS1JCR1JqUWxIQ3Z5NUliL2lXOG5aSld3ckVUM21nZDZtRWhmUDRLQ3VhTGpvcFdzN2grTWRYRmRJdjhkSFFKZ2cxeGkxZVlxQjB1RFlqeHdWbXJpMFN2NVhLdXQvb25xYXBDK0ZRaUMyQzFsdllKOU1WY282eURZc1MzQUFOVWZNdHZ0YllJMmhmd1phdGlTc25vVWVNWmQzNEdWamtNTUtBK1huakpwWGdSVzJTSFRacGxWb3dQbUpzdlh5NnczY2ZPMUFLMmR2dFpFS1RrQy9UWTlMRmlLSENHMERuck1RZEdtMmx6bEJITTlpRVl5bkgyVWNWTWhVRWpzYzBvREJUZ28yWlNRMWd6a0FIZVdlQlhZRmpZTHV1Zjh5elRDeTcvUkZSODFXRGpYTWJxMkJPSDVkVVJueG82b2l2bXhMM2NLektJbmxaa0QzMW52cEhCOUtrN0dmY2ZFMXQrMVY2NGI5THRnZUpHbHBSRnhRQ0FxV0o1RG9ZNzdza2k4Z3NPRU9yMnV5d1phb08vTkdhMFgweTFwTlFIQmkzYjJTVUdOcGNaeERUN3JMYkJmMUZTblE4Z3V4R1czVyszNkJXMGdCamU0RE96NkJhNlNWazB4aUtndCtxMkpPRnlyNFNZZm51K0ljMVFaWUl1d0hCcmd6cjZVdk9jU0N6UFRPbzdENklDNElTZVM3emtsNGgrMlZvZUhwbkcvdVdSMyt5c05nUGNPSVhRYnYwbjRtcjNCd1FjZEtKeGdQU2V5dVAvejFKamc0ZTluVXZvWGVncVFWSUUzMEVIeDVHSHYrRkFWVU5Ub3dZREpneUZoZjVJdmxZbUVxUmlmNitXTjFNa0VKbURjUUlUeDlGWDIzYTRteHkxQVFSc09ITy8rZUltWDlsOEVNSkkzb1BXelZYeFNPZUhVMWRVV1lyMnVBQTdBTWIrdkFFWlNiVTNxb2I5aWJDeVhleXBFTXBaNjg2M282UVBxbHFHSFprdVdBQlNUVk5kNGNPaDlodjNxRXBTeDJaeS9ESk1QNmNJdEVtaUJKNVBGcVFuREVJdDNOckEzQ09sT1NnejQzRDdncE5GTko1TUJoNG9GemhEUGlnbEMyeXBzTlU0SVN5d1kyZXJreWIxTkMzUWgvSWZXajBlRGdaSTQvbG44V1BmQnNUM21lVGpxMVVxdDFFN1psL3FmdHFreDZhTTlLdWVNQ2VrU25NcmNIajFDcVRXV3pFelBzWkdjRGUzVWU0V3MrWEZZVnhOYk9GRjhlemt2UUdSNlpPdE9MVTJsUUVuTUJTdHg0N3ZFNlBiN0FZTUJSajJPT2ZaWGZpc2pKbnBUZlNOam82c1o2cVN2TnhaTm1EZVM3R2szeVl5Q2sxSHRLTjJVbmhNSWpPWFV6QXFEdjkwbHg5Ty9xL0FUMVpNbml0NVhRZTl3bVF4bkUvV1NIMENxWjkvMkh5K1NmbXBlZzhSd3NISTVaOGtDOEgyOTNtL0xIVlZNL0JBN0hhVEpZZzVFbms3TS94V3BxMDE5MkFDZkJhaTJMQS9xckNqQ3I2RGgxQklNek1YSU5CbVg5Nk1KNUhuMm54bG4vUlhQRmh3SHhVbVNWMEVWMlYwam04Ni9keHh1WVNVMVc3c1ZrRWJOOUV6a0cwUUZ3UGh5SEt5YjN0K0ZqNVdvVVVURXJjYXpFL042RVc2THZwMGQvL1NEUGo3RVY5VWRKTitBbW5mM1d3azNBMFNsSjlaMDB5dlhaN24zejcwRzQ3SGZzb3c4V3ExSlhjZnduQStZeGE1bUZzZ1Y0NjRLS1A0VDMxd3FJZ3pGUGQzZUNlM2o1b3J5NWZCRjJoZ0NGeVZGckx6STllZXROWHZNN29RcXlGZ0RvNENUcC9oRFY5Tk1YOUpESFEvbnlIVEx2WkxOTEY2ZnRuMk94akdtOCtQcU93aHhuUEhXaXBrRS84d2J0eXJpODBTcjdwTU5rUUdNZm80WllLOU9jQ0M0RVNWRkZiTE1Jdmx4U29ScVdpZTB3eHFuTGZjTFNYTVNwTU1RRUpZRFZPYllzWElRTnY0VEdOd2pxMWt2VDFVT2tpY1RyRzNJYUJaM1hkU2NTM3U4c2dlWlBWcE9Ma2JpRjk0MEZqYkNlTlJJTk52RGJkMDFFUEJyVENQcG0xMm00M3plMWJCQjU5SWE2T3ZobnVyL052eDNJeHdTV29sKzNIMnFmQ0pSOGRmNmFRZjR2NldpT054a0srSXFUNHBLUXJaSy9McGxnREkvUEpaYk9lcDhkdGJWN29DcjZDZ2ZwV2E4TmN6T2tQeDgxaVNIYnNOaFZTSkJPdHJMSU1yTDMxTEs5VHFIcUFiQUhlMFJMbW1WODA2a1JMRExORWhVRUpmbTl1MHN4cGtMOTNaZ2Q2cncrdHFCZlRNaTU5eHFYSExYU0h3U2JTQmwwRUswK2xvRUNPUHRybCsvbnNhRmUxOTdkaTR5VWdvZTRqS29BSkRYYzZER0RqclFPb0ZEV1pKOUhYd3Q4eERyUVArN2FSd1dLV0kxR0Y4czhPNEt6eFdCQmN3bmwzdm5sMU9lejNvaDZFYTF2alI3L3o3RERUckZ0cVUyVy9LQUV6QXVYRE5aN01ZNzNNRjIxNmR6ZFNiV21VcDRsY203a2VKZldhTUhndXQ5eDVDOW1qNjZaMGxKK3loc2pWdnlpV3JmazFselBPVGRoRzE1WTdnUWxYdGFjdkk3cXYvWE5Tc2NEd3FrZ3dIVC9nVXNENXlCN0xkUlJ2SnhRR1lJTm45aFRwb2RLRlZTVFBydEd2eVF3K0hsUkZYSWtvZEVyQUd1OUl5MVlwZlNQYzNqa0ZoNUNYM2xQeHY3YXFqRS9KQWZUSXBFakdiL0g3TU8wZTJ2c1ZpU1cxcWEvTG1pNC9uNERFSTNnN2xZcmNhbnNwRGZFcEtrZFYxT2pTTE95MEJDVXFWb0VDYUI1NXZzMDZyWGw0anFtTHNQc0ZNLzd2WUowdnJCaERDbS8wMEEvSDgxbDF1ZWtKLzZMbWwzSGI5K05LaUxxQVRKbURweXpmWVpGSHVtRWpDNjYyTDBCd2t4aTdFOVU0Y1FBMFhNVkR1TVlBSWVMTVBnUWFNVk9kOGZtdDVTZmxGSWZ1Qm9zemVBdzdvdzVnWFBFMlkveUJjLzdqRXhBUlVmL0J4SUhRQkY1U24zaTYxdzR6NXhKZEN5TzFGMVgzKzNheCtKU3ZNZVo3UzZRU0twMUZwL3NqWXo2WitWZ0NaemliR2VFb3VqcnlmTXVsSDdSYWk1a0FmdDllYmNXNTBEeUpyMnVvMno5N21UV0l1NDVZc1NuTlNNcnJOVXVHMVhzWUJ0RDlURFl6UWZmS0I4N3ZXYmtNNEViUEFGZ29CVjRHUVMrdnRGRFVxT0ZBb2kxblR0bUlPdmczOE40aFQyU244cjhjbG1CQ1hzcEJsTUJZVG5ycUZKR0JUM3daT3pBeUpEcmU5ZEhINyt4N3FhYUtET0I0VVFBTEQ1ZWNTMERFNG9idWJRRWl1SlowRXBCVnBMdVljY2U4QWE0UFlkL1Y0RExEQUpCWUtRUENXVGNyRWFaNUhZYkppMTFHZDZoakdvbTFpaTE4VkhZbkcyOE5LcGt6MlVLVlB4bGhZU3A4dVpyMzY3aU9tb3k3enN4ZWhXOXd6Y3kyekcwYTgwUEJNQ1JRTWIzMmhuYUhlT1I4Zm5ORHpaaGFOWWhrT2REc0JVWjNsb0RNYTFZUDB1UzBjalVQM2IvNkRCbHFtWk9lTkFCRHNMbDVCSTVRSnVwczh1eEF1V0pka1VCL3BPNlpheDZ0c2c3Zk41bWpqRGdNR25nTytEUGNLcWlISURiRklHdWR4dFBUSXlEaTlTRk1LQkRjZmRHUVJ2NDFxMUFxbXhna1ZmSk1uUDh3L0JjN045L1RSNkM3bUdPYkZxRmtJRW9tOHNLaTJ4WXFKTFRDSEs3Y3h6YVp2cU9EbzIyYzN3aXNCQ1A0SGVBZ2NSYk5QQXNCa05SaFNtRDQ4ZEh1cGRCUnc0bUl2dFM1b2VGNnplVDFLTUN5aE1ubWhwa0ZBR1duR3Njb05rd3ZROFpNNWxFL3ZnVEhGWUw5OU91TnhkRkJ4VEVEZDV2MnFMUjh5OVdrWHNXZ0c2a1pObmRGRytwTy9VQWtPQ2lwcUloTDNocTdjUlNkckNxN1loVXNUb2NFY25hRmE2blZraG5TZVJZVUExWU8wejVpdEY5U2x5M1ZseFlEdzIzOVRKSkg2ZjNFVWZZTzVsYjdiY0ZjejhCcDdPbzhRbW5zVUhPei9mYWdWVUJ0S0V3MWlUODhqK2FLa3Y4Y3NjS05rTXhqWXI4MzQ0RDFrRm9aNy90ZDFXNkxDTllONTk0MzAxdFVHUm1GakF6ZVJnNXZ5b00xRjYrYkpaL1E1NGpOL2s4U0ZkM0R4UFRZYUFVc2l2c0JmZ1RuN014OEgyU3BQdDRHT2RZUm5FSk9INmpITTJwNlNnQjBneklScTZmSHhHTW1TbXFhUENtbGZ3eGl1bG9hVklpdExHTjh3aWUyQ0RXaGt6TG9DSmNPRGg3S0lPQXFiSEV2WGRVeGFTNFRUVHMwN0NsemovNkdtVnM5a2laRGVyTXhFbmhVQjZRUVBsY2Zxa0c5ODgyUnFIb0xpSEdCb0hmUXVYSXNBRzhHVEF0YW8yS1Z3Um52dmFtOGpvMWUzMTJHUUFLV0VhNHNVVkVBTUc0RzZja2NPTkR3UmNnMWUyRDMrb2hYZ1k0VUFXRjh3SEtRTXJTbnpDZ2ZGcHN4aCthSFhNR3RQUXJvUWFzUlk0VTZVZEcwcnoxVmpia2EwTWVrT0dSWlFFdnFRRmx4c2VGb3I4eldGZ0hlazN2MjkrV3FONmdhSzVnWk9UT01aenBRSUMxMjAxTGtNQ1hpbGQzdldYU2M1VVg5eGNGWWZiUlB6R0ZhMUZEY1BmUEIvalVFcS9GZUd0NDE5Q0kzWW1CbFZvSHNhNEtkY3dRUDVaU3dISGhGSjcvUGgvUmFwLzR2bUc5MWVEd1BQMGxEZkNEUkNMc3pUcWZ6TTcxeHBtaUtpMkh3UzRXbHF2R053dHZ3RjVEcXBuNktUcThheDAwVU1Qa3hEY1pyRUVFc0l2SGlVWFhFcGhkYjRHQjRGeW1sUHdCejRHcGVycXE1cFc3VFE2L3lOUmhXOFZUNU5odVAwdWRseG80Z0lMcTVaeEFaazhaR2gzZzRDcXhKbFBLWTdBUXh1cGZVY1ZwV1Q1Vkl0cDErMzBVcW95UDR3V3NSbzNvbFJSZ2tXWloyWk42VkMzT1pGZVhCOE5iblVyU2Rpa05wdEQxUWlHdUtrcjhFbVNSL0FLOVJ3K0ZGM3M1dXd1UGJ2SEdpUGVGT1ZpbHRNSzdBVWFPc3E5K3g5Y25kazNpSkVFNUxLWlJsV0piS09ad2VST3ptUE5WUGtqRTNLL1R5QTU3UnM2OFRrWjNNUjhha0twbTdjRmpualBkL0Rka1dqZ1lvS0hTcjVXdTVzc29CWVU0YWNSczVnMkRIeFVtZHE4VlhPWFJidW5EOFFOMExoZ2tzc2dhaGNkb1lzTnZ1WEdVSy9LWEQvN29GYitWR2RocUluMDJ2ZXVNNWJMdWRKT2MyS3kwR01hRzRXL3hXQnhJSmNMN3lsaUpPWE9weDBBa0JxVWd6bERjem1MVDRpSUxYRHh4dFJSMW9aYTJKV0ZnaUFiNDNvYnJKbkcvVFpDMktTSzJ3cU96UlpUWGF2WlpGTWIxZjNiWHZWYU5hSzgyOHc5VE82MTBnazhKTmYzZ01mRVR6WFhzYmN2UkdDRzlKV1FaNitjRFBxYzQ0NjZZbzJSY0tIK1BJTGVLT3F0bmxiSW5SM01tQmVHRzNGSDEweXpreWJ1cUVDMkhTUXdwQTBBbjdkOSs3M0JrRFVUbTMwYlptb1AvUkdiZ0ZOK0dyQ09mQURncXIwV2JJMWExb2twRm1zOGlIWXc5aG0welV2bEVNaXZCUnhNb2RyYkpKKzkvcDNqVWRRUTlCQ3RRZHhuT0dyVDVkelJVbXcwNTkzL21iUlNkQmcwblJ2UlpNNS9FMTZtN1pIbURFdFdod3ZmZFpDWjhKOE0xMlcweVJNc3pYYW1XZlFUd0laNGF5WWt0cm5zY1F1V3I4aWRwM1BqVDJlRi9qbXRkaElmY3BNbmIrSWZaWTJGZWJXNlVZL0FLM2pQNHUzVHU0ekU0cWxuUWdMRmJNMTlFQklzTmY3S2hqZGJxUS9ENnlpRGIrTmxFaTJTS0QraXZYVlVLOGliMG9CbzM2NmdYa1I4WnhHanBKSURjRWdaUGE5VGNZZTBUSWJpUGwvclBVUUR1M1hCSjlYL0dOcTNGQVVzS3NsbDU3RHphR01yamNUK2djdHArOU1MWVhDcStzcVA4MWVWUTByOWx0K2djUWZaYkFDUmJFanZsTXNrenRaRzhnYkM4UW45dHQyNlE3eTduRHJiWnEvTEV6N2tSNkpjNnBnM045clZYOFk1TUpyR2xNTDlwOWxVNGpiVGtLcUN2ZWVaVUpqSEIwM20yS1JLUjJUeXRvRmtUWE9MZzdrZVUxczFsclBNUUpwb09LTHVBQUMreTFIbEp1Y1U2eXNCNWhzWGh2U1BQTHE1SjdKdG5xSEtaNHZZakM0Vnk4MTUzUVkrNjc4MHhEdUdBUnNHYk9zMVdxekgwUVM3NjVyblNLRWJiS2xrTzhvSS9WRHdVZDBpczEzdEtwcUlMdTFtREpGTnkvaUpBV2N2RGdqeHZ1c0lUK1BHejNTVC9KOXI5TXRmZDBqcGFHZWlMWUlxWGM3RGlIU1M4VGNqRlZrc2k2NlBFa3hXMXo2dWpiTExVR05OWW56T1dwSDhCWkdLNGJDSzdpUitNYkl2OG5jREF6MXU0U3ROM3ZUVHpld3I5SVFqazl3eEZ4bis2TjFkZEtzMHZmZkppUzA4TjNhNEcxU1ZybFo5N1EvTSs4RzlmZTVBUDZkOS9RcTRXUm5PUlZob2ZQSUtFZENyM2xsc3BVZkUwb0tJSVlvQnlCUlBoK2JYMUhMUzNKV0dKUmhJdkUxYVc0TlRkOGVQaTRaK2tYYitaOHNuWWZTTmNxaWpoQWdWc3g0UkNNNTRjWFVpWWtqZUJtbUM0YWpPSHJDaG9FTHNjSkpDNys5ampNanc1QmFnWktsZ1JNaVNOWXo3aDd2dlpJb1FxYnRRbXNwYzBjVWsxRy83M2lYdFNwUk9sNXd0TGdRaTBtVzJFeDhpM1dVTGhjZ2d4NkUxTE1WSFVzZGM5R0hJMVBIM1UyS28wUHlHZG45S2RWT0xtN0ZQQnVpMGk5YTBIcEE2ME1zZXdWRTR6OENBdDVkNDAxR3Y2elhsSVQ1WWJpdDFWSUEwRkNzN3d0dllyZXJ1MWZVeVczb0xBWi8rYVRuWnJPY1lSTlZBOHNwb1J0bFJvV2Zsc1JDbEZjZ3prcWlIT3JmMC9TVncrRXBWYUZsSjBnNEt4cTFNTU9taVFkcE1OcHRlOGxNTVFxbTZjSUZYbG5HYmZKbGx5c0tEaSswSkpNb3RrcWdJeE9TUWdVOWRuL2xXa2VWZjhuVW0zaXdYMk5sM1dEdzlpNkFVSzN2QkFiWlpyY0pwRFEvTjY0QVZ3alQwN0plZjMwR1NTbXROdTJXbFc3WW95VzJGbFdmWkZRVXdrODY3RWRMWUtrOVZHNkpnRW5CaUJ4a1k3TE1vNFlMUUpKbEFvOWwvb1R2SmtTQVJERi9YdHlBek04TzJ0M2VUL2lYYTZ3RE4zV2V3Tm1RSGRQZnN4Q2hVL0t0TEcyTW44aTRacUtkU2xJYUJaYWR4Sm1SelZTL280eUE2NVJUU1ZpcTYwb2EzOTVMcXcwcHpZNFNpcHdFMFNYWHNLVitHWnJhR1Nrci9SVzA4d1BSdnF2U1VrWUJNQTlsUHg0bTI0YXorSUhtQ2JYQSswZmF4VFJFOXd1R2VPMDZESVhhNlFsS0ozcHVJeWl1QVZmUHI3MzZ2em8ycEJpclMrVnhlbDNUTW0zSktoejlvMlpvUnZhRlZwSWt5a2IwSGNtNG9IRkJNY05TTmo3LzRHSnQ0M29nb25ZMlZnNG5zRFFJV3hBY29ycFhBQ3pnQnFRUGpZc0UvVlVwWHB3Tk1hbkVydTROd01DRlBrWHZNb3F2b2VMTjNxeXUvTjFlV0VIdHRNRDY1djE5bC8wa0gybVIzNWl2L0ZJK3lqb0hKOWdQTXo2N2FmM01xL0JvV1hxdTNycGhpV01YVmttblBTRWtwR3BVSTJoMU1UaGlkZUdGRU9LNllaSFB3WXpNQnZwTkM3K1pIeFBiN2VwZmVmR3lJQjRKek85RFRORVluRExWVkhkUXl2T0VWZWZyazZVdjVrVFFZVllXV2RxcmRjSWw3eWxqd3dJV2RmUS95KzJRQjNlUi9xeFlPYnVZeUI0Z1RibzJpbjRQemFyVTFzTzluRVRrbWo5L0FveERBK0pNM0dNcVF0SlI0anRkdUh0bm9DTHhkMWdRVXNjSFJCL01vUllJRXNQMnBEWjlLdkhndGxrMWlUYldXYkhob2h3RkVZWDd5NTFmVVYybnVVbW5vVWNxbldJUUFBZ2w5TFRWWCtCYzBRR05FaENoeEhSNFlqZkU1MVBVZEdmc1NGRTZjazdCTDMvaFRmOWpMcTRHMUlhZklOeE9MS2VBdE83cXV1bFl2SDVZT0JjK3pYN0NyTWdXblc0Ny9qZlJzV25KallZb0U3eE1mV1YySE4yaXlJcUxJJztcbmNvbnN0IEZFTkNFRCA9IG5ldyBNYXAoW1s4MjE3LFwiYXBvc3Ryb3BoZVwiXSxbODI2MCxcImZyYWN0aW9uIHNsYXNoXCJdLFsxMjUzOSxcIm1pZGRsZSBkb3RcIl1dKTtcbmNvbnN0IE5TTV9NQVggPSA0O1xuXG5mdW5jdGlvbiBkZWNvZGVfYXJpdGhtZXRpYyhieXRlcykge1xyXG5cdGxldCBwb3MgPSAwO1xyXG5cdGZ1bmN0aW9uIHUxNigpIHsgcmV0dXJuIChieXRlc1twb3MrK10gPDwgOCkgfCBieXRlc1twb3MrK107IH1cclxuXHRcclxuXHQvLyBkZWNvZGUgdGhlIGZyZXF1ZW5jeSB0YWJsZVxyXG5cdGxldCBzeW1ib2xfY291bnQgPSB1MTYoKTtcclxuXHRsZXQgdG90YWwgPSAxO1xyXG5cdGxldCBhY2MgPSBbMCwgMV07IC8vIGZpcnN0IHN5bWJvbCBoYXMgZnJlcXVlbmN5IDFcclxuXHRmb3IgKGxldCBpID0gMTsgaSA8IHN5bWJvbF9jb3VudDsgaSsrKSB7XHJcblx0XHRhY2MucHVzaCh0b3RhbCArPSB1MTYoKSk7XHJcblx0fVxyXG5cclxuXHQvLyBza2lwIHRoZSBzaXplZC1wYXlsb2FkIHRoYXQgdGhlIGxhc3QgMyBzeW1ib2xzIGluZGV4IGludG9cclxuXHRsZXQgc2tpcCA9IHUxNigpO1xyXG5cdGxldCBwb3NfcGF5bG9hZCA9IHBvcztcclxuXHRwb3MgKz0gc2tpcDtcclxuXHJcblx0bGV0IHJlYWRfd2lkdGggPSAwO1xyXG5cdGxldCByZWFkX2J1ZmZlciA9IDA7IFxyXG5cdGZ1bmN0aW9uIHJlYWRfYml0KCkge1xyXG5cdFx0aWYgKHJlYWRfd2lkdGggPT0gMCkge1xyXG5cdFx0XHQvLyB0aGlzIHdpbGwgcmVhZCBiZXlvbmQgZW5kIG9mIGJ1ZmZlclxyXG5cdFx0XHQvLyBidXQgKHVuZGVmaW5lZHwwKSA9PiB6ZXJvIHBhZFxyXG5cdFx0XHRyZWFkX2J1ZmZlciA9IChyZWFkX2J1ZmZlciA8PCA4KSB8IGJ5dGVzW3BvcysrXTtcclxuXHRcdFx0cmVhZF93aWR0aCA9IDg7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHJlYWRfYnVmZmVyID4+IC0tcmVhZF93aWR0aCkgJiAxO1xyXG5cdH1cclxuXHJcblx0Y29uc3QgTiA9IDMxO1xyXG5cdGNvbnN0IEZVTEwgPSAyKipOO1xyXG5cdGNvbnN0IEhBTEYgPSBGVUxMID4+PiAxO1xyXG5cdGNvbnN0IFFSVFIgPSBIQUxGID4+IDE7XHJcblx0Y29uc3QgTUFTSyA9IEZVTEwgLSAxO1xyXG5cclxuXHQvLyBmaWxsIHJlZ2lzdGVyXHJcblx0bGV0IHJlZ2lzdGVyID0gMDtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykgcmVnaXN0ZXIgPSAocmVnaXN0ZXIgPDwgMSkgfCByZWFkX2JpdCgpO1xyXG5cclxuXHRsZXQgc3ltYm9scyA9IFtdO1xyXG5cdGxldCBsb3cgPSAwO1xyXG5cdGxldCByYW5nZSA9IEZVTEw7IC8vIHRyZWF0IGxpa2UgYSBmbG9hdFxyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdmFsdWUgPSBNYXRoLmZsb29yKCgoKHJlZ2lzdGVyIC0gbG93ICsgMSkgKiB0b3RhbCkgLSAxKSAvIHJhbmdlKTtcclxuXHRcdGxldCBzdGFydCA9IDA7XHJcblx0XHRsZXQgZW5kID0gc3ltYm9sX2NvdW50O1xyXG5cdFx0d2hpbGUgKGVuZCAtIHN0YXJ0ID4gMSkgeyAvLyBiaW5hcnkgc2VhcmNoXHJcblx0XHRcdGxldCBtaWQgPSAoc3RhcnQgKyBlbmQpID4+PiAxO1xyXG5cdFx0XHRpZiAodmFsdWUgPCBhY2NbbWlkXSkge1xyXG5cdFx0XHRcdGVuZCA9IG1pZDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFydCA9IG1pZDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHN0YXJ0ID09IDApIGJyZWFrOyAvLyBmaXJzdCBzeW1ib2wgaXMgZW5kIG1hcmtcclxuXHRcdHN5bWJvbHMucHVzaChzdGFydCk7XHJcblx0XHRsZXQgYSA9IGxvdyArIE1hdGguZmxvb3IocmFuZ2UgKiBhY2Nbc3RhcnRdICAgLyB0b3RhbCk7XHJcblx0XHRsZXQgYiA9IGxvdyArIE1hdGguZmxvb3IocmFuZ2UgKiBhY2Nbc3RhcnQrMV0gLyB0b3RhbCkgLSAxO1xyXG5cdFx0d2hpbGUgKCgoYSBeIGIpICYgSEFMRikgPT0gMCkge1xyXG5cdFx0XHRyZWdpc3RlciA9IChyZWdpc3RlciA8PCAxKSAmIE1BU0sgfCByZWFkX2JpdCgpO1xyXG5cdFx0XHRhID0gKGEgPDwgMSkgJiBNQVNLO1xyXG5cdFx0XHRiID0gKGIgPDwgMSkgJiBNQVNLIHwgMTtcclxuXHRcdH1cclxuXHRcdHdoaWxlIChhICYgfmIgJiBRUlRSKSB7XHJcblx0XHRcdHJlZ2lzdGVyID0gKHJlZ2lzdGVyICYgSEFMRikgfCAoKHJlZ2lzdGVyIDw8IDEpICYgKE1BU0sgPj4+IDEpKSB8IHJlYWRfYml0KCk7XHJcblx0XHRcdGEgPSAoYSA8PCAxKSBeIEhBTEY7XHJcblx0XHRcdGIgPSAoKGIgXiBIQUxGKSA8PCAxKSB8IEhBTEYgfCAxO1xyXG5cdFx0fVxyXG5cdFx0bG93ID0gYTtcclxuXHRcdHJhbmdlID0gMSArIGIgLSBhO1xyXG5cdH1cclxuXHRsZXQgb2Zmc2V0ID0gc3ltYm9sX2NvdW50IC0gNDtcclxuXHRyZXR1cm4gc3ltYm9scy5tYXAoeCA9PiB7IC8vIGluZGV4IGludG8gcGF5bG9hZFxyXG5cdFx0c3dpdGNoICh4IC0gb2Zmc2V0KSB7XHJcblx0XHRcdGNhc2UgMzogcmV0dXJuIG9mZnNldCArIDB4MTAxMDAgKyAoKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDE2KSB8IChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCA4KSB8IGJ5dGVzW3Bvc19wYXlsb2FkKytdKTtcclxuXHRcdFx0Y2FzZSAyOiByZXR1cm4gb2Zmc2V0ICsgMHgxMDAgKyAoKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDgpIHwgYnl0ZXNbcG9zX3BheWxvYWQrK10pO1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiBvZmZzZXQgKyBieXRlc1twb3NfcGF5bG9hZCsrXTtcclxuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIHggLSAxO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHRcclxuXHJcbi8vIHJldHVybnMgYW4gaXRlcmF0b3Igd2hpY2ggcmV0dXJucyB0aGUgbmV4dCBzeW1ib2xcclxuZnVuY3Rpb24gcmVhZF9wYXlsb2FkKHYpIHtcclxuXHRsZXQgcG9zID0gMDtcclxuXHRyZXR1cm4gKCkgPT4gdltwb3MrK107XHJcbn1cclxuZnVuY3Rpb24gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQocykge1xyXG5cdHJldHVybiByZWFkX3BheWxvYWQoZGVjb2RlX2FyaXRobWV0aWModW5zYWZlX2F0b2IocykpKTtcclxufVxyXG5cclxuLy8gdW5zYWZlIGluIHRoZSBzZW5zZTpcclxuLy8gZXhwZWN0ZWQgd2VsbC1mb3JtZWQgQmFzZTY0IHcvbyBwYWRkaW5nIFxyXG4vLyAyMDIyMDkyMjogYWRkZWQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvaXNzdWVzLzRcclxuZnVuY3Rpb24gdW5zYWZlX2F0b2Iocykge1xyXG5cdGxldCBsb29rdXAgPSBbXTtcclxuXHRbLi4uJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXS5mb3JFYWNoKChjLCBpKSA9PiBsb29rdXBbYy5jaGFyQ29kZUF0KDApXSA9IGkpO1xyXG5cdGxldCBuID0gcy5sZW5ndGg7XHJcblx0bGV0IHJldCA9IG5ldyBVaW50OEFycmF5KCg2ICogbikgPj4gMyk7XHJcblx0Zm9yIChsZXQgaSA9IDAsIHBvcyA9IDAsIHdpZHRoID0gMCwgY2FycnkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRjYXJyeSA9IChjYXJyeSA8PCA2KSB8IGxvb2t1cFtzLmNoYXJDb2RlQXQoaSldO1xyXG5cdFx0d2lkdGggKz0gNjtcclxuXHRcdGlmICh3aWR0aCA+PSA4KSB7XHJcblx0XHRcdHJldFtwb3MrK10gPSAoY2FycnkgPj4gKHdpZHRoIC09IDgpKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuLy8gZWcuIFswLDEsMiwzLi4uXSA9PiBbMCwtMSwxLC0yLC4uLl1cclxuZnVuY3Rpb24gc2lnbmVkKGkpIHsgXHJcblx0cmV0dXJuIChpICYgMSkgPyAofmkgPj4gMSkgOiAoaSA+PiAxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZF9kZWx0YXMobiwgbmV4dCkge1xyXG5cdGxldCB2ID0gQXJyYXkobik7XHJcblx0Zm9yIChsZXQgaSA9IDAsIHggPSAwOyBpIDwgbjsgaSsrKSB2W2ldID0geCArPSBzaWduZWQobmV4dCgpKTtcclxuXHRyZXR1cm4gdjtcclxufVxyXG5cclxuLy8gWzEyM11bNV0gPT4gWzAgM10gWzEgMV0gWzAgMF1cclxuZnVuY3Rpb24gcmVhZF9zb3J0ZWQobmV4dCwgcHJldiA9IDApIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB4ID0gbmV4dCgpO1xyXG5cdFx0bGV0IG4gPSBuZXh0KCk7XHJcblx0XHRpZiAoIW4pIGJyZWFrO1xyXG5cdFx0cHJldiArPSB4O1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0cmV0LnB1c2gocHJldiArIGkpO1xyXG5cdFx0fVxyXG5cdFx0cHJldiArPSBuICsgMTtcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZF9zb3J0ZWRfYXJyYXlzKG5leHQpIHtcclxuXHRyZXR1cm4gcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7IFxyXG5cdFx0bGV0IHYgPSByZWFkX3NvcnRlZChuZXh0KTtcclxuXHRcdGlmICh2Lmxlbmd0aCkgcmV0dXJuIHY7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8vIHJldHVybnMgbWFwIG9mIHggPT4geXNcclxuZnVuY3Rpb24gcmVhZF9tYXBwZWQobmV4dCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHcgPSBuZXh0KCk7XHJcblx0XHRpZiAodyA9PSAwKSBicmVhaztcclxuXHRcdHJldC5wdXNoKHJlYWRfbGluZWFyX3RhYmxlKHcsIG5leHQpKTtcclxuXHR9XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB3ID0gbmV4dCgpIC0gMTtcclxuXHRcdGlmICh3IDwgMCkgYnJlYWs7XHJcblx0XHRyZXQucHVzaChyZWFkX3JlcGxhY2VtZW50X3RhYmxlKHcsIG5leHQpKTtcclxuXHR9XHJcblx0cmV0dXJuIHJldC5mbGF0KCk7XHJcbn1cclxuXHJcbi8vIHJlYWQgdW50aWwgbmV4dCBpcyBmYWxzeVxyXG4vLyByZXR1cm4gYXJyYXkgb2YgcmVhZCB2YWx1ZXNcclxuZnVuY3Rpb24gcmVhZF9hcnJheV93aGlsZShuZXh0KSB7XHJcblx0bGV0IHYgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHggPSBuZXh0KHYubGVuZ3RoKTtcclxuXHRcdGlmICgheCkgYnJlYWs7XHJcblx0XHR2LnB1c2goeCk7XHJcblx0fVxyXG5cdHJldHVybiB2O1xyXG59XHJcblxyXG4vLyByZWFkIHcgY29sdW1ucyBvZiBsZW5ndGggblxyXG4vLyByZXR1cm4gYXMgbiByb3dzIG9mIGxlbmd0aCB3XHJcbmZ1bmN0aW9uIHJlYWRfdHJhbnNwb3NlZChuLCB3LCBuZXh0KSB7XHJcblx0bGV0IG0gPSBBcnJheShuKS5maWxsKCkubWFwKCgpID0+IFtdKTtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHc7IGkrKykge1xyXG5cdFx0cmVhZF9kZWx0YXMobiwgbmV4dCkuZm9yRWFjaCgoeCwgaikgPT4gbVtqXS5wdXNoKHgpKTtcclxuXHR9XHJcblx0cmV0dXJuIG07XHJcbn1cclxuIFxyXG4vLyByZXR1cm5zIFtbeCwgeXNdLCBbeCtkeCwgeXMrZHldLCBbeCsyKmR4LCB5cysyKmR5XSwgLi4uXVxyXG4vLyB3aGVyZSBkeC9keSA9IHN0ZXBzLCBuID0gcnVuIHNpemUsIHcgPSBsZW5ndGggb2YgeVxyXG5mdW5jdGlvbiByZWFkX2xpbmVhcl90YWJsZSh3LCBuZXh0KSB7XHJcblx0bGV0IGR4ID0gMSArIG5leHQoKTtcclxuXHRsZXQgZHkgPSBuZXh0KCk7XHJcblx0bGV0IHZOID0gcmVhZF9hcnJheV93aGlsZShuZXh0KTtcclxuXHRsZXQgbSA9IHJlYWRfdHJhbnNwb3NlZCh2Ti5sZW5ndGgsIDErdywgbmV4dCk7XHJcblx0cmV0dXJuIG0uZmxhdE1hcCgodiwgaSkgPT4ge1xyXG5cdFx0bGV0IFt4LCAuLi55c10gPSB2O1xyXG5cdFx0cmV0dXJuIEFycmF5KHZOW2ldKS5maWxsKCkubWFwKChfLCBqKSA9PiB7XHJcblx0XHRcdGxldCBqX2R5ID0gaiAqIGR5O1xyXG5cdFx0XHRyZXR1cm4gW3ggKyBqICogZHgsIHlzLm1hcCh5ID0+IHkgKyBqX2R5KV07XHJcblx0XHR9KTtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gcmV0dXJuIFtbeCwgeXMuLi5dLCAuLi5dXHJcbi8vIHdoZXJlIHcgPSBsZW5ndGggb2YgeVxyXG5mdW5jdGlvbiByZWFkX3JlcGxhY2VtZW50X3RhYmxlKHcsIG5leHQpIHsgXHJcblx0bGV0IG4gPSAxICsgbmV4dCgpO1xyXG5cdGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKG4sIDErdywgbmV4dCk7XHJcblx0cmV0dXJuIG0ubWFwKHYgPT4gW3ZbMF0sIHYuc2xpY2UoMSldKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHJlYWRfdHJpZShuZXh0KSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBzb3J0ZWQgPSByZWFkX3NvcnRlZChuZXh0KTsgXHJcblx0ZXhwYW5kKGRlY29kZShbXSksIFtdKTtcclxuXHRyZXR1cm4gcmV0OyAvLyBub3Qgc29ydGVkXHJcblx0ZnVuY3Rpb24gZGVjb2RlKFEpIHsgLy8gY2hhcmFjdGVycyB0aGF0IGxlYWQgaW50byB0aGlzIG5vZGVcclxuXHRcdGxldCBTID0gbmV4dCgpOyAvLyBzdGF0ZTogdmFsaWQsIHNhdmUsIGNoZWNrXHJcblx0XHRsZXQgQiA9IHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4geyAvLyBidWNrZXRzIGxlYWRpbmcgdG8gbmV3IG5vZGVzXHJcblx0XHRcdGxldCBjcHMgPSByZWFkX3NvcnRlZChuZXh0KS5tYXAoaSA9PiBzb3J0ZWRbaV0pO1xyXG5cdFx0XHRpZiAoY3BzLmxlbmd0aCkgcmV0dXJuIGRlY29kZShjcHMpO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4ge1MsIEIsIFF9O1xyXG5cdH1cclxuXHRmdW5jdGlvbiBleHBhbmQoe1MsIEJ9LCBjcHMsIHNhdmVkKSB7XHJcblx0XHRpZiAoUyAmIDQgJiYgc2F2ZWQgPT09IGNwc1tjcHMubGVuZ3RoLTFdKSByZXR1cm47XHJcblx0XHRpZiAoUyAmIDIpIHNhdmVkID0gY3BzW2Nwcy5sZW5ndGgtMV07XHJcblx0XHRpZiAoUyAmIDEpIHJldC5wdXNoKGNwcyk7IFxyXG5cdFx0Zm9yIChsZXQgYnIgb2YgQikge1xyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBici5RKSB7XHJcblx0XHRcdFx0ZXhwYW5kKGJyLCBbLi4uY3BzLCBjcF0sIHNhdmVkKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxuXG5mdW5jdGlvbiBoZXhfY3AoY3ApIHtcclxuXHRyZXR1cm4gY3AudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkucGFkU3RhcnQoMiwgJzAnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcXVvdGVfY3AoY3ApIHtcclxuXHRyZXR1cm4gYHske2hleF9jcChjcCl9fWA7IC8vIHJhZmZ5IGNvbnZlbnRpb246IGxpa2UgXCJcXHV7WH1cIiB3L28gdGhlIFwiXFx1XCJcclxufVxyXG5cclxuLypcclxuZXhwb3J0IGZ1bmN0aW9uIGV4cGxvZGVfY3Aocykge1xyXG5cdHJldHVybiBbLi4uc10ubWFwKGMgPT4gYy5jb2RlUG9pbnRBdCgwKSk7XHJcbn1cclxuKi9cclxuZnVuY3Rpb24gZXhwbG9kZV9jcChzKSB7IC8vIHRoaXMgaXMgYWJvdXQgMnggZmFzdGVyXHJcblx0bGV0IGNwcyA9IFtdO1xyXG5cdGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IHMubGVuZ3RoOyBwb3MgPCBsZW47ICkge1xyXG5cdFx0bGV0IGNwID0gcy5jb2RlUG9pbnRBdChwb3MpO1xyXG5cdFx0cG9zICs9IGNwIDwgMHgxMDAwMCA/IDEgOiAyO1xyXG5cdFx0Y3BzLnB1c2goY3ApO1xyXG5cdH1cclxuXHRyZXR1cm4gY3BzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHJfZnJvbV9jcHMoY3BzKSB7XHJcblx0Y29uc3QgY2h1bmsgPSA0MDk2O1xyXG5cdGxldCBsZW4gPSBjcHMubGVuZ3RoO1xyXG5cdGlmIChsZW4gPCBjaHVuaykgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNwcyk7XHJcblx0bGV0IGJ1ZiA9IFtdO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyApIHtcclxuXHRcdGJ1Zi5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNwcy5zbGljZShpLCBpICs9IGNodW5rKSkpO1xyXG5cdH1cclxuXHRyZXR1cm4gYnVmLmpvaW4oJycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wYXJlX2FycmF5cyhhLCBiKSB7XHJcblx0bGV0IG4gPSBhLmxlbmd0aDtcclxuXHRsZXQgYyA9IG4gLSBiLmxlbmd0aDtcclxuXHRmb3IgKGxldCBpID0gMDsgYyA9PSAwICYmIGkgPCBuOyBpKyspIGMgPSBhW2ldIC0gYltpXTtcclxuXHRyZXR1cm4gYztcclxufVxuXG4vLyBjcmVhdGVkIDIwMjMtMDktMTJUMjI6MDU6MTQuMjExWlxuLy8gY29tcHJlc3NlZCBiYXNlNjQtZW5jb2RlZCBibG9iIGZvciBpbmNsdWRlLW5mIGRhdGFcbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9ibG9iL21haW4vc3JjL21ha2UuanNcbi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcyNzZWN1cml0eVxuLy8gU0hBLTI1NjogYTk3NGI2Zjg1NDFmYzI5ZDkxOWJjODUxMThhZjBhNDQwMTU4NTFmYWI1MzQzZjg2NzljYjMxYmUyYmRiMjA5ZVxudmFyIENPTVBSRVNTRUQgPSAnQUVVRFRBSEJDRlFBVFFEUkFEQUFjZ0FnQURRQUZBQXNBQlFBSHdBT0FDUUFEUUFSQUFvQUZ3QUhBQklBQ0FBUEFBVUFDd0FGQUF3QUJBQVFBQU1BQndBRUFBb0FCUUFJQUFJQUNnQUJBQVFBRkFBTEFBSUFDd0FCQUFJQUFRQUhBQU1BQXdBRUFBc0FEQUFNQUF3QUNnQU5BQTBBQXdBS0FBa0FCQUFkQUFZQVp3RFNBZHNESmdDMENrTUI4eGhaQXFmb0MxOTBVR2NUaGdCdXJ3ZjdQVDA5UGIwOUFqZ0p1bThPakRsbHhIWVVLWEFQeHpxNnRBQkF4Z0s4eXNVdldBZ01QVDA5UFQwOVBTczZMVDJIY2dXWFd3RkxvU01FRUVsNVJGVk1Ldk8wWFE4RXhEZEpNbklnc2oyNlBUUXl5OEZmRVE4QVk4SVBBR2NFYndSd0JIRUVjZ1J6QkhRRWRRUjJCSGNFZUFSNkJIc0VmQVIrQklBRWdmbmRCUW9CWWdVTEFXSUZEQUZpQk5jRTJBVFpCUkFGRVFVdkJkQUxGQXNWRFBjTkJ3MTNEWWNPTUE0eERqTUI0QmxsSEkwQjJncmJBTURwSExrUTdRSFZBUFJOUVFGbkdSVUVnMHlFQjJ1YUpGOEFKcElCcG9iNUFFUlNNQUtOb0FYcWFRTFVCTUN6RWlBQ253UlpFa2tWc1M3dEFOQXNCRzBSdUFRTEVQQUJ2OUhJQ1RVQlhpZ1Bad1JCQXBNRE93QWFtaHRhQUJxRUFZOEt2S3gzTFE0QXJBQjhVaHdFQkFWU2FnRDhBRUZaQURrQklhZFZqMlVNVWd4NUlsNEFOUUM5QXhJQjFCbGJFUE1BczMwQ0d4bFhBaHdaS1FJRUNCYzZFYnNDb3huZ3p2N1V6UlFBOE0wQmF3TDZad2tON3dBQkFEMzNPUVJjc2dMSkNqTUNqcVVDaHR3L2ttK05Bc1hQQW9QMkJUODRQd1VSQUswUkF2cHRiNmNBcFFTL09NTWV5NUhKUzg0VWR4cHhUUGtDb2dWRklUYVRPd0VSQUs1cEF2a05CT1Z5QTdxM0JLbE9KU0FMQWdVSUJSY0VkQVNwQlhxekFCWEZTV1pPYXdMQ09xdy8vQW9sQ1pkdnYzZFNCa0VRR3llbEVQY01Nd0cxQVRzTjdVdllCUEVHT3dUSkgzMFpHUS9ObFp3SXBTM2RETzBtNHk2aGdGb2o5U3FEQmUxTDlEemRDMDFSYUE5WkMyVUo0enBqZ1U0RElRRU5Jb3NLM1EwNUNHMFE4d3JKYXczbEVVVUhPUVBWU1pvQXBRY0JDeEVkTlJXMUpoQmlyQXNKT1hjRyt4cjJDNDhtcnhNcGV2d0YweG9oQmswQktSci9BTTh1NTRXd1dqRmNIRTlmQmdNTEpTUEhGS2hRSUEwbFFMZDRTQm9iQnhVbHFRS1JRM0JLaDFFMkhwTWg5anc5RFdZdUUxRjhCL1U4QlJsUEM0RThua2FyUlE0UjBqNk5QVWdpU1V3c0JEVi9MQzhuaXduUEQ0VU11WHh5QVZrSklRbXhESEVUTVJFWE44VUlPUWNaTFpja0p4VUlJVWFWWUpvRTk1OEQ4eFBSQXdzRlB3bEJCeE1EdFJ3dEV5NFZLUVVOZ1NUWEF2TTIxUzZ6QW85V2dBRVhCY3NQSlIvZkVGQkg0QTdwQ0pzQ1pRT0RKZXNBTFJVaEFCY2ltd2hEWXdCZmo5aFRCUzdMQ01kcWJDTjBBMmNVNTJFUmN3ZVJEbGNIcHh3ekZiOGM0WERJWGd1R0NDaWpyd2xiQVhVSm1RRmZCT01JQ1RWYmpLQWdRV2RUaTFnWW15QmhRVDlkL0FJeERHVVZuMFM5aDNnQ2l3OXJFaHNCTlFGekJ6a05BUUozRWUwUmF4Q1ZDT3VHQkRXMU0vZzZKUVJQSVlNZ0VRb25BMDlzemdzbkp2a00rR2tCb3hKaUF3dzBQWGZ1WjZ0Z3RpUVgvUWNaTXNWQllDSHhDNUpQelF5Y0dzRVlRbFF1R2VRSHZ3UHpHdk1uNmtGWEJmOERvd01UT2swejdnUzlDMmtJaXdrL0FFa09veGNIMXhocUNuR00wQUV4aXdHM21RTlhrWU1DYjQ4R053Y0xBR2NMaHdWNTVRQWRBcWNJb3dBRkFNOERWd0E1QXEwSG5RQVpBSVZCQVQwREp5OEJJZVVDandPVENESExBWlV2QWZNcEJCdkREQlVBOXpkdVNnTERzUUtBYW1haUJkMVlBbzRDU1RVQlRTVUVCVTVIVVFPdmNlRUEyd0JMQmhQZlJ3RVZxMHJMR3VOREFkOXZLd0RIQVBzQUJUVUhCVUVCelFIemJRQzNBVjhMTVFtaXM3VUJUZWtwQUlNQUZXc0Ixd0tKQU4wQU5RQi84UUZUQUUwRldma0Ywd0pQU1FFUk1SZ3JWMkVCdXdNZkFUTUJEUUI1QnN1TnBja0hId1J0QjlNQ0VCc1Y0UUx2TGdlMUFRTWkzeFBOUXNVQ3ZkNVZvV0FDWklFQ1lrSmJUYTliTnlBQ29mY0NhSmdDWmdrQ240UTRHd3NDWmpzQ1ppWUViZ1IvQTM4VEEzNlNPUVk1ZHhjNWdqb2pJd0pzSFFJeU5qZ0tBbTNIQW0ydTc0b3paMFVyQVdjQTNnRGhBRW9GQjVnTWpRRCtDOElBRGJVQ2R5OENkcUkvQW5sTFF3SjR1aDFjMjBXdVJ0Y0NmRDhDZXNnQ2ZRa0NmUEFGV1FVZ1NBQklmV01rQW9GdEFvQUFBb0FGQW4rdVNWaEtXeFVYU3N3QzBRRUMwTXhMSndPSVR3T0g1a1RGa1RJQzhxRmRBd01Ecmt2T1RDMGxBODlOVEUydkFvcy9Bb3JZd1JzSEhVTm5CYmNDampjQ2pseEFsNEVDanRrQ2pseDRVYlJUTlFwUzFGU0ZBcFA3QXBNTUFPa0FIRlVlVmE5VjBBWXNHeW1WaGpMaGVHWkZPemtDbDU4Qzc3SllJYWdBV1NVQ2xvOENsbnljQUtsWnJGb0pnVTBBT3dLV3RRS1dUbHhFWE5FQ21jc0NtV1JjeWwwSEdRS2Ntem5DT3AwQ25CWUNuNXNDbnJpS0FCMFBNU29QQXAzeEFwNlNBTFU5WVRSaDd3S2Uwd0tnYmdHcEFwNmZId0tlVHFWanlHUW5KU3NDSjY4Q0puNENvUHNDb0V3Q290MENvY1FDcGk4Q3BjNENwLzhBZlFLbjhtaDhhTEVBQTBscUhHclJBcXpqQXF5dUFxMW5BcTBDQWxjZEFsWGNBckhoMXdNZlRteVhBcks5RFFLeTZCZHM0RzFqYlVoZkF5WE5BclpjT3o5dWtBTXBSUUs0WGdLNVJ4VUN1U3AzY0RadzRRSzlHUUs3Mm5DV0F6SVJBcjZJY2dJRE0zRUN2aHB6SW5OUEFzUExBc01FYzRKMFN6VkZkT0FEUEtjRFBKb0RQYjhDeFh3Q3hrY0N4aENKQXNocFVRTElSQUxKVHdMSkxnSmtuUUxkMG5oNVlYaXVlU1ZMMEFNWW8yY0NBbUgwR2ZPVkpIc0xYcEpldXhFQ3oyc0N6Mnd2UzFQUzh4T2ZBTWF0QXM5ekFTbnFBMDRTZmtzRkF0d25BdHVLQXRKUEExSmNBMU5mQVFFRFZZeUFpVDhBeXhidFlFV0NISUxUZ3M2RGpRTGF4d0xaM29RUWhFbW5QQU9HcFFBdkEyUU9obkZaK1FCVkF0OWxBdDY0YzNjQzRpL3RGQUh6TUNjQjlKc0I4dEtIQXV2ekF1bHdlUUxxK1FMcTVBRDVSd0c1QXU2SkF1dWNscXFYQXdMdVB3T0Y0Smg1Y09CeG9RTHpBd0JwQTQ0V21aTUM5eE1Ea1c0RGtvY0M5NWdDK2RrQytHYWFISnFydXplYkhnT2Rnd0wrK2dFYkFEbWZISit6QXdXTkE2WnFBNmJaQU5IRkF3WnFvWWlpQlFrRERFa0N3QUEvQXdEaFFSZFRBUkh6QTJzSGwyY0ZBSk10SzdldnZkc0JpWmtVZnhFRU9RSDdLUVVoRHAwSm53Q1MvU2xYeFFMM0FaMEF0d1c1QUc4TGJVRXVGQ2FOTGdGREFZRDhBYlVtQUhVRERnUnRBQ3dDRmd5aEFBQUtBajBDYWdQZEEzNEVrUUVnUlFVaGZBb0FCUUJFQUJNQU5oSUNkd0VBQmRVRGErOEt4UUlBOXdxZko3K3h0K1VCa1NGQlFnSHBGSDhSTk1DSkFBUUFHd0JhQWtVQ2hJc0FCanBUT3BTTmJRQzRPbzg2MEFDTk9NRTYzQUNsQU9nQXl3RTZnVG83T2Z3NStUdDJpVHBiTzU2Sk9tODVHQUZXQVRNQmJBVXZOVjAxbmpXdE5XWTFkVFcyTmNVMWdqV1JOZEkxNFRXZU5hMDE3alg5TmJJMXdUWUNOaEUxeGpYVk5oWTJKelhlTmUwMkxqWTlOaTQxTFNFMk9qWTlOancyeVRjSUJKQThWelk0TnQwM0lEY1BOc29nTjRrM01Bb0VzRHhuTmlRM0dUZHNPbzAzSVVMVVF3ZEM0RU1MSEE4UENac29iU2hSVlFZQTZYOEE2YkFCRkNuWEF1a0Jvd0M5QmJjQWJ3TnpCTDhNREFNTUFRZ0RBQWtLQ3dzTENRb0dCQVZWQkkvRHZ3RHo5YjI5a2FVQ2IwUXRzUlROTHQ0ZUdCY1NIQU1aRmhZWkVoWUVBUkFFQlVFY1FSeEJIRUVjUVJ4QkhFRWFRUnhCSEVGQ1NUeEJQRWxJU1VoQk5rTTJRVFliTmtsSVNWbUJWSWdCRkxXWkF1MEJoUUNqQmNFQWJ5a0J2d0dKQWFRY0VaMGVQQ2tsTUFBaE12QUlNQUw1NGdDN0JtOEVlc2NqelFNcEFSUXBLZ0RVQUJhdkFqNjI2eFFBSlAwQTNldHp1ZjROTlJBN2VmeTJaOU5RckNuQzBPU3lBTno1QkJJYko1SUZEUjZtaUlhdllTNnRwcmpqbXVLZWJ4bTVDNzRRMjI1WDFwa2FZWVBiNmYxREs0azN4TUVCYjlTMldNakVpYlROV2hzUkpJQSt2d05WRWlYVEU1aVhzL3dlelY2Nm9GTGZwOU5aR1lXK0drMTlKMitiQ1Q2WWUydzZMRFlkZ3pLTVVhYms1OTVlTEJDWEFOejlIVXBXYkFUcTl2cVhWeDlYRGcrUGM5WHA0K2JzUzAwNVNWTS9CSkJNNDY4N1dVdWYrVWo5ZEVpOGFETmFQeHRwYkR4Y0cxVEhUSW1VTVpxNFVDYWFOWXBzVnFyYU55S0xKWERZc0ZaLzVqbDdiTFJ0Tzg4dDdQM3haYUF4aGI1T2RQTVhxc1NrcDFXQ2llRzhqWG0xVTk5K2JsdkxsWHpQQ1MrTTkzVm5KQ2lLKzA5TGZhU2FCQVZCb215RGdKdWE4ZGZVelI3Z2EzNEl2UjJOdmorQTloZUo2bHNsMUtHNE5rSTEwMzJDbmZmMW0xd29mMkI5b0hKSzRiaTZKa0VkU3FlTmVpdW82UW9aWmluY29jNzMvVEg5U1hGOHNDRTdYeXVZeVc4V1NnYkdGQ2pQVjBpaExLaGRQczA4VHg4MmZZQWtMTGM0STJ3ZGw0YXBZN0dVNWxIUkZ6UldKZXA3V3czd2JlQTNxbWQ1OS84NlA0eHVOYXFEcHlnWHQ2TTg1Z2xTQkhPQ0dnSkRudCtwTjliSzdIQXBNZ3VYNiswNlJaTmp6Vm1jWkord2NVcko5Ly9icFJOeE51S3BObDl1RmRzK1M5dGR4N0xhTTVaa0lyUGo2bklVOW1uYkZ0VmJzOXMvdUxnbDhNVmN6QXdldCtpT0V6ekJsWVc3UkNNZ0U2Z3lOTGVxNisxdEl4NGRwZ1puZDBEa3NKUzVmK0pORHB3d2NQTlhhYVZzcHExZmJRYWpPckpnSzBvZkt0SjFOZTkwTDZWTzRNT2w1Uzg4NnA3dTZ4bzdPTGpHOFRHTCtIVTFKWEdKZ3BwZzRuTmJOSjVubHpTcHVQWXkyMUpVRWNVQTk0UG9GaVpmalp1ZStRbnlRODBla091WlZreHg0ZytjdmhKZkhnTmw0aHkxL2E2K1JLY0tsYXIvSjI5eS8vRXp0bGJWUEhWVWVRMXpYODZlUVZBalIvTTNkQTl3NFc4TGZhWHA0RWdNODV3T1dhc2xpODM3UHpWTU9uc0x6UitrM283NS9sUlBBSlNFMXhBS1F6RWk1djEwa2UrVkJ2UnQxY3dRUk1kK1U1bUxDVEdWZDZYaVp0Z0JHNWNEaTB3MjJHS2NWTnZIaXU1TFFiWkVEVnR6MG9ubjdrNStoZXVLWFZzWnRTemlsa0xSQVVtak1YRU1CM0o5WUM1MFhCeFBpejUzU0MrRWhuUGw5V3NLQ3Y5MlNNL09GRklNSlpZZmwwV1c4dElPM1V4WWN3ZE1BajdGU21ncnNaMmFBWk8wM0JPaFAxYk5OWkl0eVhZUUZUcEMzU0cxVnVQRHFIOUdraUNEbUUrSnd4eUlWU081c2lERXJBT3BFWEZnank2UFF0T1ZEaitzNmUxcjhoZVdWdm1ablRjaXVmNEVpTlp6Q0FkN1NPTWhYRVJJT2xzSElNRzM5OWk5YUxUeTNtMmhSTFpqSlZETkxTNTNpR0lLMTFkUHFRdDB6QkR5ZzZxYzdZcWtEbTJNNVZlNmRDV0NhQ2JUWFgyclRvYUlnejYremg0bFlVaS8rNm5xY0ZNQWtRSktIWUxLMHdZazVOOXN6VjZ4aWhEYkRERnI0NWxOMUs0YUNYQnEvRml0UFN1ZDlnTHQ1WlZuK1pxR1g3Y3dtMno1RUdNZ2ZGcElGeWhHR3VEUG1zbzZUSXRUTXdueSs3dVBuTENmNFc2Z29GUUZWMG9RU3NjOVZmTW1WTGNMcjZaZXREWmJhU0ZUTHFuU08vYklQakEzL3pBVW9xZ0dGQUVRUzRJaHVNekVwMkkzakp6Ynpray9JRW15YXgrcmhaVHdkNmYrQ0d0d1BpeHU4SXZ6QUNxdVBXUFJFdTladkdrVXpwUnd2UlJ1YU5ONmNyMFcxd1dpdHM5SUNkWUo3bHRiZ01pU0wzc1RQZXVmZ05jVnFNVldGa0NQREg0akcyakEwWGNWZ1FqNjJDYjI5djlmL3ovKzJLYll2SXYvenpqcFFBUGtsaWFWRHpOclc1N1RaL1pPeVpEMG5sZk1tQUlCSUFHQUkwRDNrL21kTjR4cjl2ODVaYlpiYnFmSDJqR2Q1aFVxTlpXd2w1U1Bmb0dtZkVsbWF6VUllTkwxai9ta0Y3Vk5BelRxNGpOdDhKb1ExMU5RT2NtaHByWG94U3hmUkdKOUxERU9BUStkbXhBUUg5MGl0aTllMnUvTW9ldWFHY0RUSG9DK3hzbUVlV214RUtlZlF1SXpIYnB3NVRjNWNFb2Nib0FEMDlvaXBXUWh0VE8xd2l2Zi9PK0RSZTJycGwvRTl3bHJ6Qm9yakpzT2VHMUIvWFBXNEVhSkVGZE5sRUNFWmdhNVpvR1JIWGdZb3VHUnVWa204dERFU2lFeUZObyszczVNNXB1U2RUeVVMMmxsbklOVkhFdDkxWFVOVzRld2RNZ0o0Ym9KZkV5dC9pWTVXWHFiQStBMkZrdDVaMGx1dGlXaGU5blpJeUlVanlYREMzVXNhRzF0K2VOeDZ6NFcvT1lvVEI3QTZ4K2ROU1RPaTlBSW5jdGJFU3FtNWd2T0x3dzdPV1hQcm1Id1ZaYXNybDRlRDExM3BtK0p0VDdKVk92bkNYcWR6emRUUkhnSjBQaUdURllXNUd2dDlSOUxENkx6ZnMwdi9UWlpIU215Vk5xN3ZpSUhFNkRCSzdRcDA3SXo1NUVNOFNZdFF2WmYvb2JCbmlUV2k1QzIvb3ZIZnc0Vm5ka0U1WFlkak9oQ01SakRlT0VmWGVOL0N3ZkdkdWlVSWZzb0ZlVXhYZVFYYmE3Yzc5NzJYTnY4dytkVGpqVU0wUWVOQVJlVytKMDE0ZEtBRC9NY1FZWFQ3YzBHUVBJa24zTGw2UjdnR2p1aVFvWkQwVEVlRXFRcEtvWjE1Zy8wT1BRSTE3UWlTdjlBVVJPYS9WL1RRTjNkdkxBcmVjM1Jyc1lsdkJtMWI4TFd6bHRkdWdzQzUwbE5LWUxFcDJhK1paWXFQZWpVTFJsT0poNXpqL0xWTXlURHZ3S2hNeHh3dURreEoxUXBvTkkwT1RXTG9tNFo3MVNOekk5VFYxaVhKckl1OVdjbmQrTUNhQXc4bzFqU1hkOTRZVS8xZ25rckM5QlVFT3RRdkVJUTdnMGk2aCtLTDJKS2s4WWRsN0hydXZnV01TQW1OZStMc2hHaFY0cW5XSGhPOS9SSVBRelkxdEhSajJWcU95TnNEcEswY3d3KzU2QWREQzRnc1d3WTBYeG91Y0lXSXFzL0djd25XcWxhVDBLUHI4bWJLNVU5NC8zMDFpMVdMdDRZSU5UVnZDRkJyRlpiSWJZOGV5Y09kZUoydGVENUlmUExDUmc3ampjRlR3bE1GTmw5emRoL28zRS9oSFB3ajdCV2cwTVUwOXBQckJMYnJDZ201NEE2SCtJNnYyNytqTDVna2pXZy9pWWRrczlqYmZWUDV5L24wZGxnV0VNbEthc2w3SnZGWmQ1NkxmeWJXMWVlYVZPMGd4VGZYWndEOEc0U0kxMTZ5eDdVS1ZSZ3VpNllhMVlwaXhxWGVOTGM4SXh0QXdDVTVJaHdRZ24rTnFIblJhRHY2MUN4S2hPcTRwT1g3TTZwa0ErUG1wZDRqMXZuNkFDVUFMb0xMYzR2cFhjaThWaWRMeHptN3FGQmU3cytxdXVKczZFVFltbnBnUzNMd1NaeFBJbHRnQkRYejhNMWsvVzJ5U052MmY5L05QaHhMR0syRDIxZGtIZVNHbWVuUlQzWXFjZGwwbS9oM09ZcjhWK2xYTllHZjhhQ0NwZDRiV2pFNFFJUGo3dlVLTjROcmZzN01MNlkyT3lTODMwSkNub2ZnL2s3bHBGcHQ0U3FaYzVIR2cxSENPckh2T2RDOGJQNkZHRGJFL1ZWMG1YNElha3piZFMvb3ArS3QzRzI0LzhRYkJWN3k4NnNHU1Evdlp6VThGWHM3dTZqSXZ3Y2hzRVAyQnBJaFczRzh1V053YTNIbWpmSC9aamhoQ1d2bHVBY0Yrbk1mMTRDbEtnNWhHZ3RQTEo5OHVlTkFrYzVIczJXWmxrMlFIdmZyZUNLMUNDR082bk1aVlNiOTlWTS9hanI4V0hUdGU5SlNta1hxL2kvVTk0M0hFYmR6VzZSZS9TODhkS2dnOHBHT0xsQWVOaXFyY0xrVVIzL2FDbEZwTVhjT1VQM3JtRVRjV1NmTVhaRTNUVU9pOGkrZnFSblRZTGZsVngvVmIvNkdKN2VJUlpVQTZrM1JZUjNpRlNLOWM0aURkTndKdVpMMkZLei9JSzVWaW1jTldFcWRYalNveFNnbUYwVVBsRG9VbE5yUGNNN2Z0bUE4WTlnS2lxS0VIdVdOK0FaUkl3dFZTeHllMktmOHJNM2xoSjVYY0JYVTluNHYwT3kxUlUyTSs0cU04QVFQVndzZThFck5Tb2I1b0ZQV3h1cVpuVnpvMXFCL0lCeGtNM0VWVUtGVVVsTzNlNTEyNTlHZ05jSmJDbWx2cmRqdG9UVzdyQ2htMXd5Q0t6cENUd296VVVFT0ljV0xuZVJMZ01YaCtTakdTRmtBbGx6YkdTNUhLN0xsZkNNUk5SRFN2YlFQamNYYWVuTll4Q3Z1MlF5em56NlN0dXhWajY2U2dJMFQ4QjYvc2ZIQUpZWmFaNzh0aGpPU0lGdW1OV0xRYmVaaXhEQ0NDK3YwWUJ0a3hpQkIzamVmSHFaL2RGSFUrY3JiajZPdlMxeC9KREQ3dmxtN3pPVlB3cFVDMDFuaHhadVkvNjNFN2cnO1xuXG4vLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIxNS9cclxuLy8gZm9yIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvblxyXG4vLyBzZWU6IC9kZXJpdmUvbmYuanNcclxuXHJcblxyXG4vLyBhbGdvcml0aG1pYyBoYW5ndWxcclxuLy8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvdmVyc2lvbnMvVW5pY29kZTE1LjAuMC9jaDAzLnBkZiAocGFnZSAxNDQpXHJcbmNvbnN0IFMwID0gMHhBQzAwO1xyXG5jb25zdCBMMCA9IDB4MTEwMDtcclxuY29uc3QgVjAgPSAweDExNjE7XHJcbmNvbnN0IFQwID0gMHgxMUE3O1xyXG5jb25zdCBMX0NPVU5UID0gMTk7XHJcbmNvbnN0IFZfQ09VTlQgPSAyMTtcclxuY29uc3QgVF9DT1VOVCA9IDI4O1xyXG5jb25zdCBOX0NPVU5UID0gVl9DT1VOVCAqIFRfQ09VTlQ7XHJcbmNvbnN0IFNfQ09VTlQgPSBMX0NPVU5UICogTl9DT1VOVDtcclxuY29uc3QgUzEgPSBTMCArIFNfQ09VTlQ7XHJcbmNvbnN0IEwxID0gTDAgKyBMX0NPVU5UO1xyXG5jb25zdCBWMSA9IFYwICsgVl9DT1VOVDtcclxuY29uc3QgVDEgPSBUMCArIFRfQ09VTlQ7XHJcblxyXG5mdW5jdGlvbiB1bnBhY2tfY2MocGFja2VkKSB7XHJcblx0cmV0dXJuIChwYWNrZWQgPj4gMjQpICYgMHhGRjtcclxufVxyXG5mdW5jdGlvbiB1bnBhY2tfY3AocGFja2VkKSB7XHJcblx0cmV0dXJuIHBhY2tlZCAmIDB4RkZGRkZGO1xyXG59XHJcblxyXG5sZXQgU0hJRlRFRF9SQU5LLCBFWENMVVNJT05TLCBERUNPTVAsIFJFQ09NUDtcclxuXHJcbmZ1bmN0aW9uIGluaXQkMSgpIHtcclxuXHQvL2NvbnNvbGUudGltZSgnbmYnKTtcclxuXHRsZXQgciA9IHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkKENPTVBSRVNTRUQpO1xyXG5cdFNISUZURURfUkFOSyA9IG5ldyBNYXAocmVhZF9zb3J0ZWRfYXJyYXlzKHIpLmZsYXRNYXAoKHYsIGkpID0+IHYubWFwKHggPT4gW3gsIChpKzEpIDw8IDI0XSkpKTsgLy8gcHJlLXNoaWZ0ZWRcclxuXHRFWENMVVNJT05TID0gbmV3IFNldChyZWFkX3NvcnRlZChyKSk7XHJcblx0REVDT01QID0gbmV3IE1hcCgpO1xyXG5cdFJFQ09NUCA9IG5ldyBNYXAoKTtcclxuXHRmb3IgKGxldCBbY3AsIGNwc10gb2YgcmVhZF9tYXBwZWQocikpIHtcclxuXHRcdGlmICghRVhDTFVTSU9OUy5oYXMoY3ApICYmIGNwcy5sZW5ndGggPT0gMikge1xyXG5cdFx0XHRsZXQgW2EsIGJdID0gY3BzO1xyXG5cdFx0XHRsZXQgYnVja2V0ID0gUkVDT01QLmdldChhKTtcclxuXHRcdFx0aWYgKCFidWNrZXQpIHtcclxuXHRcdFx0XHRidWNrZXQgPSBuZXcgTWFwKCk7XHJcblx0XHRcdFx0UkVDT01QLnNldChhLCBidWNrZXQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJ1Y2tldC5zZXQoYiwgY3ApO1xyXG5cdFx0fVxyXG5cdFx0REVDT01QLnNldChjcCwgY3BzLnJldmVyc2UoKSk7IC8vIHN0b3JlZCByZXZlcnNlZFxyXG5cdH1cclxuXHQvL2NvbnNvbGUudGltZUVuZCgnbmYnKTtcclxuXHQvLyAyMDIzMDkwNTogMTFtc1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc19oYW5ndWwoY3ApIHtcclxuXHRyZXR1cm4gY3AgPj0gUzAgJiYgY3AgPCBTMTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcG9zZV9wYWlyKGEsIGIpIHtcclxuXHRpZiAoYSA+PSBMMCAmJiBhIDwgTDEgJiYgYiA+PSBWMCAmJiBiIDwgVjEpIHtcclxuXHRcdHJldHVybiBTMCArIChhIC0gTDApICogTl9DT1VOVCArIChiIC0gVjApICogVF9DT1VOVDtcclxuXHR9IGVsc2UgaWYgKGlzX2hhbmd1bChhKSAmJiBiID4gVDAgJiYgYiA8IFQxICYmIChhIC0gUzApICUgVF9DT1VOVCA9PSAwKSB7XHJcblx0XHRyZXR1cm4gYSArIChiIC0gVDApO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRsZXQgcmVjb21wID0gUkVDT01QLmdldChhKTtcclxuXHRcdGlmIChyZWNvbXApIHtcclxuXHRcdFx0cmVjb21wID0gcmVjb21wLmdldChiKTtcclxuXHRcdFx0aWYgKHJlY29tcCkge1xyXG5cdFx0XHRcdHJldHVybiByZWNvbXA7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiAtMTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlY29tcG9zZWQoY3BzKSB7XHJcblx0aWYgKCFTSElGVEVEX1JBTkspIGluaXQkMSgpO1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgYnVmID0gW107XHJcblx0bGV0IGNoZWNrX29yZGVyID0gZmFsc2U7XHJcblx0ZnVuY3Rpb24gYWRkKGNwKSB7XHJcblx0XHRsZXQgY2MgPSBTSElGVEVEX1JBTksuZ2V0KGNwKTtcclxuXHRcdGlmIChjYykge1xyXG5cdFx0XHRjaGVja19vcmRlciA9IHRydWU7XHJcblx0XHRcdGNwIHw9IGNjO1xyXG5cdFx0fVxyXG5cdFx0cmV0LnB1c2goY3ApO1xyXG5cdH1cclxuXHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdGlmIChjcCA8IDB4ODApIHtcclxuXHRcdFx0XHRyZXQucHVzaChjcCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoaXNfaGFuZ3VsKGNwKSkge1xyXG5cdFx0XHRcdGxldCBzX2luZGV4ID0gY3AgLSBTMDtcclxuXHRcdFx0XHRsZXQgbF9pbmRleCA9IHNfaW5kZXggLyBOX0NPVU5UIHwgMDtcclxuXHRcdFx0XHRsZXQgdl9pbmRleCA9IChzX2luZGV4ICUgTl9DT1VOVCkgLyBUX0NPVU5UIHwgMDtcclxuXHRcdFx0XHRsZXQgdF9pbmRleCA9IHNfaW5kZXggJSBUX0NPVU5UO1xyXG5cdFx0XHRcdGFkZChMMCArIGxfaW5kZXgpO1xyXG5cdFx0XHRcdGFkZChWMCArIHZfaW5kZXgpO1xyXG5cdFx0XHRcdGlmICh0X2luZGV4ID4gMCkgYWRkKFQwICsgdF9pbmRleCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IG1hcHBlZCA9IERFQ09NUC5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmIChtYXBwZWQpIHtcclxuXHRcdFx0XHRcdGJ1Zi5wdXNoKC4uLm1hcHBlZCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGFkZChjcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghYnVmLmxlbmd0aCkgYnJlYWs7XHJcblx0XHRcdGNwID0gYnVmLnBvcCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoY2hlY2tfb3JkZXIgJiYgcmV0Lmxlbmd0aCA+IDEpIHtcclxuXHRcdGxldCBwcmV2X2NjID0gdW5wYWNrX2NjKHJldFswXSk7XHJcblx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgY2MgPSB1bnBhY2tfY2MocmV0W2ldKTtcclxuXHRcdFx0aWYgKGNjID09IDAgfHwgcHJldl9jYyA8PSBjYykge1xyXG5cdFx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsZXQgaiA9IGktMTtcclxuXHRcdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0XHRsZXQgdG1wID0gcmV0W2orMV07XHJcblx0XHRcdFx0cmV0W2orMV0gPSByZXRbal07XHJcblx0XHRcdFx0cmV0W2pdID0gdG1wO1xyXG5cdFx0XHRcdGlmICghaikgYnJlYWs7XHJcblx0XHRcdFx0cHJldl9jYyA9IHVucGFja19jYyhyZXRbLS1qXSk7XHJcblx0XHRcdFx0aWYgKHByZXZfY2MgPD0gY2MpIGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdHByZXZfY2MgPSB1bnBhY2tfY2MocmV0W2ldKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcG9zZWRfZnJvbV9kZWNvbXBvc2VkKHYpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IHN0YWNrID0gW107XHJcblx0bGV0IHByZXZfY3AgPSAtMTtcclxuXHRsZXQgcHJldl9jYyA9IDA7XHJcblx0Zm9yIChsZXQgcGFja2VkIG9mIHYpIHtcclxuXHRcdGxldCBjYyA9IHVucGFja19jYyhwYWNrZWQpO1xyXG5cdFx0bGV0IGNwID0gdW5wYWNrX2NwKHBhY2tlZCk7XHJcblx0XHRpZiAocHJldl9jcCA9PSAtMSkge1xyXG5cdFx0XHRpZiAoY2MgPT0gMCkge1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXQucHVzaChjcCk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAocHJldl9jYyA+IDAgJiYgcHJldl9jYyA+PSBjYykge1xyXG5cdFx0XHRpZiAoY2MgPT0gMCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKHByZXZfY3AsIC4uLnN0YWNrKTtcclxuXHRcdFx0XHRzdGFjay5sZW5ndGggPSAwO1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFjay5wdXNoKGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRwcmV2X2NjID0gY2M7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY29tcG9zZWQgPSBjb21wb3NlX3BhaXIocHJldl9jcCwgY3ApO1xyXG5cdFx0XHRpZiAoY29tcG9zZWQgPj0gMCkge1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjb21wb3NlZDtcclxuXHRcdFx0fSBlbHNlIGlmIChwcmV2X2NjID09IDAgJiYgY2MgPT0gMCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKHByZXZfY3ApO1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFjay5wdXNoKGNwKTtcclxuXHRcdFx0XHRwcmV2X2NjID0gY2M7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKHByZXZfY3AgPj0gMCkge1xyXG5cdFx0cmV0LnB1c2gocHJldl9jcCwgLi4uc3RhY2spO1x0XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8vIG5vdGU6IGNwcyBjYW4gYmUgaXRlcmFibGVcclxuZnVuY3Rpb24gbmZkKGNwcykge1xyXG5cdHJldHVybiBkZWNvbXBvc2VkKGNwcykubWFwKHVucGFja19jcCk7XHJcbn1cclxuZnVuY3Rpb24gbmZjKGNwcykge1xyXG5cdHJldHVybiBjb21wb3NlZF9mcm9tX2RlY29tcG9zZWQoZGVjb21wb3NlZChjcHMpKTtcclxufVxuXG5jb25zdCBIWVBIRU4gPSAweDJEO1xyXG5jb25zdCBTVE9QID0gMHgyRTtcclxuY29uc3QgU1RPUF9DSCA9ICcuJztcclxuY29uc3QgRkUwRiA9IDB4RkUwRjtcclxuY29uc3QgVU5JUVVFX1BIID0gMTtcclxuXHJcbi8vIDIwMjMwOTEzOiByZXBsYWNlIFsuLi52XSB3aXRoIEFycmF5X2Zyb20odikgdG8gYXZvaWQgbGFyZ2Ugc3ByZWFkc1xyXG5jb25zdCBBcnJheV9mcm9tID0geCA9PiBBcnJheS5mcm9tKHgpOyAvLyBBcnJheS5mcm9tLmJpbmQoQXJyYXkpO1xyXG5cclxuZnVuY3Rpb24gZ3JvdXBfaGFzX2NwKGcsIGNwKSB7XHJcblx0Ly8gMjAyMzA5MTM6IGtlZXAgcHJpbWFyeSBhbmQgc2Vjb25kYXJ5IGRpc3RpbmN0IGluc3RlYWQgb2YgY3JlYXRpbmcgdmFsaWQgdW5pb25cclxuXHRyZXR1cm4gZy5QLmhhcyhjcCkgfHwgZy5RLmhhcyhjcCk7XHJcbn1cclxuXHJcbmNsYXNzIEVtb2ppIGV4dGVuZHMgQXJyYXkge1xyXG5cdGdldCBpc19lbW9qaSgpIHsgcmV0dXJuIHRydWU7IH0gLy8gZnJlZSB0YWdnaW5nIHN5c3RlbVxyXG59XHJcblxyXG5sZXQgTUFQUEVELCBJR05PUkVELCBDTSwgTlNNLCBFU0NBUEUsIE5GQ19DSEVDSywgR1JPVVBTLCBXSE9MRV9WQUxJRCwgV0hPTEVfTUFQLCBWQUxJRCwgRU1PSklfTElTVCwgRU1PSklfUk9PVDtcclxuXHJcbmZ1bmN0aW9uIGluaXQoKSB7XHJcblx0aWYgKE1BUFBFRCkgcmV0dXJuO1xyXG5cdFxyXG5cdGxldCByID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoQ09NUFJFU1NFRCQxKTtcclxuXHRjb25zdCByZWFkX3NvcnRlZF9hcnJheSA9ICgpID0+IHJlYWRfc29ydGVkKHIpO1xyXG5cdGNvbnN0IHJlYWRfc29ydGVkX3NldCA9ICgpID0+IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKSk7XHJcblxyXG5cdE1BUFBFRCA9IG5ldyBNYXAocmVhZF9tYXBwZWQocikpOyBcclxuXHRJR05PUkVEID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIGlnbm9yZWQgY2hhcmFjdGVycyBhcmUgbm90IHZhbGlkLCBzbyBqdXN0IHJlYWQgcmF3IGNvZGVwb2ludHNcclxuXHJcblx0LypcclxuXHQvLyBkaXJlY3QgaW5jbHVkZSBmcm9tIHBheWxvYWQgaXMgc21hbGxlciB0aGFuIHRoZSBkZWNvbXByZXNzaW9uIGNvZGVcclxuXHRjb25zdCBGRU5DRUQgPSBuZXcgTWFwKHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0bGV0IGNwID0gcigpO1xyXG5cdFx0aWYgKGNwKSByZXR1cm4gW2NwLCByZWFkX3N0cihyKCkpXTtcclxuXHR9KSk7XHJcblx0Ki9cclxuXHQvLyAyMDIzMDIxNzogd2Ugc3RpbGwgbmVlZCBhbGwgQ00gZm9yIHByb3BlciBlcnJvciBmb3JtYXR0aW5nXHJcblx0Ly8gYnV0IG5vcm0gb25seSBuZWVkcyBOU00gc3Vic2V0IHRoYXQgYXJlIHBvdGVudGlhbGx5LXZhbGlkXHJcblx0Q00gPSByZWFkX3NvcnRlZF9hcnJheSgpO1xyXG5cdE5TTSA9IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKS5tYXAoaSA9PiBDTVtpXSkpO1xyXG5cdENNID0gbmV3IFNldChDTSk7XHJcblx0XHJcblx0RVNDQVBFID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgbm90IGJlIHByaW50ZWRcclxuXHRORkNfQ0hFQ0sgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gb25seSBuZWVkZWQgdG8gaWxsdXN0cmF0ZSBlbnNfdG9rZW5pemUoKSB0cmFuc2Zvcm1hdGlvbnNcclxuXHJcblx0bGV0IGNodW5rcyA9IHJlYWRfc29ydGVkX2FycmF5cyhyKTtcclxuXHRsZXQgdW5yZXN0cmljdGVkID0gcigpO1xyXG5cdGNvbnN0IHJlYWRfY2h1bmtlZCA9ICgpID0+IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKS5mbGF0TWFwKGkgPT4gY2h1bmtzW2ldKS5jb25jYXQocmVhZF9zb3J0ZWRfYXJyYXkoKSkpO1xyXG5cdEdST1VQUyA9IHJlYWRfYXJyYXlfd2hpbGUoaSA9PiB7XHJcblx0XHQvLyBtaW5pZmllciBwcm9wZXJ0eSBtYW5nbGluZyBzZWVtcyB1bnNhZmVcclxuXHRcdC8vIHNvIHRoZXNlIGFyZSBtYW51YWxseSByZW5hbWVkIHRvIHNpbmdsZSBjaGFyc1xyXG5cdFx0bGV0IE4gPSByZWFkX2FycmF5X3doaWxlKHIpLm1hcCh4ID0+IHgrMHg2MCk7XHJcblx0XHRpZiAoTi5sZW5ndGgpIHtcclxuXHRcdFx0bGV0IFIgPSBpID49IHVucmVzdHJpY3RlZDsgLy8gZmlyc3QgYXJlbnQgcmVzdHJpY3RlZFxyXG5cdFx0XHROWzBdIC09IDMyOyAvLyBjYXBpdGFsaXplXHJcblx0XHRcdE4gPSBzdHJfZnJvbV9jcHMoTik7XHJcblx0XHRcdGlmIChSKSBOPWBSZXN0cmljdGVkWyR7Tn1dYDtcclxuXHRcdFx0bGV0IFAgPSByZWFkX2NodW5rZWQoKTsgLy8gcHJpbWFyeVxyXG5cdFx0XHRsZXQgUSA9IHJlYWRfY2h1bmtlZCgpOyAvLyBzZWNvbmRhcnlcclxuXHRcdFx0bGV0IE0gPSAhcigpOyAvLyBub3Qtd2hpdGVsaXN0ZWQsIGNoZWNrIGZvciBOU01cclxuXHRcdFx0Ly8gKioqIHRoaXMgY29kZSBjdXJyZW50bHkgaXNuJ3QgbmVlZGVkICoqKlxyXG5cdFx0XHQvKlxyXG5cdFx0XHRsZXQgViA9IFsuLi5QLCAuLi5RXS5zb3J0KChhLCBiKSA9PiBhLWIpOyAvLyBkZXJpdmU6IHNvcnRlZCB2YWxpZFxyXG5cdFx0XHRsZXQgTSA9IHIoKS0xOyAvLyBudW1iZXIgb2YgY29tYmluaW5nIG1hcmtcclxuXHRcdFx0aWYgKE0gPCAwKSB7IC8vIHdoaXRlbGlzdGVkXHJcblx0XHRcdFx0TSA9IG5ldyBNYXAocmVhZF9hcnJheV93aGlsZSgoKSA9PiB7XHJcblx0XHRcdFx0XHRsZXQgaSA9IHIoKTtcclxuXHRcdFx0XHRcdGlmIChpKSByZXR1cm4gW1ZbaS0xXSwgcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7XHJcblx0XHRcdFx0XHRcdGxldCB2ID0gcmVhZF9hcnJheV93aGlsZShyKTtcclxuXHRcdFx0XHRcdFx0aWYgKHYubGVuZ3RoKSByZXR1cm4gdi5tYXAoeCA9PiB4LTEpO1xyXG5cdFx0XHRcdFx0fSldO1xyXG5cdFx0XHRcdH0pKTtcclxuXHRcdFx0fSovXHJcblx0XHRcdHJldHVybiB7TiwgUCwgUSwgTSwgUn07XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdC8vIGRlY29kZSBjb21wcmVzc2VkIHdob2xlc1xyXG5cdFdIT0xFX1ZBTElEID0gcmVhZF9zb3J0ZWRfc2V0KCk7XHJcblx0V0hPTEVfTUFQID0gbmV3IE1hcCgpO1xyXG5cdGxldCB3aG9sZXMgPSByZWFkX3NvcnRlZF9hcnJheSgpLmNvbmNhdChBcnJheV9mcm9tKFdIT0xFX1ZBTElEKSkuc29ydCgoYSwgYikgPT4gYS1iKTsgLy8gbXVzdCBiZSBzb3J0ZWRcclxuXHR3aG9sZXMuZm9yRWFjaCgoY3AsIGkpID0+IHtcclxuXHRcdGxldCBkID0gcigpOyBcclxuXHRcdGxldCB3ID0gd2hvbGVzW2ldID0gZCA/IHdob2xlc1tpLWRdIDoge1Y6IFtdLCBNOiBuZXcgTWFwKCl9O1xyXG5cdFx0dy5WLnB1c2goY3ApOyAvLyBhZGQgdG8gbWVtYmVyIHNldFxyXG5cdFx0aWYgKCFXSE9MRV9WQUxJRC5oYXMoY3ApKSB7XHJcblx0XHRcdFdIT0xFX01BUC5zZXQoY3AsIHcpOyAgLy8gcmVnaXN0ZXIgd2l0aCB3aG9sZSBtYXBcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Ly8gY29tcHV0ZSBjb25mdXNhYmxlLWV4dGVudCBjb21wbGVtZW50c1xyXG5cdGZvciAobGV0IHtWLCBNfSBvZiBuZXcgU2V0KFdIT0xFX01BUC52YWx1ZXMoKSkpIHtcclxuXHRcdC8vIGNvbm5lY3QgYWxsIGdyb3VwcyB0aGF0IGhhdmUgZWFjaCB3aG9sZSBjaGFyYWN0ZXJcclxuXHRcdGxldCByZWNzID0gW107XHJcblx0XHRmb3IgKGxldCBjcCBvZiBWKSB7XHJcblx0XHRcdGxldCBncyA9IEdST1VQUy5maWx0ZXIoZyA9PiBncm91cF9oYXNfY3AoZywgY3ApKTtcclxuXHRcdFx0bGV0IHJlYyA9IHJlY3MuZmluZCgoe0d9KSA9PiBncy5zb21lKGcgPT4gRy5oYXMoZykpKTtcclxuXHRcdFx0aWYgKCFyZWMpIHtcclxuXHRcdFx0XHRyZWMgPSB7RzogbmV3IFNldCgpLCBWOiBbXX07XHJcblx0XHRcdFx0cmVjcy5wdXNoKHJlYyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmVjLlYucHVzaChjcCk7XHJcblx0XHRcdGdzLmZvckVhY2goZyA9PiByZWMuRy5hZGQoZykpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gcGVyIGNoYXJhY3RlciBjYWNoZSBncm91cHMgd2hpY2ggYXJlIG5vdCBhIG1lbWJlciBvZiB0aGUgZXh0ZW50XHJcblx0XHRsZXQgdW5pb24gPSByZWNzLmZsYXRNYXAoeCA9PiBBcnJheV9mcm9tKHguRykpO1xyXG5cdFx0Zm9yIChsZXQge0csIFZ9IG9mIHJlY3MpIHtcclxuXHRcdFx0bGV0IGNvbXBsZW1lbnQgPSBuZXcgU2V0KHVuaW9uLmZpbHRlcihnID0+ICFHLmhhcyhnKSkpO1xyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBWKSB7XHJcblx0XHRcdFx0TS5zZXQoY3AsIGNvbXBsZW1lbnQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBjb21wdXRlIHZhbGlkIHNldFxyXG5cdGxldCB1bmlvbiA9IG5ldyBTZXQoKTsgLy8gZXhpc3RzIGluIDErIGdyb3Vwc1xyXG5cdGxldCBtdWx0aSA9IG5ldyBTZXQoKTsgLy8gZXhpc3RzIGluIDIrIGdyb3Vwc1xyXG5cdGNvbnN0IGFkZF90b191bmlvbiA9IGNwID0+IHVuaW9uLmhhcyhjcCkgPyBtdWx0aS5hZGQoY3ApIDogdW5pb24uYWRkKGNwKTtcclxuXHRmb3IgKGxldCBnIG9mIEdST1VQUykge1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgZy5QKSBhZGRfdG9fdW5pb24oY3ApO1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgZy5RKSBhZGRfdG9fdW5pb24oY3ApO1xyXG5cdH1cclxuXHQvLyBkdWFsIHB1cnBvc2UgV0hPTEVfTUFQOiByZXR1cm4gcGxhY2Vob2xkZXIgaWYgdW5pcXVlIG5vbi1jb25mdXNhYmxlXHJcblx0Zm9yIChsZXQgY3Agb2YgdW5pb24pIHtcclxuXHRcdGlmICghV0hPTEVfTUFQLmhhcyhjcCkgJiYgIW11bHRpLmhhcyhjcCkpIHtcclxuXHRcdFx0V0hPTEVfTUFQLnNldChjcCwgVU5JUVVFX1BIKTtcclxuXHRcdH1cclxuXHR9XHJcblx0VkFMSUQgPSBuZXcgU2V0KEFycmF5X2Zyb20odW5pb24pLmNvbmNhdChBcnJheV9mcm9tKG5mZCh1bmlvbikpKSk7IC8vIHBvc3NpYmx5IHZhbGlkXHJcblxyXG5cdC8vIGRlY29kZSBlbW9qaVxyXG5cdC8vIDIwMjMwNzE5OiBlbW9qaSBhcmUgbm93IGZ1bGx5LWV4cGFuZGVkIHRvIGF2b2lkIHF1aXJrIGxvZ2ljIFxyXG5cdEVNT0pJX0xJU1QgPSByZWFkX3RyaWUocikubWFwKHYgPT4gRW1vamkuZnJvbSh2KSkuc29ydChjb21wYXJlX2FycmF5cyk7XHJcblx0RU1PSklfUk9PVCA9IG5ldyBNYXAoKTsgLy8gdGhpcyBoYXMgYXBwcm94IDdLIG5vZGVzICgyKyBwZXIgZW1vamkpXHJcblx0Zm9yIChsZXQgY3BzIG9mIEVNT0pJX0xJU1QpIHtcclxuXHRcdC8vIDIwMjMwNzE5OiBjaGFuZ2UgdG8gKnNsaWdodGx5KiBzdHJpY3RlciBhbGdvcml0aG0gd2hpY2ggZGlzYWxsb3dzIFxyXG5cdFx0Ly8gaW5zZXJ0aW9uIG9mIG1pc3BsYWNlZCBGRTBGIGluIGVtb2ppIHNlcXVlbmNlcyAobWF0Y2hpbmcgRU5TSVAtMTUpXHJcblx0XHQvLyBleGFtcGxlOiBiZWF1dGlmaWVkIFtBIEJdIChlZy4gZmxhZyBlbW9qaSkgXHJcblx0XHQvLyAgYmVmb3JlOiBhbGxvdzogW0EgRkUwRiBCXSwgZXJyb3I6IFtBIEZFMEYgRkUwRiBCXSBcclxuXHRcdC8vICAgYWZ0ZXI6IGVycm9yOiBib3RoXHJcblx0XHQvLyBub3RlOiB0aGlzIGNvZGUgbm93IG1hdGNoZXMgRU5TTm9ybWFsaXplLntjcyxqYXZhfSBsb2dpY1xyXG5cdFx0bGV0IHByZXYgPSBbRU1PSklfUk9PVF07XHJcblx0XHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdFx0bGV0IG5leHQgPSBwcmV2Lm1hcChub2RlID0+IHtcclxuXHRcdFx0XHRsZXQgY2hpbGQgPSBub2RlLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKCFjaGlsZCkge1xyXG5cdFx0XHRcdFx0Ly8gc2hvdWxkIHRoaXMgYmUgb2JqZWN0PyBcclxuXHRcdFx0XHRcdC8vIChtb3N0IGhhdmUgMS0yIGl0ZW1zLCBmZXcgaGF2ZSBtYW55KVxyXG5cdFx0XHRcdFx0Ly8gMjAyMzA3MTk6IG5vLCB2OCBkZWZhdWx0IG1hcCBpcyA0P1xyXG5cdFx0XHRcdFx0Y2hpbGQgPSBuZXcgTWFwKCk7XHJcblx0XHRcdFx0XHRub2RlLnNldChjcCwgY2hpbGQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gY2hpbGQ7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpZiAoY3AgPT09IEZFMEYpIHtcclxuXHRcdFx0XHRwcmV2LnB1c2goLi4ubmV4dCk7IC8vIGxlc3MgdGhhbiAyMCBlbGVtZW50c1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHByZXYgPSBuZXh0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKGxldCB4IG9mIHByZXYpIHtcclxuXHRcdFx0eC5WID0gY3BzO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gaWYgZXNjYXBlZDoge0hFWH1cclxuLy8gICAgICAgZWxzZTogXCJ4XCIge0hFWH1cclxuZnVuY3Rpb24gcXVvdGVkX2NwKGNwKSB7XHJcblx0cmV0dXJuIChzaG91bGRfZXNjYXBlKGNwKSA/ICcnIDogYCR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhbY3BdKSl9IGApICsgcXVvdGVfY3AoY3ApO1xyXG59XHJcblxyXG4vLyAyMDIzMDIxMTogc29tZSBtZXNzYWdlcyBjYW4gYmUgbWl4ZWQtZGlyZWN0aW9uYWwgYW5kIHJlc3VsdCBpbiBzcGlsbG92ZXJcclxuLy8gdXNlIDIwMEUgYWZ0ZXIgYSBxdW90ZWQgc3RyaW5nIHRvIGZvcmNlIHRoZSByZW1haW5kZXIgb2YgYSBzdHJpbmcgZnJvbSBcclxuLy8gYWNxdXJpbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcXVvdGVcclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL0ludGVybmF0aW9uYWwvcXVlc3Rpb25zL3FhLWJpZGktdW5pY29kZS1jb250cm9scyNleGNlcHRpb25zXHJcbmZ1bmN0aW9uIGJpZGlfcXEocykge1xyXG5cdHJldHVybiBgXCIke3N9XCJcXHUyMDBFYDsgLy8gc3Ryb25nIExUUlxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja19sYWJlbF9leHRlbnNpb24oY3BzKSB7XHJcblx0aWYgKGNwcy5sZW5ndGggPj0gNCAmJiBjcHNbMl0gPT0gSFlQSEVOICYmIGNwc1szXSA9PSBIWVBIRU4pIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBsYWJlbCBleHRlbnNpb246IFwiJHtzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKDAsIDQpKX1cImApO1xyXG5cdH1cclxufVxyXG5mdW5jdGlvbiBjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUoY3BzKSB7XHJcblx0Y29uc3QgVU5ERVJTQ09SRSA9IDB4NUY7XHJcblx0Zm9yIChsZXQgaSA9IGNwcy5sYXN0SW5kZXhPZihVTkRFUlNDT1JFKTsgaSA+IDA7ICkge1xyXG5cdFx0aWYgKGNwc1stLWldICE9PSBVTkRFUlNDT1JFKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcigndW5kZXJzY29yZSBhbGxvd2VkIG9ubHkgYXQgc3RhcnQnKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuLy8gY2hlY2sgdGhhdCBhIGZlbmNlZCBjcCBpcyBub3QgbGVhZGluZywgdHJhaWxpbmcsIG9yIHRvdWNoaW5nIGFub3RoZXIgZmVuY2VkIGNwXHJcbmZ1bmN0aW9uIGNoZWNrX2ZlbmNlZChjcHMpIHtcclxuXHRsZXQgY3AgPSBjcHNbMF07XHJcblx0bGV0IHByZXYgPSBGRU5DRUQuZ2V0KGNwKTtcclxuXHRpZiAocHJldikgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGBsZWFkaW5nICR7cHJldn1gKTtcclxuXHRsZXQgbiA9IGNwcy5sZW5ndGg7XHJcblx0bGV0IGxhc3QgPSAtMTsgLy8gcHJldmVudHMgdHJhaWxpbmcgZnJvbSB0aHJvd2luZ1xyXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRjcCA9IGNwc1tpXTtcclxuXHRcdGxldCBtYXRjaCA9IEZFTkNFRC5nZXQoY3ApO1xyXG5cdFx0aWYgKG1hdGNoKSB7XHJcblx0XHRcdC8vIHNpbmNlIGNwc1swXSBpc24ndCBmZW5jZWQsIGNwc1sxXSBjYW5ub3QgdGhyb3dcclxuXHRcdFx0aWYgKGxhc3QgPT0gaSkgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGAke3ByZXZ9ICsgJHttYXRjaH1gKTtcclxuXHRcdFx0bGFzdCA9IGkgKyAxO1xyXG5cdFx0XHRwcmV2ID0gbWF0Y2g7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChsYXN0ID09IG4pIHRocm93IGVycm9yX3BsYWNlbWVudChgdHJhaWxpbmcgJHtwcmV2fWApO1xyXG59XHJcblxyXG4vLyBjcmVhdGUgYSBzYWZlIHRvIHByaW50IHN0cmluZyBcclxuLy8gaW52aXNpYmxlcyBhcmUgZXNjYXBlZFxyXG4vLyBsZWFkaW5nIGNtIHVzZXMgcGxhY2Vob2xkZXJcclxuLy8gcXVvdGVyKGNwKSA9PiBzdHJpbmcsIGVnLiAzMDAwID0+IFwiezMwMDB9XCJcclxuLy8gbm90ZTogaW4gaHRtbCwgeW91J2QgY2FsbCB0aGlzIGZ1bmN0aW9uIHRoZW4gcmVwbGFjZSBbPD4mXSB3aXRoIGVudGl0aWVzXHJcbmZ1bmN0aW9uIHNhZmVfc3RyX2Zyb21fY3BzKGNwcywgcXVvdGVyID0gcXVvdGVfY3ApIHtcclxuXHQvL2lmIChOdW1iZXIuaXNJbnRlZ2VyKGNwcykpIGNwcyA9IFtjcHNdO1xyXG5cdC8vaWYgKCFBcnJheS5pc0FycmF5KGNwcykpIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIGNvZGVwb2ludHNgKTtcclxuXHRsZXQgYnVmID0gW107XHJcblx0aWYgKGlzX2NvbWJpbmluZ19tYXJrKGNwc1swXSkpIGJ1Zi5wdXNoKCfil4wnKTtcclxuXHRsZXQgcHJldiA9IDA7XHJcblx0bGV0IG4gPSBjcHMubGVuZ3RoO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRsZXQgY3AgPSBjcHNbaV07XHJcblx0XHRpZiAoc2hvdWxkX2VzY2FwZShjcCkpIHtcclxuXHRcdFx0YnVmLnB1c2goc3RyX2Zyb21fY3BzKGNwcy5zbGljZShwcmV2LCBpKSkpO1xyXG5cdFx0XHRidWYucHVzaChxdW90ZXIoY3ApKTtcclxuXHRcdFx0cHJldiA9IGkgKyAxO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRidWYucHVzaChzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKHByZXYsIG4pKSk7XHJcblx0cmV0dXJuIGJ1Zi5qb2luKCcnKTtcclxufVxyXG5cclxuLy8gbm90ZTogc2V0KHMpIGNhbm5vdCBiZSBleHBvc2VkIGJlY2F1c2UgdGhleSBjYW4gYmUgbW9kaWZpZWRcclxuLy8gbm90ZTogT2JqZWN0LmZyZWV6ZSgpIGRvZXNuJ3Qgd29ya1xyXG5mdW5jdGlvbiBpc19jb21iaW5pbmdfbWFyayhjcCkge1xyXG5cdGluaXQoKTtcclxuXHRyZXR1cm4gQ00uaGFzKGNwKTtcclxufVxyXG5mdW5jdGlvbiBzaG91bGRfZXNjYXBlKGNwKSB7XHJcblx0aW5pdCgpO1xyXG5cdHJldHVybiBFU0NBUEUuaGFzKGNwKTtcclxufVxyXG5cclxuLy8gcmV0dXJuIGFsbCBzdXBwb3J0ZWQgZW1vamkgYXMgZnVsbHktcXVhbGlmaWVkIGVtb2ppIFxyXG4vLyBvcmRlcmVkIGJ5IGxlbmd0aCB0aGVuIGxleGljb2dyYXBoaWMgXHJcbmZ1bmN0aW9uIGVuc19lbW9qaSgpIHtcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIEVNT0pJX0xJU1QubWFwKHggPT4geC5zbGljZSgpKTsgLy8gZW1vamkgYXJlIGV4cG9zZWQgc28gY29weVxyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfbm9ybWFsaXplX2ZyYWdtZW50KGZyYWcsIGRlY29tcG9zZSkge1xyXG5cdGluaXQoKTtcclxuXHRsZXQgbmYgPSBkZWNvbXBvc2UgPyBuZmQgOiBuZmM7XHJcblx0cmV0dXJuIGZyYWcuc3BsaXQoU1RPUF9DSCkubWFwKGxhYmVsID0+IHN0cl9mcm9tX2Nwcyh0b2tlbnNfZnJvbV9zdHIoZXhwbG9kZV9jcChsYWJlbCksIG5mLCBmaWx0ZXJfZmUwZikuZmxhdCgpKSkuam9pbihTVE9QX0NIKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX25vcm1hbGl6ZShuYW1lKSB7XHJcblx0cmV0dXJuIGZsYXR0ZW4oc3BsaXQobmFtZSwgbmZjLCBmaWx0ZXJfZmUwZikpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfYmVhdXRpZnkobmFtZSkge1xyXG5cdGxldCBsYWJlbHMgPSBzcGxpdChuYW1lLCBuZmMsIHggPT4geCk7IC8vIGVtb2ppIG5vdCBleHBvc2VkXHJcblx0Zm9yIChsZXQge3R5cGUsIG91dHB1dCwgZXJyb3J9IG9mIGxhYmVscykge1xyXG5cdFx0aWYgKGVycm9yKSBicmVhazsgLy8gZmxhdHRlbiB3aWxsIHRocm93XHJcblxyXG5cdFx0Ly8gcmVwbGFjZSBsZWFkaW5nL3RyYWlsaW5nIGh5cGhlblxyXG5cdFx0Ly8gMjAyMzAxMjE6IGNvbnNpZGVyIGJlYXV0aWZpbmcgYWxsIG9yIGxlYWRpbmcvdHJhaWxpbmcgaHlwaGVuIHRvIHVuaWNvZGUgdmFyaWFudFxyXG5cdFx0Ly8gbm90IGV4YWN0bHkgdGhlIHNhbWUgaW4gZXZlcnkgZm9udCwgYnV0IHZlcnkgc2ltaWxhcjogXCItXCIgdnMgXCLigJBcIlxyXG5cdFx0LypcclxuXHRcdGNvbnN0IFVOSUNPREVfSFlQSEVOID0gMHgyMDEwO1xyXG5cdFx0Ly8gbWF5YmUgdGhpcyBzaG91bGQgcmVwbGFjZSBhbGwgZm9yIHZpc3VhbCBjb25zaXN0YW5jeT9cclxuXHRcdC8vIGBub2RlIHRvb2xzL3JlZy1jb3VudC5qcyByZWdleCBeLVxcezIsXFx9YCA9PiA1OTJcclxuXHRcdC8vZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspIGlmIChvdXRwdXRbaV0gPT0gMHgyRCkgb3V0cHV0W2ldID0gMHgyMDEwO1xyXG5cdFx0aWYgKG91dHB1dFswXSA9PSBIWVBIRU4pIG91dHB1dFswXSA9IFVOSUNPREVfSFlQSEVOO1xyXG5cdFx0bGV0IGVuZCA9IG91dHB1dC5sZW5ndGgtMTtcclxuXHRcdGlmIChvdXRwdXRbZW5kXSA9PSBIWVBIRU4pIG91dHB1dFtlbmRdID0gVU5JQ09ERV9IWVBIRU47XHJcblx0XHQqL1xyXG5cdFx0Ly8gMjAyMzAxMjM6IFdIQVRXRyBVUkwgdXNlcyBcIkNoZWNrSHlwaGVuc1wiIGZhbHNlXHJcblx0XHQvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2lkbmFcclxuXHJcblx0XHQvLyB1cGRhdGUgZXRoZXJldW0gc3ltYm9sXHJcblx0XHQvLyDOviA9PiDOniBpZiBub3QgZ3JlZWtcclxuXHRcdGlmICh0eXBlICE9PSAnR3JlZWsnKSB7IFxyXG5cdFx0XHRsZXQgcHJldiA9IDA7XHJcblx0XHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdFx0bGV0IG5leHQgPSBvdXRwdXQuaW5kZXhPZigweDNCRSwgcHJldik7XHJcblx0XHRcdFx0aWYgKG5leHQgPCAwKSBicmVhaztcclxuXHRcdFx0XHRvdXRwdXRbbmV4dF0gPSAweDM5RTsgXHJcblx0XHRcdFx0cHJldiA9IG5leHQgKyAxO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gMjAyMjEyMTM6IGZpeGVzIGJpZGkgc3ViZG9tYWluIGlzc3VlLCBidXQgYnJlYWtzIGludmFyaWFudCAoMjAwRSBpcyBkaXNhbGxvd2VkKVxyXG5cdFx0Ly8gY291bGQgYmUgZml4ZWQgd2l0aCBzcGVjaWFsIGNhc2UgZm9yOiAyRCAoLikgKyAyMDBFIChMVFIpXHJcblx0XHQvLyBodHRwczovL2Rpc2N1c3MuZW5zLmRvbWFpbnMvdC9iaWRpLWxhYmVsLW9yZGVyaW5nLXNwb29mLzE1ODI0XHJcblx0XHQvL291dHB1dC5zcGxpY2UoMCwgMCwgMHgyMDBFKTtcclxuXHR9XHJcblx0cmV0dXJuIGZsYXR0ZW4obGFiZWxzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX3NwbGl0KG5hbWUsIHByZXNlcnZlX2Vtb2ppKSB7XHJcblx0cmV0dXJuIHNwbGl0KG5hbWUsIG5mYywgcHJlc2VydmVfZW1vamkgPyB4ID0+IHguc2xpY2UoKSA6IGZpbHRlcl9mZTBmKTsgLy8gZW1vamkgYXJlIGV4cG9zZWQgc28gY29weVxyXG59XHJcblxyXG5mdW5jdGlvbiBzcGxpdChuYW1lLCBuZiwgZWYpIHtcclxuXHRpZiAoIW5hbWUpIHJldHVybiBbXTsgLy8gMjAyMzA3MTk6IGVtcHR5IG5hbWUgYWxsb3dhbmNlXHJcblx0aW5pdCgpO1xyXG5cdGxldCBvZmZzZXQgPSAwO1xyXG5cdC8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjQ2LyNWYWxpZGl0eV9Dcml0ZXJpYVxyXG5cdC8vIDQuKSBcIlRoZSBsYWJlbCBtdXN0IG5vdCBjb250YWluIGEgVSswMDJFICggLiApIEZVTEwgU1RPUC5cIlxyXG5cdHJldHVybiBuYW1lLnNwbGl0KFNUT1BfQ0gpLm1hcChsYWJlbCA9PiB7XHJcblx0XHRsZXQgaW5wdXQgPSBleHBsb2RlX2NwKGxhYmVsKTtcclxuXHRcdGxldCBpbmZvID0ge1xyXG5cdFx0XHRpbnB1dCxcclxuXHRcdFx0b2Zmc2V0LCAvLyBjb2RlcG9pbnQsIG5vdCBzdWJzdHJpbmchXHJcblx0XHR9O1xyXG5cdFx0b2Zmc2V0ICs9IGlucHV0Lmxlbmd0aCArIDE7IC8vICsgc3RvcFxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gMS4pIFwiVGhlIGxhYmVsIG11c3QgYmUgaW4gVW5pY29kZSBOb3JtYWxpemF0aW9uIEZvcm0gTkZDXCJcclxuXHRcdFx0bGV0IHRva2VucyA9IGluZm8udG9rZW5zID0gdG9rZW5zX2Zyb21fc3RyKGlucHV0LCBuZiwgZWYpO1xyXG5cdFx0XHRsZXQgdG9rZW5fY291bnQgPSB0b2tlbnMubGVuZ3RoO1xyXG5cdFx0XHRsZXQgdHlwZTtcclxuXHRcdFx0aWYgKCF0b2tlbl9jb3VudCkgeyAvLyB0aGUgbGFiZWwgd2FzIGVmZmVjdGl2ZWx5IGVtcHR5IChjb3VsZCBvZiBoYWQgaWdub3JlZCBjaGFyYWN0ZXJzKVxyXG5cdFx0XHRcdC8vbm9ybSA9IFtdO1xyXG5cdFx0XHRcdC8vdHlwZSA9ICdOb25lJzsgLy8gdXNlIHRoaXMgaW5zdGVhZCBvZiBuZXh0IG1hdGNoLCBcIkFTQ0lJXCJcclxuXHRcdFx0XHQvLyAyMDIzMDEyMDogY2hhbmdlIHRvIHN0cmljdFxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vZGlzY3Vzcy5lbnMuZG9tYWlucy90L2Vucy1uYW1lLW5vcm1hbGl6YXRpb24tMm5kLzE0NTY0LzU5XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBlbXB0eSBsYWJlbGApO1xyXG5cdFx0XHR9IFxyXG5cdFx0XHRsZXQgbm9ybSA9IGluZm8ub3V0cHV0ID0gdG9rZW5zLmZsYXQoKTtcclxuXHRcdFx0Y2hlY2tfbGVhZGluZ191bmRlcnNjb3JlKG5vcm0pO1xyXG5cdFx0XHRsZXQgZW1vamkgPSBpbmZvLmVtb2ppID0gdG9rZW5fY291bnQgPiAxIHx8IHRva2Vuc1swXS5pc19lbW9qaTsgLy8gc2FtZSBhczogdG9rZW5zLnNvbWUoeCA9PiB4LmlzX2Vtb2ppKTtcclxuXHRcdFx0aWYgKCFlbW9qaSAmJiBub3JtLmV2ZXJ5KGNwID0+IGNwIDwgMHg4MCkpIHsgLy8gc3BlY2lhbCBjYXNlIGZvciBhc2NpaVxyXG5cdFx0XHRcdC8vIDIwMjMwMTIzOiBtYXRjaGVzIG1hdGNoZXMgV0hBVFdHLCBzZWUgbm90ZSAzLjNcclxuXHRcdFx0XHRjaGVja19sYWJlbF9leHRlbnNpb24obm9ybSk7IC8vIG9ubHkgbmVlZGVkIGZvciBhc2NpaVxyXG5cdFx0XHRcdC8vIGNhbnQgaGF2ZSBmZW5jZWRcclxuXHRcdFx0XHQvLyBjYW50IGhhdmUgY21cclxuXHRcdFx0XHQvLyBjYW50IGhhdmUgd2hvbGVzXHJcblx0XHRcdFx0Ly8gc2VlIGRlcml2ZTogXCJGYXN0cGF0aCBBU0NJSVwiXHJcblx0XHRcdFx0dHlwZSA9ICdBU0NJSSc7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IGNoYXJzID0gdG9rZW5zLmZsYXRNYXAoeCA9PiB4LmlzX2Vtb2ppID8gW10gOiB4KTsgLy8gYWxsIG9mIHRoZSBuZmMgdG9rZW5zIGNvbmNhdCB0b2dldGhlclxyXG5cdFx0XHRcdGlmICghY2hhcnMubGVuZ3RoKSB7IC8vIHRoZXJlcyBubyB0ZXh0LCBqdXN0IGVtb2ppXHJcblx0XHRcdFx0XHR0eXBlID0gJ0Vtb2ppJztcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gNS4pIFwiVGhlIGxhYmVsIG11c3Qgbm90IGJlZ2luIHdpdGggYSBjb21iaW5pbmcgbWFyaywgdGhhdCBpczogR2VuZXJhbF9DYXRlZ29yeT1NYXJrLlwiXHJcblx0XHRcdFx0XHRpZiAoQ00uaGFzKG5vcm1bMF0pKSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoJ2xlYWRpbmcgY29tYmluaW5nIG1hcmsnKTtcclxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgdG9rZW5fY291bnQ7IGkrKykgeyAvLyB3ZSd2ZSBhbHJlYWR5IGNoZWNrZWQgdGhlIGZpcnN0IHRva2VuXHJcblx0XHRcdFx0XHRcdGxldCBjcHMgPSB0b2tlbnNbaV07XHJcblx0XHRcdFx0XHRcdGlmICghY3BzLmlzX2Vtb2ppICYmIENNLmhhcyhjcHNbMF0pKSB7IC8vIGV2ZXJ5IHRleHQgdG9rZW4gaGFzIGVtb2ppIG5laWdoYm9ycywgZWcuIEV0RUVFdEV0Li4uXHJcblx0XHRcdFx0XHRcdFx0Ly8gYmlkaV9xcSgpIG5vdCBuZWVkZWQgc2luY2UgZW1vamkgaXMgTFRSIGFuZCBjcHMgaXMgYSBDTVxyXG5cdFx0XHRcdFx0XHRcdHRocm93IGVycm9yX3BsYWNlbWVudChgZW1vamkgKyBjb21iaW5pbmcgbWFyazogXCIke3N0cl9mcm9tX2Nwcyh0b2tlbnNbaS0xXSl9ICsgJHtzYWZlX3N0cl9mcm9tX2NwcyhbY3BzWzBdXSl9XCJgKTsgXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGNoZWNrX2ZlbmNlZChub3JtKTtcclxuXHRcdFx0XHRcdGxldCB1bmlxdWUgPSBBcnJheV9mcm9tKG5ldyBTZXQoY2hhcnMpKTtcclxuXHRcdFx0XHRcdGxldCBbZ10gPSBkZXRlcm1pbmVfZ3JvdXAodW5pcXVlKTsgLy8gdGFrZSB0aGUgZmlyc3QgbWF0Y2hcclxuXHRcdFx0XHRcdC8vIHNlZSBkZXJpdmU6IFwiTWF0Y2hpbmcgR3JvdXBzIGhhdmUgU2FtZSBDTSBTdHlsZVwiXHJcblx0XHRcdFx0XHQvLyBhbHRlcm5hdGl2ZTogY291bGQgZm9ybSBhIGh5YnJpZCB0eXBlOiBMYXRpbi9KYXBhbmVzZS8uLi5cdFxyXG5cdFx0XHRcdFx0Y2hlY2tfZ3JvdXAoZywgY2hhcnMpOyAvLyBuZWVkIHRleHQgaW4gb3JkZXJcclxuXHRcdFx0XHRcdGNoZWNrX3dob2xlKGcsIHVuaXF1ZSk7IC8vIG9ubHkgbmVlZCB1bmlxdWUgdGV4dCAob3JkZXIgd291bGQgYmUgcmVxdWlyZWQgZm9yIG11bHRpcGxlLWNoYXIgY29uZnVzYWJsZXMpXHJcblx0XHRcdFx0XHR0eXBlID0gZy5OO1xyXG5cdFx0XHRcdFx0Ly8gMjAyMzAxMjE6IGNvbnNpZGVyIGV4cG9zaW5nIHJlc3RyaWN0ZWQgZmxhZ1xyXG5cdFx0XHRcdFx0Ly8gaXQncyBzaW1wbGVyIHRvIGp1c3QgY2hlY2sgZm9yICdSZXN0cmljdGVkJ1xyXG5cdFx0XHRcdFx0Ly8gb3IgZXZlbiBiZXR0ZXI6IHR5cGUuZW5kc1dpdGgoJ10nKVxyXG5cdFx0XHRcdFx0Ly9pZiAoZy5SKSBpbmZvLnJlc3RyaWN0ZWQgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpbmZvLnR5cGUgPSB0eXBlO1xyXG5cdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdGluZm8uZXJyb3IgPSBlcnI7IC8vIHVzZSBmdWxsIGVycm9yIG9iamVjdFxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGluZm87XHJcblx0fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrX3dob2xlKGdyb3VwLCB1bmlxdWUpIHtcclxuXHRsZXQgbWFrZXI7XHJcblx0bGV0IHNoYXJlZCA9IFtdO1xyXG5cdGZvciAobGV0IGNwIG9mIHVuaXF1ZSkge1xyXG5cdFx0bGV0IHdob2xlID0gV0hPTEVfTUFQLmdldChjcCk7XHJcblx0XHRpZiAod2hvbGUgPT09IFVOSVFVRV9QSCkgcmV0dXJuOyAvLyB1bmlxdWUsIG5vbi1jb25mdXNhYmxlXHJcblx0XHRpZiAod2hvbGUpIHtcclxuXHRcdFx0bGV0IHNldCA9IHdob2xlLk0uZ2V0KGNwKTsgLy8gZ3JvdXBzIHdoaWNoIGhhdmUgYSBjaGFyYWN0ZXIgdGhhdCBsb29rLWxpa2UgdGhpcyBjaGFyYWN0ZXJcclxuXHRcdFx0bWFrZXIgPSBtYWtlciA/IG1ha2VyLmZpbHRlcihnID0+IHNldC5oYXMoZykpIDogQXJyYXlfZnJvbShzZXQpO1xyXG5cdFx0XHRpZiAoIW1ha2VyLmxlbmd0aCkgcmV0dXJuOyAvLyBjb25mdXNhYmxlIGludGVyc2VjdGlvbiBpcyBlbXB0eVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c2hhcmVkLnB1c2goY3ApOyBcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKG1ha2VyKSB7XHJcblx0XHQvLyB3ZSBoYXZlIDErIGNvbmZ1c2FibGVcclxuXHRcdC8vIGNoZWNrIGlmIGFueSBvZiB0aGUgcmVtYWluaW5nIGdyb3Vwc1xyXG5cdFx0Ly8gY29udGFpbiB0aGUgc2hhcmVkIGNoYXJhY3RlcnMgdG9vXHJcblx0XHRmb3IgKGxldCBnIG9mIG1ha2VyKSB7XHJcblx0XHRcdGlmIChzaGFyZWQuZXZlcnkoY3AgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSkpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHdob2xlLXNjcmlwdCBjb25mdXNhYmxlOiAke2dyb3VwLk59LyR7Zy5OfWApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBhc3N1bXB0aW9uOiB1bmlxdWUuc2l6ZSA+IDBcclxuLy8gcmV0dXJucyBsaXN0IG9mIG1hdGNoaW5nIGdyb3Vwc1xyXG5mdW5jdGlvbiBkZXRlcm1pbmVfZ3JvdXAodW5pcXVlKSB7XHJcblx0bGV0IGdyb3VwcyA9IEdST1VQUztcclxuXHRmb3IgKGxldCBjcCBvZiB1bmlxdWUpIHtcclxuXHRcdC8vIG5vdGU6IHdlIG5lZWQgdG8gZG9kZ2UgQ00gdGhhdCBhcmUgd2hpdGVsaXN0ZWRcclxuXHRcdC8vIGJ1dCB0aGF0IGNvZGUgaXNuJ3QgY3VycmVudGx5IG5lY2Vzc2FyeVxyXG5cdFx0bGV0IGdzID0gZ3JvdXBzLmZpbHRlcihnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpO1xyXG5cdFx0aWYgKCFncy5sZW5ndGgpIHtcclxuXHRcdFx0aWYgKCFHUk9VUFMuc29tZShnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpKSB7IFxyXG5cdFx0XHRcdC8vIHRoZSBjaGFyYWN0ZXIgd2FzIGNvbXBvc2VkIG9mIHZhbGlkIHBhcnRzXHJcblx0XHRcdFx0Ly8gYnV0IGl0J3MgTkZDIGZvcm0gaXMgaW52YWxpZFxyXG5cdFx0XHRcdC8vIDIwMjMwNzE2OiBjaGFuZ2UgdG8gbW9yZSBleGFjdCBzdGF0ZW1lbnQsIHNlZTogRU5TTm9ybWFsaXplLntjcyxqYXZhfVxyXG5cdFx0XHRcdC8vIG5vdGU6IHRoaXMgZG9lc24ndCBoYXZlIHRvIGJlIGEgY29tcG9zaXRpb25cclxuXHRcdFx0XHQvLyAyMDIzMDcyMDogY2hhbmdlIHRvIGZ1bGwgY2hlY2tcclxuXHRcdFx0XHR0aHJvdyBlcnJvcl9kaXNhbGxvd2VkKGNwKTsgLy8gdGhpcyBzaG91bGQgYmUgcmFyZVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIHRoZXJlIGlzIG5vIGdyb3VwIHRoYXQgY29udGFpbnMgYWxsIHRoZXNlIGNoYXJhY3RlcnNcclxuXHRcdFx0XHQvLyB0aHJvdyB1c2luZyB0aGUgaGlnaGVzdCBwcmlvcml0eSBncm91cCB0aGF0IG1hdGNoZWRcclxuXHRcdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI21peGVkX3NjcmlwdF9jb25mdXNhYmxlc1xyXG5cdFx0XHRcdHRocm93IGVycm9yX2dyb3VwX21lbWJlcihncm91cHNbMF0sIGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Z3JvdXBzID0gZ3M7XHJcblx0XHRpZiAoZ3MubGVuZ3RoID09IDEpIGJyZWFrOyAvLyB0aGVyZSBpcyBvbmx5IG9uZSBncm91cCBsZWZ0XHJcblx0fVxyXG5cdC8vIHRoZXJlIGFyZSBhdCBsZWFzdCAxIGdyb3VwKHMpIHdpdGggYWxsIG9mIHRoZXNlIGNoYXJhY3RlcnNcclxuXHRyZXR1cm4gZ3JvdXBzO1xyXG59XHJcblxyXG4vLyB0aHJvdyBvbiBmaXJzdCBlcnJvclxyXG5mdW5jdGlvbiBmbGF0dGVuKHNwbGl0KSB7XHJcblx0cmV0dXJuIHNwbGl0Lm1hcCgoe2lucHV0LCBlcnJvciwgb3V0cHV0fSkgPT4ge1xyXG5cdFx0aWYgKGVycm9yKSB7XHJcblx0XHRcdC8vIGRvbid0IHByaW50IGxhYmVsIGFnYWluIGlmIGp1c3QgYSBzaW5nbGUgbGFiZWxcclxuXHRcdFx0bGV0IG1zZyA9IGVycm9yLm1lc3NhZ2U7XHJcblx0XHRcdC8vIGJpZGlfcXEoKSBvbmx5IG5lY2Vzc2FyeSBpZiBtc2cgaXMgZGlnaXRzXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihzcGxpdC5sZW5ndGggPT0gMSA/IG1zZyA6IGBJbnZhbGlkIGxhYmVsICR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhpbnB1dCkpfTogJHttc2d9YCk7IFxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0cl9mcm9tX2NwcyhvdXRwdXQpO1xyXG5cdH0pLmpvaW4oU1RPUF9DSCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVycm9yX2Rpc2FsbG93ZWQoY3ApIHtcclxuXHQvLyBUT0RPOiBhZGQgY3AgdG8gZXJyb3I/XHJcblx0cmV0dXJuIG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjaGFyYWN0ZXI6ICR7cXVvdGVkX2NwKGNwKX1gKTsgXHJcbn1cclxuZnVuY3Rpb24gZXJyb3JfZ3JvdXBfbWVtYmVyKGcsIGNwKSB7XHJcblx0bGV0IHF1b3RlZCA9IHF1b3RlZF9jcChjcCk7XHJcblx0bGV0IGdnID0gR1JPVVBTLmZpbmQoZyA9PiBnLlAuaGFzKGNwKSk7IC8vIG9ubHkgY2hlY2sgcHJpbWFyeVxyXG5cdGlmIChnZykge1xyXG5cdFx0cXVvdGVkID0gYCR7Z2cuTn0gJHtxdW90ZWR9YDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBFcnJvcihgaWxsZWdhbCBtaXh0dXJlOiAke2cuTn0gKyAke3F1b3RlZH1gKTtcclxufVxyXG5mdW5jdGlvbiBlcnJvcl9wbGFjZW1lbnQod2hlcmUpIHtcclxuXHRyZXR1cm4gbmV3IEVycm9yKGBpbGxlZ2FsIHBsYWNlbWVudDogJHt3aGVyZX1gKTtcclxufVxyXG5cclxuLy8gYXNzdW1wdGlvbjogY3BzLmxlbmd0aCA+IDBcclxuLy8gYXNzdW1wdGlvbjogY3BzWzBdIGlzbid0IGEgQ01cclxuLy8gYXNzdW1wdGlvbjogdGhlIHByZXZpb3VzIGNoYXJhY3RlciBpc24ndCBhbiBlbW9qaVxyXG5mdW5jdGlvbiBjaGVja19ncm91cChnLCBjcHMpIHtcclxuXHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdGlmICghZ3JvdXBfaGFzX2NwKGcsIGNwKSkge1xyXG5cdFx0XHQvLyBmb3Igd2hpdGVsaXN0ZWQgc2NyaXB0cywgdGhpcyB3aWxsIHRocm93IGlsbGVnYWwgbWl4dHVyZSBvbiBpbnZhbGlkIGNtLCBlZy4gXCJlezMwMH17MzAwfVwiXHJcblx0XHRcdC8vIGF0IHRoZSBtb21lbnQsIGl0J3MgdW5uZWNlc3NhcnkgdG8gaW50cm9kdWNlIGFuIGV4dHJhIGVycm9yIHR5cGVcclxuXHRcdFx0Ly8gdW50aWwgdGhlcmUgZXhpc3RzIGEgd2hpdGVsaXN0ZWQgbXVsdGktY2hhcmFjdGVyXHJcblx0XHRcdC8vICAgZWcuIGlmIChNIDwgMCAmJiBpc19jb21iaW5pbmdfbWFyayhjcCkpIHsgLi4uIH1cclxuXHRcdFx0Ly8gdGhlcmUgYXJlIDMgY2FzZXM6XHJcblx0XHRcdC8vICAgMS4gaWxsZWdhbCBjbSBmb3Igd3JvbmcgZ3JvdXAgPT4gbWl4dHVyZSBlcnJvclxyXG5cdFx0XHQvLyAgIDIuIGlsbGVnYWwgY20gZm9yIHNhbWUgZ3JvdXAgPT4gY20gZXJyb3JcclxuXHRcdFx0Ly8gICAgICAgcmVxdWlyZXMgc2V0IG9mIHdoaXRlbGlzdCBjbSBwZXIgZ3JvdXA6IFxyXG5cdFx0XHQvLyAgICAgICAgZWcuIG5ldyBTZXQoWy4uLmcuUCwgLi4uZy5RXS5mbGF0TWFwKG5mYykuZmlsdGVyKGNwID0+IENNLmhhcyhjcCkpKVxyXG5cdFx0XHQvLyAgIDMuIHdyb25nIGdyb3VwID0+IG1peHR1cmUgZXJyb3JcclxuXHRcdFx0dGhyb3cgZXJyb3JfZ3JvdXBfbWVtYmVyKGcsIGNwKTtcclxuXHRcdH1cclxuXHR9XHJcblx0Ly9pZiAoTSA+PSAwKSB7IC8vIHdlIGhhdmUgYSBrbm93biBmaXhlZCBjbSBjb3VudFxyXG5cdGlmIChnLk0pIHsgLy8gd2UgbmVlZCB0byBjaGVjayBmb3IgTlNNXHJcblx0XHRsZXQgZGVjb21wb3NlZCA9IG5mZChjcHMpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDEsIGUgPSBkZWNvbXBvc2VkLmxlbmd0aDsgaSA8IGU7IGkrKykgeyAvLyBzZWU6IGFzc3VtcHRpb25cclxuXHRcdFx0Ly8gMjAyMzAyMTA6IGJ1Z2ZpeDogdXNpbmcgY3BzIGluc3RlYWQgb2YgZGVjb21wb3NlZCBoL3QgQ2FyYm9uMjI1XHJcblx0XHRcdC8qXHJcblx0XHRcdGlmIChDTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdHdoaWxlIChqIDwgZSAmJiBDTS5oYXMoZGVjb21wb3NlZFtqXSkpIGorKztcclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBNKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHRvbyBtYW55IGNvbWJpbmluZyBtYXJrczogJHtnLk59ICR7YmlkaV9xcShzdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKSl9ICgke2otaX0vJHtNfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdFx0Ki9cclxuXHRcdFx0Ly8gMjAyMzAyMTc6IHN3aXRjaCB0byBOU00gY291bnRpbmdcclxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNPcHRpb25hbF9EZXRlY3Rpb25cclxuXHRcdFx0aWYgKE5TTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdGZvciAobGV0IGNwOyBqIDwgZSAmJiBOU00uaGFzKGNwID0gZGVjb21wb3NlZFtqXSk7IGorKykge1xyXG5cdFx0XHRcdFx0Ly8gYS4gRm9yYmlkIHNlcXVlbmNlcyBvZiB0aGUgc2FtZSBub25zcGFjaW5nIG1hcmsuXHJcblx0XHRcdFx0XHRmb3IgKGxldCBrID0gaTsgayA8IGo7IGsrKykgeyAvLyBPKG5eMikgYnV0IG4gPCAxMDBcclxuXHRcdFx0XHRcdFx0aWYgKGRlY29tcG9zZWRba10gPT0gY3ApIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZSBub24tc3BhY2luZyBtYXJrczogJHtxdW90ZWRfY3AoY3ApfWApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIHBhcnNlIHRvIGVuZCBzbyB3ZSBoYXZlIGZ1bGwgbnNtIGNvdW50XHJcblx0XHRcdFx0Ly8gYi4gRm9yYmlkIHNlcXVlbmNlcyBvZiBtb3JlIHRoYW4gNCBub25zcGFjaW5nIG1hcmtzIChnYz1NbiBvciBnYz1NZSkuXHJcblx0XHRcdFx0aWYgKGogLSBpID4gTlNNX01BWCkge1xyXG5cdFx0XHRcdFx0Ly8gbm90ZTogdGhpcyBzbGljZSBzdGFydHMgd2l0aCBhIGJhc2UgY2hhciBvciBzcGFjaW5nLW1hcmsgY21cclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZXhjZXNzaXZlIG5vbi1zcGFjaW5nIG1hcmtzOiAke2JpZGlfcXEoc2FmZV9zdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKSl9ICgke2otaX0vJHtOU01fTUFYfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0Ly8gKioqIHRoaXMgY29kZSBjdXJyZW50bHkgaXNuJ3QgbmVlZGVkICoqKlxyXG5cdC8qXHJcblx0bGV0IGNtX3doaXRlbGlzdCA9IE0gaW5zdGFuY2VvZiBNYXA7XHJcblx0Zm9yIChsZXQgaSA9IDAsIGUgPSBjcHMubGVuZ3RoOyBpIDwgZTsgKSB7XHJcblx0XHRsZXQgY3AgPSBjcHNbaSsrXTtcclxuXHRcdGxldCBzZXFzID0gY21fd2hpdGVsaXN0ICYmIE0uZ2V0KGNwKTtcclxuXHRcdGlmIChzZXFzKSB7IFxyXG5cdFx0XHQvLyBsaXN0IG9mIGNvZGVwb2ludHMgdGhhdCBjYW4gZm9sbG93XHJcblx0XHRcdC8vIGlmIHRoaXMgZXhpc3RzLCB0aGlzIHdpbGwgYWx3YXlzIGJlIDErXHJcblx0XHRcdGxldCBqID0gaTtcclxuXHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhjcHNbal0pKSBqKys7XHJcblx0XHRcdGxldCBjbXMgPSBjcHMuc2xpY2UoaSwgaik7XHJcblx0XHRcdGxldCBtYXRjaCA9IHNlcXMuZmluZChzZXEgPT4gIWNvbXBhcmVfYXJyYXlzKHNlcSwgY21zKSk7XHJcblx0XHRcdGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjb21iaW5pbmcgbWFyayBzZXF1ZW5jZTogXCIke3NhZmVfc3RyX2Zyb21fY3BzKFtjcCwgLi4uY21zXSl9XCJgKTtcclxuXHRcdFx0aSA9IGo7XHJcblx0XHR9IGVsc2UgaWYgKCFWLmhhcyhjcCkpIHtcclxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNtaXhlZF9zY3JpcHRfY29uZnVzYWJsZXNcclxuXHRcdFx0bGV0IHF1b3RlZCA9IHF1b3RlZF9jcChjcCk7XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0XHRcdGxldCB1ID0gVU5JUVVFLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKHUgJiYgdSAhPT0gZykge1xyXG5cdFx0XHRcdFx0Ly8gaWYgYm90aCBzY3JpcHRzIGFyZSByZXN0cmljdGVkIHRoaXMgZXJyb3IgaXMgY29uZnVzaW5nXHJcblx0XHRcdFx0XHQvLyBiZWNhdXNlIHdlIGRvbid0IGRpZmZlcmVudGlhdGUgUmVzdHJpY3RlZEEgZnJvbSBSZXN0cmljdGVkQiBcclxuXHRcdFx0XHRcdGlmICghdS5SKSBxdW90ZWQgPSBgJHtxdW90ZWR9IGlzICR7dS5OfWA7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkICR7Zy5OfSBjaGFyYWN0ZXI6ICR7cXVvdGVkfWApO1xyXG5cdFx0XHQvL3Rocm93IG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjaGFyYWN0ZXI6ICR7cXVvdGVkfSAoZXhwZWN0ZWQgJHtnLk59KWApO1xyXG5cdFx0XHQvL3Rocm93IG5ldyBFcnJvcihgJHtnLk59IGRvZXMgbm90IGFsbG93OiAke3F1b3RlZH1gKTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKCFjbV93aGl0ZWxpc3QpIHtcclxuXHRcdGxldCBkZWNvbXBvc2VkID0gbmZkKGNwcyk7XHJcblx0XHRmb3IgKGxldCBpID0gMSwgZSA9IGRlY29tcG9zZWQubGVuZ3RoOyBpIDwgZTsgaSsrKSB7IC8vIHdlIGtub3cgaXQgY2FuJ3QgYmUgY20gbGVhZGluZ1xyXG5cdFx0XHRpZiAoQ00uaGFzKGRlY29tcG9zZWRbaV0pKSB7XHJcblx0XHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGRlY29tcG9zZWRbal0pKSBqKys7XHJcblx0XHRcdFx0aWYgKGogLSBpID4gTSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB0b28gbWFueSBjb21iaW5pbmcgbWFya3M6IFwiJHtzdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKX1cIiAoJHtqLWl9LyR7TX0pYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGkgPSBqO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdCovXHJcbn1cclxuXHJcbi8vIGdpdmVuIGEgbGlzdCBvZiBjb2RlcG9pbnRzXHJcbi8vIHJldHVybnMgYSBsaXN0IG9mIGxpc3RzLCB3aGVyZSBlbW9qaSBhcmUgYSBmdWxseS1xdWFsaWZpZWQgKGFzIEFycmF5IHN1YmNsYXNzKVxyXG4vLyBlZy4gZXhwbG9kZV9jcChcImFiY/CfkqlkXCIpID0+IFtbNjEsIDYyLCA2M10sIEVtb2ppWzFGNEE5LCBGRTBGXSwgWzY0XV1cclxuLy8gMjAyMzA4MTg6IHJlbmFtZSBmb3IgJ3Byb2Nlc3MnIG5hbWUgY29sbGlzaW9uIGgvdCBKYXZhcm9tZVxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2lzc3Vlcy8yM1xyXG5mdW5jdGlvbiB0b2tlbnNfZnJvbV9zdHIoaW5wdXQsIG5mLCBlZikge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgY2hhcnMgPSBbXTtcclxuXHRpbnB1dCA9IGlucHV0LnNsaWNlKCkucmV2ZXJzZSgpOyAvLyBmbGlwIHNvIHdlIGNhbiBwb3BcclxuXHR3aGlsZSAoaW5wdXQubGVuZ3RoKSB7XHJcblx0XHRsZXQgZW1vamkgPSBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGlucHV0KTtcclxuXHRcdGlmIChlbW9qaSkge1xyXG5cdFx0XHRpZiAoY2hhcnMubGVuZ3RoKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gobmYoY2hhcnMpKTtcclxuXHRcdFx0XHRjaGFycyA9IFtdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldC5wdXNoKGVmKGVtb2ppKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY3AgPSBpbnB1dC5wb3AoKTtcclxuXHRcdFx0aWYgKFZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0XHRjaGFycy5wdXNoKGNwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY3BzID0gTUFQUEVELmdldChjcCk7XHJcblx0XHRcdFx0aWYgKGNwcykge1xyXG5cdFx0XHRcdFx0Y2hhcnMucHVzaCguLi5jcHMpOyAvLyBsZXNzIHRoYW4gMTAgZWxlbWVudHNcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCFJR05PUkVELmhhcyhjcCkpIHtcclxuXHRcdFx0XHRcdC8vIDIwMjMwOTEyOiB1bmljb2RlIDE1LjEgY2hhbmdlZCB0aGUgb3JkZXIgb2YgcHJvY2Vzc2luZyBzdWNoIHRoYXRcclxuXHRcdFx0XHRcdC8vIGRpc2FsbG93ZWQgcGFydHMgYXJlIG9ubHkgcmVqZWN0ZWQgYWZ0ZXIgTkZDXHJcblx0XHRcdFx0XHQvLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI0Ni8jVmFsaWRpdHlfQ3JpdGVyaWFcclxuXHRcdFx0XHRcdC8vIHRoaXMgZG9lc24ndCBpbXBhY3Qgbm9ybWFsaXphdGlvbiBhcyBvZiB0b2RheVxyXG5cdFx0XHRcdFx0Ly8gdGVjaG5pY2FsbHksIHRoaXMgZXJyb3IgY2FuIGJlIHJlbW92ZWQgYXMgdGhlIGdyb3VwIGxvZ2ljIHdpbGwgYXBwbHkgc2ltaWxhciBsb2dpY1xyXG5cdFx0XHRcdFx0Ly8gaG93ZXZlciB0aGUgZXJyb3IgdHlwZSBtaWdodCBiZSBsZXNzIGNsZWFyXHJcblx0XHRcdFx0XHR0aHJvdyBlcnJvcl9kaXNhbGxvd2VkKGNwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGNoYXJzLmxlbmd0aCkge1xyXG5cdFx0cmV0LnB1c2gobmYoY2hhcnMpKTtcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gZmlsdGVyX2ZlMGYoY3BzKSB7XHJcblx0cmV0dXJuIGNwcy5maWx0ZXIoY3AgPT4gY3AgIT0gRkUwRik7XHJcbn1cclxuXHJcbi8vIGdpdmVuIGFycmF5IG9mIGNvZGVwb2ludHNcclxuLy8gcmV0dXJucyB0aGUgbG9uZ2VzdCB2YWxpZCBlbW9qaSBzZXF1ZW5jZSAob3IgdW5kZWZpbmVkIGlmIG5vIG1hdGNoKVxyXG4vLyAqTVVUQVRFUyogdGhlIHN1cHBsaWVkIGFycmF5XHJcbi8vIGRpc2FsbG93cyBpbnRlcmxlYXZlZCBpZ25vcmVkIGNoYXJhY3RlcnNcclxuLy8gZmlsbHMgKG9wdGlvbmFsKSBlYXRlbiBhcnJheSB3aXRoIG1hdGNoZWQgY29kZXBvaW50c1xyXG5mdW5jdGlvbiBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGNwcywgZWF0ZW4pIHtcclxuXHRsZXQgbm9kZSA9IEVNT0pJX1JPT1Q7XHJcblx0bGV0IGVtb2ppO1xyXG5cdGxldCBwb3MgPSBjcHMubGVuZ3RoO1xyXG5cdHdoaWxlIChwb3MpIHtcclxuXHRcdG5vZGUgPSBub2RlLmdldChjcHNbLS1wb3NdKTtcclxuXHRcdGlmICghbm9kZSkgYnJlYWs7XHJcblx0XHRsZXQge1Z9ID0gbm9kZTtcclxuXHRcdGlmIChWKSB7IC8vIHRoaXMgaXMgYSB2YWxpZCBlbW9qaSAoc28gZmFyKVxyXG5cdFx0XHRlbW9qaSA9IFY7XHJcblx0XHRcdGlmIChlYXRlbikgZWF0ZW4ucHVzaCguLi5jcHMuc2xpY2UocG9zKS5yZXZlcnNlKCkpOyAvLyAob3B0aW9uYWwpIGNvcHkgaW5wdXQsIHVzZWQgZm9yIGVuc190b2tlbml6ZSgpXHJcblx0XHRcdGNwcy5sZW5ndGggPSBwb3M7IC8vIHRydW5jYXRlXHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBlbW9qaTtcclxufVxyXG5cclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vIHRva2VuaXplciBcclxuXHJcbmNvbnN0IFRZX1ZBTElEID0gJ3ZhbGlkJztcclxuY29uc3QgVFlfTUFQUEVEID0gJ21hcHBlZCc7XHJcbmNvbnN0IFRZX0lHTk9SRUQgPSAnaWdub3JlZCc7XHJcbmNvbnN0IFRZX0RJU0FMTE9XRUQgPSAnZGlzYWxsb3dlZCc7XHJcbmNvbnN0IFRZX0VNT0pJID0gJ2Vtb2ppJztcclxuY29uc3QgVFlfTkZDID0gJ25mYyc7XHJcbmNvbnN0IFRZX1NUT1AgPSAnc3RvcCc7XHJcblxyXG5mdW5jdGlvbiBlbnNfdG9rZW5pemUobmFtZSwge1xyXG5cdG5mID0gdHJ1ZSwgLy8gY29sbGFwc2UgdW5ub3JtYWxpemVkIHJ1bnMgaW50byBhIHNpbmdsZSB0b2tlblxyXG59ID0ge30pIHtcclxuXHRpbml0KCk7XHJcblx0bGV0IGlucHV0ID0gZXhwbG9kZV9jcChuYW1lKS5yZXZlcnNlKCk7XHJcblx0bGV0IGVhdGVuID0gW107XHJcblx0bGV0IHRva2VucyA9IFtdO1xyXG5cdHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcclxuXHRcdGxldCBlbW9qaSA9IGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoaW5wdXQsIGVhdGVuKTtcclxuXHRcdGlmIChlbW9qaSkge1xyXG5cdFx0XHR0b2tlbnMucHVzaCh7XHJcblx0XHRcdFx0dHlwZTogVFlfRU1PSkksXHJcblx0XHRcdFx0ZW1vamk6IGVtb2ppLnNsaWNlKCksIC8vIGNvcHkgZW1vamlcclxuXHRcdFx0XHRpbnB1dDogZWF0ZW4sXHJcblx0XHRcdFx0Y3BzOiBmaWx0ZXJfZmUwZihlbW9qaSlcclxuXHRcdFx0fSk7XHJcblx0XHRcdGVhdGVuID0gW107IC8vIHJlc2V0IGJ1ZmZlclxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGNwID0gaW5wdXQucG9wKCk7XHJcblx0XHRcdGlmIChjcCA9PSBTVE9QKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX1NUT1AsIGNwfSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9WQUxJRCwgY3BzOiBbY3BdfSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoSUdOT1JFRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX0lHTk9SRUQsIGNwfSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IGNwcyA9IE1BUFBFRC5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmIChjcHMpIHtcclxuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9NQVBQRUQsIGNwLCBjcHM6IGNwcy5zbGljZSgpfSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9ESVNBTExPV0VELCBjcH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAobmYpIHtcclxuXHRcdGZvciAobGV0IGkgPSAwLCBzdGFydCA9IC0xOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCB0b2tlbiA9IHRva2Vuc1tpXTtcclxuXHRcdFx0aWYgKGlzX3ZhbGlkX29yX21hcHBlZCh0b2tlbi50eXBlKSkge1xyXG5cdFx0XHRcdGlmIChyZXF1aXJlc19jaGVjayh0b2tlbi5jcHMpKSB7IC8vIG5vcm1hbGl6YXRpb24gbWlnaHQgYmUgbmVlZGVkXHJcblx0XHRcdFx0XHRsZXQgZW5kID0gaSArIDE7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBwb3MgPSBlbmQ7IHBvcyA8IHRva2Vucy5sZW5ndGg7IHBvcysrKSB7IC8vIGZpbmQgYWRqYWNlbnQgdGV4dFxyXG5cdFx0XHRcdFx0XHRsZXQge3R5cGUsIGNwc30gPSB0b2tlbnNbcG9zXTtcclxuXHRcdFx0XHRcdFx0aWYgKGlzX3ZhbGlkX29yX21hcHBlZCh0eXBlKSkge1xyXG5cdFx0XHRcdFx0XHRcdGlmICghcmVxdWlyZXNfY2hlY2soY3BzKSkgYnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0ZW5kID0gcG9zICsgMTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlICE9PSBUWV9JR05PUkVEKSB7IC8vIHx8IHR5cGUgIT09IFRZX0RJU0FMTE9XRUQpIHsgXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChzdGFydCA8IDApIHN0YXJ0ID0gaTtcclxuXHRcdFx0XHRcdGxldCBzbGljZSA9IHRva2Vucy5zbGljZShzdGFydCwgZW5kKTtcclxuXHRcdFx0XHRcdGxldCBjcHMwID0gc2xpY2UuZmxhdE1hcCh4ID0+IGlzX3ZhbGlkX29yX21hcHBlZCh4LnR5cGUpID8geC5jcHMgOiBbXSk7IC8vIHN0cmlwIGp1bmsgdG9rZW5zXHJcblx0XHRcdFx0XHRsZXQgY3BzID0gbmZjKGNwczApO1xyXG5cdFx0XHRcdFx0aWYgKGNvbXBhcmVfYXJyYXlzKGNwcywgY3BzMCkpIHsgLy8gYnVuZGxlIGludG8gYW4gbmZjIHRva2VuXHJcblx0XHRcdFx0XHRcdHRva2Vucy5zcGxpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0LCB7XHJcblx0XHRcdFx0XHRcdFx0dHlwZTogVFlfTkZDLCBcclxuXHRcdFx0XHRcdFx0XHRpbnB1dDogY3BzMCwgLy8gdGhlcmUgYXJlIDMgc3RhdGVzOiB0b2tlbnMwID09KHByb2Nlc3MpPT4gaW5wdXQgPT0obmZjKT0+IHRva2Vucy9jcHNcclxuXHRcdFx0XHRcdFx0XHRjcHMsIFxyXG5cdFx0XHRcdFx0XHRcdHRva2VuczA6IGNvbGxhcHNlX3ZhbGlkX3Rva2VucyhzbGljZSksXHJcblx0XHRcdFx0XHRcdFx0dG9rZW5zOiBlbnNfdG9rZW5pemUoc3RyX2Zyb21fY3BzKGNwcyksIHtuZjogZmFsc2V9KVxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0aSA9IHN0YXJ0O1xyXG5cdFx0XHRcdFx0fSBlbHNlIHsgXHJcblx0XHRcdFx0XHRcdGkgPSBlbmQgLSAxOyAvLyBza2lwIHRvIGVuZCBvZiBzbGljZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c3RhcnQgPSAtMTsgLy8gcmVzZXRcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c3RhcnQgPSBpOyAvLyByZW1lbWJlciBsYXN0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKHRva2VuLnR5cGUgIT09IFRZX0lHTk9SRUQpIHsgLy8gMjAyMjEwMjQ6IGlzIHRoaXMgY29ycmVjdD9cclxuXHRcdFx0XHRzdGFydCA9IC0xOyAvLyByZXNldFxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBjb2xsYXBzZV92YWxpZF90b2tlbnModG9rZW5zKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNfdmFsaWRfb3JfbWFwcGVkKHR5cGUpIHtcclxuXHRyZXR1cm4gdHlwZSA9PSBUWV9WQUxJRCB8fCB0eXBlID09IFRZX01BUFBFRDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVxdWlyZXNfY2hlY2soY3BzKSB7XHJcblx0cmV0dXJuIGNwcy5zb21lKGNwID0+IE5GQ19DSEVDSy5oYXMoY3ApKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29sbGFwc2VfdmFsaWRfdG9rZW5zKHRva2Vucykge1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAodG9rZW5zW2ldLnR5cGUgPT0gVFlfVkFMSUQpIHtcclxuXHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0d2hpbGUgKGogPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tqXS50eXBlID09IFRZX1ZBTElEKSBqKys7XHJcblx0XHRcdHRva2Vucy5zcGxpY2UoaSwgaiAtIGksIHt0eXBlOiBUWV9WQUxJRCwgY3BzOiB0b2tlbnMuc2xpY2UoaSwgaikuZmxhdE1hcCh4ID0+IHguY3BzKX0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gdG9rZW5zO1xyXG59XG5cbmV4cG9ydCB7IGVuc19iZWF1dGlmeSwgZW5zX2Vtb2ppLCBlbnNfbm9ybWFsaXplLCBlbnNfbm9ybWFsaXplX2ZyYWdtZW50LCBlbnNfc3BsaXQsIGVuc190b2tlbml6ZSwgaXNfY29tYmluaW5nX21hcmssIG5mYywgbmZkLCBzYWZlX3N0cl9mcm9tX2Nwcywgc2hvdWxkX2VzY2FwZSB9O1xuIiwiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBoZXhsaWZ5LCBhc3NlcnRBcmd1bWVudCwgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGVuc19ub3JtYWxpemUgfSBmcm9tIFwiQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZVwiO1xuY29uc3QgWmVyb3MgPSBuZXcgVWludDhBcnJheSgzMik7XG5aZXJvcy5maWxsKDApO1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnQoY29tcCkge1xuICAgIGFzc2VydEFyZ3VtZW50KGNvbXAubGVuZ3RoICE9PSAwLCBcImludmFsaWQgRU5TIG5hbWU7IGVtcHR5IGNvbXBvbmVudFwiLCBcImNvbXBcIiwgY29tcCk7XG4gICAgcmV0dXJuIGNvbXA7XG59XG5mdW5jdGlvbiBlbnNOYW1lU3BsaXQobmFtZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gdG9VdGY4Qnl0ZXMoZW5zTm9ybWFsaXplKG5hbWUpKTtcbiAgICBjb25zdCBjb21wcyA9IFtdO1xuICAgIGlmIChuYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY29tcHM7XG4gICAgfVxuICAgIGxldCBsYXN0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGQgPSBieXRlc1tpXTtcbiAgICAgICAgLy8gQSBzZXBhcmF0b3IgKGkuZS4gXCIuXCIpOyBjb3B5IHRoaXMgY29tcG9uZW50XG4gICAgICAgIGlmIChkID09PSAweDJlKSB7XG4gICAgICAgICAgICBjb21wcy5wdXNoKGNoZWNrQ29tcG9uZW50KGJ5dGVzLnNsaWNlKGxhc3QsIGkpKSk7XG4gICAgICAgICAgICBsYXN0ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhlcmUgd2FzIGEgc3RyYXkgc2VwYXJhdG9yIGF0IHRoZSBlbmQgb2YgdGhlIG5hbWVcbiAgICBhc3NlcnRBcmd1bWVudChsYXN0IDwgYnl0ZXMubGVuZ3RoLCBcImludmFsaWQgRU5TIG5hbWU7IGVtcHR5IGNvbXBvbmVudFwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgY29tcHMucHVzaChjaGVja0NvbXBvbmVudChieXRlcy5zbGljZShsYXN0KSkpO1xuICAgIHJldHVybiBjb21wcztcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIEVOUyAlJW5hbWUlJSBub3JtYWxpemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zTm9ybWFsaXplKG5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IGxhYmVsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnNfbm9ybWFsaXplKG5hbWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIEVOUyBuYW1lICgke2Vycm9yLm1lc3NhZ2V9KWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUlbmFtZSUlIGlzIGEgdmFsaWQgRU5TIG5hbWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTmFtZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChlbnNOYW1lU3BsaXQobmFtZSkubGVuZ3RoICE9PSAwKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBbW2xpbmstbmFtZWhhc2hdXSBmb3IgJSVuYW1lJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuYW1laGFzaChuYW1lKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIEVOUyBuYW1lOyBub3QgYSBzdHJpbmdcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIGFzc2VydEFyZ3VtZW50KG5hbWUubGVuZ3RoLCBgaW52YWxpZCBFTlMgbmFtZSAoZW1wdHkgbGFiZWwpYCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIGxldCByZXN1bHQgPSBaZXJvcztcbiAgICBjb25zdCBjb21wcyA9IGVuc05hbWVTcGxpdChuYW1lKTtcbiAgICB3aGlsZSAoY29tcHMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGtlY2NhazI1Nihjb25jYXQoW3Jlc3VsdCwga2VjY2FrMjU2KChjb21wcy5wb3AoKSkpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgRE5TIGVuY29kZWQgJSVuYW1lJSUuXG4gKlxuICogIFRoaXMgaXMgdXNlZCBmb3IgdmFyaW91cyBwYXJ0cyBvZiBFTlMgbmFtZSByZXNvbHV0aW9uLCBzdWNoXG4gKiAgYXMgdGhlIHdpbGRjYXJkIHJlc29sdXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkbnNFbmNvZGUobmFtZSkge1xuICAgIHJldHVybiBoZXhsaWZ5KGNvbmNhdChlbnNOYW1lU3BsaXQobmFtZSkubWFwKChjb21wKSA9PiB7XG4gICAgICAgIC8vIEROUyBkb2VzIG5vdCBhbGxvdyBjb21wb25lbnRzIG92ZXIgNjMgYnl0ZXMgaW4gbGVuZ3RoXG4gICAgICAgIGlmIChjb21wLmxlbmd0aCA+IDYzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEROUyBlbmNvZGVkIGVudHJ5OyBsZW5ndGggZXhjZWVkcyA2MyBieXRlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGNvbXAubGVuZ3RoICsgMSk7XG4gICAgICAgIGJ5dGVzLnNldChjb21wLCAxKTtcbiAgICAgICAgYnl0ZXNbMF0gPSBieXRlcy5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSkpKSArIFwiMDBcIjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hbWVoYXNoLmpzLm1hcCIsImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5mdW5jdGlvbiBhY2Nlc3NTZXRpZnkoYWRkciwgc3RvcmFnZUtleXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBnZXRBZGRyZXNzKGFkZHIpLFxuICAgICAgICBzdG9yYWdlS2V5czogc3RvcmFnZUtleXMubWFwKChzdG9yYWdlS2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcoc3RvcmFnZUtleSwgMzIpLCBcImludmFsaWQgc2xvdFwiLCBgc3RvcmFnZUtleXNbJHtpbmRleH1dYCwgc3RvcmFnZUtleSk7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZUtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KVxuICAgIH07XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tBY2Nlc3NMaXN0XV0gZnJvbSBhbnkgZXRoZXJzLXN1cHBvcnRlZCBhY2Nlc3MtbGlzdCBzdHJ1Y3R1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHNldCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNldCkpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzZXQubGVuZ3RoID09PSAyLCBcImludmFsaWQgc2xvdCBzZXRcIiwgYHZhbHVlWyR7aW5kZXh9XWAsIHNldCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShzZXRbMF0sIHNldFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzZXQgIT0gbnVsbCAmJiB0eXBlb2YgKHNldCkgPT09IFwib2JqZWN0XCIsIFwiaW52YWxpZCBhZGRyZXNzLXNsb3Qgc2V0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShzZXQuYWRkcmVzcywgc2V0LnN0b3JhZ2VLZXlzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlICE9IG51bGwgJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIsIFwiaW52YWxpZCBhY2Nlc3MgbGlzdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3Qua2V5cyh2YWx1ZSkubWFwKChhZGRyKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdmFsdWVbYWRkcl0ucmVkdWNlKChhY2N1bSwgc3RvcmFnZUtleSkgPT4ge1xuICAgICAgICAgICAgYWNjdW1bc3RvcmFnZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoYWRkciwgT2JqZWN0LmtleXMoc3RvcmFnZUtleXMpLnNvcnQoKSk7XG4gICAgfSk7XG4gICAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IChhLmFkZHJlc3MubG9jYWxlQ29tcGFyZShiLmFkZHJlc3MpKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY2Vzc2xpc3QuanMubWFwIiwiaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYsIFNpZ25pbmdLZXkgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG4vKipcbiAqICBSZXR1cm5zIHRoZSBhZGRyZXNzIGZvciB0aGUgJSVrZXklJS5cbiAqXG4gKiAgVGhlIGtleSBtYXkgYmUgYW55IHN0YW5kYXJkIGZvcm0gb2YgcHVibGljIGtleSBvciBhIHByaXZhdGUga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUFkZHJlc3Moa2V5KSB7XG4gICAgbGV0IHB1YmtleTtcbiAgICBpZiAodHlwZW9mIChrZXkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHB1YmtleSA9IFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShrZXksIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHB1YmtleSA9IGtleS5wdWJsaWNLZXk7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZGRyZXNzKGtlY2NhazI1NihcIjB4XCIgKyBwdWJrZXkuc3Vic3RyaW5nKDQpKS5zdWJzdHJpbmcoMjYpKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIHJlY292ZXJlZCBhZGRyZXNzIGZvciB0aGUgcHJpdmF0ZSBrZXkgdGhhdCB3YXNcbiAqICB1c2VkIHRvIHNpZ24gJSVkaWdlc3QlJSB0aGF0IHJlc3VsdGVkIGluICUlc2lnbmF0dXJlJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBjb21wdXRlQWRkcmVzcyhTaWduaW5nS2V5LnJlY292ZXJQdWJsaWNLZXkoZGlnZXN0LCBzaWduYXR1cmUpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIiwiaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYsIFNpZ25hdHVyZSwgU2lnbmluZ0tleSB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGVjb2RlUmxwLCBlbmNvZGVSbHAsIGdldEJ5dGVzLCBnZXRCaWdJbnQsIGdldE51bWJlciwgaGV4bGlmeSwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgdG9CZUFycmF5LCB6ZXJvUGFkVmFsdWUgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi9hY2Nlc3NsaXN0LmpzXCI7XG5pbXBvcnQgeyByZWNvdmVyQWRkcmVzcyB9IGZyb20gXCIuL2FkZHJlc3MuanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8yID0gQmlnSW50KDIpO1xuY29uc3QgQk5fMjcgPSBCaWdJbnQoMjcpO1xuY29uc3QgQk5fMjggPSBCaWdJbnQoMjgpO1xuY29uc3QgQk5fMzUgPSBCaWdJbnQoMzUpO1xuY29uc3QgQk5fTUFYX1VJTlQgPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG5mdW5jdGlvbiBoYW5kbGVBZGRyZXNzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZGRyZXNzKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFjY2Vzc0xpc3QodmFsdWUsIHBhcmFtKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGFjY2Vzc0xpc3RpZnkodmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGVycm9yLm1lc3NhZ2UsIHBhcmFtLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlTnVtYmVyKF92YWx1ZSwgcGFyYW0pIHtcbiAgICBpZiAoX3ZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBnZXROdW1iZXIoX3ZhbHVlLCBwYXJhbSk7XG59XG5mdW5jdGlvbiBoYW5kbGVVaW50KF92YWx1ZSwgcGFyYW0pIHtcbiAgICBpZiAoX3ZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgcGFyYW0pO1xuICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlIDw9IEJOX01BWF9VSU5ULCBcInZhbHVlIGV4Y2VlZHMgdWludCBzaXplXCIsIHBhcmFtLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKF92YWx1ZSwgbmFtZSkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCByZXN1bHQgPSB0b0JlQXJyYXkodmFsdWUpO1xuICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5sZW5ndGggPD0gMzIsIGB2YWx1ZSB0b28gbGFyZ2VgLCBgdHguJHtuYW1lfWAsIHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZm9ybWF0QWNjZXNzTGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKS5tYXAoKHNldCkgPT4gW3NldC5hZGRyZXNzLCBzZXQuc3RvcmFnZUtleXNdKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUxlZ2FjeShkYXRhKSB7XG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGRhdGEpO1xuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOSB8fCBmaWVsZHMubGVuZ3RoID09PSA2KSwgXCJpbnZhbGlkIGZpZWxkIGNvdW50IGZvciBsZWdhY3kgdHJhbnNhY3Rpb25cIiwgXCJkYXRhXCIsIGRhdGEpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAwLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1swXSwgXCJub25jZVwiKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZVVpbnQoZmllbGRzWzFdLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbMl0sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1szXSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s0XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbNV0pLFxuICAgICAgICBjaGFpbklkOiBCTl8wXG4gICAgfTtcbiAgICAvLyBMZWdhY3kgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gNikge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIGNvbnN0IHYgPSBoYW5kbGVVaW50KGZpZWxkc1s2XSwgXCJ2XCIpO1xuICAgIGNvbnN0IHIgPSBoYW5kbGVVaW50KGZpZWxkc1s3XSwgXCJyXCIpO1xuICAgIGNvbnN0IHMgPSBoYW5kbGVVaW50KGZpZWxkc1s4XSwgXCJzXCIpO1xuICAgIGlmIChyID09PSBCTl8wICYmIHMgPT09IEJOXzApIHtcbiAgICAgICAgLy8gRUlQLTE1NSB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgICAgICB0eC5jaGFpbklkID0gdjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIEVJUC0xNTUgY2hhaW4gSUQgKG9yIDAgZm9yIGxlZ2FjeSlcbiAgICAgICAgbGV0IGNoYWluSWQgPSAodiAtIEJOXzM1KSAvIEJOXzI7XG4gICAgICAgIGlmIChjaGFpbklkIDwgQk5fMCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IEJOXzA7XG4gICAgICAgIH1cbiAgICAgICAgdHguY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIC8vIFNpZ25lZCBMZWdhY3kgVHJhbnNhY3Rpb25cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoY2hhaW5JZCAhPT0gQk5fMCB8fCAodiA9PT0gQk5fMjcgfHwgdiA9PT0gQk5fMjgpLCBcIm5vbi1jYW5vbmljYWwgbGVnYWN5IHZcIiwgXCJ2XCIsIGZpZWxkc1s2XSk7XG4gICAgICAgIHR4LnNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHtcbiAgICAgICAgICAgIHI6IHplcm9QYWRWYWx1ZShmaWVsZHNbN10sIDMyKSxcbiAgICAgICAgICAgIHM6IHplcm9QYWRWYWx1ZShmaWVsZHNbOF0sIDMyKSxcbiAgICAgICAgICAgIHZcbiAgICAgICAgfSk7XG4gICAgICAgIHR4Lmhhc2ggPSBrZWNjYWsyNTYoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVMZWdhY3kodHgsIHNpZykge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlIHx8IDAsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNQcmljZSB8fCAwLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQgfHwgMCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKCh0eC50byAhPSBudWxsKSA/IGdldEFkZHJlc3ModHgudG8pIDogXCIweFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LnZhbHVlIHx8IDAsIFwidmFsdWVcIiksXG4gICAgICAgICh0eC5kYXRhIHx8IFwiMHhcIiksXG4gICAgXTtcbiAgICBsZXQgY2hhaW5JZCA9IEJOXzA7XG4gICAgaWYgKHR4LmNoYWluSWQgIT0gQk5fMCkge1xuICAgICAgICAvLyBBIGNoYWluSWQgd2FzIHByb3ZpZGVkOyBpZiBub24temVybyB3ZSdsbCB1c2UgRUlQLTE1NVxuICAgICAgICBjaGFpbklkID0gZ2V0QmlnSW50KHR4LmNoYWluSWQsIFwidHguY2hhaW5JZFwiKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBhIGNoYWluSWQgaW4gdGhlIHR4IGFuZCBhbiBFSVAtMTU1IHYgaW4gdGhlIHNpZ25hdHVyZSxcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZXkgYWdyZWUgd2l0aCBlYWNoIG90aGVyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCFzaWcgfHwgc2lnLm5ldHdvcmtWID09IG51bGwgfHwgc2lnLmxlZ2FjeUNoYWluSWQgPT09IGNoYWluSWQsIFwidHguY2hhaW5JZC9zaWcudiBtaXNtYXRjaFwiLCBcInNpZ1wiLCBzaWcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eC5zaWduYXR1cmUpIHtcbiAgICAgICAgLy8gTm8gZXhwbGljaXQgY2hhaW5JZCwgYnV0IEVJUC0xNTUgaGF2ZSBhIGRlcml2ZWQgaW1wbGljaXQgY2hhaW5JZFxuICAgICAgICBjb25zdCBsZWdhY3kgPSB0eC5zaWduYXR1cmUubGVnYWN5Q2hhaW5JZDtcbiAgICAgICAgaWYgKGxlZ2FjeSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gbGVnYWN5O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJlcXVlc3RpbmcgYW4gdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICBpZiAoIXNpZykge1xuICAgICAgICAvLyBXZSBoYXZlIGFuIEVJUC0xNTUgdHJhbnNhY3Rpb24gKGNoYWluSWQgd2FzIHNwZWNpZmllZCBhbmQgbm9uLXplcm8pXG4gICAgICAgIGlmIChjaGFpbklkICE9PSBCTl8wKSB7XG4gICAgICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoY2hhaW5JZCkpO1xuICAgICAgICAgICAgZmllbGRzLnB1c2goXCIweFwiKTtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKFwiMHhcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZVJscChmaWVsZHMpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogV2Ugc2hvdWxkIHByb2JhYmx5IGNoZWNrIHRoYXQgdHguc2lnbmF0dXJlLCBjaGFpbklkLCBhbmQgc2lnXG4gICAgLy8gICAgICAgIG1hdGNoIGJ1dCB0aGF0IGxvZ2ljIGNvdWxkIGJyZWFrIGV4aXN0aW5nIGNvZGUsIHNvIHNjaGVkdWxlXG4gICAgLy8gICAgICAgIHRoaXMgZm9yIHRoZSBuZXh0IG1ham9yIGJ1bXAuXG4gICAgLy8gQ29tcHV0ZSB0aGUgRUlQLTE1NSB2XG4gICAgbGV0IHYgPSBCaWdJbnQoMjcgKyBzaWcueVBhcml0eSk7XG4gICAgaWYgKGNoYWluSWQgIT09IEJOXzApIHtcbiAgICAgICAgdiA9IFNpZ25hdHVyZS5nZXRDaGFpbklkVihjaGFpbklkLCBzaWcudik7XG4gICAgfVxuICAgIGVsc2UgaWYgKEJpZ0ludChzaWcudikgIT09IHYpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidHguY2hhaW5JZC9zaWcudiBtaXNtYXRjaFwiLCBcInNpZ1wiLCBzaWcpO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIHNpZ25hdHVyZVxuICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheSh2KSk7XG4gICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5yKSk7XG4gICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XG4gICAgcmV0dXJuIGVuY29kZVJscChmaWVsZHMpO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMpIHtcbiAgICBsZXQgeVBhcml0eTtcbiAgICB0cnkge1xuICAgICAgICB5UGFyaXR5ID0gaGFuZGxlTnVtYmVyKGZpZWxkc1swXSwgXCJ5UGFyaXR5XCIpO1xuICAgICAgICBpZiAoeVBhcml0eSAhPT0gMCAmJiB5UGFyaXR5ICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgeVBhcml0eVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCB5UGFyaXR5XCIsIFwieVBhcml0eVwiLCBmaWVsZHNbMF0pO1xuICAgIH1cbiAgICBjb25zdCByID0gemVyb1BhZFZhbHVlKGZpZWxkc1sxXSwgMzIpO1xuICAgIGNvbnN0IHMgPSB6ZXJvUGFkVmFsdWUoZmllbGRzWzJdLCAzMik7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20oeyByLCBzLCB5UGFyaXR5IH0pO1xuICAgIHR4LnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcDE1NTkoZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IGRlY29kZVJscChnZXRCeXRlcyhkYXRhKS5zbGljZSgxKSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSA5IHx8IGZpZWxkcy5sZW5ndGggPT09IDEyKSwgXCJpbnZhbGlkIGZpZWxkIGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAyXCIsIFwiZGF0YVwiLCBoZXhsaWZ5KGRhdGEpKTtcbiAgICBjb25zdCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpO1xuICAgIGNvbnN0IG1heEZlZVBlckdhcyA9IGhhbmRsZVVpbnQoZmllbGRzWzNdLCBcIm1heEZlZVBlckdhc1wiKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMixcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlVWludChmaWVsZHNbMF0sIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMV0sIFwibm9uY2VcIiksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgbWF4RmVlUGVyR2FzOiBtYXhGZWVQZXJHYXMsXG4gICAgICAgIGdhc1ByaWNlOiBudWxsLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbNF0sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1s1XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s2XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbN10pLFxuICAgICAgICBhY2Nlc3NMaXN0OiBoYW5kbGVBY2Nlc3NMaXN0KGZpZWxkc1s4XSwgXCJhY2Nlc3NMaXN0XCIpLFxuICAgIH07XG4gICAgLy8gVW5zaWduZWQgRUlQLTE1NTkgVHJhbnNhY3Rpb25cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gOSkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHR4Lmhhc2ggPSBrZWNjYWsyNTYoZGF0YSk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoOSkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXAxNTU5KHR4LCBzaWcpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5jaGFpbklkIHx8IDAsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlIHx8IDAsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAwLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQgfHwgMCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKCh0eC50byAhPSBudWxsKSA/IGdldEFkZHJlc3ModHgudG8pIDogXCIweFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LnZhbHVlIHx8IDAsIFwidmFsdWVcIiksXG4gICAgICAgICh0eC5kYXRhIHx8IFwiMHhcIiksXG4gICAgICAgIChmb3JtYXRBY2Nlc3NMaXN0KHR4LmFjY2Vzc0xpc3QgfHwgW10pKVxuICAgIF07XG4gICAgaWYgKHNpZykge1xuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnlQYXJpdHksIFwieVBhcml0eVwiKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdChbXCIweDAyXCIsIGVuY29kZVJscChmaWVsZHMpXSk7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXAyOTMwKGRhdGEpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBkZWNvZGVSbHAoZ2V0Qnl0ZXMoZGF0YSkuc2xpY2UoMSkpO1xuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOCB8fCBmaWVsZHMubGVuZ3RoID09PSAxMSksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMVwiLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxuICAgICAgICBnYXNQcmljZTogaGFuZGxlVWludChmaWVsZHNbMl0sIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1szXSwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzRdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZVVpbnQoZmllbGRzWzVdLCBcInZhbHVlXCIpLFxuICAgICAgICBkYXRhOiBoZXhsaWZ5KGZpZWxkc1s2XSksXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGhhbmRsZUFjY2Vzc0xpc3QoZmllbGRzWzddLCBcImFjY2Vzc0xpc3RcIilcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0yOTMwIFRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDgpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICB0eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xuICAgIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLnNsaWNlKDgpKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMjkzMCh0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCB8fCAwLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSB8fCAwLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzUHJpY2UgfHwgMCwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0IHx8IDAsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICgodHgudG8gIT0gbnVsbCkgPyBnZXRBZGRyZXNzKHR4LnRvKSA6IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSB8fCAwLCBcInZhbHVlXCIpLFxuICAgICAgICAodHguZGF0YSB8fCBcIjB4XCIpLFxuICAgICAgICAoZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKSlcbiAgICBdO1xuICAgIGlmIChzaWcpIHtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInJlY292ZXJ5UGFyYW1cIikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXQoW1wiMHgwMVwiLCBlbmNvZGVSbHAoZmllbGRzKV0pO1xufVxuLyoqXG4gKiAgQSAqKlRyYW5zYWN0aW9uKiogZGVzY3JpYmVzIGFuIG9wZXJhdGlvbiB0byBiZSBleGVjdXRlZCBvblxuICogIEV0aGVyZXVtIGJ5IGFuIEV4dGVybmFsbHkgT3duZWQgQWNjb3VudCAoRU9BKS4gSXQgaW5jbHVkZXNcbiAqICB3aG8gKHRoZSBbW3RvXV0gYWRkcmVzcyksIHdoYXQgKHRoZSBbW2RhdGFdXSkgYW5kIGhvdyBtdWNoICh0aGVcbiAqICBbW3ZhbHVlXV0gaW4gZXRoZXIpIHRoZSBvcGVyYXRpb24gc2hvdWxkIGVudGFpbC5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICB0eCA9IG5ldyBUcmFuc2FjdGlvbigpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgdHguZGF0YSA9IFwiMHgxMjM0XCI7XG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbiB7XG4gICAgI3R5cGU7XG4gICAgI3RvO1xuICAgICNkYXRhO1xuICAgICNub25jZTtcbiAgICAjZ2FzTGltaXQ7XG4gICAgI2dhc1ByaWNlO1xuICAgICNtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAjbWF4RmVlUGVyR2FzO1xuICAgICN2YWx1ZTtcbiAgICAjY2hhaW5JZDtcbiAgICAjc2lnO1xuICAgICNhY2Nlc3NMaXN0O1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKlxuICAgICAqICBJZiBudWxsLCB0aGUgdHlwZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgaW5mZXJyZWQgYmFzZWQgb25cbiAgICAgKiAgZXhwbGljaXQgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuI3R5cGU7IH1cbiAgICBzZXQgdHlwZSh2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYXNlIFwibGVnYWN5XCI6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIFwiYmVybGluXCI6XG4gICAgICAgICAgICBjYXNlIFwiZWlwLTI5MzBcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhc2UgXCJsb25kb25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtMTU1OVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlXCIsIFwidHlwZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqL1xuICAgIGdldCB0eXBlTmFtZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFwibGVnYWN5XCI7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBcImVpcC0yOTMwXCI7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBcImVpcC0xNTU5XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGB0b2BgIGFkZHJlc3MgZm9yIHRoZSB0cmFuc2FjdGlvbiBvciBgYG51bGxgYCBpZiB0aGVcbiAgICAgKiAgdHJhbnNhY3Rpb24gaXMgYW4gYGBpbml0YGAgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy4jdG87IH1cbiAgICBzZXQgdG8odmFsdWUpIHtcbiAgICAgICAgdGhpcy4jdG8gPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gbm9uY2UuXG4gICAgICovXG4gICAgZ2V0IG5vbmNlKCkgeyByZXR1cm4gdGhpcy4jbm9uY2U7IH1cbiAgICBzZXQgbm9uY2UodmFsdWUpIHsgdGhpcy4jbm9uY2UgPSBnZXROdW1iZXIodmFsdWUsIFwidmFsdWVcIik7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBsaW1pdC5cbiAgICAgKi9cbiAgICBnZXQgZ2FzTGltaXQoKSB7IHJldHVybiB0aGlzLiNnYXNMaW1pdDsgfVxuICAgIHNldCBnYXNMaW1pdCh2YWx1ZSkgeyB0aGlzLiNnYXNMaW1pdCA9IGdldEJpZ0ludCh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZS5cbiAgICAgKlxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MgdGhpcyBkZWZpbmVzIHRoZSBmZWUgdGhhdCB3aWxsIGJlIHBhaWQuIE9uXG4gICAgICogIEVJUC0xNTU5IG5ldHdvcmtzLCB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgZ2FzUHJpY2UoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jZ2FzUHJpY2U7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICh0aGlzLnR5cGUgPT09IDAgfHwgdGhpcy50eXBlID09PSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgZ2FzUHJpY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ2FzUHJpY2UgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcImdhc1ByaWNlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gcHJpb3JpdHkgZmVlIHBlciB1bml0IG9mIGdhcyB0byBwYXkuIE9uIGxlZ2FjeVxuICAgICAqICBuZXR3b3JrcyB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBtYXhQcmlvcml0eUZlZVBlckdhcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNtYXhQcmlvcml0eUZlZVBlckdhcyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRCaWdJbnQodmFsdWUsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB0b3RhbCBmZWUgcGVyIHVuaXQgb2YgZ2FzIHRvIHBheS4gT24gbGVnYWN5XG4gICAgICogIG5ldHdvcmtzIHRoaXMgc2hvdWxkIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBtYXhGZWVQZXJHYXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4RmVlUGVyR2FzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgbWF4RmVlUGVyR2FzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI21heEZlZVBlckdhcyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRCaWdJbnQodmFsdWUsIFwibWF4RmVlUGVyR2FzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGRhdGEuIEZvciBgYGluaXRgYCB0cmFuc2FjdGlvbnMgdGhpcyBpcyB0aGVcbiAgICAgKiAgZGVwbG95bWVudCBjb2RlLlxuICAgICAqL1xuICAgIGdldCBkYXRhKCkgeyByZXR1cm4gdGhpcy4jZGF0YTsgfVxuICAgIHNldCBkYXRhKHZhbHVlKSB7IHRoaXMuI2RhdGEgPSBoZXhsaWZ5KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYW1vdW50IG9mIGV0aGVyIChpbiB3ZWkpIHRvIHNlbmQgaW4gdGhpcyB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkgeyByZXR1cm4gdGhpcy4jdmFsdWU7IH1cbiAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jdmFsdWUgPSBnZXRCaWdJbnQodmFsdWUsIFwidmFsdWVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW4gSUQgdGhpcyB0cmFuc2FjdGlvbiBpcyB2YWxpZCBvbi5cbiAgICAgKi9cbiAgICBnZXQgY2hhaW5JZCgpIHsgcmV0dXJuIHRoaXMuI2NoYWluSWQ7IH1cbiAgICBzZXQgY2hhaW5JZCh2YWx1ZSkgeyB0aGlzLiNjaGFpbklkID0gZ2V0QmlnSW50KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqICBJZiBzaWduZWQsIHRoZSBzaWduYXR1cmUgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHNpZ25hdHVyZSgpIHsgcmV0dXJuIHRoaXMuI3NpZyB8fCBudWxsOyB9XG4gICAgc2V0IHNpZ25hdHVyZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNzaWcgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogU2lnbmF0dXJlLmZyb20odmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGFjY2VzcyBsaXN0LlxuICAgICAqXG4gICAgICogIEFuIGFjY2VzcyBsaXN0IHBlcm1pdHMgZGlzY291bnRlZCAoYnV0IHByZS1wYWlkKSBhY2Nlc3MgdG9cbiAgICAgKiAgYnl0ZWNvZGUgYW5kIHN0YXRlIHZhcmlhYmxlIGFjY2VzcyB3aXRoaW4gY29udHJhY3QgZXhlY3V0aW9uLlxuICAgICAqL1xuICAgIGdldCBhY2Nlc3NMaXN0KCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2FjY2Vzc0xpc3QgfHwgbnVsbDtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDEgfHwgdGhpcy50eXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgYWNjZXNzTGlzdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNhY2Nlc3NMaXN0ID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGFjY2Vzc0xpc3RpZnkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBUcmFuc2FjdGlvbiB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLiN0eXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jdG8gPSBudWxsO1xuICAgICAgICB0aGlzLiNub25jZSA9IDA7XG4gICAgICAgIHRoaXMuI2dhc0xpbWl0ID0gQmlnSW50KDApO1xuICAgICAgICB0aGlzLiNnYXNQcmljZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI21heFByaW9yaXR5RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGF0YSA9IFwiMHhcIjtcbiAgICAgICAgdGhpcy4jdmFsdWUgPSBCaWdJbnQoMCk7XG4gICAgICAgIHRoaXMuI2NoYWluSWQgPSBCaWdJbnQoMCk7XG4gICAgICAgIHRoaXMuI3NpZyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2FjY2Vzc0xpc3QgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2gsIGlmIHNpZ25lZC4gT3RoZXJ3aXNlLCBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgaGFzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmF0dXJlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYodGhpcy5zZXJpYWxpemVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwcmUtaW1hZ2UgaGFzaCBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdGhlIGRpZ2VzdCB0aGF0IGEgW1tTaWduZXJdXSBtdXN0IHNpZ24gdG8gYXV0aG9yaXplXG4gICAgICogIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHVuc2lnbmVkSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih0aGlzLnVuc2lnbmVkU2VyaWFsaXplZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgc2VuZGluZyBhZGRyZXNzLCBpZiBzaWduZWQuIE90aGVyd2lzZSwgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGZyb20oKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hdHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjb3ZlckFkZHJlc3ModGhpcy51bnNpZ25lZEhhc2gsIHRoaXMuc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwdWJsaWMga2V5IG9mIHRoZSBzZW5kZXIsIGlmIHNpZ25lZC4gT3RoZXJ3aXNlLCBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgZnJvbVB1YmxpY0tleSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmF0dXJlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTaWduaW5nS2V5LnJlY292ZXJQdWJsaWNLZXkodGhpcy51bnNpZ25lZEhhc2gsIHRoaXMuc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiBzaWduZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCBwcm9wZXJ0aWVzIHJlcXVpcmluZyBhIHNpZ25lZFxuICAgICAqICB0cmFuc2FjdGlvbiBhcmUgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNTaWduZWQoKSB7XG4gICAgICAgIC8vaXNTaWduZWQoKTogdGhpcyBpcyBTaWduZWRUcmFuc2FjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZSAhPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyB0aHJvd3MgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIHVuc2lnbmVkLiBGb3IgdGhlIHByZS1pbWFnZSxcbiAgICAgKiAgdXNlIFtbdW5zaWduZWRTZXJpYWxpemVkXV0uXG4gICAgICovXG4gICAgZ2V0IHNlcmlhbGl6ZWQoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLnNpZ25hdHVyZSAhPSBudWxsLCBcImNhbm5vdCBzZXJpYWxpemUgdW5zaWduZWQgdHJhbnNhY3Rpb247IG1heWJlIHlvdSBtZWFudCAudW5zaWduZWRTZXJpYWxpemVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIi5zZXJpYWxpemVkXCIgfSk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5pbmZlclR5cGUoKSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplTGVnYWN5KHRoaXMsIHRoaXMuc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDI5MzAodGhpcywgdGhpcy5zaWduYXR1cmUpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMTU1OSh0aGlzLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiLnNlcmlhbGl6ZWRcIiB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBwcmUtaW1hZ2UuXG4gICAgICpcbiAgICAgKiAgVGhlIGhhc2ggb2YgdGhpcyBpcyB0aGUgZGlnZXN0IHdoaWNoIG5lZWRzIHRvIGJlIHNpZ25lZCB0b1xuICAgICAqICBhdXRob3JpemUgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgdW5zaWduZWRTZXJpYWxpemVkKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaW5mZXJUeXBlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUxlZ2FjeSh0aGlzKTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDI5MzAodGhpcyk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAxNTU5KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIi51bnNpZ25lZFNlcmlhbGl6ZWRcIiB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgbW9zdCBcImxpa2VseVwiIHR5cGU7IGN1cnJlbnRseSB0aGUgaGlnaGVzdFxuICAgICAqICBzdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICBpbmZlclR5cGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pbmZlclR5cGVzKCkucG9wKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVmFsaWRhdGVzIHRoZSBleHBsaWNpdCBwcm9wZXJ0aWVzIGFuZCByZXR1cm5zIGEgbGlzdCBvZiBjb21wYXRpYmxlXG4gICAgICogIHRyYW5zYWN0aW9uIHR5cGVzLlxuICAgICAqL1xuICAgIGluZmVyVHlwZXMoKSB7XG4gICAgICAgIC8vIENoZWNrcyB0aGF0IHRoZXJlIGFyZSBubyBjb25mbGljdGluZyBwcm9wZXJ0aWVzIHNldFxuICAgICAgICBjb25zdCBoYXNHYXNQcmljZSA9IHRoaXMuZ2FzUHJpY2UgIT0gbnVsbDtcbiAgICAgICAgY29uc3QgaGFzRmVlID0gKHRoaXMubWF4RmVlUGVyR2FzICE9IG51bGwgfHwgdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKTtcbiAgICAgICAgY29uc3QgaGFzQWNjZXNzTGlzdCA9ICh0aGlzLmFjY2Vzc0xpc3QgIT0gbnVsbCk7XG4gICAgICAgIC8vaWYgKGhhc0dhc1ByaWNlICYmIGhhc0ZlZSkge1xuICAgICAgICAvLyAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2FjdGlvbiBjYW5ub3QgaGF2ZSBnYXNQcmljZSBhbmQgbWF4RmVlUGVyR2FzXCIpO1xuICAgICAgICAvL31cbiAgICAgICAgaWYgKHRoaXMubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5tYXhGZWVQZXJHYXMgPj0gdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcywgXCJwcmlvcml0eUZlZSBjYW5ub3QgYmUgbW9yZSB0aGFuIG1heEZlZVwiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRoaXMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9pZiAodGhpcy50eXBlID09PSAyICYmIGhhc0dhc1ByaWNlKSB7XG4gICAgICAgIC8vICAgIHRocm93IG5ldyBFcnJvcihcImVpcC0xNTU5IHRyYW5zYWN0aW9uIGNhbm5vdCBoYXZlIGdhc1ByaWNlXCIpO1xuICAgICAgICAvL31cbiAgICAgICAgYXNzZXJ0KCFoYXNGZWUgfHwgKHRoaXMudHlwZSAhPT0gMCAmJiB0aGlzLnR5cGUgIT09IDEpLCBcInRyYW5zYWN0aW9uIHR5cGUgY2Fubm90IGhhdmUgbWF4RmVlUGVyR2FzIG9yIG1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZTogdGhpcyB9KTtcbiAgICAgICAgYXNzZXJ0KHRoaXMudHlwZSAhPT0gMCB8fCAhaGFzQWNjZXNzTGlzdCwgXCJsZWdhY3kgdHJhbnNhY3Rpb24gY2Fubm90IGhhdmUgYWNjZXNzTGlzdFwiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRoaXMgfSk7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgICAgIC8vIEV4cGxpY2l0IHR5cGVcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eXBlcy5wdXNoKHRoaXMudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzRmVlKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0dhc1ByaWNlKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0FjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZXMucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNBY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDEpO1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHlwZXMuc29ydCgpO1xuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBhIGxlZ2FjeSB0cmFuc2FjdGlvbiAoaS5lLlxuICAgICAqICBgYHR5cGUgPT09IDBgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqICBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0xlZ2FjeSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgYmVybGluIGhhcmRmb3JtIHRyYW5zYWN0aW9uIChpLmUuXG4gICAgICogIGBgdHlwZSA9PT0gMWBgKS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoZSByZWxhdGVkIHByb3BlcnRpZXMgYXJlXG4gICAgICogIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzQmVybGluKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBsb25kb24gaGFyZGZvcm0gdHJhbnNhY3Rpb24gKGkuZS5cbiAgICAgKiAgYGB0eXBlID09PSAyYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcbiAgICAgKiAgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyB0cmFuc2FjaXRvbi5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20odGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBKU09OLWZyaWVuZGx5IG9iamVjdC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHMgPSAodikgPT4ge1xuICAgICAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIHRvOiB0aGlzLnRvLFxuICAgICAgICAgICAgLy8gICAgICAgICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICBub25jZTogdGhpcy5ub25jZSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBzKHRoaXMuZ2FzTGltaXQpLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHModGhpcy5nYXNQcmljZSksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogcyh0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogcyh0aGlzLm1heEZlZVBlckdhcyksXG4gICAgICAgICAgICB2YWx1ZTogcyh0aGlzLnZhbHVlKSxcbiAgICAgICAgICAgIGNoYWluSWQ6IHModGhpcy5jaGFpbklkKSxcbiAgICAgICAgICAgIHNpZzogdGhpcy5zaWduYXR1cmUgPyB0aGlzLnNpZ25hdHVyZS50b0pTT04oKSA6IG51bGwsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0OiB0aGlzLmFjY2Vzc0xpc3RcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhICoqVHJhbnNhY3Rpb24qKiBmcm9tIGEgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBvciBhXG4gICAgICogIFRyYW5zYWN0aW9uLWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHR4KSB7XG4gICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZ2V0Qnl0ZXModHgpO1xuICAgICAgICAgICAgaWYgKHBheWxvYWRbMF0gPj0gMHg3ZikgeyAvLyBAVE9ETzogPiB2cyA+PSA/P1xuICAgICAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUxlZ2FjeShwYXlsb2FkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHBheWxvYWRbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUVpcDI5MzAocGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlRWlwMTU1OShwYXlsb2FkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmcm9tXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIGlmICh0eC50eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gdHgudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgudG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnRvID0gdHgudG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm5vbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ub25jZSA9IHR4Lm5vbmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5nYXNMaW1pdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuZ2FzTGltaXQgPSB0eC5nYXNMaW1pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lmdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1heEZlZVBlckdhcyA9IHR4Lm1heEZlZVBlckdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IHR4LmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHR4LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gdHguY2hhaW5JZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh0eC5zaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5hY2Nlc3NMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hY2Nlc3NMaXN0ID0gdHguYWNjZXNzTGlzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguaGFzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuaXNTaWduZWQoKSwgXCJ1bnNpZ25lZCB0cmFuc2FjdGlvbiBjYW5ub3QgZGVmaW5lIGhhc2hcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuaGFzaCA9PT0gdHguaGFzaCwgXCJoYXNoIG1pc21hdGNoXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5pc1NpZ25lZCgpLCBcInVuc2lnbmVkIHRyYW5zYWN0aW9uIGNhbm5vdCBkZWZpbmUgZnJvbVwiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5mcm9tLnRvTG93ZXJDYXNlKCkgPT09ICh0eC5mcm9tIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBtaXNtYXRjaFwiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zYWN0aW9uLmpzLm1hcCIsIi8vaW1wb3J0IHsgVHlwZWREYXRhRG9tYWluLCBUeXBlZERhdGFGaWVsZCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm92aWRlcmFic3RyYWN0LXNpZ25lclwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyByZWNvdmVyQWRkcmVzcyB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBoZXhsaWZ5LCBpc0hleFN0cmluZywgbWFzaywgdG9CZUhleCwgdG9RdWFudGl0eSwgdG9Ud29zLCB6ZXJvUGFkVmFsdWUsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuL2lkLmpzXCI7XG5jb25zdCBwYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xucGFkZGluZy5maWxsKDApO1xuY29uc3QgQk5fXzEgPSBCaWdJbnQoLTEpO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl9NQVhfVUlOVDI1NiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbjtcbjtcbmZ1bmN0aW9uIGhleFBhZFJpZ2h0KHZhbHVlKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh2YWx1ZSk7XG4gICAgY29uc3QgcGFkT2Zmc2V0ID0gYnl0ZXMubGVuZ3RoICUgMzI7XG4gICAgaWYgKHBhZE9mZnNldCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KFtieXRlcywgcGFkZGluZy5zbGljZShwYWRPZmZzZXQpXSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbn1cbmNvbnN0IGhleFRydWUgPSB0b0JlSGV4KEJOXzEsIDMyKTtcbmNvbnN0IGhleEZhbHNlID0gdG9CZUhleChCTl8wLCAzMik7XG5jb25zdCBkb21haW5GaWVsZFR5cGVzID0ge1xuICAgIG5hbWU6IFwic3RyaW5nXCIsXG4gICAgdmVyc2lvbjogXCJzdHJpbmdcIixcbiAgICBjaGFpbklkOiBcInVpbnQyNTZcIixcbiAgICB2ZXJpZnlpbmdDb250cmFjdDogXCJhZGRyZXNzXCIsXG4gICAgc2FsdDogXCJieXRlczMyXCJcbn07XG5jb25zdCBkb21haW5GaWVsZE5hbWVzID0gW1xuICAgIFwibmFtZVwiLCBcInZlcnNpb25cIiwgXCJjaGFpbklkXCIsIFwidmVyaWZ5aW5nQ29udHJhY3RcIiwgXCJzYWx0XCJcbl07XG5mdW5jdGlvbiBjaGVja1N0cmluZyhrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiLCBgaW52YWxpZCBkb21haW4gdmFsdWUgZm9yICR7SlNPTi5zdHJpbmdpZnkoa2V5KX1gLCBgZG9tYWluLiR7a2V5fWAsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59XG5jb25zdCBkb21haW5DaGVja3MgPSB7XG4gICAgbmFtZTogY2hlY2tTdHJpbmcoXCJuYW1lXCIpLFxuICAgIHZlcnNpb246IGNoZWNrU3RyaW5nKFwidmVyc2lvblwiKSxcbiAgICBjaGFpbklkOiBmdW5jdGlvbiAoX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJkb21haW4uY2hhaW5JZFwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gMCwgXCJpbnZhbGlkIGNoYWluIElEXCIsIFwiZG9tYWluLmNoYWluSWRcIiwgX3ZhbHVlKTtcbiAgICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvUXVhbnRpdHkodmFsdWUpO1xuICAgIH0sXG4gICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInZlcmlmeWluZ0NvbnRyYWN0XCJgLCBcImRvbWFpbi52ZXJpZnlpbmdDb250cmFjdFwiLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzYWx0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh2YWx1ZSwgXCJkb21haW4uc2FsdFwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYnl0ZXMubGVuZ3RoID09PSAzMiwgYGludmFsaWQgZG9tYWluIHZhbHVlIFwic2FsdFwiYCwgXCJkb21haW4uc2FsdFwiLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gZ2V0QmFzZUVuY29kZXIodHlwZSkge1xuICAgIC8vIGludFhYIGFuZCB1aW50WFhcbiAgICB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXih1PylpbnQoXFxkKikkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkID0gKG1hdGNoWzFdID09PSBcIlwiKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh3aWR0aCAlIDggPT09IDAgJiYgd2lkdGggIT09IDAgJiYgd2lkdGggPD0gMjU2ICYmIChtYXRjaFsyXSA9PSBudWxsIHx8IG1hdGNoWzJdID09PSBTdHJpbmcod2lkdGgpKSwgXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgYm91bmRzVXBwZXIgPSBtYXNrKEJOX01BWF9VSU5UMjU2LCBzaWduZWQgPyAod2lkdGggLSAxKSA6IHdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc0xvd2VyID0gc2lnbmVkID8gKChib3VuZHNVcHBlciArIEJOXzEpICogQk5fXzEpIDogQk5fMDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IGJvdW5kc0xvd2VyICYmIHZhbHVlIDw9IGJvdW5kc1VwcGVyLCBgdmFsdWUgb3V0LW9mLWJvdW5kcyBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b0JlSGV4KHNpZ25lZCA/IHRvVHdvcyh2YWx1ZSwgMjU2KSA6IHZhbHVlLCAzMik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGJ5dGVzWFhcbiAgICB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCspJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQod2lkdGggIT09IDAgJiYgd2lkdGggPD0gMzIgJiYgbWF0Y2hbMV0gPT09IFN0cmluZyh3aWR0aCksIFwiaW52YWxpZCBieXRlcyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYnl0ZXMubGVuZ3RoID09PSB3aWR0aCwgYGludmFsaWQgbGVuZ3RoIGZvciAke3R5cGV9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleFBhZFJpZ2h0KHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB6ZXJvUGFkVmFsdWUoZ2V0QWRkcmVzcyh2YWx1ZSksIDMyKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImJvb2xcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgoIXZhbHVlKSA/IGhleEZhbHNlIDogaGV4VHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJieXRlc1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGVuY29kZVR5cGUobmFtZSwgZmllbGRzKSB7XG4gICAgcmV0dXJuIGAke25hbWV9KCR7ZmllbGRzLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+ICh0eXBlICsgXCIgXCIgKyBuYW1lKSkuam9pbihcIixcIil9KWA7XG59XG4vKipcbiAqICBBICoqVHlwZWREYXRhRW5jb2RlKiogcHJlcGFyZXMgYW5kIGVuY29kZXMgW1tsaW5rLWVpcC03MTJdXSBwYXlsb2Fkc1xuICogIGZvciBzaWduZWQgdHlwZWQgZGF0YS5cbiAqXG4gKiAgVGhpcyBpcyB1c2VmdWwgZm9yIHRob3NlIHRoYXQgd2lzaCB0byBjb21wdXRlIHZhcmlvdXMgY29tcG9uZW50cyBvZiBhXG4gKiAgdHlwZWQgZGF0YSBoYXNoLCBwcmltYXJ5IHR5cGVzLCBvciBzdWItY29tcG9uZW50cywgYnV0IGdlbmVyYWxseSB0aGVcbiAqICBoaWdoZXIgbGV2ZWwgW1tTaWduZXItc2lnblR5cGVkRGF0YV1dIGlzIG1vcmUgdXNlZnVsLlxuICovXG5leHBvcnQgY2xhc3MgVHlwZWREYXRhRW5jb2RlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcmltYXJ5IHR5cGUgZm9yIHRoZSBzdHJ1Y3R1cmVkIFtbdHlwZXNdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGRlcml2ZWQgYXV0b21hdGljYWxseSBmcm9tIHRoZSBbW3R5cGVzXV0sIHNpbmNlIG5vXG4gICAgICogIHJlY3Vyc2lvbiBpcyBwb3NzaWJsZSwgb25jZSB0aGUgREFHIGZvciB0aGUgdHlwZXMgaXMgY29uc3R1cmN0ZWRcbiAgICAgKiAgaW50ZXJuYWxseSwgdGhlIHByaW1hcnkgdHlwZSBtdXN0IGJlIHRoZSBvbmx5IHJlbWFpbmluZyB0eXBlIHdpdGhcbiAgICAgKiAgbm8gcGFyZW50IG5vZGVzLlxuICAgICAqL1xuICAgIHByaW1hcnlUeXBlO1xuICAgICN0eXBlcztcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGVzLlxuICAgICAqL1xuICAgIGdldCB0eXBlcygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy4jdHlwZXMpO1xuICAgIH1cbiAgICAjZnVsbFR5cGVzO1xuICAgICNlbmNvZGVyQ2FjaGU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlR5cGVkRGF0YUVuY29kZXIqKiBmb3IgJSV0eXBlcyUlLlxuICAgICAqXG4gICAgICogIFRoaXMgcGVyZm9ybXMgYWxsIG5lY2Vzc2FyeSBjaGVja2luZyB0aGF0IHR5cGVzIGFyZSB2YWxpZCBhbmRcbiAgICAgKiAgZG8gbm90IHZpb2xhdGUgdGhlIFtbbGluay1laXAtNzEyXV0gc3RydWN0dXJhbCBjb25zdHJhaW50cyBhc1xuICAgICAqICB3ZWxsIGFzIGNvbXB1dGVzIHRoZSBbW3ByaW1hcnlUeXBlXV0uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHlwZXMpIHtcbiAgICAgICAgdGhpcy4jdHlwZXMgPSBKU09OLnN0cmluZ2lmeSh0eXBlcyk7XG4gICAgICAgIHRoaXMuI2Z1bGxUeXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZW5jb2RlckNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMaW5rIHN0cnVjdCB0eXBlcyB0byB0aGVpciBkaXJlY3QgY2hpbGQgc3RydWN0c1xuICAgICAgICBjb25zdCBsaW5rcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTGluayBzdHJ1Y3RzIHRvIHN0cnVjdHMgd2hpY2ggY29udGFpbiB0aGVtIGFzIGEgY2hpbGRcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTGluayBhbGwgc3VidHlwZXMgd2l0aGluIGEgZ2l2ZW4gc3RydWN0XG4gICAgICAgIGNvbnN0IHN1YnR5cGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBPYmplY3Qua2V5cyh0eXBlcykuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICAgICAgbGlua3Muc2V0KHR5cGUsIG5ldyBTZXQoKSk7XG4gICAgICAgICAgICBwYXJlbnRzLnNldCh0eXBlLCBbXSk7XG4gICAgICAgICAgICBzdWJ0eXBlcy5zZXQodHlwZSwgbmV3IFNldCgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0eXBlcykge1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZWFjaCBmaWVsZCBoYXMgYSB1bmlxdWUgbmFtZVxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KCF1bmlxdWVOYW1lcy5oYXMoZmllbGQubmFtZSksIGBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZSAke0pTT04uc3RyaW5naWZ5KGZpZWxkLm5hbWUpfSBpbiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzLmFkZChmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGJhc2UgdHlwZSAoZHJvcCBhbnkgYXJyYXkgc3BlY2lmaWVycylcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlVHlwZSA9IChmaWVsZC50eXBlLm1hdGNoKC9eKFteXFx4NWJdKikoXFx4NWJ8JCkvKSlbMV0gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChiYXNlVHlwZSAhPT0gbmFtZSwgYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgYSBiYXNlIGVuY29kaW5nIHR5cGU/XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKGJhc2VUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQocGFyZW50cy5oYXMoYmFzZVR5cGUpLCBgdW5rbm93biB0eXBlICR7SlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBsaW5rYWdlXG4gICAgICAgICAgICAgICAgcGFyZW50cy5nZXQoYmFzZVR5cGUpLnB1c2gobmFtZSk7XG4gICAgICAgICAgICAgICAgbGlua3MuZ2V0KG5hbWUpLmFkZChiYXNlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVkdWNlIHRoZSBwcmltYXJ5IHR5cGVcbiAgICAgICAgY29uc3QgcHJpbWFyeVR5cGVzID0gQXJyYXkuZnJvbShwYXJlbnRzLmtleXMoKSkuZmlsdGVyKChuKSA9PiAocGFyZW50cy5nZXQobikubGVuZ3RoID09PSAwKSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHByaW1hcnlUeXBlcy5sZW5ndGggIT09IDAsIFwibWlzc2luZyBwcmltYXJ5IHR5cGVcIiwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHByaW1hcnlUeXBlcy5sZW5ndGggPT09IDEsIGBhbWJpZ3VvdXMgcHJpbWFyeSB0eXBlcyBvciB1bnVzZWQgdHlwZXM6ICR7cHJpbWFyeVR5cGVzLm1hcCgodCkgPT4gKEpTT04uc3RyaW5naWZ5KHQpKSkuam9pbihcIiwgXCIpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHJpbWFyeVR5cGU6IHByaW1hcnlUeXBlc1swXSB9KTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlc1xuICAgICAgICBmdW5jdGlvbiBjaGVja0NpcmN1bGFyKHR5cGUsIGZvdW5kKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghZm91bmQuaGFzKHR5cGUpLCBgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2UgdG8gJHtKU09OLnN0cmluZ2lmeSh0eXBlKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgIGZvdW5kLmFkZCh0eXBlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgbGlua3MuZ2V0KHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRzLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNoZWNrIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgY2hlY2tDaXJjdWxhcihjaGlsZCwgZm91bmQpO1xuICAgICAgICAgICAgICAgIC8vIE1hcmsgYWxsIGFuY2VzdG9ycyBhcyBoYXZpbmcgdGhpcyBkZWNlbmRhbnRcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN1YnR5cGUgb2YgZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VidHlwZXMuZ2V0KHN1YnR5cGUpLmFkZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm91bmQuZGVsZXRlKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrQ2lyY3VsYXIodGhpcy5wcmltYXJ5VHlwZSwgbmV3IFNldCgpKTtcbiAgICAgICAgLy8gQ29tcHV0ZSBlYWNoIGZ1bGx5IGRlc2NyaWJlIHR5cGVcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgc2V0XSBvZiBzdWJ0eXBlcykge1xuICAgICAgICAgICAgY29uc3Qgc3QgPSBBcnJheS5mcm9tKHNldCk7XG4gICAgICAgICAgICBzdC5zb3J0KCk7XG4gICAgICAgICAgICB0aGlzLiNmdWxsVHlwZXMuc2V0KG5hbWUsIGVuY29kZVR5cGUobmFtZSwgdHlwZXNbbmFtZV0pICsgc3QubWFwKCh0KSA9PiBlbmNvZGVUeXBlKHQsIHR5cGVzW3RdKSkuam9pbihcIlwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnRoZSBlbmNvZGVyIGZvciB0aGUgc3BlY2lmaWMgJSV0eXBlJSUuXG4gICAgICovXG4gICAgZ2V0RW5jb2Rlcih0eXBlKSB7XG4gICAgICAgIGxldCBlbmNvZGVyID0gdGhpcy4jZW5jb2RlckNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFlbmNvZGVyKSB7XG4gICAgICAgICAgICBlbmNvZGVyID0gdGhpcy4jZ2V0RW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIHRoaXMuI2VuY29kZXJDYWNoZS5zZXQodHlwZSwgZW5jb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgfVxuICAgICNnZXRFbmNvZGVyKHR5cGUpIHtcbiAgICAgICAgLy8gQmFzaWMgZW5jb2RlciB0eXBlIChhZGRyZXNzLCBib29sLCB1aW50MjU2LCBldGMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKC4qKShcXHg1YihcXGQqKVxceDVkKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJ0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBjb25zdCBzdWJFbmNvZGVyID0gdGhpcy5nZXRFbmNvZGVyKHN1YnR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KCFtYXRjaFszXSB8fCBwYXJzZUludChtYXRjaFszXSkgPT09IHZhbHVlLmxlbmd0aCwgYGFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7cGFyc2VJbnQobWF0Y2hbM10pfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB2YWx1ZS5tYXAoc3ViRW5jb2Rlcik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2Z1bGxUeXBlcy5oYXMoc3VidHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm1hcChrZWNjYWsyNTYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGNvbmNhdChyZXN1bHQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMudHlwZXNbdHlwZV07XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRUeXBlID0gaWQodGhpcy4jZnVsbFR5cGVzLmdldCh0eXBlKSk7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZmllbGRzLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2Z1bGxUeXBlcy5oYXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhbHVlcy51bnNoaWZ0KGVuY29kZWRUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY2F0KHZhbHVlcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxsIHR5cGUgZm9yICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGVuY29kZVR5cGUobmFtZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNmdWxsVHlwZXMuZ2V0KG5hbWUpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQsIGB1bmtub3duIHR5cGU6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlICUldHlwZSUlLlxuICAgICAqL1xuICAgIGVuY29kZURhdGEodHlwZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBoYXNoIG9mICUldmFsdWUlJSBmb3IgdGhlIHR5cGUgb2YgJSVuYW1lJSUuXG4gICAgICovXG4gICAgaGFzaFN0cnVjdChuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHRoaXMuZW5jb2RlRGF0YShuYW1lLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxsZWQgZW5jb2RlZCAlJXZhbHVlJSUgZm9yIHRoZSBbW3R5cGVzXV0uXG4gICAgICovXG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZURhdGEodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoIG9mIHRoZSBmdWxseSBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlIFtbdHlwZXNdXS5cbiAgICAgKi9cbiAgICBoYXNoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hTdHJ1Y3QodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgX3Zpc2l0KHR5cGUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodHlwZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXiguKikoXFx4NWIoXFxkKilcXHg1ZCkkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIW1hdGNoWzNdIHx8IHBhcnNlSW50KG1hdGNoWzNdKSA9PT0gdmFsdWUubGVuZ3RoLCBgYXJyYXkgbGVuZ3RoIG1pc21hdGNoOyBleHBlY3RlZCBsZW5ndGggJHtwYXJzZUludChtYXRjaFszXSl9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiB0aGlzLl92aXNpdChtYXRjaFsxXSwgdiwgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJ1Y3RcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy50eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoKGFjY3VtLCB7IG5hbWUsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gdGhpcy5fdmlzaXQodHlwZSwgdmFsdWVbbmFtZV0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGB1bmtub3duIHR5cGU6ICR7dHlwZX1gLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDYWxsICUlY2FsYmFjayUlIGZvciBlYWNoIHZhbHVlIGluICUldmFsdWUlJSwgcGFzc2luZyB0aGUgdHlwZSBhbmRcbiAgICAgKiAgY29tcG9uZW50IHdpdGhpbiAlJXZhbHVlJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyB1c2VmdWwgZm9yIHJlcGxhY2luZyBhZGRyZXNzZXMgb3Igb3RoZXIgdHJhbnNmb3JtYXRpb24gdGhhdFxuICAgICAqICBtYXkgYmUgZGVzaXJlZCBvbiBlYWNoIGNvbXBvbmVudCwgYmFzZWQgb24gaXRzIHR5cGUuXG4gICAgICovXG4gICAgdmlzaXQodmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdCh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqVHlwZWREYXRhRW5jb2RlcioqIGZvciAlJXR5cGVzJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZERhdGFFbmNvZGVyKHR5cGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcHJpbWFyeSB0eXBlIGZvciAlJXR5cGVzJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFByaW1hcnlUeXBlKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLnByaW1hcnlUeXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoZWQgc3RydWN0IGZvciAlJXZhbHVlJSUgdXNpbmcgJSV0eXBlcyUlIGFuZCAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaFN0cnVjdChuYW1lLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykuaGFzaFN0cnVjdChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGRvbWFpbiBoYXNoIGZvciAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBoYXNoRG9tYWluKGRvbWFpbikge1xuICAgICAgICBjb25zdCBkb21haW5GaWVsZHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRvbWFpbikge1xuICAgICAgICAgICAgaWYgKGRvbWFpbltuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gZG9tYWluRmllbGRUeXBlc1tuYW1lXTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGUsIGBpbnZhbGlkIHR5cGVkLWRhdGEgZG9tYWluIGtleTogJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcImRvbWFpblwiLCBkb21haW4pO1xuICAgICAgICAgICAgZG9tYWluRmllbGRzLnB1c2goeyBuYW1lLCB0eXBlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRvbWFpbkZpZWxkcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGEubmFtZSkgLSBkb21haW5GaWVsZE5hbWVzLmluZGV4T2YoYi5uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmhhc2hTdHJ1Y3QoXCJFSVA3MTJEb21haW5cIiwgeyBFSVA3MTJEb21haW46IGRvbWFpbkZpZWxkcyB9LCBkb21haW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxseSBlbmNvZGVkIFtbbGluay1laXAtNzEyXV0gJSV2YWx1ZSUlIGZvciAlJXR5cGVzJSUgd2l0aCAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBlbmNvZGUoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgICAgICBcIjB4MTkwMVwiLFxuICAgICAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoRG9tYWluKGRvbWFpbiksXG4gICAgICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2godmFsdWUpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoIG9mIHRoZSBmdWxseSBlbmNvZGVkIFtbbGluay1laXAtNzEyXV0gJSV2YWx1ZSUlIGZvciAlJXR5cGVzJSUgd2l0aCAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBoYXNoKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYoVHlwZWREYXRhRW5jb2Rlci5lbmNvZGUoZG9tYWluLCB0eXBlcywgdmFsdWUpKTtcbiAgICB9XG4gICAgLy8gUmVwbGFjZXMgYWxsIGFkZHJlc3MgdHlwZXMgd2l0aCBFTlMgbmFtZXMgd2l0aCB0aGVpciBsb29rZWQgdXAgYWRkcmVzc1xuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRvIHRoZSB2YWx1ZSBmcm9tIHJlc29sdmluZyBhbGwgYWRkcmVzc2VzIGluICUldmFsdWUlJSBmb3JcbiAgICAgKiAlJXR5cGVzJSUgYW5kIHRoZSAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyByZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIHJlc29sdmVOYW1lKSB7XG4gICAgICAgIC8vIE1ha2UgYSBjb3B5IHRvIGlzb2xhdGUgaXQgZnJvbSB0aGUgb2JqZWN0IHBhc3NlZCBpblxuICAgICAgICBkb21haW4gPSBPYmplY3QuYXNzaWduKHt9LCBkb21haW4pO1xuICAgICAgICAvLyBBbGxvdyBwYXNzaW5nIG51bGwgdG8gaWdub3JlIHZhbHVlXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRvbWFpbikge1xuICAgICAgICAgICAgaWYgKGRvbWFpbltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZG9tYWluW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9vayB1cCBhbGwgRU5TIG5hbWVzXG4gICAgICAgIGNvbnN0IGVuc0NhY2hlID0ge307XG4gICAgICAgIC8vIERvIHdlIG5lZWQgdG8gbG9vayB1cCB0aGUgZG9tYWluJ3MgdmVyaWZ5aW5nQ29udHJhY3Q/XG4gICAgICAgIGlmIChkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgJiYgIWlzSGV4U3RyaW5nKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCwgMjApKSB7XG4gICAgICAgICAgICBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdID0gXCIweFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGFyZSBnb2luZyB0byB1c2UgdGhlIGVuY29kZXIgdG8gdmlzaXQgYWxsIHRoZSBiYXNlIHZhbHVlc1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcbiAgICAgICAgLy8gR2V0IGEgbGlzdCBvZiBhbGwgdGhlIGFkZHJlc3Nlc1xuICAgICAgICBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiAhaXNIZXhTdHJpbmcodmFsdWUsIDIwKSkge1xuICAgICAgICAgICAgICAgIGVuc0NhY2hlW3ZhbHVlXSA9IFwiMHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIExvb2t1cCBlYWNoIG5hbWVcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGVuc0NhY2hlKSB7XG4gICAgICAgICAgICBlbnNDYWNoZVtuYW1lXSA9IGF3YWl0IHJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGRvbWFpbiB2ZXJpZnlpbmdDb250cmFjdCBpZiBuZWVkZWRcbiAgICAgICAgaWYgKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCAmJiBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdKSB7XG4gICAgICAgICAgICBkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgPSBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcGxhY2UgYWxsIEVOUyBuYW1lcyB3aXRoIHRoZWlyIGFkZHJlc3NcbiAgICAgICAgdmFsdWUgPSBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiBlbnNDYWNoZVt2YWx1ZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5zQ2FjaGVbdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgZG9tYWluLCB2YWx1ZSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgSlNPTi1lbmNvZGVkIHBheWxvYWQgZXhwZWN0ZWQgYnkgbm9kZXMgd2hpY2ggaW1wbGVtZW50XG4gICAgICogIHRoZSBKU09OLVJQQyBbW2xpbmstZWlwLTcxMl1dIG1ldGhvZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UGF5bG9hZChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZG9tYWluIGZpZWxkc1xuICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmhhc2hEb21haW4oZG9tYWluKTtcbiAgICAgICAgLy8gRGVyaXZlIHRoZSBFSVA3MTJEb21haW4gU3RydWN0IHJlZmVyZW5jZSB0eXBlXG4gICAgICAgIGNvbnN0IGRvbWFpblZhbHVlcyA9IHt9O1xuICAgICAgICBjb25zdCBkb21haW5UeXBlcyA9IFtdO1xuICAgICAgICBkb21haW5GaWVsZE5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9tYWluW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb21haW5WYWx1ZXNbbmFtZV0gPSBkb21haW5DaGVja3NbbmFtZV0odmFsdWUpO1xuICAgICAgICAgICAgZG9tYWluVHlwZXMucHVzaCh7IG5hbWUsIHR5cGU6IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcbiAgICAgICAgY29uc3QgdHlwZXNXaXRoRG9tYWluID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZXMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlc1dpdGhEb21haW4uRUlQNzEyRG9tYWluID09IG51bGwsIFwidHlwZXMgbXVzdCBub3QgY29udGFpbiBFSVA3MTJEb21haW4gdHlwZVwiLCBcInR5cGVzLkVJUDcxMkRvbWFpblwiLCB0eXBlcyk7XG4gICAgICAgIHR5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW4gPSBkb21haW5UeXBlcztcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRhdGEgc3RydWN0dXJlcyBhbmQgdHlwZXNcbiAgICAgICAgZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZXM6IHR5cGVzV2l0aERvbWFpbixcbiAgICAgICAgICAgIGRvbWFpbjogZG9tYWluVmFsdWVzLFxuICAgICAgICAgICAgcHJpbWFyeVR5cGU6IGVuY29kZXIucHJpbWFyeVR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBieXRlc1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKikvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShnZXRCeXRlcyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1aW50IG9yIGludFxuICAgICAgICAgICAgICAgIGlmICh0eXBlLm1hdGNoKC9edT9pbnQvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QmlnSW50KHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgYWRkcmVzcyB1c2VkIHRvIHNpZ24gdGhlIHR5cGVkIGRhdGEgZm9yIHRoZSAlJXNpZ25hdHVyZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5VHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCBzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gcmVjb3ZlckFkZHJlc3MoVHlwZWREYXRhRW5jb2Rlci5oYXNoKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSwgc2lnbmF0dXJlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVkLWRhdGEuanMubWFwIiwiLyoqXG4gKiAgQSBmcmFnbWVudCBpcyBhIHNpbmdsZSBpdGVtIGZyb20gYW4gQUJJLCB3aGljaCBtYXkgcmVwcmVzZW50IGFueSBvZjpcbiAqXG4gKiAgLSBbRnVuY3Rpb25zXShGdW5jdGlvbkZyYWdtZW50KVxuICogIC0gW0V2ZW50c10oRXZlbnRGcmFnbWVudClcbiAqICAtIFtDb25zdHJ1Y3RvcnNdKENvbnN0cnVjdG9yRnJhZ21lbnQpXG4gKiAgLSBDdXN0b20gW0Vycm9yc10oRXJyb3JGcmFnbWVudClcbiAqICAtIFtGYWxsYmFjayBvciBSZWNlaXZlXShGYWxsYmFja0ZyYWdtZW50KSBmdW5jdGlvbnNcbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS9hYmkvYWJpLWNvZGVyOkZyYWdtZW50cyAgW2Fib3V0LWZyYWdtZW50c11cbiAqL1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGFzc2VydCwgYXNzZXJ0UHJpdmF0ZSwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbjtcbi8vIFsgXCJhXCIsIFwiYlwiIF0gPT4geyBcImFcIjogMSwgXCJiXCI6IDEgfVxuZnVuY3Rpb24gc2V0aWZ5KGl0ZW1zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgIGl0ZW1zLmZvckVhY2goKGspID0+IHJlc3VsdC5hZGQoaykpO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG59XG5jb25zdCBfa3dWaXNpYkRlcGxveSA9IFwiZXh0ZXJuYWwgcHVibGljIHBheWFibGVcIjtcbmNvbnN0IEt3VmlzaWJEZXBsb3kgPSBzZXRpZnkoX2t3VmlzaWJEZXBsb3kuc3BsaXQoXCIgXCIpKTtcbi8vIFZpc2liaWxpdHkgS2V5d29yZHNcbmNvbnN0IF9rd1Zpc2liID0gXCJjb25zdGFudCBleHRlcm5hbCBpbnRlcm5hbCBwYXlhYmxlIHByaXZhdGUgcHVibGljIHB1cmUgdmlld1wiO1xuY29uc3QgS3dWaXNpYiA9IHNldGlmeShfa3dWaXNpYi5zcGxpdChcIiBcIikpO1xuY29uc3QgX2t3VHlwZXMgPSBcImNvbnN0cnVjdG9yIGVycm9yIGV2ZW50IGZhbGxiYWNrIGZ1bmN0aW9uIHJlY2VpdmUgc3RydWN0XCI7XG5jb25zdCBLd1R5cGVzID0gc2V0aWZ5KF9rd1R5cGVzLnNwbGl0KFwiIFwiKSk7XG5jb25zdCBfa3dNb2RpZmllcnMgPSBcImNhbGxkYXRhIG1lbW9yeSBzdG9yYWdlIHBheWFibGUgaW5kZXhlZFwiO1xuY29uc3QgS3dNb2RpZmllcnMgPSBzZXRpZnkoX2t3TW9kaWZpZXJzLnNwbGl0KFwiIFwiKSk7XG5jb25zdCBfa3dPdGhlciA9IFwidHVwbGUgcmV0dXJuc1wiO1xuLy8gQWxsIEtleXdvcmRzXG5jb25zdCBfa2V5d29yZHMgPSBbX2t3VHlwZXMsIF9rd01vZGlmaWVycywgX2t3T3RoZXIsIF9rd1Zpc2liXS5qb2luKFwiIFwiKTtcbmNvbnN0IEtleXdvcmRzID0gc2V0aWZ5KF9rZXl3b3Jkcy5zcGxpdChcIiBcIikpO1xuLy8gU2luZ2xlIGNoYXJhY3RlciB0b2tlbnNcbmNvbnN0IFNpbXBsZVRva2VucyA9IHtcbiAgICBcIihcIjogXCJPUEVOX1BBUkVOXCIsIFwiKVwiOiBcIkNMT1NFX1BBUkVOXCIsXG4gICAgXCJbXCI6IFwiT1BFTl9CUkFDS0VUXCIsIFwiXVwiOiBcIkNMT1NFX0JSQUNLRVRcIixcbiAgICBcIixcIjogXCJDT01NQVwiLCBcIkBcIjogXCJBVFwiXG59O1xuLy8gUGFyc2VyIHJlZ2V4ZXMgdG8gY29uc3VtZSB0aGUgbmV4dCB0b2tlblxuY29uc3QgcmVnZXhXaGl0ZXNwYWNlUHJlZml4ID0gbmV3IFJlZ0V4cChcIl4oXFxcXHMqKVwiKTtcbmNvbnN0IHJlZ2V4TnVtYmVyUHJlZml4ID0gbmV3IFJlZ0V4cChcIl4oWzAtOV0rKVwiKTtcbmNvbnN0IHJlZ2V4SWRQcmVmaXggPSBuZXcgUmVnRXhwKFwiXihbYS16QS1aJF9dW2EtekEtWjAtOSRfXSopXCIpO1xuLy8gUGFyc2VyIHJlZ2V4cyB0byBjaGVjayB2YWxpZGl0eVxuY29uc3QgcmVnZXhJZCA9IG5ldyBSZWdFeHAoXCJeKFthLXpBLVokX11bYS16QS1aMC05JF9dKikkXCIpO1xuY29uc3QgcmVnZXhUeXBlID0gbmV3IFJlZ0V4cChcIl4oYWRkcmVzc3xib29sfGJ5dGVzKFswLTldKil8c3RyaW5nfHU/aW50KFswLTldKikpJFwiKTtcbmNsYXNzIFRva2VuU3RyaW5nIHtcbiAgICAjb2Zmc2V0O1xuICAgICN0b2tlbnM7XG4gICAgZ2V0IG9mZnNldCgpIHsgcmV0dXJuIHRoaXMuI29mZnNldDsgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLiN0b2tlbnMubGVuZ3RoIC0gdGhpcy4jb2Zmc2V0OyB9XG4gICAgY29uc3RydWN0b3IodG9rZW5zKSB7XG4gICAgICAgIHRoaXMuI29mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuI3Rva2VucyA9IHRva2Vucy5zbGljZSgpO1xuICAgIH1cbiAgICBjbG9uZSgpIHsgcmV0dXJuIG5ldyBUb2tlblN0cmluZyh0aGlzLiN0b2tlbnMpOyB9XG4gICAgcmVzZXQoKSB7IHRoaXMuI29mZnNldCA9IDA7IH1cbiAgICAjc3ViVG9rZW5TdHJpbmcoZnJvbSA9IDAsIHRvID0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHRoaXMuI3Rva2Vucy5zbGljZShmcm9tLCB0bykubWFwKCh0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShPYmplY3QuYXNzaWduKHt9LCB0LCB7XG4gICAgICAgICAgICAgICAgbWF0Y2g6ICh0Lm1hdGNoIC0gZnJvbSksXG4gICAgICAgICAgICAgICAgbGlua0JhY2s6ICh0LmxpbmtCYWNrIC0gZnJvbSksXG4gICAgICAgICAgICAgICAgbGlua05leHQ6ICh0LmxpbmtOZXh0IC0gZnJvbSksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4sIGlmIGl0IGlzIGEga2V5d29yZCBpbiBhbGxvd2VkOyB0aHJvd3MgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBvcEtleXdvcmQoYWxsb3dlZCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKHRvcC50eXBlICE9PSBcIktFWVdPUkRcIiB8fCAhYWxsb3dlZC5oYXModG9wLnRleHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIGtleXdvcmQgJHt0b3AudGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3AoKS50ZXh0O1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmV4dCB0b2tlbiBpZiBpdCBpcyBgdHlwZWA7IHRocm93cyBpZiBvdXQgb2YgdG9rZW5zXG4gICAgcG9wVHlwZSh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLnBlZWsoKS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7dHlwZX07IGdvdCAke0pTT04uc3RyaW5naWZ5KHRoaXMucGVlaygpKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3AoKS50ZXh0O1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIGEgXCIoXCIgVE9LRU5TIFwiKVwiXG4gICAgcG9wUGFyZW4oKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiT1BFTl9QQVJFTlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgc3RhcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jc3ViVG9rZW5TdHJpbmcodGhpcy4jb2Zmc2V0ICsgMSwgdG9wLm1hdGNoICsgMSk7XG4gICAgICAgIHRoaXMuI29mZnNldCA9IHRvcC5tYXRjaCArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIGl0ZW1zIHdpdGhpbiBcIihcIiBJVEVNMSBcIixcIiBJVEVNMiBcIixcIiAuLi4gXCIpXCJcbiAgICBwb3BQYXJhbXMoKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiT1BFTl9QQVJFTlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgc3RhcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLiNvZmZzZXQgPCB0b3AubWF0Y2ggLSAxKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5wZWVrKCkubGlua05leHQ7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLiNzdWJUb2tlblN0cmluZyh0aGlzLiNvZmZzZXQgKyAxLCBsaW5rKSk7XG4gICAgICAgICAgICB0aGlzLiNvZmZzZXQgPSBsaW5rO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI29mZnNldCA9IHRvcC5tYXRjaCArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHRvcCBUb2tlbiwgdGhyb3dpbmcgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBlZWsoKSB7XG4gICAgICAgIGlmICh0aGlzLiNvZmZzZXQgPj0gdGhpcy4jdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3V0LW9mLWJvdW5kc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jdG9rZW5zW3RoaXMuI29mZnNldF07XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG5leHQgdmFsdWUsIGlmIGl0IGlzIGEga2V5d29yZCBpbiBgYWxsb3dlZGBcbiAgICBwZWVrS2V5d29yZChhbGxvd2VkKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVla1R5cGUoXCJLRVlXT1JEXCIpO1xuICAgICAgICByZXR1cm4gKHRvcCAhPSBudWxsICYmIGFsbG93ZWQuaGFzKHRvcCkpID8gdG9wIDogbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4gaWYgaXQgaXMgYHR5cGVgXG4gICAgcGVla1R5cGUodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICByZXR1cm4gKHRvcC50eXBlID09PSB0eXBlKSA/IHRvcC50ZXh0IDogbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbmV4dCB0b2tlbjsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwb3AoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucGVlaygpO1xuICAgICAgICB0aGlzLiNvZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy4jb2Zmc2V0OyBpIDwgdGhpcy4jdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuI3Rva2Vuc1tpXTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKGAke3Rva2VuLnR5cGV9OiR7dG9rZW4udGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYDxUb2tlblN0cmluZyAke3Rva2Vucy5qb2luKFwiIFwiKX0+YDtcbiAgICB9XG59XG5mdW5jdGlvbiBsZXgodGV4dCkge1xuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGNvbnN0IHRocm93RXJyb3IgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICBjb25zdCB0b2tlbiA9IChvZmZzZXQgPCB0ZXh0Lmxlbmd0aCkgPyBKU09OLnN0cmluZ2lmeSh0ZXh0W29mZnNldF0pIDogXCIkRU9JXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0b2tlbiAke3Rva2VufSBhdCAke29mZnNldH06ICR7bWVzc2FnZX1gKTtcbiAgICB9O1xuICAgIGxldCBicmFja2V0cyA9IFtdO1xuICAgIGxldCBjb21tYXMgPSBbXTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICB3aGlsZSAob2Zmc2V0IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIGFueSBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgbGV0IGN1ciA9IHRleHQuc3Vic3RyaW5nKG9mZnNldCk7XG4gICAgICAgIGxldCBtYXRjaCA9IGN1ci5tYXRjaChyZWdleFdoaXRlc3BhY2VQcmVmaXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgICAgICBjdXIgPSB0ZXh0LnN1YnN0cmluZyhvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VuID0geyBkZXB0aDogYnJhY2tldHMubGVuZ3RoLCBsaW5rQmFjazogLTEsIGxpbmtOZXh0OiAtMSwgbWF0Y2g6IC0xLCB0eXBlOiBcIlwiLCB0ZXh0OiBcIlwiLCBvZmZzZXQsIHZhbHVlOiAtMSB9O1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGxldCB0eXBlID0gKFNpbXBsZVRva2Vuc1tjdXJbMF1dIHx8IFwiXCIpO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgdG9rZW4udHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gY3VyWzBdO1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJPUEVOX1BBUkVOXCIpIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBjb21tYXMucHVzaCh0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFwiQ0xPU0VfUEFSRU5cIikge1xuICAgICAgICAgICAgICAgIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihcIm5vIG1hdGNoaW5nIG9wZW4gYnJhY2tldFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW4ubWF0Y2ggPSBicmFja2V0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2VuLm1hdGNoXSkubWF0Y2ggPSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB0b2tlbi5kZXB0aC0tO1xuICAgICAgICAgICAgICAgIHRva2VuLmxpbmtCYWNrID0gY29tbWFzLnBvcCgpO1xuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW4ubGlua0JhY2tdKS5saW5rTmV4dCA9IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJDT01NQVwiKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ubGlua0JhY2sgPSBjb21tYXMucG9wKCk7XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbi5saW5rQmFja10pLmxpbmtOZXh0ID0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgY29tbWFzLnB1c2godG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJPUEVOX0JSQUNLRVRcIikge1xuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIkJSQUNLRVRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQ0xPU0VfQlJBQ0tFVFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBDTE9TRV9CUkFDS0VUXG4gICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IHRva2Vucy5wb3AoKS50ZXh0O1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgPT09IFwiTlVNQkVSXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0b2tlbnMucG9wKCkudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gdmFsdWUgKyBzdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKS52YWx1ZSA9IGdldE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSAhPT0gXCJCUkFDS0VUXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBvcGVuaW5nIGJyYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKS50ZXh0ICs9IHN1ZmZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4SWRQcmVmaXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIG9mZnNldCArPSB0b2tlbi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChLZXl3b3Jkcy5oYXModG9rZW4udGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJLRVlXT1JEXCI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4udGV4dC5tYXRjaChyZWdleFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiVFlQRVwiO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiSURcIjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4TnVtYmVyUHJlZml4KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gXCJOVU1CRVJcIjtcbiAgICAgICAgICAgIG9mZnNldCArPSB0b2tlbi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCB0b2tlbiAke0pTT04uc3RyaW5naWZ5KGN1clswXSl9IGF0IHBvc2l0aW9uICR7b2Zmc2V0fWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHRva2Vucy5tYXAoKHQpID0+IE9iamVjdC5mcmVlemUodCkpKTtcbn1cbi8vIENoZWNrIG9ubHkgb25lIG9mIGBhbGxvd2VkYCBpcyBpbiBgc2V0YFxuZnVuY3Rpb24gYWxsb3dTaW5nbGUoc2V0LCBhbGxvd2VkKSB7XG4gICAgbGV0IGluY2x1ZGVkID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYWxsb3dlZC5rZXlzKCkpIHtcbiAgICAgICAgaWYgKHNldC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgaW5jbHVkZWQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbmNsdWRlZC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29uZmxpY3RpbmcgdHlwZXM6ICR7aW5jbHVkZWQuam9pbihcIiwgXCIpfWApO1xuICAgIH1cbn1cbi8vIEZ1bmN0aW9ucyB0byBwcm9jZXNzIGEgU29saWRpdHkgU2lnbmF0dXJlIFRva2VuU3RyaW5nIGZyb20gbGVmdC10by1yaWdodCBmb3IuLi5cbi8vIC4uLnRoZSBuYW1lIHdpdGggYW4gb3B0aW9uYWwgdHlwZSwgcmV0dXJuaW5nIHRoZSBuYW1lXG5mdW5jdGlvbiBjb25zdW1lTmFtZSh0eXBlLCB0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLnBlZWtLZXl3b3JkKEt3VHlwZXMpKSB7XG4gICAgICAgIGNvbnN0IGtleXdvcmQgPSB0b2tlbnMucG9wKCkudGV4dDtcbiAgICAgICAgaWYgKGtleXdvcmQgIT09IHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHt0eXBlfSwgZ290ICR7a2V5d29yZH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zLnBvcFR5cGUoXCJJRFwiKTtcbn1cbi8vIC4uLmFsbCBrZXl3b3JkcyBtYXRjaGluZyBhbGxvd2VkLCByZXR1cm5pbmcgdGhlIGtleXdvcmRzXG5mdW5jdGlvbiBjb25zdW1lS2V5d29yZHModG9rZW5zLCBhbGxvd2VkKSB7XG4gICAgY29uc3Qga2V5d29yZHMgPSBuZXcgU2V0KCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3Qga2V5d29yZCA9IHRva2Vucy5wZWVrVHlwZShcIktFWVdPUkRcIik7XG4gICAgICAgIGlmIChrZXl3b3JkID09IG51bGwgfHwgKGFsbG93ZWQgJiYgIWFsbG93ZWQuaGFzKGtleXdvcmQpKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICBpZiAoa2V5d29yZHMuaGFzKGtleXdvcmQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZSBrZXl3b3JkczogJHtKU09OLnN0cmluZ2lmeShrZXl3b3JkKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBrZXl3b3Jkcy5hZGQoa2V5d29yZCk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGtleXdvcmRzKTtcbn1cbi8vIC4uLmFsbCB2aXNpYmlsaXR5IGtleXdvcmRzLCByZXR1cm5pbmcgdGhlIGNvYWxlc2NlZCBtdXRhYmlsaXR5XG5mdW5jdGlvbiBjb25zdW1lTXV0YWJpbGl0eSh0b2tlbnMpIHtcbiAgICBsZXQgbW9kaWZpZXJzID0gY29uc3VtZUtleXdvcmRzKHRva2VucywgS3dWaXNpYik7XG4gICAgLy8gRGV0ZWN0IGNvbmZsaWN0aW5nIG1vZGlmaWVyc1xuICAgIGFsbG93U2luZ2xlKG1vZGlmaWVycywgc2V0aWZ5KFwiY29uc3RhbnQgcGF5YWJsZSBub25wYXlhYmxlXCIuc3BsaXQoXCIgXCIpKSk7XG4gICAgYWxsb3dTaW5nbGUobW9kaWZpZXJzLCBzZXRpZnkoXCJwdXJlIHZpZXcgcGF5YWJsZSBub25wYXlhYmxlXCIuc3BsaXQoXCIgXCIpKSk7XG4gICAgLy8gUHJvY2VzcyBtdXRhYmlsaXR5IHN0YXRlc1xuICAgIGlmIChtb2RpZmllcnMuaGFzKFwidmlld1wiKSkge1xuICAgICAgICByZXR1cm4gXCJ2aWV3XCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwicHVyZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJwdXJlXCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwicGF5YWJsZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJwYXlhYmxlXCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwibm9ucGF5YWJsZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJub25wYXlhYmxlXCI7XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgbGVnYWN5IGBjb25zdGFudGAgbGFzdFxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwiY29uc3RhbnRcIikpIHtcbiAgICAgICAgcmV0dXJuIFwidmlld1wiO1xuICAgIH1cbiAgICByZXR1cm4gXCJub25wYXlhYmxlXCI7XG59XG4vLyAuLi5hIHBhcmFtZXRlciBsaXN0LCByZXR1cm5pbmcgdGhlIFBhcmFtVHlwZSBsaXN0XG5mdW5jdGlvbiBjb25zdW1lUGFyYW1zKHRva2VucywgYWxsb3dJbmRleGVkKSB7XG4gICAgcmV0dXJuIHRva2Vucy5wb3BQYXJhbXMoKS5tYXAoKHQpID0+IFBhcmFtVHlwZS5mcm9tKHQsIGFsbG93SW5kZXhlZCkpO1xufVxuLy8gLi4uYSBnYXMgbGltaXQsIHJldHVybmluZyBhIEJpZ051bWJlciBvciBudWxsIGlmIG5vbmVcbmZ1bmN0aW9uIGNvbnN1bWVHYXModG9rZW5zKSB7XG4gICAgaWYgKHRva2Vucy5wZWVrVHlwZShcIkFUXCIpKSB7XG4gICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgaWYgKHRva2Vucy5wZWVrVHlwZShcIk5VTUJFUlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh0b2tlbnMucG9wKCkudGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBnYXNcIik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29uc3VtZUVvaSh0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgdG9rZW5zOiAke3Rva2Vucy50b1N0cmluZygpfWApO1xuICAgIH1cbn1cbmNvbnN0IHJlZ2V4QXJyYXlUeXBlID0gbmV3IFJlZ0V4cCgvXiguKilcXFsoWzAtOV0qKVxcXSQvKTtcbmZ1bmN0aW9uIHZlcmlmeUJhc2ljVHlwZSh0eXBlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4VHlwZSk7XG4gICAgYXNzZXJ0QXJndW1lbnQobWF0Y2gsIFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICBpZiAodHlwZSA9PT0gXCJ1aW50XCIpIHtcbiAgICAgICAgcmV0dXJuIFwidWludDI1NlwiO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJpbnRcIikge1xuICAgICAgICByZXR1cm4gXCJpbnQyNTZcIjtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgIC8vIGJ5dGVzWFhcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChsZW5ndGggIT09IDAgJiYgbGVuZ3RoIDw9IDMyLCBcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgLy8gaW50WFggb3IgdWludFhYXG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHNpemUgIT09IDAgJiYgc2l6ZSA8PSAyNTYgJiYgKHNpemUgJSA4KSA9PT0gMCwgXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbn1cbi8vIE1ha2UgdGhlIEZyYWdtZW50IGNvbnN0cnVjdG9ycyBlZmZlY3RpdmVseSBwcml2YXRlXG5jb25zdCBfZ3VhcmQgPSB7fTtcbmNvbnN0IGludGVybmFsID0gU3ltYm9sLmZvcihcIl9ldGhlcnNfaW50ZXJuYWxcIik7XG5jb25zdCBQYXJhbVR5cGVJbnRlcm5hbCA9IFwiX1BhcmFtVHlwZUludGVybmFsXCI7XG5jb25zdCBFcnJvckZyYWdtZW50SW50ZXJuYWwgPSBcIl9FcnJvckludGVybmFsXCI7XG5jb25zdCBFdmVudEZyYWdtZW50SW50ZXJuYWwgPSBcIl9FdmVudEludGVybmFsXCI7XG5jb25zdCBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwgPSBcIl9Db25zdHJ1Y3RvckludGVybmFsXCI7XG5jb25zdCBGYWxsYmFja0ZyYWdtZW50SW50ZXJuYWwgPSBcIl9GYWxsYmFja0ludGVybmFsXCI7XG5jb25zdCBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwgPSBcIl9GdW5jdGlvbkludGVybmFsXCI7XG5jb25zdCBTdHJ1Y3RGcmFnbWVudEludGVybmFsID0gXCJfU3RydWN0SW50ZXJuYWxcIjtcbi8qKlxuICogIEVhY2ggaW5wdXQgYW5kIG91dHB1dCBvZiBhIFtbRnJhZ21lbnRdXSBpcyBhbiBBcnJheSBvZiAqKlBhcmFtVHlwZSoqLlxuICovXG5leHBvcnQgY2xhc3MgUGFyYW1UeXBlIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGxvY2FsIG5hbWUgb2YgdGhlIHBhcmFtZXRlciAob3IgYGBcIlwiYGAgaWYgdW5ib3VuZClcbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbHkgcXVhbGlmaWVkIHR5cGUgKGUuZy4gYGBcImFkZHJlc3NcImBgLCBgYFwidHVwbGUoYWRkcmVzcylcImBgLFxuICAgICAqICBgYFwidWludDI1NlszXVtdXCJgYClcbiAgICAgKi9cbiAgICB0eXBlO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmFzZSB0eXBlIChlLmcuIGBgXCJhZGRyZXNzXCJgYCwgYGBcInR1cGxlXCJgYCwgYGBcImFycmF5XCJgYClcbiAgICAgKi9cbiAgICBiYXNlVHlwZTtcbiAgICAvKipcbiAgICAgKiAgVHJ1ZSBpZiB0aGUgcGFyYW1ldGVycyBpcyBpbmRleGVkLlxuICAgICAqXG4gICAgICogIEZvciBub24taW5kZXhhYmxlIHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgaW5kZXhlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbXBvbmVudHMgZm9yIHRoZSB0dXBsZS5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLXR1cGxlIHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgY29tcG9uZW50cztcbiAgICAvKipcbiAgICAgKiAgVGhlIGFycmF5IGxlbmd0aCwgb3IgYGAtMWBgIGZvciBkeW5hbWljLWxlbmd0aGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLWFycmF5IHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgYXJyYXlMZW5ndGg7XG4gICAgLyoqXG4gICAgICogIFRoZSB0eXBlIG9mIGVhY2ggY2hpbGQgaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogIEZvciBub24tYXJyYXkgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBhcnJheUNoaWxkcmVuO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcG9uZW50cywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pIHtcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIlBhcmFtVHlwZVwiKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBQYXJhbVR5cGVJbnRlcm5hbCB9KTtcbiAgICAgICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSBPYmplY3QuZnJlZXplKGNvbXBvbmVudHMuc2xpY2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIGlmIChhcnJheUxlbmd0aCA9PSBudWxsIHx8IGFycmF5Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcnJheUxlbmd0aCAhPSBudWxsIHx8IGFycmF5Q2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgbmFtZSwgdHlwZSwgYmFzZVR5cGUsIGluZGV4ZWQsIGNvbXBvbmVudHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSxcbiAgICAgKlxuICAgICAqICBgYHNpZ2hhc2hcIiA9PiBcIih1aW50MjU2LGFkZHJlc3MpXCJgYFxuICAgICAqXG4gICAgICogIGBgXCJtaW5pbWFsXCIgPT4gXCJ0dXBsZSh1aW50MjU2LGFkZHJlc3MpIGluZGV4ZWRcImBgXG4gICAgICpcbiAgICAgKiAgYGBcImZ1bGxcIiA9PiBcInR1cGxlKHVpbnQyNTYgZm9vLCBhZGRyZXNzIGJhcikgaW5kZXhlZCBiYXpcImBgXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lIHx8IFwiXCI7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoXCJqc29uXCIpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnR5cGUgKz0gYFskeyh0aGlzLmFycmF5TGVuZ3RoIDwgMCA/IFwiXCIgOiBTdHJpbmcodGhpcy5hcnJheUxlbmd0aCkpfV1gO1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICgodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSA/IFwidHVwbGVcIiA6IHRoaXMudHlwZSksXG4gICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRoaXMuaW5kZXhlZCkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmluZGV4ZWQgPSB0aGlzLmluZGV4ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cy5tYXAoKGMpID0+IEpTT04ucGFyc2UoYy5mb3JtYXQoZm9ybWF0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBgWyR7KHRoaXMuYXJyYXlMZW5ndGggPCAwID8gXCJcIiA6IFN0cmluZyh0aGlzLmFycmF5TGVuZ3RoKSl9XWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIoXCIgKyB0aGlzLmNvbXBvbmVudHMubWFwKChjb21wKSA9PiBjb21wLmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IFwiZnVsbFwiKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBpbmRleGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBcImZ1bGxcIiAmJiB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhbiBBcnJheSB0eXBlLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGdhdXJkIGVuc3VyaW5nIHRoYXQgW1thcnJheUNoaWxkcmVuXV1cbiAgICAgKiAgYW5kIFtbYXJyYXlMZW5ndGhdXSBhcmUgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhc2VUeXBlID09PSBcImFycmF5XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGEgVHVwbGUgdHlwZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbY29tcG9uZW50c11dXG4gICAgICogIGlzIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzVHVwbGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhbiBJbmRleGFibGUgdHlwZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbaW5kZXhlZF1dXG4gICAgICogIGlzIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzSW5kZXhhYmxlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW5kZXhlZCAhPSBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdhbGtzIHRoZSAqKlBhcmFtVHlwZSoqIHdpdGggJSV2YWx1ZSUlLCBjYWxsaW5nICUlcHJvY2VzcyUlXG4gICAgICogIG9uIGVhY2ggdHlwZSwgZGVzdHJ1Y3RpbmcgdGhlICUldmFsdWUlJSByZWN1cnNpdmVseS5cbiAgICAgKi9cbiAgICB3YWxrKHZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXJyYXkgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hcnJheUxlbmd0aCAhPT0gLTEgJiYgdmFsdWUubGVuZ3RoICE9PSB0aGlzLmFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gKF90aGlzLmFycmF5Q2hpbGRyZW4ud2Fsayh2LCBwcm9jZXNzKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHVwbGUgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodiwgaSkgPT4gKF90aGlzLmNvbXBvbmVudHNbaV0ud2Fsayh2LCBwcm9jZXNzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9jZXNzKHRoaXMudHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAjd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2Vzcywgc2V0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhcnJheSB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5TGVuZ3RoICE9PSAtMSAmJiB2YWx1ZS5sZW5ndGggIT09IHRoaXMuYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSB0aGlzLmFycmF5Q2hpbGRyZW47XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5zbGljZSgpO1xuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkVHlwZS4jd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2VzcywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0VmFsdWUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHM7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBvYmplY3QgaW50byBhbiBhcnJheVxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgKHZhbHVlKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb21wb25lbnRzLm1hcCgocGFyYW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdXNlIG9iamVjdCB2YWx1ZSB3aXRoIHVubmFtZWQgY29tcG9uZW50c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXJhbS5uYW1lIGluIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIHZhbHVlIGZvciBjb21wb25lbnQgJHtwYXJhbS5uYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtwYXJhbS5uYW1lXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNbaW5kZXhdLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRWYWx1ZShyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3ModGhpcy50eXBlLCB2YWx1ZSk7XG4gICAgICAgIGlmIChyZXN1bHQudGhlbikge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyBzZXRWYWx1ZShhd2FpdCByZXN1bHQpOyB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdhbGtzIHRoZSAqKlBhcmFtVHlwZSoqIHdpdGggJSV2YWx1ZSUlLCBhc3luY2hyb25vdXNseSBjYWxsaW5nXG4gICAgICogICUlcHJvY2VzcyUlIG9uIGVhY2ggdHlwZSwgZGVzdHJ1Y3RpbmcgdGhlICUldmFsdWUlJSByZWN1cnNpdmVseS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiBiZSB1c2VkIHRvIHJlc29sdmUgRU5TIG5hZXMgYnkgd2Fsa2luZyBhbmQgcmVzb2x2aW5nIGVhY2hcbiAgICAgKiAgYGBcImFkZHJlc3NcImBgIHR5cGUuXG4gICAgICovXG4gICAgYXN5bmMgd2Fsa0FzeW5jKHZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFt2YWx1ZV07XG4gICAgICAgIHRoaXMuI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipQYXJhbVR5cGUqKiBmb3IgJSVvYmolJS5cbiAgICAgKlxuICAgICAqICBJZiAlJWFsbG93SW5kZXhlZCUlIHRoZW4gdGhlIGBgaW5kZXhlZGBgIGtleXdvcmQgaXMgcGVybWl0dGVkLFxuICAgICAqICBvdGhlcndpc2UgdGhlIGBgaW5kZXhlZGBgIGtleXdvcmQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmosIGFsbG93SW5kZXhlZCkge1xuICAgICAgICBpZiAoUGFyYW1UeXBlLmlzUGFyYW1UeXBlKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyYW1UeXBlLmZyb20obGV4KG9iaiksIGFsbG93SW5kZXhlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHBhcmFtIHR5cGVcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBcIlwiLCBiYXNlVHlwZSA9IFwiXCI7XG4gICAgICAgICAgICBsZXQgY29tcHMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJ0dXBsZVwiXSkpLmhhcyhcInR1cGxlXCIpIHx8IG9iai5wZWVrVHlwZShcIk9QRU5fUEFSRU5cIikpIHtcbiAgICAgICAgICAgICAgICAvLyBUdXBsZVxuICAgICAgICAgICAgICAgIGJhc2VUeXBlID0gXCJ0dXBsZVwiO1xuICAgICAgICAgICAgICAgIGNvbXBzID0gb2JqLnBvcFBhcmFtcygpLm1hcCgodCkgPT4gUGFyYW1UeXBlLmZyb20odCkpO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBgdHVwbGUoJHtjb21wcy5tYXAoKGMpID0+IGMuZm9ybWF0KCkpLmpvaW4oXCIsXCIpfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsXG4gICAgICAgICAgICAgICAgdHlwZSA9IHZlcmlmeUJhc2ljVHlwZShvYmoucG9wVHlwZShcIlRZUEVcIikpO1xuICAgICAgICAgICAgICAgIGJhc2VUeXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBBcnJheVxuICAgICAgICAgICAgbGV0IGFycmF5Q2hpbGRyZW4gPSBudWxsO1xuICAgICAgICAgICAgbGV0IGFycmF5TGVuZ3RoID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChvYmoubGVuZ3RoICYmIG9iai5wZWVrVHlwZShcIkJSQUNLRVRcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBicmFja2V0ID0gb2JqLnBvcCgpOyAvL2FycmF5c1tpXTtcbiAgICAgICAgICAgICAgICBhcnJheUNoaWxkcmVuID0gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIFwiXCIsIHR5cGUsIGJhc2VUeXBlLCBudWxsLCBjb21wcywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGFycmF5TGVuZ3RoID0gYnJhY2tldC52YWx1ZTtcbiAgICAgICAgICAgICAgICB0eXBlICs9IGJyYWNrZXQudGV4dDtcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IFwiYXJyYXlcIjtcbiAgICAgICAgICAgICAgICBjb21wcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaW5kZXhlZCA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBrZXl3b3JkcyA9IGNvbnN1bWVLZXl3b3JkcyhvYmosIEt3TW9kaWZpZXJzKTtcbiAgICAgICAgICAgIGlmIChrZXl3b3Jkcy5oYXMoXCJpbmRleGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSAob2JqLnBlZWtUeXBlKFwiSURcIikgPyBvYmoucG9wKCkudGV4dCA6IFwiXCIpO1xuICAgICAgICAgICAgaWYgKG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsZWZ0b3ZlciB0b2tlbnNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUsIHR5cGUsIGJhc2VUeXBlLCBpbmRleGVkLCBjb21wcywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSBvYmoubmFtZTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIW5hbWUgfHwgKHR5cGVvZiAobmFtZSkgPT09IFwic3RyaW5nXCIgJiYgbmFtZS5tYXRjaChyZWdleElkKSksIFwiaW52YWxpZCBuYW1lXCIsIFwib2JqLm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGxldCBpbmRleGVkID0gb2JqLmluZGV4ZWQ7XG4gICAgICAgIGlmIChpbmRleGVkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFsbG93SW5kZXhlZCwgXCJwYXJhbWV0ZXIgY2Fubm90IGJlIGluZGV4ZWRcIiwgXCJvYmouaW5kZXhlZFwiLCBvYmouaW5kZXhlZCk7XG4gICAgICAgICAgICBpbmRleGVkID0gISFpbmRleGVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gb2JqLnR5cGU7XG4gICAgICAgIGxldCBhcnJheU1hdGNoID0gdHlwZS5tYXRjaChyZWdleEFycmF5VHlwZSk7XG4gICAgICAgIGlmIChhcnJheU1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBhcnJheUxlbmd0aCA9IHBhcnNlSW50KGFycmF5TWF0Y2hbMl0gfHwgXCItMVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5Q2hpbGRyZW4gPSBQYXJhbVR5cGUuZnJvbSh7XG4gICAgICAgICAgICAgICAgdHlwZTogYXJyYXlNYXRjaFsxXSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBvYmouY29tcG9uZW50c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUgfHwgXCJcIiwgdHlwZSwgXCJhcnJheVwiLCBpbmRleGVkLCBudWxsLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwidHVwbGVcIiB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJ0dXBsZShcIiAvKiBmaXg6ICkgKi8pIHx8IHR5cGUuc3RhcnRzV2l0aChcIihcIiAvKiBmaXg6ICkgKi8pKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wcyA9IChvYmouY29tcG9uZW50cyAhPSBudWxsKSA/IG9iai5jb21wb25lbnRzLm1hcCgoYykgPT4gUGFyYW1UeXBlLmZyb20oYykpIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHR1cGxlID0gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUgfHwgXCJcIiwgdHlwZSwgXCJ0dXBsZVwiLCBpbmRleGVkLCBjb21wcywgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAvLyBAVE9ETzogdXNlIGxleGVyIHRvIHZhbGlkYXRlIGFuZCBub3JtYWxpemUgdHlwZVxuICAgICAgICAgICAgcmV0dXJuIHR1cGxlO1xuICAgICAgICB9XG4gICAgICAgIHR5cGUgPSB2ZXJpZnlCYXNpY1R5cGUob2JqLnR5cGUpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUgfHwgXCJcIiwgdHlwZSwgdHlwZSwgaW5kZXhlZCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgKipQYXJhbVR5cGUqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNQYXJhbVR5cGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IFBhcmFtVHlwZUludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBbiBhYnN0cmFjdCBjbGFzcyB0byByZXByZXNlbnQgQW4gaW5kaXZpZHVhbCBmcmFnbWVudCBmcm9tIGEgcGFyc2UgQUJJLlxuICovXG5leHBvcnQgY2xhc3MgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZSBvZiB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGlucHV0cyBmb3IgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGlucHV0cztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdHlwZSwgaW5wdXRzKSB7XG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJGcmFnbWVudFwiKTtcbiAgICAgICAgaW5wdXRzID0gT2JqZWN0LmZyZWV6ZShpbnB1dHMuc2xpY2UoKSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyB0eXBlLCBpbnB1dHMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRnJhZ21lbnQqKiBmb3IgJSVvYmolJSwgd2ljaCBjYW4gYmUgYW55IHN1cHBvcnRlZFxuICAgICAqICBBQkkgZnJnYW1lbnQgdHlwZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gVHJ5IHBhcnNpbmcgSlNPTi4uLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBGcmFnbWVudC5mcm9tKEpTT04ucGFyc2Uob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICAvLyAuLi5vdGhlcndpc2UsIHVzZSB0aGUgaHVtYW4tcmVhZGFibGUgbGV4ZXJcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIC8vIEh1bWFuLXJlYWRhYmxlIEFCSSAoYWxyZWFkeSBsZXhlZClcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBvYmoucGVla0tleXdvcmQoS3dUeXBlcyk7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjogcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6IHJldHVybiBFdmVudEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVjZWl2ZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFsbGJhY2tGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6IHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RydWN0XCI6IHJldHVybiBTdHJ1Y3RGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChvYmopID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBKU09OIEFCSVxuICAgICAgICAgICAgc3dpdGNoIChvYmoudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOiByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHJldHVybiBFcnJvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjogcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWxsYmFja1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWNlaXZlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWxsYmFja0ZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjogcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJ1Y3RcIjogcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYHVuc3VwcG9ydGVkIHR5cGU6ICR7b2JqLnR5cGV9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJGcmFnbWVudC5mcm9tXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIGZyZ2FtZW50IG9iamVjdFwiLCBcIm9ialwiLCBvYmopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbQ29uc3RydWN0b3JGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0NvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhbiBbW0Vycm9yRnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFcnJvcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gW1tFdmVudEZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzRXZlbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgW1tGdW5jdGlvbkZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgW1tTdHJ1Y3RGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1N0cnVjdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gU3RydWN0RnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gYWJzdHJhY3QgY2xhc3MgdG8gcmVwcmVzZW50IEFuIGluZGl2aWR1YWwgZnJhZ21lbnRcbiAqICB3aGljaCBoYXMgYSBuYW1lIGZyb20gYSBwYXJzZSBBQkkuXG4gKi9cbmV4cG9ydCBjbGFzcyBOYW1lZEZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdHlwZSwgbmFtZSwgaW5wdXRzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCB0eXBlLCBpbnB1dHMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiICYmIG5hbWUubWF0Y2gocmVnZXhJZCksIFwiaW52YWxpZCBpZGVudGlmaWVyXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgaW5wdXRzID0gT2JqZWN0LmZyZWV6ZShpbnB1dHMuc2xpY2UoKSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGpvaW5QYXJhbXMoZm9ybWF0LCBwYXJhbXMpIHtcbiAgICByZXR1cm4gXCIoXCIgKyBwYXJhbXMubWFwKChwKSA9PiBwLmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IFwiZnVsbFwiKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKVwiO1xufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgLy9DdXN0b20gRXJyb3IvLy5cbiAqL1xuZXhwb3J0IGNsYXNzIEVycm9yRnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgaW5wdXRzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcImVycm9yXCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRXJyb3JGcmFnbWVudEludGVybmFsIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEN1c3RvbSBFcnJvciBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBpZCh0aGlzLmZvcm1hdChcInNpZ2hhc2hcIikpLnN1YnN0cmluZygwLCAxMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZnJhZ21lbnQgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJlcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5hbWUgKyBqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipFcnJvckZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChFcnJvckZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZXJyb3JcIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3JGcmFnbWVudChfZ3VhcmQsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvckZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFuXG4gICAgICogICoqRXJyb3JGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBFcnJvckZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhbiBFdmVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50RnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgV2hldGhlciB0aGlzIGV2ZW50IGlzIGFub255bW91cy5cbiAgICAgKi9cbiAgICBhbm9ueW1vdXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIGlucHV0cywgYW5vbnltb3VzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcImV2ZW50XCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRXZlbnRGcmFnbWVudEludGVybmFsIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYW5vbnltb3VzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEV2ZW50IHRvcGljIGhhc2guXG4gICAgICovXG4gICAgZ2V0IHRvcGljSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIGlkKHRoaXMuZm9ybWF0KFwic2lnaGFzaFwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZXZlbnQgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJldmVudFwiLFxuICAgICAgICAgICAgICAgIGFub255bW91czogdGhpcy5hbm9ueW1vdXMsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpKSA9PiBKU09OLnBhcnNlKGkuZm9ybWF0KGZvcm1hdCkpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcImV2ZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubmFtZSArIGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cykpO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIiAmJiB0aGlzLmFub255bW91cykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJhbm9ueW1vdXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgdG9waWMgaGFzaCBmb3IgYW4gZXZlbnQgd2l0aCAlJW5hbWUlJSBhbmQgJSVwYXJhbXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0VG9waWNIYXNoKG5hbWUsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSAocGFyYW1zIHx8IFtdKS5tYXAoKHApID0+IFBhcmFtVHlwZS5mcm9tKHApKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBuZXcgRXZlbnRGcmFnbWVudChfZ3VhcmQsIG5hbWUsIHBhcmFtcywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQudG9waWNIYXNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkV2ZW50RnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKEV2ZW50RnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGV2ZW50IGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcImV2ZW50XCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaiwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBhbm9ueW1vdXMgPSAhIWNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJhbm9ueW1vdXNcIl0pKS5oYXMoXCJhbm9ueW1vdXNcIik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50RnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBpbnB1dHMsIGFub255bW91cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudEZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcCgocCkgPT4gUGFyYW1UeXBlLmZyb20ocCwgdHJ1ZSkpIDogW10sICEhb2JqLmFub255bW91cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFuXG4gICAgICogICoqRXZlbnRGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBFdmVudEZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIGNvbnN0cnVjdG9yLlxuICovXG5leHBvcnQgY2xhc3MgQ29uc3RydWN0b3JGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgV2hldGhlciB0aGUgY29uc3RydWN0b3IgY2FuIHJlY2VpdmUgYW4gZW5kb3dtZW50LlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNvbW1lbmRlZCBnYXMgbGltaXQgZm9yIGRlcGxveW1lbnQgb3IgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2FzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB0eXBlLCBpbnB1dHMsIHBheWFibGUsIGdhcykge1xuICAgICAgICBzdXBlcihndWFyZCwgdHlwZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwYXlhYmxlLCBnYXMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29uc3RydWN0b3IgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGFzc2VydChmb3JtYXQgIT0gbnVsbCAmJiBmb3JtYXQgIT09IFwic2lnaGFzaFwiLCBcImNhbm5vdCBmb3JtYXQgYSBjb25zdHJ1Y3RvciBmb3Igc2lnaGFzaFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmb3JtYXQoc2lnaGFzaClcIiB9KTtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogKHRoaXMucGF5YWJsZSA/IFwicGF5YWJsZVwiIDogXCJ1bmRlZmluZWRcIiksXG4gICAgICAgICAgICAgICAgcGF5YWJsZTogdGhpcy5wYXlhYmxlLFxuICAgICAgICAgICAgICAgIGdhczogKCh0aGlzLmdhcyAhPSBudWxsKSA/IHRoaXMuZ2FzIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtgY29uc3RydWN0b3Ike2pvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cyl9YF07XG4gICAgICAgIGlmICh0aGlzLnBheWFibGUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwicGF5YWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYEAke3RoaXMuZ2FzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipDb25zdHJ1Y3RvckZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChDb25zdHJ1Y3RvckZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBjb25zdHVjdG9yIGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJjb25zdHJ1Y3RvclwiXSkpO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgY29uc3QgcGF5YWJsZSA9ICEhY29uc3VtZUtleXdvcmRzKG9iaiwgS3dWaXNpYkRlcGxveSkuaGFzKFwicGF5YWJsZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGdhcyA9IGNvbnN1bWVHYXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3JGcmFnbWVudChfZ3VhcmQsIFwiY29uc3RydWN0b3JcIiwgaW5wdXRzLCBwYXlhYmxlLCBnYXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3JGcmFnbWVudChfZ3VhcmQsIFwiY29uc3RydWN0b3JcIiwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdLCAhIW9iai5wYXlhYmxlLCAob2JqLmdhcyAhPSBudWxsKSA/IG9iai5nYXMgOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxuICAgICAqICAqKkNvbnN0cnVjdG9yRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gQ29uc3RydWN0b3JGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBtZXRob2QuXG4gKi9cbmV4cG9ydCBjbGFzcyBGYWxsYmFja0ZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgZnVuY3Rpb24gY2FuIGJlIHNlbnQgdmFsdWUgZHVyaW5nIGludm9jYXRpb24uXG4gICAgICovXG4gICAgcGF5YWJsZTtcbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgaW5wdXRzLCBwYXlhYmxlKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcImZhbGxiYWNrXCIsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRmFsbGJhY2tGcmFnbWVudEludGVybmFsIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcGF5YWJsZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmYWxsYmFjayBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9ICgodGhpcy5pbnB1dHMubGVuZ3RoID09PSAwKSA/IFwicmVjZWl2ZVwiIDogXCJmYWxsYmFja1wiKTtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlTXV0YWJpbGl0eSA9ICh0aGlzLnBheWFibGUgPyBcInBheWFibGVcIiA6IFwibm9ucGF5YWJsZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IHR5cGUsIHN0YXRlTXV0YWJpbGl0eSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dHlwZX0oKSR7dGhpcy5wYXlhYmxlID8gXCIgcGF5YWJsZVwiIDogXCJcIn1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkZhbGxiYWNrRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKEZhbGxiYWNrRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGZhbGxiYWNrIGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yT2JqID0gb2JqLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCB0b3BJc1ZhbGlkID0gb2JqLnBlZWtLZXl3b3JkKHNldGlmeShbXCJmYWxsYmFja1wiLCBcInJlY2VpdmVcIl0pKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHRvcElzVmFsaWQsIFwidHlwZSBtdXN0IGJlIGZhbGxiYWNrIG9yIHJlY2VpdmVcIiwgXCJvYmpcIiwgZXJyb3JPYmopO1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG9iai5wb3BLZXl3b3JkKHNldGlmeShbXCJmYWxsYmFja1wiLCBcInJlY2VpdmVcIl0pKTtcbiAgICAgICAgICAgIC8vIHJlY2VpdmUoKVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwicmVjZWl2ZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlucHV0cy5sZW5ndGggPT09IDAsIGByZWNlaXZlIGNhbm5vdCBoYXZlIGFyZ3VtZW50c2AsIFwib2JqLmlucHV0c1wiLCBpbnB1dHMpO1xuICAgICAgICAgICAgICAgIGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJwYXlhYmxlXCJdKSk7XG4gICAgICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIFtdLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZhbGxiYWNrKCkgW3BheWFibGVdXG4gICAgICAgICAgICAvLyBmYWxsYmFjayhieXRlcykgW3BheWFibGVdIHJldHVybnMgKGJ5dGVzKVxuICAgICAgICAgICAgbGV0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5wdXRzLmxlbmd0aCA9PT0gMSAmJiBpbnB1dHNbMF0udHlwZSA9PT0gXCJieXRlc1wiLCBcImludmFsaWQgZmFsbGJhY2sgaW5wdXRzXCIsIFwib2JqLmlucHV0c1wiLCBpbnB1dHMubWFwKChpKSA9PiBpLmZvcm1hdChcIm1pbmltYWxcIikpLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSBbUGFyYW1UeXBlLmZyb20oXCJieXRlc1wiKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtdXRhYmlsaXR5ID0gY29uc3VtZU11dGFiaWxpdHkob2JqKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG11dGFiaWxpdHkgPT09IFwibm9ucGF5YWJsZVwiIHx8IG11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiLCBcImZhbGxiYWNrIGNhbm5vdCBiZSBjb25zdGFudHNcIiwgXCJvYmouc3RhdGVNdXRhYmlsaXR5XCIsIG11dGFiaWxpdHkpO1xuICAgICAgICAgICAgaWYgKGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJyZXR1cm5zXCJdKSkuaGFzKFwicmV0dXJuc1wiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQob3V0cHV0cy5sZW5ndGggPT09IDEgJiYgb3V0cHV0c1swXS50eXBlID09PSBcImJ5dGVzXCIsIFwiaW52YWxpZCBmYWxsYmFjayBvdXRwdXRzXCIsIFwib2JqLm91dHB1dHNcIiwgb3V0cHV0cy5tYXAoKGkpID0+IGkuZm9ybWF0KFwibWluaW1hbFwiKSkuam9pbihcIiwgXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIGlucHV0cywgbXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJyZWNlaXZlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIFtdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiZmFsbGJhY2tcIikge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gW1BhcmFtVHlwZS5mcm9tKFwiYnl0ZXNcIildO1xuICAgICAgICAgICAgY29uc3QgcGF5YWJsZSA9IChvYmouc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBpbnB1dHMsIHBheWFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZmFsbGJhY2sgZGVzY3JpcHRpb25cIiwgXCJvYmpcIiwgb2JqKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxuICAgICAqICAqKkZhbGxiYWNrRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRmFsbGJhY2tGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBtZXRob2QuXG4gKi9cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbkZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIElmIHRoZSBmdW5jdGlvbiBpcyBjb25zdGFudCAoZS5nLiBgYHB1cmVgYCBvciBgYHZpZXdgYCBmdW5jdGlvbnMpLlxuICAgICAqL1xuICAgIGNvbnN0YW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgcmV0dXJuZWQgdHlwZXMgZm9yIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIG91dHB1dHM7XG4gICAgLyoqXG4gICAgICogIFRoZSBzdGF0ZSBtdXRhYmlsaXR5IChlLmcuIGBgcGF5YWJsZWBgLCBgYG5vbnBheWFibGVgYCwgYGB2aWV3YGBcbiAgICAgKiAgb3IgYGBwdXJlYGApXG4gICAgICovXG4gICAgc3RhdGVNdXRhYmlsaXR5O1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgZnVuY3Rpb24gY2FuIGJlIHNlbnQgdmFsdWUgZHVyaW5nIGludm9jYXRpb24uXG4gICAgICovXG4gICAgcGF5YWJsZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJlY29tbWVuZGVkIGdhcyBsaW1pdCB0byBzZW5kIHdoZW4gY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGdhcztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgc3RhdGVNdXRhYmlsaXR5LCBpbnB1dHMsIG91dHB1dHMsIGdhcykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJmdW5jdGlvblwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgb3V0cHV0cyA9IE9iamVjdC5mcmVlemUob3V0cHV0cy5zbGljZSgpKTtcbiAgICAgICAgY29uc3QgY29uc3RhbnQgPSAoc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBzdGF0ZU11dGFiaWxpdHkgPT09IFwicHVyZVwiKTtcbiAgICAgICAgY29uc3QgcGF5YWJsZSA9IChzdGF0ZU11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGNvbnN0YW50LCBnYXMsIG91dHB1dHMsIHBheWFibGUsIHN0YXRlTXV0YWJpbGl0eSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBGdW5jdGlvbiBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBpZCh0aGlzLmZvcm1hdChcInNpZ2hhc2hcIikpLnN1YnN0cmluZygwLCAxMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBjb25zdGFudDogdGhpcy5jb25zdGFudCxcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICgodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSA/IHRoaXMuc3RhdGVNdXRhYmlsaXR5IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBwYXlhYmxlOiB0aGlzLnBheWFibGUsXG4gICAgICAgICAgICAgICAgZ2FzOiAoKHRoaXMuZ2FzICE9IG51bGwpID8gdGhpcy5nYXMgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpKSA9PiBKU09OLnBhcnNlKGkuZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiB0aGlzLm91dHB1dHMubWFwKChvKSA9PiBKU09OLnBhcnNlKG8uZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5hbWUgKyBqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpKTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnN0YXRlTXV0YWJpbGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRzICYmIHRoaXMub3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChcInJldHVybnNcIik7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goam9pblBhcmFtcyhmb3JtYXQsIHRoaXMub3V0cHV0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChgQCR7dGhpcy5nYXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBzZWxlY3RvciBmb3IgYSBmdW5jdGlvbiB3aXRoICUlbmFtZSUlIGFuZCAlJXBhcmFtcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTZWxlY3RvcihuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkubWFwKChwKSA9PiBQYXJhbVR5cGUuZnJvbShwKSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBcInZpZXdcIiwgcGFyYW1zLCBbXSwgbnVsbCk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5zZWxlY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipGdW5jdGlvbkZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChGdW5jdGlvbkZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBmdW5jdGlvbiBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJmdW5jdGlvblwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgY29uc3QgbXV0YWJpbGl0eSA9IGNvbnN1bWVNdXRhYmlsaXR5KG9iaik7XG4gICAgICAgICAgICBsZXQgb3V0cHV0cyA9IFtdO1xuICAgICAgICAgICAgaWYgKGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJyZXR1cm5zXCJdKSkuaGFzKFwicmV0dXJuc1wiKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBnYXMgPSBjb25zdW1lR2FzKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBtdXRhYmlsaXR5LCBpbnB1dHMsIG91dHB1dHMsIGdhcyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXRlTXV0YWJpbGl0eSA9IG9iai5zdGF0ZU11dGFiaWxpdHk7XG4gICAgICAgIC8vIFVzZSBsZWdhY3kgU29saWRpdHkgQUJJIGxvZ2ljIGlmIHN0YXRlTXV0YWJpbGl0eSBpcyBtaXNzaW5nXG4gICAgICAgIGlmIChzdGF0ZU11dGFiaWxpdHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJwYXlhYmxlXCI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChvYmouY29uc3RhbnQpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwidmlld1wiO1xuICAgICAgICAgICAgICAgIGlmICghb2JqLmNvbnN0YW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChvYmoucGF5YWJsZSkgPT09IFwiYm9vbGVhblwiICYmICFvYmoucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJub25wYXlhYmxlXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgKG9iai5wYXlhYmxlKSA9PT0gXCJib29sZWFuXCIgJiYgIW9iai5wYXlhYmxlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJub25wYXlhYmxlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IHZlcmlmeVN0YXRlIGZvciBzdGF0ZU11dGFiaWxpdHkgKGUuZy4gdGhyb3cgaWZcbiAgICAgICAgLy8gICAgICAgIHBheWFibGU6IGZhbHNlIGJ1dCBzdGF0ZU11dGFiaWxpdHkgaXMgXCJub25wYXlhYmxlXCIpXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25GcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBzdGF0ZU11dGFiaWxpdHksIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSwgb2JqLm91dHB1dHMgPyBvYmoub3V0cHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sIChvYmouZ2FzICE9IG51bGwpID8gb2JqLmdhcyA6IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXG4gICAgICogICoqRnVuY3Rpb25GcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIHN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cnVjdEZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIGlucHV0cykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJzdHJ1Y3RcIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBTdHJ1Y3RGcmFnbWVudEludGVybmFsIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHN0cnVjdCBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqU3RydWN0RnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RydWN0RnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHN0cnVjdCBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJzdHJ1Y3RcIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RydWN0RnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0RnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IGZpeCB0aGlzIHJldHVybiB0eXBlXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxuICAgICAqICAqKlN0cnVjdEZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IFN0cnVjdEZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyYWdtZW50cy5qcy5tYXAiLCIvKipcbiAqICBXaGVuIHNlbmRpbmcgdmFsdWVzIHRvIG9yIHJlY2VpdmluZyB2YWx1ZXMgZnJvbSBhIFtbQ29udHJhY3RdXSwgdGhlXG4gKiAgZGF0YSBpcyBnZW5lcmFsbHkgZW5jb2RlZCB1c2luZyB0aGUgW0FCSSBzdGFuZGFyZF0obGluay1zb2xjLWFiaSkuXG4gKlxuICogIFRoZSBBYmlDb2RlciBwcm92aWRlcyBhIHV0aWxpdHkgdG8gZW5jb2RlIHZhbHVlcyB0byBBQkkgZGF0YSBhbmRcbiAqICBkZWNvZGUgdmFsdWVzIGZyb20gQUJJIGRhdGEuXG4gKlxuICogIE1vc3Qgb2YgdGhlIHRpbWUsIGRldmVsb3BlcnMgc2hvdWxkIGZhdm91ciB0aGUgW1tDb250cmFjdF1dIGNsYXNzLFxuICogIHdoaWNoIGZ1cnRoZXIgYWJzdHJhY3RzIGEgbG90IG9mIHRoZSBmaW5lciBkZXRhaWxzIG9mIEFCSSBkYXRhLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL2FiaS9hYmktY29kZXI6QUJJIEVuY29kaW5nXG4gKi9cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9FdGhlcmV1bS1Db250cmFjdC1BQklcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50Q291bnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBSZWFkZXIsIFdyaXRlciB9IGZyb20gXCIuL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuaW1wb3J0IHsgQWRkcmVzc0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2FkZHJlc3MuanNcIjtcbmltcG9ydCB7IEFycmF5Q29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYXJyYXkuanNcIjtcbmltcG9ydCB7IEJvb2xlYW5Db2RlciB9IGZyb20gXCIuL2NvZGVycy9ib29sZWFuLmpzXCI7XG5pbXBvcnQgeyBCeXRlc0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2J5dGVzLmpzXCI7XG5pbXBvcnQgeyBGaXhlZEJ5dGVzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvZml4ZWQtYnl0ZXMuanNcIjtcbmltcG9ydCB7IE51bGxDb2RlciB9IGZyb20gXCIuL2NvZGVycy9udWxsLmpzXCI7XG5pbXBvcnQgeyBOdW1iZXJDb2RlciB9IGZyb20gXCIuL2NvZGVycy9udW1iZXIuanNcIjtcbmltcG9ydCB7IFN0cmluZ0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL3N0cmluZy5qc1wiO1xuaW1wb3J0IHsgVHVwbGVDb2RlciB9IGZyb20gXCIuL2NvZGVycy90dXBsZS5qc1wiO1xuaW1wb3J0IHsgUGFyYW1UeXBlIH0gZnJvbSBcIi4vZnJhZ21lbnRzLmpzXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBoZXhsaWZ5LCBtYWtlRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8vIGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL3YwLjguMTcvY29udHJvbC1zdHJ1Y3R1cmVzLmh0bWxcbmNvbnN0IFBhbmljUmVhc29ucyA9IG5ldyBNYXAoKTtcblBhbmljUmVhc29ucy5zZXQoMHgwMCwgXCJHRU5FUklDX1BBTklDXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDAxLCBcIkFTU0VSVF9GQUxTRVwiKTtcblBhbmljUmVhc29ucy5zZXQoMHgxMSwgXCJPVkVSRkxPV1wiKTtcblBhbmljUmVhc29ucy5zZXQoMHgxMiwgXCJESVZJREVfQllfWkVST1wiKTtcblBhbmljUmVhc29ucy5zZXQoMHgyMSwgXCJFTlVNX1JBTkdFX0VSUk9SXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDIyLCBcIkJBRF9TVE9SQUdFX0RBVEFcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MzEsIFwiU1RBQ0tfVU5ERVJGTE9XXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDMyLCBcIkFSUkFZX1JBTkdFX0VSUk9SXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDQxLCBcIk9VVF9PRl9NRU1PUllcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4NTEsIFwiVU5JTklUSUFMSVpFRF9GVU5DVElPTl9DQUxMXCIpO1xuY29uc3QgcGFyYW1UeXBlQnl0ZXMgPSBuZXcgUmVnRXhwKC9eYnl0ZXMoWzAtOV0qKSQvKTtcbmNvbnN0IHBhcmFtVHlwZU51bWJlciA9IG5ldyBSZWdFeHAoL14odT9pbnQpKFswLTldKikkLyk7XG5sZXQgZGVmYXVsdENvZGVyID0gbnVsbDtcbmZ1bmN0aW9uIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEsIGFiaUNvZGVyKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBcIm1pc3NpbmcgcmV2ZXJ0IGRhdGFcIjtcbiAgICBsZXQgcmVhc29uID0gbnVsbDtcbiAgICBjb25zdCBpbnZvY2F0aW9uID0gbnVsbDtcbiAgICBsZXQgcmV2ZXJ0ID0gbnVsbDtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBtZXNzYWdlID0gXCJleGVjdXRpb24gcmV2ZXJ0ZWRcIjtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcbiAgICAgICAgZGF0YSA9IGhleGxpZnkoZGF0YSk7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKG5vIGRhdGEgcHJlc2VudDsgbGlrZWx5IHJlcXVpcmUoZmFsc2UpIG9jY3VycmVkXCI7XG4gICAgICAgICAgICByZWFzb24gPSBcInJlcXVpcmUoZmFsc2UpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnl0ZXMubGVuZ3RoICUgMzIgIT09IDQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKGNvdWxkIG5vdCBkZWNvZGUgcmVhc29uOyBpbnZhbGlkIGRhdGEgbGVuZ3RoKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgNCkpID09PSBcIjB4MDhjMzc5YTBcIikge1xuICAgICAgICAgICAgLy8gRXJyb3Ioc3RyaW5nKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZWFzb24gPSBhYmlDb2Rlci5kZWNvZGUoW1wic3RyaW5nXCJdLCBieXRlcy5zbGljZSg0KSlbMF07XG4gICAgICAgICAgICAgICAgcmV2ZXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiRXJyb3Ioc3RyaW5nKVwiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZWFzb25dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGA6ICR7SlNPTi5zdHJpbmdpZnkocmVhc29uKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSByZWFzb247IGludmFsaWQgc3RyaW5nIGRhdGEpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgPT09IFwiMHg0ZTQ4N2I3MVwiKSB7XG4gICAgICAgICAgICAvLyBQYW5pYyh1aW50MjU2KVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gTnVtYmVyKGFiaUNvZGVyLmRlY29kZShbXCJ1aW50MjU2XCJdLCBieXRlcy5zbGljZSg0KSlbMF0pO1xuICAgICAgICAgICAgICAgIHJldmVydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIlBhbmljKHVpbnQyNTYpXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiUGFuaWNcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2NvZGVdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZWFzb24gPSBgUGFuaWMgZHVlIHRvICR7UGFuaWNSZWFzb25zLmdldChjb2RlKSB8fCBcIlVOS05PV05cIn0oJHtjb2RlfSlgO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYDogJHtyZWFzb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKGNvdWxkIG5vdCBkZWNvZGUgcGFuaWMgY29kZSlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKHVua25vd24gY3VzdG9tIGVycm9yKVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgICB0bzogKHR4LnRvID8gZ2V0QWRkcmVzcyh0eC50bykgOiBudWxsKSxcbiAgICAgICAgZGF0YTogKHR4LmRhdGEgfHwgXCIweFwiKVxuICAgIH07XG4gICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZnJvbSA9IGdldEFkZHJlc3ModHguZnJvbSk7XG4gICAgfVxuICAgIHJldHVybiBtYWtlRXJyb3IobWVzc2FnZSwgXCJDQUxMX0VYQ0VQVElPTlwiLCB7XG4gICAgICAgIGFjdGlvbiwgZGF0YSwgcmVhc29uLCB0cmFuc2FjdGlvbiwgaW52b2NhdGlvbiwgcmV2ZXJ0XG4gICAgfSk7XG59XG4vKipcbiAqICBUaGUgKipBYmlDb2RlcioqIGlzIGEgbG93LWxldmVsIGNsYXNzIHJlc3BvbnNpYmxlIGZvciBlbmNvZGluZyBKYXZhU2NyaXB0XG4gKiAgdmFsdWVzIGludG8gYmluYXJ5IGRhdGEgYW5kIGRlY29kaW5nIGJpbmFyeSBkYXRhIGludG8gSmF2YVNjcmlwdCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBBYmlDb2RlciB7XG4gICAgI2dldENvZGVyKHBhcmFtKSB7XG4gICAgICAgIGlmIChwYXJhbS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlDb2Rlcih0aGlzLiNnZXRDb2RlcihwYXJhbS5hcnJheUNoaWxkcmVuKSwgcGFyYW0uYXJyYXlMZW5ndGgsIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbS5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGVDb2RlcihwYXJhbS5jb21wb25lbnRzLm1hcCgoYykgPT4gdGhpcy4jZ2V0Q29kZXIoYykpLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHBhcmFtLmJhc2VUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWRkcmVzc0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5Db2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCeXRlc0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTnVsbENvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHU/aW50WzAtOV0qXG4gICAgICAgIGxldCBtYXRjaCA9IHBhcmFtLnR5cGUubWF0Y2gocGFyYW1UeXBlTnVtYmVyKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiMjU2XCIpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDI1NiAmJiAoc2l6ZSAlIDgpID09PSAwLCBcImludmFsaWQgXCIgKyBtYXRjaFsxXSArIFwiIGJpdCBsZW5ndGhcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE51bWJlckNvZGVyKHNpemUgLyA4LCAobWF0Y2hbMV0gPT09IFwiaW50XCIpLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBieXRlc1swLTldK1xuICAgICAgICBtYXRjaCA9IHBhcmFtLnR5cGUubWF0Y2gocGFyYW1UeXBlQnl0ZXMpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDMyLCBcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaXhlZEJ5dGVzQ29kZXIoc2l6ZSwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCBwYXJhbS50eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgZGVmYXVsdCB2YWx1ZXMgZm9yIHRoZSBnaXZlbiAlJXR5cGVzJSUuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsIGEgYGB1aW50YGAgaXMgYnkgZGVmYXVsdCBgYDBgYCBhbmQgYGBib29sYGBcbiAgICAgKiAgaXMgYnkgZGVmYXVsdCBgYGZhbHNlYGAuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFZhbHVlKHR5cGVzKSB7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSBuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKTtcbiAgICAgICAgcmV0dXJuIGNvZGVyLmRlZmF1bHRWYWx1ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlIHRoZSAlJXZhbHVlcyUlIGFzIHRoZSAlJXR5cGVzJSUgaW50byBBQkkgZGF0YS5cbiAgICAgKlxuICAgICAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXG4gICAgICovXG4gICAgZW5jb2RlKHR5cGVzLCB2YWx1ZXMpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnRDb3VudCh2YWx1ZXMubGVuZ3RoLCB0eXBlcy5sZW5ndGgsIFwidHlwZXMvdmFsdWVzIGxlbmd0aCBtaXNtYXRjaFwiKTtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IChuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKSk7XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IG5ldyBXcml0ZXIoKTtcbiAgICAgICAgY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlci5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRGVjb2RlIHRoZSBBQkkgJSVkYXRhJSUgYXMgdGhlICUldHlwZXMlJSBpbnRvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICBJZiAlJWxvb3NlJSUgZGVjb2RpbmcgaXMgZW5hYmxlZCwgdGhlbiBzdHJpY3QgcGFkZGluZyBpc1xuICAgICAqICBub3QgZW5mb3JjZWQuIFNvbWUgb2xkZXIgdmVyc2lvbnMgb2YgU29saWRpdHkgaW5jb3JyZWN0bHlcbiAgICAgKiAgcGFkZGVkIGV2ZW50IGRhdGEgZW1pdHRlZCBmcm9tIGBgZXh0ZXJuYWxgYCBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgZGVjb2RlKHR5cGVzLCBkYXRhLCBsb29zZSkge1xuICAgICAgICBjb25zdCBjb2RlcnMgPSB0eXBlcy5tYXAoKHR5cGUpID0+IHRoaXMuI2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gbmV3IFR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIik7XG4gICAgICAgIHJldHVybiBjb2Rlci5kZWNvZGUobmV3IFJlYWRlcihkYXRhLCBsb29zZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgc2hhcmVkIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBhIGRlZmF1bHQgW1tBYmlDb2Rlcl1dLlxuICAgICAqXG4gICAgICogIE9uIHRoZSBmaXJzdCBjYWxsLCB0aGUgaW5zdGFuY2UgaXMgY3JlYXRlZCBpbnRlcm5hbGx5LlxuICAgICAqL1xuICAgIHN0YXRpYyBkZWZhdWx0QWJpQ29kZXIoKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Q29kZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVmYXVsdENvZGVyID0gbmV3IEFiaUNvZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRDb2RlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYW4gZXRoZXJzLWNvbXBhdGlibGUgW1tDYWxsRXhjZXB0aW9uRXJyb3JdXSBFcnJvciBmb3IgdGhlIGdpdmVuXG4gICAgICogIHJlc3VsdCAlJWRhdGElJSBmb3IgdGhlIFtbQ2FsbEV4Y2VwdGlvbkFjdGlvbl1dICUlYWN0aW9uJSUgYWdhaW5zdFxuICAgICAqICB0aGUgVHJhbnNhY3Rpb24gJSV0eCUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihhY3Rpb24sIHR4LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihhY3Rpb24sIHR4LCBkYXRhLCBBYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXIoKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJpLWNvZGVyLmpzLm1hcCIsIi8qKlxuICogIFRoZSBJbnRlcmZhY2UgY2xhc3MgaXMgYSBsb3ctbGV2ZWwgY2xhc3MgdGhhdCBhY2NlcHRzIGFuXG4gKiAgQUJJIGFuZCBwcm92aWRlcyBhbGwgdGhlIG5lY2Vzc2FyeSBmdW5jdGlvbmFsaXR5IHRvIGVuY29kZVxuICogIGFuZCBkZWNvZGUgcGFyYW1hdGVycyB0byBhbmQgcmVzdWx0cyBmcm9tIG1ldGhvZHMsIGV2ZW50c1xuICogIGFuZCBlcnJvcnMuXG4gKlxuICogIEl0IGFsc28gcHJvdmlkZXMgc2V2ZXJhbCBjb252ZW5pZW5jZSBtZXRob2RzIHRvIGF1dG9tYXRpY2FsbHlcbiAqICBzZWFyY2ggYW5kIGZpbmQgbWF0Y2hpbmcgdHJhbnNhY3Rpb25zIGFuZCBldmVudHMgdG8gcGFyc2UgdGhlbS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS9hYmk6SW50ZXJmYWNlcyAgW2ludGVyZmFjZXNdXG4gKi9cbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YVNsaWNlLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBnZXRCeXRlc0NvcHksIGhleGxpZnksIHplcm9QYWRCeXRlcywgemVyb1BhZFZhbHVlLCBpc0hleFN0cmluZywgZGVmaW5lUHJvcGVydGllcywgYXNzZXJ0QXJndW1lbnQsIHRvQmVIZXgsIGFzc2VydCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQWJpQ29kZXIgfSBmcm9tIFwiLi9hYmktY29kZXIuanNcIjtcbmltcG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBSZXN1bHQgfSBmcm9tIFwiLi9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanNcIjtcbmltcG9ydCB7IENvbnN0cnVjdG9yRnJhZ21lbnQsIEVycm9yRnJhZ21lbnQsIEV2ZW50RnJhZ21lbnQsIEZyYWdtZW50LCBGdW5jdGlvbkZyYWdtZW50LCBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHMuanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4vdHlwZWQuanNcIjtcbmV4cG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBSZXN1bHQgfTtcbi8qKlxuICogIFdoZW4gdXNpbmcgdGhlIFtbSW50ZXJmYWNlLXBhcnNlTG9nXV0gdG8gYXV0b21hdGljYWxseSBtYXRjaCBhIExvZyB0byBpdHMgZXZlbnRcbiAqICBmb3IgcGFyc2luZywgYSAqKkxvZ0Rlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2dEZXNjcmlwdGlvbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBmcmFnbWVudCBmb3IgdGhlIGBgdG9waWMwYGAuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBFdmVudC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbCBFdmVudCBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgdG9waWMgaGFzaCBmb3IgdGhlIEV2ZW50LlxuICAgICAqL1xuICAgIHRvcGljO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHRoZSBFdmVudCB3aXRoIGBgZW1pdGBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50LCB0b3BpYywgYXJncykge1xuICAgICAgICBjb25zdCBuYW1lID0gZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZnJhZ21lbnQsIG5hbWUsIHNpZ25hdHVyZSwgdG9waWMsIGFyZ3NcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VUcmFuc2FjdGlvbl1dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2hcbiAqICBhIHRyYW5zYWN0aW9uIGRhdGEgdG8gaXRzIGZ1bmN0aW9uIGZvciBwYXJzaW5nLFxuICogIGEgKipUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50IGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRnVuY3Rpb24gZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxsIEZ1bmN0aW9uIHNpZ25hdHVyZSBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBzaWduYXR1cmU7XG4gICAgLyoqXG4gICAgICogIFRoZSBzZWxlY3RvciBmb3IgdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIHNlbGVjdG9yO1xuICAgIC8qKlxuICAgICAqICBUaGUgYGB2YWx1ZWBgIChpbiB3ZWkpIGZyb20gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHZhbHVlO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgc2VsZWN0b3IsIGFyZ3MsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgYXJncywgc2lnbmF0dXJlLCBzZWxlY3RvciwgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VFcnJvcl1dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggYW5cbiAqICBlcnJvciBmb3IgYSBjYWxsIHJlc3VsdCBmb3IgcGFyc2luZywgYW4gKipFcnJvckRlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvckRlc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRXJyb3IuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIEVycm9yIHdpdGggYGByZXZlcnRgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbCBFcnJvciBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VsZWN0b3IgZm9yIHRoZSBFcnJvci5cbiAgICAgKi9cbiAgICBzZWxlY3RvcjtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIHNlbGVjdG9yLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgYXJncywgc2lnbmF0dXJlLCBzZWxlY3RvclxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqICBBbiAqKkluZGV4ZWQqKiBpcyB1c2VkIGFzIGEgdmFsdWUgd2hlbiBhIHZhbHVlIHRoYXQgZG9lcyBub3RcbiAqICBmaXQgd2l0aGluIGEgdG9waWMgKGkuZS4gbm90IGEgZml4ZWQtbGVuZ3RoLCAzMi1ieXRlIHR5cGUpLiBJdFxuICogIGlzIHRoZSBgYGtlY2NhazI1NmBgIG9mIHRoZSB2YWx1ZSwgYW5kIHVzZWQgZm9yIHR5cGVzIHN1Y2ggYXNcbiAqICBhcnJheXMsIHR1cGxlcywgYnl0ZXMgYW5kIHN0cmluZ3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmRleGVkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGBga2VjY2FrMjU2YGAgb2YgdGhlIHZhbHVlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBfaXNJbmRleGVkO1xuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUldmFsdWUlJSBpcyBhbiAqKkluZGV4ZWQqKi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCBmb3IgcHJvcGVydHkgYWNjZXNzLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0luZGV4ZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0luZGV4ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaGFzaCkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgaGFzaCwgX2lzSW5kZXhlZDogdHJ1ZSB9KTtcbiAgICB9XG59XG4vLyBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjEzL2NvbnRyb2wtc3RydWN0dXJlcy5odG1sP2hpZ2hsaWdodD1wYW5pYyNwYW5pYy12aWEtYXNzZXJ0LWFuZC1lcnJvci12aWEtcmVxdWlyZVxuY29uc3QgUGFuaWNSZWFzb25zID0ge1xuICAgIFwiMFwiOiBcImdlbmVyaWMgcGFuaWNcIixcbiAgICBcIjFcIjogXCJhc3NlcnQoZmFsc2UpXCIsXG4gICAgXCIxN1wiOiBcImFyaXRobWV0aWMgb3ZlcmZsb3dcIixcbiAgICBcIjE4XCI6IFwiZGl2aXNpb24gb3IgbW9kdWxvIGJ5IHplcm9cIixcbiAgICBcIjMzXCI6IFwiZW51bSBvdmVyZmxvd1wiLFxuICAgIFwiMzRcIjogXCJpbnZhbGlkIGVuY29kZWQgc3RvcmFnZSBieXRlIGFycmF5IGFjY2Vzc2VkXCIsXG4gICAgXCI0OVwiOiBcIm91dC1vZi1ib3VuZHMgYXJyYXkgYWNjZXNzOyBwb3BwaW5nIG9uIGFuIGVtcHR5IGFycmF5XCIsXG4gICAgXCI1MFwiOiBcIm91dC1vZi1ib3VuZHMgYWNjZXNzIG9mIGFuIGFycmF5IG9yIGJ5dGVzTlwiLFxuICAgIFwiNjVcIjogXCJvdXQgb2YgbWVtb3J5XCIsXG4gICAgXCI4MVwiOiBcInVuaW5pdGlhbGl6ZWQgZnVuY3Rpb25cIixcbn07XG5jb25zdCBCdWlsdGluRXJyb3JzID0ge1xuICAgIFwiMHgwOGMzNzlhMFwiOiB7XG4gICAgICAgIHNpZ25hdHVyZTogXCJFcnJvcihzdHJpbmcpXCIsXG4gICAgICAgIG5hbWU6IFwiRXJyb3JcIixcbiAgICAgICAgaW5wdXRzOiBbXCJzdHJpbmdcIl0sXG4gICAgICAgIHJlYXNvbjogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBgcmV2ZXJ0ZWQgd2l0aCByZWFzb24gc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZSl9YDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIweDRlNDg3YjcxXCI6IHtcbiAgICAgICAgc2lnbmF0dXJlOiBcIlBhbmljKHVpbnQyNTYpXCIsXG4gICAgICAgIG5hbWU6IFwiUGFuaWNcIixcbiAgICAgICAgaW5wdXRzOiBbXCJ1aW50MjU2XCJdLFxuICAgICAgICByZWFzb246IChjb2RlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVhc29uID0gXCJ1bmtub3duIHBhbmljIGNvZGVcIjtcbiAgICAgICAgICAgIGlmIChjb2RlID49IDAgJiYgY29kZSA8PSAweGZmICYmIFBhbmljUmVhc29uc1tjb2RlLnRvU3RyaW5nKCldKSB7XG4gICAgICAgICAgICAgICAgcmVhc29uID0gUGFuaWNSZWFzb25zW2NvZGUudG9TdHJpbmcoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYHJldmVydGVkIHdpdGggcGFuaWMgY29kZSAweCR7Y29kZS50b1N0cmluZygxNil9ICgke3JlYXNvbn0pYDtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqICBBbiBJbnRlcmZhY2UgYWJzdHJhY3RzIG1hbnkgb2YgdGhlIGxvdy1sZXZlbCBkZXRhaWxzIGZvclxuICogIGVuY29kaW5nIGFuZCBkZWNvZGluZyB0aGUgZGF0YSBvbiB0aGUgYmxvY2tjaGFpbi5cbiAqXG4gKiAgQW4gQUJJIHByb3ZpZGVzIGluZm9ybWF0aW9uIG9uIGhvdyB0byBlbmNvZGUgZGF0YSB0byBzZW5kIHRvXG4gKiAgYSBDb250cmFjdCwgaG93IHRvIGRlY29kZSB0aGUgcmVzdWx0cyBhbmQgZXZlbnRzIGFuZCBob3cgdG9cbiAqICBpbnRlcnByZXQgcmV2ZXJ0IGVycm9ycy5cbiAqXG4gKiAgVGhlIEFCSSBjYW4gYmUgc3BlY2lmaWVkIGJ5IFthbnkgc3VwcG9ydGVkIGZvcm1hdF0oSW50ZXJmYWNlQWJpKS5cbiAqL1xuZXhwb3J0IGNsYXNzIEludGVyZmFjZSB7XG4gICAgLyoqXG4gICAgICogIEFsbCB0aGUgQ29udHJhY3QgQUJJIG1lbWJlcnMgKGkuZS4gbWV0aG9kcywgZXZlbnRzLCBlcnJvcnMsIGV0YykuXG4gICAgICovXG4gICAgZnJhZ21lbnRzO1xuICAgIC8qKlxuICAgICAqICBUaGUgQ29udHJhY3QgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgZGVwbG95O1xuICAgIC8qKlxuICAgICAqICBUaGUgRmFsbGJhY2sgbWV0aG9kLCBpZiBhbnkuXG4gICAgICovXG4gICAgZmFsbGJhY2s7XG4gICAgLyoqXG4gICAgICogIElmIHJlY2VpdmluZyBldGhlciBpcyBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgcmVjZWl2ZTtcbiAgICAjZXJyb3JzO1xuICAgICNldmVudHM7XG4gICAgI2Z1bmN0aW9ucztcbiAgICAvLyAgICAjc3RydWN0czogTWFwPHN0cmluZywgU3RydWN0RnJhZ21lbnQ+O1xuICAgICNhYmlDb2RlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEludGVyZmFjZSBmb3IgdGhlICUlZnJhZ21lbnRzJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIGxldCBhYmkgPSBbXTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnRzKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYWJpID0gSlNPTi5wYXJzZShmcmFnbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWJpID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Z1bmN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZXJyb3JzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNldmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vICAgICAgICB0aGlzLiNzdHJ1Y3RzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBmcmFncyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGEgb2YgYWJpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZyYWdzLnB1c2goRnJhZ21lbnQuZnJvbShhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVFXCIsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGZyYWdtZW50czogT2JqZWN0LmZyZWV6ZShmcmFncylcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBmYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGxldCByZWNlaXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2FiaUNvZGVyID0gdGhpcy5nZXRBYmlDb2RlcigpO1xuICAgICAgICAvLyBBZGQgYWxsIGZyYWdtZW50cyBieSB0aGVpciBzaWduYXR1cmVcbiAgICAgICAgdGhpcy5mcmFnbWVudHMuZm9yRWFjaCgoZnJhZ21lbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgYnVja2V0O1xuICAgICAgICAgICAgc3dpdGNoIChmcmFnbWVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlcGxveSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJkdXBsaWNhdGUgZGVmaW5pdGlvbiAtIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZGVwbG95OiBmcmFnbWVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWxsYmFja1wiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghZmFsbGJhY2sgfHwgZnJhZ21lbnQucGF5YWJsZSAhPT0gZmFsbGJhY2sucGF5YWJsZSwgXCJjb25mbGljdGluZyBmYWxsYmFjayBmcmFnbWVudHNcIiwgYGZyYWdtZW50c1ske2luZGV4fV1gLCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjayA9IGZyYWdtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZSA9IGZhbGxiYWNrLnBheWFibGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcIm91dHB1dFwiLCAoPEZ1bmN0aW9uRnJhZ21lbnQ+ZnJhZ21lbnQpLm91dHB1dHMpO1xuICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSB0aGlzLiNmdW5jdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy4jZXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy4jZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUd28gaWRlbnRpY2FsIGVudHJpZXM7IGlnbm9yZSBpdFxuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgICAgICBpZiAoYnVja2V0LmhhcyhzaWduYXR1cmUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVja2V0LnNldChzaWduYXR1cmUsIGZyYWdtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHdlIGRvIG5vdCBoYXZlIGEgY29uc3RydWN0b3IgYWRkIGEgZGVmYXVsdFxuICAgICAgICBpZiAoIXRoaXMuZGVwbG95KSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgICAgICBkZXBsb3k6IENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShcImNvbnN0cnVjdG9yKClcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBmYWxsYmFjaywgcmVjZWl2ZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGVudGlyZSBIdW1hbi1SZWFkYWJsZSBBQkksIGFzIGFuIGFycmF5IG9mXG4gICAgICogIHNpZ25hdHVyZXMsIG9wdGlvbmFsbHkgYXMgJSVtaW5pbWFsJSUgc3RyaW5ncywgd2hpY2hcbiAgICAgKiAgcmVtb3ZlcyBwYXJhbWV0ZXIgbmFtZXMgYW5kIHVubmVjZWVzYXJ5IHNwYWNlcy5cbiAgICAgKi9cbiAgICBmb3JtYXQobWluaW1hbCkge1xuICAgICAgICBjb25zdCBmb3JtYXQgPSAobWluaW1hbCA/IFwibWluaW1hbFwiIDogXCJmdWxsXCIpO1xuICAgICAgICBjb25zdCBhYmkgPSB0aGlzLmZyYWdtZW50cy5tYXAoKGYpID0+IGYuZm9ybWF0KGZvcm1hdCkpO1xuICAgICAgICByZXR1cm4gYWJpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBKU09OLWVuY29kZWQgQUJJLiBUaGlzIGlzIHRoZSBmb3JtYXQgU29saWRpeVxuICAgICAqICByZXR1cm5zLlxuICAgICAqL1xuICAgIGZvcm1hdEpzb24oKSB7XG4gICAgICAgIGNvbnN0IGFiaSA9IHRoaXMuZnJhZ21lbnRzLm1hcCgoZikgPT4gZi5mb3JtYXQoXCJqc29uXCIpKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZS1idW5kbGUgdGhlIEpTT04gZnJhZ21lbnRzIGEgYml0XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhYmkubWFwKChqKSA9PiBKU09OLnBhcnNlKGopKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgQUJJIGNvZGVyIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGVuY29kZSBhbmQgZGVjb2RlIGJpbmFyeVxuICAgICAqICBkYXRhLlxuICAgICAqL1xuICAgIGdldEFiaUNvZGVyKCkge1xuICAgICAgICByZXR1cm4gQWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyKCk7XG4gICAgfVxuICAgIC8vIEZpbmQgYSBmdW5jdGlvbiBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgI2dldEZ1bmN0aW9uKGtleSwgdmFsdWVzLCBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAvLyBTZWxlY3RvclxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgdGhpcy4jZnVuY3Rpb25zLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSBmcmFnbWVudC5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZnVuY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RWYWx1ZSA9ICh2YWx1ZXMubGVuZ3RoID4gMCkgPyB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVMZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBhbGxvd09wdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChUeXBlZC5pc1R5cGVkKGxhc3RWYWx1ZSkgJiYgbGFzdFZhbHVlLnR5cGUgPT09IFwib3ZlcnJpZGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPcHRpb25zID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlTGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IGhhdmUgYSBjb21wYXRpYmxlIGxlbmd0aC4gVGhlIGFyZ3NcbiAgICAgICAgICAgICAgICAvLyBtYXkgY29udGFpbiBhbiBvdmVycmlkZXMsIHNvIHRoZSBtYXRjaCBtYXkgaGF2ZSBuIG9yIG4gLSAxIHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0cyAhPT0gdmFsdWVMZW5ndGggJiYgKCFhbGxvd09wdGlvbnMgfHwgaW5wdXRzICE9PSB2YWx1ZUxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGVzIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIFR5cGVkIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBtYXRjaGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBtYXRjaGluZ1tpXS5pbnB1dHM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYSB0eXBlZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFUeXBlZC5pc1R5cGVkKHZhbHVlc1tqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBwYXN0IHRoZSBpbnB1dHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqID49IGlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2pdLnR5cGUgPT09IFwib3ZlcnJpZGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdmFsdWUgdHlwZSBtYXRjaGVzIHRoZSBpbnB1dCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2pdLnR5cGUgIT09IGlucHV0c1tqXS5iYXNlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgc2luZ2xlIG1hdGNoaW5nIHNpZ25hdHVyZSB3aXRoIGFuIG92ZXJyaWRlcywgYnV0IHRoZVxuICAgICAgICAgICAgLy8gbGFzdCB2YWx1ZSBpcyBzb21ldGhpbmcgdGhhdCBjYW5ub3QgcG9zc2libHkgYmUgYW4gb3B0aW9uc1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMSAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCAhPT0gbWF0Y2hpbmdbMF0uaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RBcmcgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0QXJnID09IG51bGwgfHwgQXJyYXkuaXNBcnJheShsYXN0QXJnKSB8fCB0eXBlb2YgKGxhc3RBcmcpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZSgwLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSAmJiBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoU3RyID0gbWF0Y2hpbmcubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtLmZvcm1hdCgpKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgYW1iaWd1b3VzIGZ1bmN0aW9uIGRlc2NyaXB0aW9uIChpLmUuIG1hdGNoZXMgJHttYXRjaFN0cn0pYCwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNmdW5jdGlvbnMuZ2V0KEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShrZXkpLmZvcm1hdCgpKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgZnVuY3Rpb24gbmFtZSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgZnVuY3Rpb24gc2VsZWN0b3IsXG4gICAgICogIGZ1bmN0aW9uIG5hbWUgb3IgZnVuY3Rpb24gc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqL1xuICAgIGdldEZ1bmN0aW9uTmFtZShrZXkpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLiNnZXRGdW5jdGlvbihrZXksIG51bGwsIGZhbHNlKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnVuY3Rpb25cIiwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50Lm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVrZXklJSAoYSBmdW5jdGlvbiBzZWxlY3RvciwgZnVuY3Rpb24gbmFtZSBvclxuICAgICAqICBmdW5jdGlvbiBzaWduYXR1cmUpIGlzIHByZXNlbnQgaW4gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJbiB0aGUgY2FzZSBvZiBhIGZ1bmN0aW9uIG5hbWUsIHRoZSBuYW1lIG1heSBiZSBhbWJpZ3VvdXMsIHNvXG4gICAgICogIGFjY2Vzc2luZyB0aGUgW1tGdW5jdGlvbkZyYWdtZW50XV0gbWF5IHJlcXVpcmUgcmVmaW5lbWVudC5cbiAgICAgKi9cbiAgICBoYXNGdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRnVuY3Rpb25GcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSBmdW5jdGlvblxuICAgICAqICBzZWxlY3RvciwgZnVuY3Rpb24gbmFtZSBvciBmdW5jdGlvbiBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSWYgJSV2YWx1ZXMlJSBpcyBwcm92aWRlZCwgaXQgd2lsbCB1c2UgdGhlIFR5cGVkIEFQSSB0byBoYW5kbGVcbiAgICAgKiAgYW1iaWd1b3VzIGNhc2VzIHdoZXJlIG11bHRpcGxlIGZ1bmN0aW9ucyBtYXRjaCBieSBuYW1lLlxuICAgICAqXG4gICAgICogIElmIHRoZSAlJWtleSUlIGFuZCAlJXZhbHVlcyUlIGRvIG5vdCByZWZpbmUgdG8gYSBzaW5nbGUgZnVuY3Rpb24gaW5cbiAgICAgKiAgdGhlIEFCSSwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIGdldEZ1bmN0aW9uKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnZXRGdW5jdGlvbihrZXksIHZhbHVlcyB8fCBudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEl0ZXJhdGUgb3ZlciBhbGwgZnVuY3Rpb25zLCBjYWxsaW5nICUlY2FsbGJhY2slJSwgc29ydGVkIGJ5IHRoZWlyIG5hbWUuXG4gICAgICovXG4gICAgZm9yRWFjaEZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gQXJyYXkuZnJvbSh0aGlzLiNmdW5jdGlvbnMua2V5cygpKTtcbiAgICAgICAgbmFtZXMuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgY2FsbGJhY2soKHRoaXMuI2Z1bmN0aW9ucy5nZXQobmFtZSkpLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGaW5kIGFuIGV2ZW50IGRlZmluaXRpb24gYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAodW5sZXNzIGl0IGlzIGFtYmlndW91cylcbiAgICAjZ2V0RXZlbnQoa2V5LCB2YWx1ZXMsIGZvcmNlVW5pcXVlKSB7XG4gICAgICAgIC8vIEV2ZW50VG9waWNcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VG9waWMgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgdGhpcy4jZXZlbnRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50VG9waWMgPT09IGZyYWdtZW50LnRvcGljSGFzaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IGhhdmUgYSBjb21wYXRpYmxlIGxlbmd0aC5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nW2ldLmlucHV0cy5sZW5ndGggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGVzIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIFR5cGVkIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBtYXRjaGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBtYXRjaGluZ1tpXS5pbnB1dHM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYSB0eXBlZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFUeXBlZC5pc1R5cGVkKHZhbHVlc1tqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdmFsdWUgdHlwZSBtYXRjaGVzIHRoZSBpbnB1dCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2pdLnR5cGUgIT09IGlucHV0c1tqXS5iYXNlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPiAxICYmIGZvcmNlVW5pcXVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hTdHIgPSBtYXRjaGluZy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0uZm9ybWF0KCkpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBhbWJpZ3VvdXMgZXZlbnQgZGVzY3JpcHRpb24gKGkuZS4gbWF0Y2hlcyAke21hdGNoU3RyfSlgLCBcImtleVwiLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2V2ZW50cy5nZXQoRXZlbnRGcmFnbWVudC5mcm9tKGtleSkuZm9ybWF0KCkpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBldmVudCBuYW1lIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSB0b3BpYyBoYXNoLFxuICAgICAqICBldmVudCBuYW1lIG9yIGV2ZW50IHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKi9cbiAgICBnZXRFdmVudE5hbWUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy4jZ2V0RXZlbnQoa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGV2ZW50XCIsIFwia2V5XCIsIGtleSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUla2V5JSUgKGFuIGV2ZW50IHRvcGljIGhhc2gsIGV2ZW50IG5hbWUgb3JcbiAgICAgKiAgZXZlbnQgc2lnbmF0dXJlKSBpcyBwcmVzZW50IGluIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSW4gdGhlIGNhc2Ugb2YgYW4gZXZlbnQgbmFtZSwgdGhlIG5hbWUgbWF5IGJlIGFtYmlndW91cywgc29cbiAgICAgKiAgYWNjZXNzaW5nIHRoZSBbW0V2ZW50RnJhZ21lbnRdXSBtYXkgcmVxdWlyZSByZWZpbmVtZW50LlxuICAgICAqL1xuICAgIGhhc0V2ZW50KGtleSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiNnZXRFdmVudChrZXksIG51bGwsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgW1tFdmVudEZyYWdtZW50XV0gZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIHRvcGljIGhhc2gsXG4gICAgICogIGV2ZW50IG5hbWUgb3IgZXZlbnQgc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBldmVudHMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGV2ZW50IGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRFdmVudChrZXksIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0RXZlbnQoa2V5LCB2YWx1ZXMgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGV2ZW50cywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hFdmVudChjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZXZlbnRzLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNldmVudHMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgW1tFcnJvckZyYWdtZW50XV0gZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhbiBlcnJvclxuICAgICAqICBzZWxlY3RvciwgZXJyb3IgbmFtZSBvciBlcnJvciBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSWYgJSV2YWx1ZXMlJSBpcyBwcm92aWRlZCwgaXQgd2lsbCB1c2UgdGhlIFR5cGVkIEFQSSB0byBoYW5kbGVcbiAgICAgKiAgYW1iaWd1b3VzIGNhc2VzIHdoZXJlIG11bHRpcGxlIGVycm9ycyBtYXRjaCBieSBuYW1lLlxuICAgICAqXG4gICAgICogIElmIHRoZSAlJWtleSUlIGFuZCAlJXZhbHVlcyUlIGRvIG5vdCByZWZpbmUgdG8gYSBzaW5nbGUgZXJyb3IgaW5cbiAgICAgKiAgdGhlIEFCSSwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIGdldEVycm9yKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIGlmIChpc0hleFN0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKEJ1aWx0aW5FcnJvcnNbc2VsZWN0b3JdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShCdWlsdGluRXJyb3JzW3NlbGVjdG9yXS5zaWduYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBmcmFnbWVudCBvZiB0aGlzLiNlcnJvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09IGZyYWdtZW50LnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGZyYWdtZW50XSBvZiB0aGlzLiNlcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJFcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBFcnJvcihzdHJpbmcpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIlBhbmljXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShcImVycm9yIFBhbmljKHVpbnQyNTYpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFN0ciA9IG1hdGNoaW5nLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobS5mb3JtYXQoKSkpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGFtYmlndW91cyBlcnJvciBkZXNjcmlwdGlvbiAoaS5lLiAke21hdGNoU3RyfSlgLCBcIm5hbWVcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBrZXkgPSBFcnJvckZyYWdtZW50LmZyb20oa2V5KS5mb3JtYXQoKTtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJFcnJvcihzdHJpbmcpXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBFcnJvcihzdHJpbmcpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09IFwiUGFuaWModWludDI1NilcIikge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShcImVycm9yIFBhbmljKHVpbnQyNTYpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2Vycm9ycy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEl0ZXJhdGUgb3ZlciBhbGwgZXJyb3JzLCBjYWxsaW5nICUlY2FsbGJhY2slJSwgc29ydGVkIGJ5IHRoZWlyIG5hbWUuXG4gICAgICovXG4gICAgZm9yRWFjaEVycm9yKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gQXJyYXkuZnJvbSh0aGlzLiNlcnJvcnMua2V5cygpKTtcbiAgICAgICAgbmFtZXMuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgY2FsbGJhY2soKHRoaXMuI2Vycm9ycy5nZXQobmFtZSkpLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHZXQgdGhlIDQtYnl0ZSBzZWxlY3RvciB1c2VkIGJ5IFNvbGlkaXR5IHRvIGlkZW50aWZ5IGEgZnVuY3Rpb25cbiAgICAvKlxuZ2V0U2VsZWN0b3IoZnJhZ21lbnQ6IEVycm9yRnJhZ21lbnQgfCBGdW5jdGlvbkZyYWdtZW50KTogc3RyaW5nIHtcbiAgICBpZiAodHlwZW9mKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBtYXRjaGVzOiBBcnJheTxGcmFnbWVudD4gPSBbIF07XG5cbiAgICAgICAgdHJ5IHsgbWF0Y2hlcy5wdXNoKHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpKTsgfSBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB0cnkgeyBtYXRjaGVzLnB1c2godGhpcy5nZXRFcnJvcig8c3RyaW5nPmZyYWdtZW50KSk7IH0gY2F0Y2ggKF8pIHsgfVxuXG4gICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVua25vd24gZnJhZ21lbnRcIiwgXCJrZXlcIiwgZnJhZ21lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFtYmlndW91cyBmcmFnbWVudCBtYXRjaGVzIGZ1bmN0aW9uIGFuZCBlcnJvclwiLCBcImtleVwiLCBmcmFnbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFnbWVudCA9IG1hdGNoZXNbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFTbGljZShpZChmcmFnbWVudC5mb3JtYXQoKSksIDAsIDQpO1xufVxuICAgICovXG4gICAgLy8gR2V0IHRoZSAzMi1ieXRlIHRvcGljIGhhc2ggdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhbiBldmVudFxuICAgIC8qXG4gICAgZ2V0RXZlbnRUb3BpYyhmcmFnbWVudDogRXZlbnRGcmFnbWVudCk6IHN0cmluZyB7XG4gICAgICAgIC8vaWYgKHR5cGVvZihmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHsgZnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpOyB9XG4gICAgICAgIHJldHVybiBpZChmcmFnbWVudC5mb3JtYXQoKSk7XG4gICAgfVxuICAgICovXG4gICAgX2RlY29kZVBhcmFtcyhwYXJhbXMsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2FiaUNvZGVyLmRlY29kZShwYXJhbXMsIGRhdGEpO1xuICAgIH1cbiAgICBfZW5jb2RlUGFyYW1zKHBhcmFtcywgdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5lbmNvZGUocGFyYW1zLCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyBhIGBgdHguZGF0YWBgIG9iamVjdCBmb3IgZGVwbG95aW5nIHRoZSBDb250cmFjdCB3aXRoXG4gICAgICogIHRoZSAlJXZhbHVlcyUlIGFzIHRoZSBjb25zdHJ1Y3RvciBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZW5jb2RlRGVwbG95KHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlUGFyYW1zKHRoaXMuZGVwbG95LmlucHV0cywgdmFsdWVzIHx8IFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZXMgdGhlIHJlc3VsdCAlJWRhdGElJSAoZS5nLiBmcm9tIGFuIGBgZXRoX2NhbGxgYCkgZm9yIHRoZVxuICAgICAqICBzcGVjaWZpZWQgZXJyb3IgKHNlZSBbW2dldEVycm9yXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3JcbiAgICAgKiAgJSVrZXklJSkuXG4gICAgICpcbiAgICAgKiAgTW9zdCBkZXZlbG9wZXJzIHNob3VsZCBwcmVmZXIgdGhlIFtbcGFyc2VDYWxsUmVzdWx0XV0gbWV0aG9kIGluc3RlYWQsXG4gICAgICogIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgYSBgYENBTExfRVhDRVBUSU9OYGAgYW5kIHRocm93IHRoZVxuICAgICAqICBjb3JyZXNwb25kaW5nIGVycm9yLlxuICAgICAqL1xuICAgIGRlY29kZUVycm9yUmVzdWx0KGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXJyb3IoZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGVycm9yXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFTbGljZShkYXRhLCAwLCA0KSA9PT0gZnJhZ21lbnQuc2VsZWN0b3IsIGBkYXRhIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCBlcnJvciAke2ZyYWdtZW50Lm5hbWV9LmAsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIGRhdGFTbGljZShkYXRhLCA0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGVzIHRoZSB0cmFuc2FjdGlvbiByZXZlcnQgZGF0YSBmb3IgYSBjYWxsIHJlc3VsdCB0aGF0XG4gICAgICogIHJldmVydGVkIGZyb20gdGhlIHRoZSBDb250cmFjdCB3aXRoIHRoZSBzZXBjaWZpZWQgJSVlcnJvciUlXG4gICAgICogIChzZWUgW1tnZXRFcnJvcl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yICUlZnJhZ21lbnQlJSkgd2l0aCB0aGUgJSV2YWx1ZXMlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZCBieSBtb3N0IGRldmVsb3BlcnMsIHVubGVzcyB0cnlpbmcgdG8gbW9ja1xuICAgICAqICBhIHJlc3VsdCBmcm9tIGEgQ29udHJhY3QuXG4gICAgICovXG4gICAgZW5jb2RlRXJyb3JSZXN1bHQoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBlcnJvclwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgICAgIGZyYWdtZW50LnNlbGVjdG9yLFxuICAgICAgICAgICAgdGhpcy5fZW5jb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgdmFsdWVzIHx8IFtdKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZXMgdGhlICUlZGF0YSUlIGZyb20gYSB0cmFuc2FjdGlvbiBgYHR4LmRhdGFgYCBmb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIHNwZWNpZmllZCAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzXG4gICAgICogIGZvciAlJWZyYWdtZW50JSUpLlxuICAgICAqXG4gICAgICogIE1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcHJlZmVyIHRoZSBbW3BhcnNlVHJhbnNhY3Rpb25dXSBtZXRob2RcbiAgICAgKiAgaW5zdGVhZCwgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVjdCB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZGVjb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFTbGljZShkYXRhLCAwLCA0KSA9PT0gZnJhZ21lbnQuc2VsZWN0b3IsIGBkYXRhIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCBmdW5jdGlvbiAke2ZyYWdtZW50Lm5hbWV9LmAsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIGRhdGFTbGljZShkYXRhLCA0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGVzIHRoZSBgYHR4LmRhdGFgYCBmb3IgYSB0cmFuc2FjdGlvbiB0aGF0IGNhbGxzIHRoZSBmdW5jdGlvblxuICAgICAqICBzcGVjaWZpZWQgKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3IgJSVmcmFnbWVudCUlKSB3aXRoXG4gICAgICogIHRoZSAlJXZhbHVlcyUlLlxuICAgICAqL1xuICAgIGVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICAgICAgZnJhZ21lbnQuc2VsZWN0b3IsXG4gICAgICAgICAgICB0aGlzLl9lbmNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCB2YWx1ZXMgfHwgW10pXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRGVjb2RlcyB0aGUgcmVzdWx0ICUlZGF0YSUlIChlLmcuIGZyb20gYW4gYGBldGhfY2FsbGBgKSBmb3IgdGhlXG4gICAgICogIHNwZWNpZmllZCBmdW5jdGlvbiAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzIGZvclxuICAgICAqICAlJWtleSUlKS5cbiAgICAgKlxuICAgICAqICBNb3N0IGRldmVsb3BlcnMgc2hvdWxkIHByZWZlciB0aGUgW1twYXJzZUNhbGxSZXN1bHRdXSBtZXRob2QgaW5zdGVhZCxcbiAgICAgKiAgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVjdCBhIGBgQ0FMTF9FWENFUFRJT05gYCBhbmQgdGhyb3cgdGhlXG4gICAgICogIGNvcnJlc3BvbmRpbmcgZXJyb3IuXG4gICAgICovXG4gICAgZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZnVuY3Rpb25cIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBcImludmFsaWQgbGVuZ3RoIGZvciByZXN1bHQgZGF0YVwiO1xuICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzQ29weShkYXRhKTtcbiAgICAgICAgaWYgKChieXRlcy5sZW5ndGggJSAzMikgPT09IDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5vdXRwdXRzLCBieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJjb3VsZCBub3QgZGVjb2RlIHJlc3VsdCBkYXRhXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsbCByZXR1cm5lZCBkYXRhIHdpdGggbm8gZXJyb3IsIGJ1dCB0aGUgZGF0YSBpcyBqdW5rXG4gICAgICAgIGFzc2VydChmYWxzZSwgbWVzc2FnZSwgXCJCQURfREFUQVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogaGV4bGlmeShieXRlcyksXG4gICAgICAgICAgICBpbmZvOiB7IG1ldGhvZDogZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlOiBmcmFnbWVudC5mb3JtYXQoKSB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYWtlRXJyb3IoX2RhdGEsIHR4KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xuICAgICAgICBjb25zdCBlcnJvciA9IEFiaUNvZGVyLmdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKFwiY2FsbFwiLCB0eCwgZGF0YSk7XG4gICAgICAgIC8vIE5vdCBhIGJ1aWx0LWluIGVycm9yOyB0cnkgZmluZGluZyBhIGN1c3RvbSBlcnJvclxuICAgICAgICBjb25zdCBjdXN0b21QcmVmaXggPSBcImV4ZWN1dGlvbiByZXZlcnRlZCAodW5rbm93biBjdXN0b20gZXJyb3IpXCI7XG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoY3VzdG9tUHJlZml4KSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBoZXhsaWZ5KGRhdGEuc2xpY2UoMCwgNCkpO1xuICAgICAgICAgICAgY29uc3QgZWYgPSB0aGlzLmdldEVycm9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmIChlZikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZWYuaW5wdXRzLCBkYXRhLnNsaWNlKDQpKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucmV2ZXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZWYubmFtZSwgc2lnbmF0dXJlOiBlZi5mb3JtYXQoKSwgYXJnc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5yZWFzb24gPSBlcnJvci5yZXZlcnQuc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gYGV4ZWN1dGlvbiByZXZlcnRlZDogJHtlcnJvci5yZWFzb259YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGBleGVjdXRpb24gcmV2ZXJ0ZWQgKGNvdWx0IG5vdCBkZWNvZGUgY3VzdG9tIGVycm9yKWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgaW52b2NhdGlvbiwgaWYgYXZhaWxhYmxlXG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2VUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgIGVycm9yLmludm9jYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBwYXJzZWQubmFtZSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHBhcnNlZC5zaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgYXJnczogcGFyc2VkLmFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgcmVzdWx0IGRhdGEgKGUuZy4gZnJvbSBhbiBgYGV0aF9jYWxsYGApIGZvciB0aGVcbiAgICAgKiAgc3BlY2lmaWVkIGZ1bmN0aW9uIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXNcbiAgICAgKiAgZm9yICUlZnJhZ21lbnQlJSkgd2l0aCAlJXZhbHVlcyUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VkIGJ5IG1vc3QgZGV2ZWxvcGVycywgdW5sZXNzIHRyeWluZyB0byBtb2NrXG4gICAgICogIGEgcmVzdWx0IGZyb20gYSBDb250cmFjdC5cbiAgICAgKi9cbiAgICBlbmNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHRoaXMuI2FiaUNvZGVyLmVuY29kZShmcmFnbWVudC5vdXRwdXRzLCB2YWx1ZXMgfHwgW10pKTtcbiAgICB9XG4gICAgLypcbiAgICAgICAgc3BlbHVuayhpbnB1dHM6IEFycmF5PFBhcmFtVHlwZT4sIHZhbHVlczogUmVhZG9ubHlBcnJheTxhbnk+LCBwcm9jZXNzZnVuYzogKHR5cGU6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gUHJvbWlzZTxhbnk+KTogUHJvbWlzZTxBcnJheTxhbnk+PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlczogQXJyYXk8UHJvbWlzZTw+PiA9IFsgXTtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3MgPSBmdW5jdGlvbih0eXBlOiBQYXJhbVR5cGUsIHZhbHVlOiBhbnkpOiBhbnkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NlbmQodHlwZS5jaGlsZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZS4gPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IGRlc2NlbmQgPSBmdW5jdGlvbiAoaW5wdXRzOiBBcnJheTxQYXJhbVR5cGU+LCB2YWx1ZXM6IFJlYWRvbmx5QXJyYXk8YW55Pikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKSB7IHRocm93IG5ldyBFcnJvcihcImxlbmd0aCBtaXNtYXRjaFwiKTsgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8YW55PiA9IFsgXTtcbiAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKHZhbHVlLm1hcCgodmFsdWUpID0+IGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICovXG4gICAgLy8gQ3JlYXRlIHRoZSBmaWx0ZXIgZm9yIHRoZSBldmVudCB3aXRoIHNlYXJjaCBjcml0ZXJpYSAoZS5nLiBmb3IgZXRoX2ZpbHRlckxvZylcbiAgICBlbmNvZGVGaWx0ZXJUb3BpY3MoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEV2ZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCh2YWx1ZXMubGVuZ3RoIDw9IGZyYWdtZW50LmlucHV0cy5sZW5ndGgsIGB0b28gbWFueSBhcmd1bWVudHMgZm9yICR7ZnJhZ21lbnQuZm9ybWF0KCl9YCwgXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCIsIHsgY291bnQ6IHZhbHVlcy5sZW5ndGgsIGV4cGVjdGVkQ291bnQ6IGZyYWdtZW50LmlucHV0cy5sZW5ndGggfSk7XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IFtdO1xuICAgICAgICBpZiAoIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgdG9waWNzLnB1c2goZnJhZ21lbnQudG9waWNIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogVXNlIHRoZSBjb2RlcnMgZm9yIHRoaXM7IHRvIHByb3Blcmx5IHN1cHBvcnQgdHVwbGVzLCBldGMuXG4gICAgICAgIGNvbnN0IGVuY29kZVRvcGljID0gKHBhcmFtLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJieXRlc1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1NihoZXhsaWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJib29sXCIgJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgPyBcIjB4MDFcIiA6IFwiMHgwMFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUubWF0Y2goL151P2ludC8pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0JlSGV4KHZhbHVlKTsgLy8gQFRPRE86IFNob3VsZCB0aGlzIHRvVHdvcz8/XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlLm1hdGNoKC9eYnl0ZXMvKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gemVyb1BhZEJ5dGVzKHZhbHVlLCAzMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGFkZHJlc3NlcyBhcmUgdmFsaWRcbiAgICAgICAgICAgICAgICB0aGlzLiNhYmlDb2Rlci5lbmNvZGUoW1wiYWRkcmVzc1wiXSwgW3ZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gemVyb1BhZFZhbHVlKGhleGxpZnkodmFsdWUpLCAzMik7XG4gICAgICAgIH07XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gZnJhZ21lbnQuaW5wdXRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghcGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID09IG51bGwsIFwiY2Fubm90IGZpbHRlciBub24taW5kZXhlZCBwYXJhbWV0ZXJzOyBtdXN0IGJlIG51bGxcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJmaWx0ZXJpbmcgd2l0aCB0dXBsZXMgb3IgYXJyYXlzIG5vdCBzdXBwb3J0ZWRcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh2YWx1ZS5tYXAoKHZhbHVlKSA9PiBlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRyaW0gb2ZmIHRyYWlsaW5nIG51bGxzXG4gICAgICAgIHdoaWxlICh0b3BpY3MubGVuZ3RoICYmIHRvcGljc1t0b3BpY3MubGVuZ3RoIC0gMV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRvcGljcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9waWNzO1xuICAgIH1cbiAgICBlbmNvZGVFdmVudExvZyhmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXZlbnQoZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGV2ZW50XCIsIFwiZXZlbnRGcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9waWNzID0gW107XG4gICAgICAgIGNvbnN0IGRhdGFUeXBlcyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhVmFsdWVzID0gW107XG4gICAgICAgIGlmICghZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICB0b3BpY3MucHVzaChmcmFnbWVudC50b3BpY0hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlcy5sZW5ndGggPT09IGZyYWdtZW50LmlucHV0cy5sZW5ndGgsIFwiZXZlbnQgYXJndW1lbnRzL3ZhbHVlcyBtaXNtYXRjaFwiLCBcInZhbHVlc1wiLCB2YWx1ZXMpO1xuICAgICAgICBmcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGlkKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIikge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChrZWNjYWsyNTYodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKHRoaXMuI2FiaUNvZGVyLmVuY29kZShbcGFyYW0udHlwZV0sIFt2YWx1ZV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgZGF0YVZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLiNhYmlDb2Rlci5lbmNvZGUoZGF0YVR5cGVzLCBkYXRhVmFsdWVzKSxcbiAgICAgICAgICAgIHRvcGljczogdG9waWNzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIERlY29kZSBhIGZpbHRlciBmb3IgdGhlIGV2ZW50IGFuZCB0aGUgc2VhcmNoIGNyaXRlcmlhXG4gICAgZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGRhdGEsIHRvcGljcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEV2ZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3BpY3MgIT0gbnVsbCAmJiAhZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRvcGljID0gZnJhZ21lbnQudG9waWNIYXNoO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodG9waWNzWzBdLCAzMikgJiYgdG9waWNzWzBdLnRvTG93ZXJDYXNlKCkgPT09IGV2ZW50VG9waWMsIFwiZnJhZ21lbnQvdG9waWMgbWlzbWF0Y2hcIiwgXCJ0b3BpY3NbMF1cIiwgdG9waWNzWzBdKTtcbiAgICAgICAgICAgIHRvcGljcyA9IHRvcGljcy5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleGVkID0gW107XG4gICAgICAgIGNvbnN0IG5vbkluZGV4ZWQgPSBbXTtcbiAgICAgICAgY29uc3QgZHluYW1pYyA9IFtdO1xuICAgICAgICBmcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiIHx8IHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKFBhcmFtVHlwZS5mcm9tKHsgdHlwZTogXCJieXRlczMyXCIsIG5hbWU6IHBhcmFtLm5hbWUgfSkpO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2godHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVkLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vbkluZGV4ZWQucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdEluZGV4ZWQgPSAodG9waWNzICE9IG51bGwpID8gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGluZGV4ZWQsIGNvbmNhdCh0b3BpY3MpKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IHJlc3VsdE5vbkluZGV4ZWQgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUobm9uSW5kZXhlZCwgZGF0YSwgdHJ1ZSk7XG4gICAgICAgIC8vY29uc3QgcmVzdWx0OiAoQXJyYXk8YW55PiAmIHsgWyBrZXk6IHN0cmluZyBdOiBhbnkgfSkgPSBbIF07XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgIGxldCBub25JbmRleGVkSW5kZXggPSAwLCBpbmRleGVkSW5kZXggPSAwO1xuICAgICAgICBmcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0SW5kZXhlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEluZGV4ZWQobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGR5bmFtaWNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEluZGV4ZWQocmVzdWx0SW5kZXhlZFtpbmRleGVkSW5kZXgrK10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0SW5kZXhlZFtpbmRleGVkSW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHROb25JbmRleGVkW25vbkluZGV4ZWRJbmRleCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAga2V5cy5wdXNoKHBhcmFtLm5hbWUgfHwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUmVzdWx0LmZyb21JdGVtcyh2YWx1ZXMsIGtleXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGFyc2VzIGEgdHJhbnNhY3Rpb24sIGZpbmRpbmcgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIGFuZCBleHRyYWN0c1xuICAgICAqICB0aGUgcGFyYW1ldGVyIHZhbHVlcyBhbG9uZyB3aXRoIG90aGVyIHVzZWZ1bCBmdW5jdGlvbiBkZXRhaWxzLlxuICAgICAqXG4gICAgICogIElmIHRoZSBtYXRjaGluZyBmdW5jdGlvbiBjYW5ub3QgYmUgZm91bmQsIHJldHVybiBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKHR4LmRhdGEsIFwidHguZGF0YVwiKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoKHR4LnZhbHVlICE9IG51bGwpID8gdHgudmFsdWUgOiAwLCBcInR4LnZhbHVlXCIpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oaGV4bGlmeShkYXRhLnNsaWNlKDAsIDQpKSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCBkYXRhLnNsaWNlKDQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKGZyYWdtZW50LCBmcmFnbWVudC5zZWxlY3RvciwgYXJncywgdmFsdWUpO1xuICAgIH1cbiAgICBwYXJzZUNhbGxSZXN1bHQoZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhcnNlcyBhIHJlY2VpcHQgbG9nLCBmaW5kaW5nIHRoZSBtYXRjaGluZyBldmVudCBhbmQgZXh0cmFjdHNcbiAgICAgKiAgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYWxvbmcgd2l0aCBvdGhlciB1c2VmdWwgZXZlbnQgZGV0YWlscy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgbWF0Y2hpbmcgZXZlbnQgY2Fubm90IGJlIGZvdW5kLCByZXR1cm5zIG51bGwuXG4gICAgICovXG4gICAgcGFyc2VMb2cobG9nKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCB8fCBmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBJZiBhbm9ueW1vdXMsIGFuZCB0aGUgb25seSBtZXRob2QsIGFuZCB0aGUgaW5wdXQgY291bnQgbWF0Y2hlcywgc2hvdWxkIHdlIHBhcnNlP1xuICAgICAgICAvLyAgICAgICAgUHJvYmFibHkgbm90LCBiZWNhdXNlIGp1c3QgYmVjYXVzZSBpdCBpcyB0aGUgb25seSBldmVudCBpbiB0aGUgQUJJIGRvZXNcbiAgICAgICAgLy8gICAgICAgIG5vdCBtZWFuIHdlIGhhdmUgdGhlIGZ1bGwgQUJJOyBtYXliZSBqdXN0IGEgZnJhZ21lbnQ/XG4gICAgICAgIHJldHVybiBuZXcgTG9nRGVzY3JpcHRpb24oZnJhZ21lbnQsIGZyYWdtZW50LnRvcGljSGFzaCwgdGhpcy5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhcnNlcyBhIHJldmVydCBkYXRhLCBmaW5kaW5nIHRoZSBtYXRjaGluZyBlcnJvciBhbmQgZXh0cmFjdHNcbiAgICAgKiAgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYWxvbmcgd2l0aCBvdGhlciB1c2VmdWwgZXJyb3IgZGV0YWlscy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgbWF0Y2hpbmcgZXJyb3IgY2Fubm90IGJlIGZvdW5kLCByZXR1cm5zIG51bGwuXG4gICAgICovXG4gICAgcGFyc2VFcnJvcihkYXRhKSB7XG4gICAgICAgIGNvbnN0IGhleERhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuZ2V0RXJyb3IoZGF0YVNsaWNlKGhleERhdGEsIDAsIDQpKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuI2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5pbnB1dHMsIGRhdGFTbGljZShoZXhEYXRhLCA0KSk7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JEZXNjcmlwdGlvbihmcmFnbWVudCwgZnJhZ21lbnQuc2VsZWN0b3IsIGFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW0ludGVyZmFjZV1dIGZyb20gdGhlIEFCSSAlJXZhbHVlJSUuXG4gICAgICpcbiAgICAgKiAgVGhlICUldmFsdWUlJSBtYXkgYmUgcHJvdmlkZWQgYXMgYW4gZXhpc3RpbmcgW1tJbnRlcmZhY2VdXSBvYmplY3QsXG4gICAgICogIGEgSlNPTi1lbmNvZGVkIEFCSSBvciBhbnkgSHVtYW4tUmVhZGFibGUgQUJJIGZvcm1hdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICAvLyBBbHJlYWR5IGFuIEludGVyZmFjZSwgd2hpY2ggaXMgaW1tdXRhYmxlXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEludGVyZmFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEpTT05cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZShKU09OLnBhcnNlKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWF5YmUgYW4gaW50ZXJmYWNlIGZyb20gYW4gb2xkZXIgdmVyc2lvbiwgb3IgZnJvbSBhIHN5bWxpbmtlZCBjb3B5XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlLmZvcm1hdCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UodmFsdWUuZm9ybWF0KFwianNvblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXkgb2YgZnJhZ21lbnRzXG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwIiwiLy9pbXBvcnQgeyByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hZGRyZXNzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGdldE51bWJlciwgaGV4bGlmeSwgcmVzb2x2ZVByb3BlcnRpZXMsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGlzRXJyb3IsIG1ha2VFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB0b0pzb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG59XG4vLyBAVE9ETz8gPFQgZXh0ZW5kcyBGZWVEYXRhID0geyB9PiBpbXBsZW1lbnRzIFJlcXVpcmVkPFQ+XG4vKipcbiAqICBBICoqRmVlRGF0YSoqIHdyYXBzIGFsbCB0aGUgZmVlLXJlbGF0ZWQgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aFxuICogIHRoZSBuZXR3b3JrLlxuICovXG5leHBvcnQgY2xhc3MgRmVlRGF0YSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgcHJpY2UgZm9yIGxlZ2FjeSBuZXR3b3Jrcy5cbiAgICAgKi9cbiAgICBnYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gZmVlIHRvIHBheSBwZXIgZ2FzLlxuICAgICAqXG4gICAgICogIFRoZSBiYXNlIGZlZSBwZXIgZ2FzIGlzIGRlZmluZWQgYnkgdGhlIG5ldHdvcmsgYW5kIGJhc2VkIG9uXG4gICAgICogIGNvbmdlc3Rpb24sIGluY3JlYXNpbmcgdGhlIGNvc3QgZHVyaW5nIHRpbWVzIG9mIGhlYXZ5IGxvYWRcbiAgICAgKiAgYW5kIGxvd2VyaW5nIHdoZW4gbGVzcyBidXN5LlxuICAgICAqXG4gICAgICogIFRoZSBhY3R1YWwgZmVlIHBlciBnYXMgd2lsbCBiZSB0aGUgYmFzZSBmZWUgZm9yIHRoZSBibG9ja1xuICAgICAqICBhbmQgdGhlIHByaW9yaXR5IGZlZSwgdXAgdG8gdGhlIG1heCBmZWUgcGVyIGdhcy5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgYmUgYGBudWxsYGAgb24gbGVnYWN5IG5ldHdvcmtzIChpLmUuIFtwcmUtRUlQLTE1NTldKGxpbmstZWlwLTE1NTkpKVxuICAgICAqL1xuICAgIG1heEZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZGl0aW9uYWwgYW1vdXQgdG8gcGF5IHBlciBnYXMgdG8gZW5jb3VyYWdlIGEgdmFsaWRhdG9yXG4gICAgICogIHRvIGluY2x1ZGUgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoZSBwdXJwb3NlIG9mIHRoaXMgaXMgdG8gY29tcGVuc2F0ZSB0aGUgdmFsaWRhdG9yIGZvciB0aGVcbiAgICAgKiAgYWRqdXN0ZWQgcmlzayBmb3IgaW5jbHVkaW5nIGEgZ2l2ZW4gdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIGJlIGBgbnVsbGBgIG9uIGxlZ2FjeSBuZXR3b3JrcyAoaS5lLiBbcHJlLUVJUC0xNTU5XShsaW5rLWVpcC0xNTU5KSlcbiAgICAgKi9cbiAgICBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBGZWVEYXRhIGZvciAlJWdhc1ByaWNlJSUsICUlbWF4RmVlUGVyR2FzJSUgYW5kXG4gICAgICogICUlbWF4UHJpb3JpdHlGZWVQZXJHYXMlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcykge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGdhc1ByaWNlOiBnZXRWYWx1ZShnYXNQcmljZSksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IGdldFZhbHVlKG1heEZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogZ2V0VmFsdWUobWF4UHJpb3JpdHlGZWVQZXJHYXMpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tZnJpZW5kbHkgdmFsdWUuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiRmVlRGF0YVwiLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRvSnNvbihnYXNQcmljZSksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHRvSnNvbihtYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRvSnNvbihtYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgIH07XG4gICAgfVxufVxuO1xuLyoqXG4gKiAgUmV0dXJucyBhIGNvcHkgb2YgJSVyZXElJSB3aXRoIGFsbCBwcm9wZXJ0aWVzIGNvZXJjZWQgdG8gdGhlaXIgc3RyaWN0XG4gKiAgdHlwZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5UmVxdWVzdChyZXEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAvLyBUaGVzZSBjb3VsZCBiZSBhZGRyZXNzZXMsIEVOUyBuYW1lcyBvciBBZGRyZXNzYWJsZXNcbiAgICBpZiAocmVxLnRvKSB7XG4gICAgICAgIHJlc3VsdC50byA9IHJlcS50bztcbiAgICB9XG4gICAgaWYgKHJlcS5mcm9tKSB7XG4gICAgICAgIHJlc3VsdC5mcm9tID0gcmVxLmZyb207XG4gICAgfVxuICAgIGlmIChyZXEuZGF0YSkge1xuICAgICAgICByZXN1bHQuZGF0YSA9IGhleGxpZnkocmVxLmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBiaWdJbnRLZXlzID0gXCJjaGFpbklkLGdhc0xpbWl0LGdhc1ByaWNlLG1heEZlZVBlckdhcyxtYXhQcmlvcml0eUZlZVBlckdhcyx2YWx1ZVwiLnNwbGl0KC8sLyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgYmlnSW50S2V5cykge1xuICAgICAgICBpZiAoIShrZXkgaW4gcmVxKSB8fCByZXFba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRba2V5XSA9IGdldEJpZ0ludChyZXFba2V5XSwgYHJlcXVlc3QuJHtrZXl9YCk7XG4gICAgfVxuICAgIGNvbnN0IG51bWJlcktleXMgPSBcInR5cGUsbm9uY2VcIi5zcGxpdCgvLC8pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIG51bWJlcktleXMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHJlcSkgfHwgcmVxW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0gPSBnZXROdW1iZXIocmVxW2tleV0sIGByZXF1ZXN0LiR7a2V5fWApO1xuICAgIH1cbiAgICBpZiAocmVxLmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSBhY2Nlc3NMaXN0aWZ5KHJlcS5hY2Nlc3NMaXN0KTtcbiAgICB9XG4gICAgaWYgKFwiYmxvY2tUYWdcIiBpbiByZXEpIHtcbiAgICAgICAgcmVzdWx0LmJsb2NrVGFnID0gcmVxLmJsb2NrVGFnO1xuICAgIH1cbiAgICBpZiAoXCJlbmFibGVDY2lwUmVhZFwiIGluIHJlcSkge1xuICAgICAgICByZXN1bHQuZW5hYmxlQ2NpcFJlYWQgPSAhIXJlcS5lbmFibGVDY2lwUmVhZDtcbiAgICB9XG4gICAgaWYgKFwiY3VzdG9tRGF0YVwiIGluIHJlcSkge1xuICAgICAgICByZXN1bHQuY3VzdG9tRGF0YSA9IHJlcS5jdXN0b21EYXRhO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgQSAqKkJsb2NrKiogcmVwcmVzZW50cyB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggYSBmdWxsIGJsb2NrIG9uXG4gKiAgRXRoZXJldW0uXG4gKi9cbmV4cG9ydCBjbGFzcyBCbG9jayB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGJsb2NrIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciwgc29tZXRpbWVzIGNhbGxlZCB0aGUgYmxvY2sgaGVpZ2h0LiBUaGlzIGlzIGFcbiAgICAgKiAgc2VxdWVudGlhbCBudW1iZXIgdGhhdCBpcyBvbmUgaGlnaGVyIHRoYW4gdGhlIHBhcmVudCBibG9jay5cbiAgICAgKi9cbiAgICBudW1iZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoLlxuICAgICAqXG4gICAgICogIFRoaXMgaGFzaCBpbmNsdWRlcyBhbGwgcHJvcGVydGllcywgc28gY2FuIGJlIHNhZmVseSB1c2VkIHRvIGlkZW50aWZ5XG4gICAgICogIGFuIGV4YWN0IHNldCBvZiBibG9jayBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSB0aW1lc3RhbXAgZm9yIHRoaXMgYmxvY2ssIHdoaWNoIGlzIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZVxuICAgICAqICBlcG9jaCB0aGF0IHRoaXMgYmxvY2sgd2FzIGluY2x1ZGVkLlxuICAgICAqL1xuICAgIHRpbWVzdGFtcDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2ggb2YgdGhlIHBhcmVudCBibG9jay5cbiAgICAgKi9cbiAgICBwYXJlbnRIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgbm9uY2UuXG4gICAgICpcbiAgICAgKiAgT24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzIGlzIHRoZSByYW5kb20gbnVtYmVyIGluc2VydGVkIHdoaWNoXG4gICAgICogIHBlcm1pdHRlZCB0aGUgZGlmZmljdWx0eSB0YXJnZXQgdG8gYmUgcmVhY2hlZC5cbiAgICAgKi9cbiAgICBub25jZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGRpZmZpY3VsdHkgdGFyZ2V0LlxuICAgICAqXG4gICAgICogIE9uIGxlZ2FjeSBuZXR3b3JrcywgdGhpcyBpcyB0aGUgcHJvb2Ytb2Ytd29yayB0YXJnZXQgcmVxdWlyZWRcbiAgICAgKiAgZm9yIGEgYmxvY2sgdG8gbWVldCB0aGUgcHJvdG9jb2wgcnVsZXMgdG8gYmUgaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiAgT24gbW9kZXJuIG5ldHdvcmtzLCB0aGlzIGlzIGEgcmFuZG9tIG51bWJlciBhcnJpdmVkIGF0IHVzaW5nXG4gICAgICogIHJhbmRhby4gIEBUT0RPOiBGaW5kIGxpbmtzP1xuICAgICAqL1xuICAgIGRpZmZpY3VsdHk7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBnYXMgbGltaXQgZm9yIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgZ2FzTGltaXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBnYXMgdXNlZCBpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBtaW5lciBjb2luYmFzZSBhZGRyZXNzLCB3aWhjaCByZWNlaXZlcyBhbnkgc3Vic2lkaWVzIGZvclxuICAgICAqICBpbmNsdWRpbmcgdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBtaW5lcjtcbiAgICAvKipcbiAgICAgKiAgQW55IGV4dHJhIGRhdGEgdGhlIHZhbGlkYXRvciB3aXNoZWQgdG8gaW5jbHVkZS5cbiAgICAgKi9cbiAgICBleHRyYURhdGE7XG4gICAgLyoqXG4gICAgICogIFRoZSBiYXNlIGZlZSBwZXIgZ2FzIHRoYXQgYWxsIHRyYW5zYWN0aW9ucyBpbiB0aGlzIGJsb2NrIHdlcmVcbiAgICAgKiAgY2hhcmdlZC5cbiAgICAgKlxuICAgICAqICBUaGlzIGFkanVzdHMgYWZ0ZXIgZWFjaCBibG9jaywgZGVwZW5kaW5nIG9uIGhvdyBjb25nZXN0ZWQgdGhlIG5ldHdvcmtcbiAgICAgKiAgaXMuXG4gICAgICovXG4gICAgYmFzZUZlZVBlckdhcztcbiAgICAjdHJhbnNhY3Rpb25zO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipCbG9jayoqIG9iamVjdC5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIG5lY2Vzc2FyeSBhcyB0aGUgdW5sZXNzIGltcGxlbWVudGluZyBhXG4gICAgICogIGxvdy1sZXZlbCBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrLCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLiN0cmFuc2FjdGlvbnMgPSBibG9jay50cmFuc2FjdGlvbnMubWFwKCh0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodHgpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBwcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgaGFzaDogZ2V0VmFsdWUoYmxvY2suaGFzaCksXG4gICAgICAgICAgICBudW1iZXI6IGJsb2NrLm51bWJlcixcbiAgICAgICAgICAgIHRpbWVzdGFtcDogYmxvY2sudGltZXN0YW1wLFxuICAgICAgICAgICAgcGFyZW50SGFzaDogYmxvY2sucGFyZW50SGFzaCxcbiAgICAgICAgICAgIG5vbmNlOiBibG9jay5ub25jZSxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IGJsb2NrLmRpZmZpY3VsdHksXG4gICAgICAgICAgICBnYXNMaW1pdDogYmxvY2suZ2FzTGltaXQsXG4gICAgICAgICAgICBnYXNVc2VkOiBibG9jay5nYXNVc2VkLFxuICAgICAgICAgICAgbWluZXI6IGJsb2NrLm1pbmVyLFxuICAgICAgICAgICAgZXh0cmFEYXRhOiBibG9jay5leHRyYURhdGEsXG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBnZXRWYWx1ZShibG9jay5iYXNlRmVlUGVyR2FzKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGxpc3Qgb2YgdHJhbnNhY3Rpb24gaGFzaGVzLCBpbiB0aGUgb3JkZXJcbiAgICAgKiAgdGhleSB3ZXJlIGV4ZWN1dGVkIHdpdGhpbiB0aGUgYmxvY2suXG4gICAgICovXG4gICAgZ2V0IHRyYW5zYWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3RyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHguaGFzaDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBjb21wbGV0ZSB0cmFuc2FjdGlvbnMsIGluIHRoZSBvcmRlciB0aGV5XG4gICAgICogIHdlcmUgZXhlY3V0ZWQgd2l0aGluIHRoZSBibG9jay5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBibG9ja3Mgd2hpY2ggcHJlZmV0Y2hlZFxuICAgICAqICB0cmFuc2FjdGlvbnMsIGJ5IHBhc3NpbmcgYGB0cnVlYGAgdG8gJSVwcmVmZXRjaFR4cyUlXG4gICAgICogIGludG8gW1tQcm92aWRlci1nZXRCbG9ja11dLlxuICAgICAqL1xuICAgIGdldCBwcmVmZXRjaGVkVHJhbnNhY3Rpb25zKCkge1xuICAgICAgICBjb25zdCB0eHMgPSB0aGlzLiN0cmFuc2FjdGlvbnMuc2xpY2UoKTtcbiAgICAgICAgLy8gRG9lc24ndCBtYXR0ZXIuLi5cbiAgICAgICAgaWYgKHR4cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgcHJlZmV0Y2hlZCB0aGUgdHJhbnNhY3Rpb25zXG4gICAgICAgIGFzc2VydCh0eXBlb2YgKHR4c1swXSkgPT09IFwib2JqZWN0XCIsIFwidHJhbnNhY3Rpb25zIHdlcmUgbm90IHByZWZldGNoZWQgd2l0aCBibG9jayByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0cmFuc2FjdGlvblJlc3BvbnNlcygpXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1mcmllbmRseSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgYmFzZUZlZVBlckdhcywgZGlmZmljdWx0eSwgZXh0cmFEYXRhLCBnYXNMaW1pdCwgZ2FzVXNlZCwgaGFzaCwgbWluZXIsIG5vbmNlLCBudW1iZXIsIHBhcmVudEhhc2gsIHRpbWVzdGFtcCwgdHJhbnNhY3Rpb25zIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiQmxvY2tcIixcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IHRvSnNvbihiYXNlRmVlUGVyR2FzKSxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IHRvSnNvbihkaWZmaWN1bHR5KSxcbiAgICAgICAgICAgIGV4dHJhRGF0YSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0b0pzb24oZ2FzTGltaXQpLFxuICAgICAgICAgICAgZ2FzVXNlZDogdG9Kc29uKGdhc1VzZWQpLFxuICAgICAgICAgICAgaGFzaCwgbWluZXIsIG5vbmNlLCBudW1iZXIsIHBhcmVudEhhc2gsIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IHR4cyA9IHRoaXMudHJhbnNhY3Rpb25zO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHhzW2luZGV4KytdLCBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbnVtYmVyIG9mIHRyYW5zYWN0aW9ucyBpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLiN0cmFuc2FjdGlvbnMubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstanMtZGF0ZV1dIHRoaXMgYmxvY2sgd2FzIGluY2x1ZGVkIGF0LlxuICAgICAqL1xuICAgIGdldCBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lc3RhbXAgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudGltZXN0YW1wICogMTAwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIHRyYW5zYWN0aW9uIGF0ICUlaW5kZXhlJSUgd2l0aGluIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oaW5kZXhPckhhc2gpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgaW50ZXJuYWwgdmFsdWUgYnkgaXRzIGluZGV4IG9yIGhhc2hcbiAgICAgICAgbGV0IHR4ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHlwZW9mIChpbmRleE9ySGFzaCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHR4ID0gdGhpcy4jdHJhbnNhY3Rpb25zW2luZGV4T3JIYXNoXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBpbmRleE9ySGFzaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHRoaXMuI3RyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSBoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0eCA9IHY7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYuaGFzaCA9PT0gaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHggPSB2O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHN1Y2ggdHhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24odHgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgYSAqKkJsb2NrKiogd2FzIGZldGNoZWQgd2l0aCBhIHJlcXVlc3QgdG8gaW5jbHVkZSB0aGUgdHJhbnNhY3Rpb25zXG4gICAgICogIHRoaXMgd2lsbCBhbGxvdyBzeW5jaHJvbm91cyBhY2Nlc3MgdG8gdGhvc2UgdHJhbnNhY3Rpb25zLlxuICAgICAqXG4gICAgICogIElmIHRoZSB0cmFuc2FjdGlvbnMgd2VyZSBub3QgcHJlZmV0Y2hlZCwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIGdldFByZWZldGNoZWRUcmFuc2FjdGlvbihpbmRleE9ySGFzaCkge1xuICAgICAgICBjb25zdCB0eHMgPSB0aGlzLnByZWZldGNoZWRUcmFuc2FjdGlvbnM7XG4gICAgICAgIGlmICh0eXBlb2YgKGluZGV4T3JIYXNoKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHR4c1tpbmRleE9ySGFzaF07XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXhPckhhc2ggPSBpbmRleE9ySGFzaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IHR4IG9mIHR4cykge1xuICAgICAgICAgICAgaWYgKHR4Lmhhc2ggPT09IGluZGV4T3JIYXNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcIm5vIG1hdGNoaW5nIHRyYW5zYWN0aW9uXCIsIFwiaW5kZXhPckhhc2hcIiwgaW5kZXhPckhhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgYmxvY2sgYmVlbiBtaW5lZC4gVGhpcyBwcm92aWRlcyBhIHR5cGUgZ3VhcmRcbiAgICAgKiAgZm9yIGFsbCBwcm9wZXJ0aWVzIG9uIGEgW1tNaW5lZEJsb2NrXV0uXG4gICAgICovXG4gICAgaXNNaW5lZCgpIHsgcmV0dXJuICEhdGhpcy5oYXNoOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGJsb2NrIGlzIGFuIFtbbGluay1laXAtMjkzMF1dIGJsb2NrLlxuICAgICAqL1xuICAgIGlzTG9uZG9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmJhc2VGZWVQZXJHYXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBvcnBoYW5lZEV2ZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNNaW5lZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9ycGhhbmVkQmxvY2tGaWx0ZXIodGhpcyk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTG9nXG4vKipcbiAqICBBICoqTG9nKiogaW4gRXRoZXJldW0gcmVwcmVzZW50cyBhbiBldmVudCB0aGF0IGhhcyBiZWVuIGluY2x1ZGVkIGluIGFcbiAqICB0cmFuc2FjdGlvbiB1c2luZyB0aGUgYGBMT0cqYGAgb3Bjb2Rlcywgd2hpY2ggYXJlIG1vc3QgY29tbW9ubHkgdXNlZCBieVxuICogIFNvbGlkaXR5J3MgZW1pdCBmb3IgYW5ub3VuY2luZyBldmVudHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2cge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgY29ubmVjdGVkIHRvIHRoZSBsb2cgdXNlZCB0byBmZXRjaCBhZGRpdGlvbmFsIGRldGFpbHNcbiAgICAgKiAgaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gdGhpcyBsb2cgb2NjdXJyZWQgaW4uIFVzZSB0aGVcbiAgICAgKiAgW1tMb2ctZ2V0VHJhbnNhY3Rpb25dXSB0byBnZXQgdGhlIFtbVHJhbnNhY3Rpb25SZXNwb25zZV1dLlxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9uSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2ggb2YgdGhlIGJsb2NrIHRoaXMgbG9nIG9jY3VycmVkIGluLiBVc2UgdGhlXG4gICAgICogIFtbTG9nLWdldEJsb2NrXV0gdG8gZ2V0IHRoZSBbW0Jsb2NrXV0uXG4gICAgICovXG4gICAgYmxvY2tIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBibG9jayB0aGlzIGxvZyBvY2N1cnJlZCBpbi4gSXQgaXMgcHJlZmVycmVkXG4gICAgICogIHRvIHVzZSB0aGUgW1tCbG9jay1oYXNoXV0gd2hlbiBmZXRjaGluZyB0aGUgcmVsYXRlZCBbW0Jsb2NrXV0sXG4gICAgICogIHNpbmNlIGluIHRoZSBjYXNlIG9mIGFuIG9ycGhhbmVkIGJsb2NrLCB0aGUgYmxvY2sgYXQgdGhhdCBoZWlnaHQgbWF5XG4gICAgICogIGhhdmUgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlICoqTG9nKiogcmVwcmVzZW50cyBhIGJsb2NrIHRoYXQgd2FzIHJlbW92ZWQgZHVlIHRvIGFuIG9ycGhhbmVkXG4gICAgICogIGJsb2NrLCB0aGlzIHdpbGwgYmUgdHJ1ZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiBvbmx5IGhhcHBlbiB3aXRoaW4gYW4gb3JwaGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuICAgIHJlbW92ZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRyZXNzIG9mIHRoZSBjb250cmFjdCB0aGF0IGVtaXR0ZWQgdGhpcyBsb2cuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhpcyBsb2cgd2hlbiBpdCB3YXMgZW1pdHRlZC5cbiAgICAgKi9cbiAgICBkYXRhO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXhlZCB0b3BpY3MgaW5jbHVkZWQgaW4gdGhpcyBsb2cgd2hlbiBpdCB3YXMgZW1pdHRlZC5cbiAgICAgKlxuICAgICAqICBBbGwgdG9waWNzIGFyZSBpbmNsdWRlZCBpbiB0aGUgYmxvb20gZmlsdGVycywgc28gdGhleSBjYW4gYmVcbiAgICAgKiAgZWZmaWNpZW50bHkgZmlsdGVyZWQgdXNpbmcgdGhlIFtbUHJvdmlkZXItZ2V0TG9nc11dIG1ldGhvZC5cbiAgICAgKi9cbiAgICB0b3BpY3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleCB3aXRoaW4gdGhlIGJsb2NrIHRoaXMgbG9nIG9jY3VycmVkIGF0LiBUaGlzIGlzIGdlbmVyYWxseVxuICAgICAqICBub3QgdXNlZnVsIHRvIGRldmVsb3BlcnMsIGJ1dCBjYW4gYmUgdXNlZCB3aXRoIHRoZSB2YXJpb3VzIHJvb3RzXG4gICAgICogIHRvIHByb29mIGluY2x1c2lvbiB3aXRoaW4gYSBibG9jay5cbiAgICAgKi9cbiAgICBpbmRleDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24gb2YgdGhpcyBsb2cuXG4gICAgICovXG4gICAgdHJhbnNhY3Rpb25JbmRleDtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9nLCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IE9iamVjdC5mcmVlemUobG9nLnRvcGljcy5zbGljZSgpKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGxvZy50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICBibG9ja0hhc2g6IGxvZy5ibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9ja051bWJlcjogbG9nLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgcmVtb3ZlZDogbG9nLnJlbW92ZWQsXG4gICAgICAgICAgICBhZGRyZXNzOiBsb2cuYWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IGxvZy5kYXRhLFxuICAgICAgICAgICAgdG9waWNzLFxuICAgICAgICAgICAgaW5kZXg6IGxvZy5pbmRleCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IGxvZy50cmFuc2FjdGlvbkluZGV4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0LlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBhZGRyZXNzLCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBkYXRhLCBpbmRleCwgcmVtb3ZlZCwgdG9waWNzLCB0cmFuc2FjdGlvbkhhc2gsIHRyYW5zYWN0aW9uSW5kZXggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJsb2dcIixcbiAgICAgICAgICAgIGFkZHJlc3MsIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsIGRhdGEsIGluZGV4LFxuICAgICAgICAgICAgcmVtb3ZlZCwgdG9waWNzLCB0cmFuc2FjdGlvbkhhc2gsIHRyYW5zYWN0aW9uSW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGJsb2NrIHRoYXQgdGhpcyBsb2cgb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9jayh0aGlzLmJsb2NrSGFzaCk7XG4gICAgICAgIGFzc2VydCghIWJsb2NrLCBcImZhaWxlZCB0byBmaW5kIHRyYW5zYWN0aW9uXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7fSk7XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIHRoYXQgdGhpcyBsb2cgb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgIGFzc2VydCghIXR4LCBcImZhaWxlZCB0byBmaW5kIHRyYW5zYWN0aW9uXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7fSk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHQgZm90IHRoZSB0cmFuc2FjdGlvbiB0aGF0IHRoaXNcbiAgICAgKiAgbG9nIG9jY3VycmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCgpIHtcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgYXNzZXJ0KCEhcmVjZWlwdCwgXCJmYWlsZWQgdG8gZmluZCB0cmFuc2FjdGlvbiByZWNlaXB0XCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7fSk7XG4gICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgcmVtb3ZlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVtb3ZlZExvZ0ZpbHRlcih0aGlzKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBUcmFuc2FjdGlvbiBSZWNlaXB0XG4vKlxuZXhwb3J0IGludGVyZmFjZSBMZWdhY3lUcmFuc2FjdGlvblJlY2VpcHQge1xuICAgIGJ5emFudGl1bTogZmFsc2U7XG4gICAgc3RhdHVzOiBudWxsO1xuICAgIHJvb3Q6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCeXphbnRpdW1UcmFuc2FjdGlvblJlY2VpcHQge1xuICAgIGJ5emFudGl1bTogdHJ1ZTtcbiAgICBzdGF0dXM6IG51bWJlcjtcbiAgICByb290OiBudWxsO1xufVxuKi9cbi8qKlxuICogIEEgKipUcmFuc2FjdGlvblJlY2VpcHQqKiBpbmNsdWRlcyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IGFcbiAqICB0cmFuc2FjdGlvbiB0aGF0IGlzIG9ubHkgYXZhaWxhYmxlIGFmdGVyIGl0IGhhcyBiZWVuIG1pbmVkLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIGNvbm5lY3RlZCB0byB0aGUgbG9nIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3MgdGhlIHRyYW5zYWN0aW9uIHdhcyBzZW50IHRvLlxuICAgICAqL1xuICAgIHRvO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VuZGVyIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBmcm9tO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgaWYgdGhlIHRyYW5zYWN0aW9uIHdhcyBkaXJlY3RseVxuICAgICAqICByZXNwb25zaWJsZSBmb3IgZGVwbG95aW5nIG9uZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vbi1udWxsICoqb25seSoqIGlmIHRoZSBgYHRvYGAgaXMgZW1wdHkgYW5kIHRoZSBgYGRhdGFgYFxuICAgICAqICB3YXMgc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkIGFzIGluaXRjb2RlLlxuICAgICAqL1xuICAgIGNvbnRyYWN0QWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IG9mIHRoaXMgdHJhbnNhY3Rpb24gd2l0aGluIHRoZSBibG9jayB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoIG9mIHRoZSBbW0Jsb2NrXV0gdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICovXG4gICAgYmxvY2tIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBbW0Jsb2NrXV0gdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9vbSBmaWx0ZXIgYnl0ZXMgdGhhdCByZXByZXNlbnQgYWxsIGxvZ3MgdGhhdCBvY2N1cnJlZCB3aXRoaW5cbiAgICAgKiAgdGhpcyB0cmFuc2FjdGlvbi4gVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWZ1bCBmb3IgbW9zdCBkZXZlbG9wZXJzLFxuICAgICAqICBidXQgY2FuIGJlIHVzZWQgdG8gdmFsaWRhdGUgdGhlIGluY2x1ZGVkIGxvZ3MuXG4gICAgICovXG4gICAgbG9nc0Jsb29tO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWN0dWFsIGFtb3VudCBvZiBnYXMgdXNlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFdoZW4gY3JlYXRpbmcgYSB0cmFuc2FjdGlvbiwgdGhlIGFtb3VudCBvZiBnYXMgdGhhdCB3aWxsIGJlIHVzZWQgY2FuXG4gICAgICogIG9ubHkgYmUgYXBwcm94aW1hdGVkLCBidXQgdGhlIHNlbmRlciBtdXN0IHBheSB0aGUgZ2FzIGZlZSBmb3IgdGhlXG4gICAgICogIGVudGlyZSBnYXMgbGltaXQuIEFmdGVyIHRoZSB0cmFuc2FjdGlvbiwgdGhlIGRpZmZlcmVuY2UgaXMgcmVmdW5kZWQuXG4gICAgICovXG4gICAgZ2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFtb3VudCBvZiBnYXMgdXNlZCBieSBhbGwgdHJhbnNhY3Rpb25zIHdpdGhpbiB0aGUgYmxvY2sgZm9yIHRoaXNcbiAgICAgKiAgYW5kIGFsbCB0cmFuc2FjdGlvbnMgd2l0aCBhIGxvd2VyIGBgaW5kZXhgYC5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZnVsIGZvciBkZXZlbG9wZXJzIGJ1dCBjYW4gYmUgdXNlZCB0b1xuICAgICAqICB2YWxpZGF0ZSBjZXJ0YWluIGFzcGVjdHMgb2YgZXhlY3V0aW9uLlxuICAgICAqL1xuICAgIGN1bXVsYXRpdmVHYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWN0dWFsIGdhcyBwcmljZSB1c2VkIGR1cmluZyBleGVjdXRpb24uXG4gICAgICpcbiAgICAgKiAgRHVlIHRvIHRoZSBjb21wbGV4aXR5IG9mIFtbbGluay1laXAtMTU1OV1dIHRoaXMgdmFsdWUgY2FuIG9ubHlcbiAgICAgKiAgYmUgY2FsdWNsYXRlZCBhZnRlciB0aGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQsIHNuY2UgdGhlIGJhc2VcbiAgICAgKiAgZmVlIGlzIHByb3RvY29sLWVuZm9yY2VkLlxuICAgICAqL1xuICAgIGdhc1ByaWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yNzE4XV0gdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICB0eXBlO1xuICAgIC8vcmVhZG9ubHkgYnl6YW50aXVtITogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiAgVGhlIHN0YXR1cyBvZiB0aGlzIHRyYW5zYWN0aW9uLCBpbmRpY2F0aW5nIHN1Y2Nlc3MgKGkuZS4gYGAxYGApIG9yXG4gICAgICogIGEgcmV2ZXJ0IChpLmUuIGBgMGBgKS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGF2YWlsYWJsZSBpbiBwb3N0LWJ5emFudGl1bSBibG9ja3MsIGJ1dCBzb21lIGJhY2tlbmRzIG1heVxuICAgICAqICBiYWNrZmlsbCB0aGlzIHZhbHVlLlxuICAgICAqL1xuICAgIHN0YXR1cztcbiAgICAvKipcbiAgICAgKiAgVGhlIHJvb3QgaGFzaCBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgbm8gcHJlc2VudCBhbmQgd2FzIG9ubHkgaW5jbHVkZWQgaW4gcHJlLWJ5emFudGl1bSBibG9ja3MsIGJ1dFxuICAgICAqICBjb3VsZCBiZSB1c2VkIHRvIHZhbGlkYXRlIGNlcnRhaW4gcGFydHMgb2YgdGhlIHJlY2VpcHQuXG4gICAgICovXG4gICAgcm9vdDtcbiAgICAjbG9ncztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHgsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI2xvZ3MgPSBPYmplY3QuZnJlZXplKHR4LmxvZ3MubWFwKChsb2cpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9nKGxvZywgcHJvdmlkZXIpO1xuICAgICAgICB9KSk7XG4gICAgICAgIGxldCBnYXNQcmljZSA9IEJOXzA7XG4gICAgICAgIGlmICh0eC5lZmZlY3RpdmVHYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBnYXNQcmljZSA9IHR4LmVmZmVjdGl2ZUdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR4Lmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgIHRvOiB0eC50byxcbiAgICAgICAgICAgIGZyb206IHR4LmZyb20sXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IHR4LmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgIGhhc2g6IHR4Lmhhc2gsXG4gICAgICAgICAgICBpbmRleDogdHguaW5kZXgsXG4gICAgICAgICAgICBibG9ja0hhc2g6IHR4LmJsb2NrSGFzaCxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0eC5ibG9ja051bWJlcixcbiAgICAgICAgICAgIGxvZ3NCbG9vbTogdHgubG9nc0Jsb29tLFxuICAgICAgICAgICAgZ2FzVXNlZDogdHguZ2FzVXNlZCxcbiAgICAgICAgICAgIGN1bXVsYXRpdmVHYXNVc2VkOiB0eC5jdW11bGF0aXZlR2FzVXNlZCxcbiAgICAgICAgICAgIGdhc1ByaWNlLFxuICAgICAgICAgICAgdHlwZTogdHgudHlwZSxcbiAgICAgICAgICAgIC8vYnl6YW50aXVtOiB0eC5ieXphbnRpdW0sXG4gICAgICAgICAgICBzdGF0dXM6IHR4LnN0YXR1cyxcbiAgICAgICAgICAgIHJvb3Q6IHR4LnJvb3RcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbG9ncyBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgbG9ncygpIHsgcmV0dXJuIHRoaXMuI2xvZ3M7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgdG8sIGZyb20sIGNvbnRyYWN0QWRkcmVzcywgaGFzaCwgaW5kZXgsIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsIGxvZ3NCbG9vbSwgbG9ncywgLy9ieXphbnRpdW0sIFxuICAgICAgICBzdGF0dXMsIHJvb3QgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJUcmFuc2FjdGlvblJlY2VpcHRcIixcbiAgICAgICAgICAgIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICAvL2J5emFudGl1bSwgXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICBjdW11bGF0aXZlR2FzVXNlZDogdG9Kc29uKHRoaXMuY3VtdWxhdGl2ZUdhc1VzZWQpLFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiB0b0pzb24odGhpcy5nYXNQcmljZSksXG4gICAgICAgICAgICBnYXNVc2VkOiB0b0pzb24odGhpcy5nYXNVc2VkKSxcbiAgICAgICAgICAgIGhhc2gsIGluZGV4LCBsb2dzLCBsb2dzQmxvb20sIHJvb3QsIHN0YXR1cywgdG9cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLmxvZ3MubGVuZ3RoOyB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHRoaXMubG9nc1tpbmRleCsrXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRvdGFsIGZlZSBmb3IgdGhpcyB0cmFuc2FjdGlvbiwgaW4gd2VpLlxuICAgICAqL1xuICAgIGdldCBmZWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdhc1VzZWQgKiB0aGlzLmdhc1ByaWNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGJsb2NrIHRoaXMgdHJhbnNhY3Rpb24gb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9jayh0aGlzLmJsb2NrSGFzaCk7XG4gICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiB0aGlzIHRyYW5zYWN0aW9uIG9jY3VycmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24odGhpcy5oYXNoKTtcbiAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZXhlY3V0aW9uIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgU3VwcG9ydCBmb3IgdGhpcyBmZWF0dXJlIGlzIGxpbWl0ZWQsIGFzIGl0IHJlcXVpcmVzIGFuIGFyY2hpdmUgbm9kZVxuICAgICAqICB3aXRoIHRoZSBgYGRlYnVnX2BgIG9yIGBgdHJhY2VfYGAgQVBJIGVuYWJsZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmVzdWx0KCkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZXN1bHQodGhpcy5oYXNoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgdGhpcyB0cmFuc2FjdGlvbiBoYXMuXG4gICAgICovXG4gICAgYXN5bmMgY29uZmlybWF0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCkpIC0gdGhpcy5ibG9ja051bWJlciArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICByZW1vdmVkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICByZW9yZGVyZWRFdmVudChvdGhlcikge1xuICAgICAgICBhc3NlcnQoIW90aGVyIHx8IG90aGVyLmlzTWluZWQoKSwgXCJ1bm1pbmVkICdvdGhlcicgdHJhbnNjdGlvbiBjYW5ub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVvcmRlcmVkRXZlbnQob3RoZXIpXCIgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzLCBvdGhlcik7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKlRyYW5zYWN0aW9uUmVzcG9uc2UqKiBpbmNsdWRlcyBhbGwgcHJvcGVydGllcyBhYm91dCBhIHRyYW5zYWN0aW9uXG4gKiAgdGhhdCB3YXMgc2VudCB0byB0aGUgbmV0d29yaywgd2hpY2ggbWF5IG9yIG1heSBub3QgYmUgaW5jbHVkZWQgaW4gYVxuICogIGJsb2NrLlxuICpcbiAqICBUaGUgW1tUcmFuc2FjdGlvblJlc3BvbnNlLWlzTWluZWRdXSBjYW4gYmUgdXNlZCB0byBjaGVjayBpZiB0aGVcbiAqICB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhcyB3ZWxsIGFzIHR5cGUgZ3VhcmQgdGhhdCB0aGUgb3RoZXJ3aXNlXG4gKiAgcG9zc2libHkgYGBudWxsYGAgcHJvcGVydGllcyBhcmUgZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uUmVzcG9uc2Uge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgdGhpcyBpcyBjb25uZWN0ZWQgdG8sIHdoaWNoIHdpbGwgaW5mbHVlbmNlIGhvdyBpdHNcbiAgICAgKiAgbWV0aG9kcyB3aWxsIHJlc29sdmUgaXRzIGFzeW5jIGluc3BlY3Rpb24gbWV0aG9kcy5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgYmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGBgbnVsbGBgIGZvciBwZW5kaW5nIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrSGFzaCBvZiB0aGUgYmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGBgbnVsbGBgIGZvciBwZW5kaW5nIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBibG9ja0hhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleCB3aXRoaW4gdGhlIGJsb2NrIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiByZXNpZGVzIGF0LlxuICAgICAqL1xuICAgIGluZGV4O1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gaGFzaC5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yNzE4XV0gdHJhbnNhY3Rpb24gZW52ZWxvcGUgdHlwZS4gVGhpcyBpc1xuICAgICAqICBgYDBgYCBmb3IgbGVnYWN5IHRyYW5zYWN0aW9ucyB0eXBlcy5cbiAgICAgKi9cbiAgICB0eXBlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcmVjZWl2ZXIgb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBJZiBgYG51bGxgYCwgdGhlbiB0aGUgdHJhbnNhY3Rpb24gaXMgYW4gaW5pdGNvZGUgdHJhbnNhY3Rpb24uXG4gICAgICogIFRoaXMgbWVhbnMgdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgdGhlIFtbZGF0YV1dIHdpbGwgYmUgZGVwbG95ZWRcbiAgICAgKiAgYXMgYSBuZXcgY29udHJhY3Qgb24gY2hhaW4gKGFzc3VtaW5nIGl0IGRvZXMgbm90IHJldmVydCkgYW5kIHRoZVxuICAgICAqICBhZGRyZXNzIG1heSBiZSBjb21wdXRlZCB1c2luZyBbW2dldENyZWF0ZUFkZHJlc3NdXS5cbiAgICAgKi9cbiAgICB0bztcbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbmRlciBvZiB0aGlzIHRyYW5zYWN0aW9uLiBJdCBpcyBpbXBsaWNpdGx5IGNvbXB1dGVkXG4gICAgICogIGZyb20gdGhlIHRyYW5zYWN0aW9uIHByZS1pbWFnZSBoYXNoIChhcyB0aGUgZGlnZXN0KSBhbmQgdGhlXG4gICAgICogIFtbc2lnbmF0dXJlXV0gdXNpbmcgZWNyZWNvdmVyLlxuICAgICAqL1xuICAgIGZyb207XG4gICAgLyoqXG4gICAgICogIFRoZSBub25jZSwgd2hpY2ggaXMgdXNlZCB0byBwcmV2ZW50IHJlcGxheSBhdHRhY2tzIGFuZCBvZmZlclxuICAgICAqICBhIG1ldGhvZCB0byBlbnN1cmUgdHJhbnNhY3Rpb25zIGZyb20gYSBnaXZlbiBzZW5kZXIgYXJlIGV4cGxpY2l0bHlcbiAgICAgKiAgb3JkZXJlZC5cbiAgICAgKlxuICAgICAqICBXaGVuIHNlbmRpbmcgYSB0cmFuc2FjdGlvbiwgdGhpcyBtdXN0IGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgKiAgdHJhbnNhY3Rpb25zIGV2ZXIgc2VudCBieSBbW2Zyb21dXS5cbiAgICAgKi9cbiAgICBub25jZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gdW5pdHMgb2YgZ2FzIHRoaXMgdHJhbnNhY3Rpb24gY2FuIGNvbnN1bWUuIElmIGV4ZWN1dGlvblxuICAgICAqICBleGNlZWRzIHRoaXMsIHRoZSBlbnRyaWVzIHRyYW5zYWN0aW9uIGlzIHJldmVydGVkIGFuZCB0aGUgc2VuZGVyXG4gICAgICogIGlzIGNoYXJnZWQgZm9yIHRoZSBmdWxsIGFtb3VudCwgZGVzcGl0ZSBub3Qgc3RhdGUgY2hhbmdlcyBiZWluZyBtYWRlLlxuICAgICAqL1xuICAgIGdhc0xpbWl0O1xuICAgIC8qKlxuICAgICAqICBUaGUgZ2FzIHByaWNlIGNhbiBoYXZlIHZhcmlvdXMgdmFsdWVzLCBkZXBlbmRpbmcgb24gdGhlIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiAgSW4gbW9kZXJuIG5ldHdvcmtzLCBmb3IgdHJhbnNhY3Rpb25zIHRoYXQgYXJlIGluY2x1ZGVkIHRoaXMgaXNcbiAgICAgKiAgdGhlIC8vZWZmZWN0aXZlIGdhcyBwcmljZS8vICh0aGUgZmVlIHBlciBnYXMgdGhhdCB3YXMgYWN0dWFsbHlcbiAgICAgKiAgY2hhcmdlZCksIHdoaWxlIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBoYXZlIG5vdCBiZWVuIGluY2x1ZGVkIHlldFxuICAgICAqICBpcyB0aGUgW1ttYXhGZWVQZXJHYXNdXS5cbiAgICAgKlxuICAgICAqICBGb3IgbGVnYWN5IHRyYW5zYWN0aW9ucywgb3IgdHJhbnNhY3Rpb25zIG9uIGxlZ2FjeSBuZXR3b3JrcywgdGhpc1xuICAgICAqICBpcyB0aGUgZmVlIHRoYXQgd2lsbCBiZSBjaGFyZ2VkIHBlciB1bml0IG9mIGdhcyB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiAgY29uc3VtZXMuXG4gICAgICovXG4gICAgZ2FzUHJpY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHByaW9yaXR5IGZlZSAocGVyIHVuaXQgb2YgZ2FzKSB0byBhbGxvdyBhXG4gICAgICogIHZhbGlkYXRvciB0byBjaGFyZ2UgdGhlIHNlbmRlci4gVGhpcyBpcyBpbmNsdXNpdmUgb2YgdGhlXG4gICAgICogIFtbbWF4RmVlRmVlUGVyR2FzXV0uXG4gICAgICovXG4gICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIGZlZSAocGVyIHVuaXQgb2YgZ2FzKSB0byBhbGxvdyB0aGlzIHRyYW5zYWN0aW9uXG4gICAgICogIHRvIGNoYXJnZSB0aGUgc2VuZGVyLlxuICAgICAqL1xuICAgIG1heEZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGRhdGEuXG4gICAgICovXG4gICAgZGF0YTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHZhbHVlLCBpbiB3ZWkuIFVzZSBbW2Zvcm1hdEV0aGVyXV0gdG8gZm9ybWF0IHRoaXMgdmFsdWVcbiAgICAgKiAgYXMgZXRoZXIuXG4gICAgICovXG4gICAgdmFsdWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbiBJRC5cbiAgICAgKi9cbiAgICBjaGFpbklkO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIHNpZ25hdHVyZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjkzMF1dIGFjY2VzcyBsaXN0IGZvciB0cmFuc2FjdGlvbiB0eXBlcyB0aGF0XG4gICAgICogIHN1cHBvcnQgaXQsIG90aGVyd2lzZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBhY2Nlc3NMaXN0O1xuICAgICNzdGFydEJsb2NrO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eCwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLmJsb2NrTnVtYmVyID0gKHR4LmJsb2NrTnVtYmVyICE9IG51bGwpID8gdHguYmxvY2tOdW1iZXIgOiBudWxsO1xuICAgICAgICB0aGlzLmJsb2NrSGFzaCA9ICh0eC5ibG9ja0hhc2ggIT0gbnVsbCkgPyB0eC5ibG9ja0hhc2ggOiBudWxsO1xuICAgICAgICB0aGlzLmhhc2ggPSB0eC5oYXNoO1xuICAgICAgICB0aGlzLmluZGV4ID0gdHguaW5kZXg7XG4gICAgICAgIHRoaXMudHlwZSA9IHR4LnR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IHR4LmZyb207XG4gICAgICAgIHRoaXMudG8gPSB0eC50byB8fCBudWxsO1xuICAgICAgICB0aGlzLmdhc0xpbWl0ID0gdHguZ2FzTGltaXQ7XG4gICAgICAgIHRoaXMubm9uY2UgPSB0eC5ub25jZTtcbiAgICAgICAgdGhpcy5kYXRhID0gdHguZGF0YTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHR4LnZhbHVlO1xuICAgICAgICB0aGlzLmdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XG4gICAgICAgIHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkgPyB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA6IG51bGw7XG4gICAgICAgIHRoaXMubWF4RmVlUGVyR2FzID0gKHR4Lm1heEZlZVBlckdhcyAhPSBudWxsKSA/IHR4Lm1heEZlZVBlckdhcyA6IG51bGw7XG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IHR4LmNoYWluSWQ7XG4gICAgICAgIHRoaXMuc2lnbmF0dXJlID0gdHguc2lnbmF0dXJlO1xuICAgICAgICB0aGlzLmFjY2Vzc0xpc3QgPSAodHguYWNjZXNzTGlzdCAhPSBudWxsKSA/IHR4LmFjY2Vzc0xpc3QgOiBudWxsO1xuICAgICAgICB0aGlzLiNzdGFydEJsb2NrID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IGJsb2NrTnVtYmVyLCBibG9ja0hhc2gsIGluZGV4LCBoYXNoLCB0eXBlLCB0bywgZnJvbSwgbm9uY2UsIGRhdGEsIHNpZ25hdHVyZSwgYWNjZXNzTGlzdCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcIlRyYW5zYWN0aW9uUmVjZWlwdFwiLFxuICAgICAgICAgICAgYWNjZXNzTGlzdCwgYmxvY2tOdW1iZXIsIGJsb2NrSGFzaCxcbiAgICAgICAgICAgIGNoYWluSWQ6IHRvSnNvbih0aGlzLmNoYWluSWQpLFxuICAgICAgICAgICAgZGF0YSwgZnJvbSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0b0pzb24odGhpcy5nYXNMaW1pdCksXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgaGFzaCxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogdG9Kc29uKHRoaXMubWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0b0pzb24odGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICBub25jZSwgc2lnbmF0dXJlLCB0bywgaW5kZXgsIHR5cGUsXG4gICAgICAgICAgICB2YWx1ZTogdG9Kc29uKHRoaXMudmFsdWUpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIEJsb2NrIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHJldHVybiBudWxsIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gaW5jbHVkZWQgeWV0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJsb2NrKCkge1xuICAgICAgICBsZXQgYmxvY2tOdW1iZXIgPSB0aGlzLmJsb2NrTnVtYmVyO1xuICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAodHgpIHtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IHR4LmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9jayA9IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2soYmxvY2tOdW1iZXIpO1xuICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGlzIHRyYW5zYWN0aW9uIGJlaW5nIHJlLXJlcXVlc3RlZCBmcm9tIHRoZVxuICAgICAqICBwcm92aWRlci4gVGhpcyBjYW4gYmUgdXNlZCBpZiB5b3UgaGF2ZSBhbiB1bm1pbmVkIHRyYW5zYWN0aW9uXG4gICAgICogIGFuZCB3aXNoIHRvIGdldCBhbiB1cC10by1kYXRlIHBvcHVsYXRlZCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24odGhpcy5oYXNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmUgdG8gdGhlIG51bWJlciBvZiBjb25maXJtYXRpb25zIHRoaXMgdHJhbnNhY3Rpb24gaGFzLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbmZpcm1hdGlvbnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHgsIGJsb2NrTnVtYmVyIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgdHg6IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKSxcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE5vdCBtaW5lZCB5ZXQuLi5cbiAgICAgICAgICAgIGlmICh0eCA9PSBudWxsIHx8IHR4LmJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBibG9ja051bWJlciAtIHR4LmJsb2NrTnVtYmVyICsgMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyIC0gdGhpcy5ibG9ja051bWJlciArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyBvbmNlIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQgYW5kIGhhc1xuICAgICAqICAlJWNvbmZpcm1zJSUgYmxvY2tzIGluY2x1ZGluZyBpdCAoZGVmYXVsdDogYGAxYGApIHdpdGggYW5cbiAgICAgKiAgb3B0aW9uYWwgJSV0aW1lb3V0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gcmVzb2x2ZSB0byBgYG51bGxgYCBvbmx5IGlmICUlY29uZmlybXMlJSBpcyBgYDBgYFxuICAgICAqICBhbmQgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBtaW5lZCwgb3RoZXJ3aXNlIHRoaXMgd2lsbFxuICAgICAqICB3YWl0IHVudGlsIGVub3VnaCBjb25maXJtYXRpb25zIGhhdmUgY29tcGxldGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQoX2NvbmZpcm1zLCBfdGltZW91dCkge1xuICAgICAgICBjb25zdCBjb25maXJtcyA9IChfY29uZmlybXMgPT0gbnVsbCkgPyAxIDogX2NvbmZpcm1zO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gKF90aW1lb3V0ID09IG51bGwpID8gMCA6IF90aW1lb3V0O1xuICAgICAgICBsZXQgc3RhcnRCbG9jayA9IHRoaXMuI3N0YXJ0QmxvY2s7XG4gICAgICAgIGxldCBuZXh0U2NhbiA9IC0xO1xuICAgICAgICBsZXQgc3RvcFNjYW5uaW5nID0gKHN0YXJ0QmxvY2sgPT09IC0xKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgY29uc3QgY2hlY2tSZXBsYWNlbWVudCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiBjb3VudCBmb3IgdGhpcyBzZW5kZXJcbiAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgYmxvY2tOdW1iZXIsIG5vbmNlIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKSxcbiAgICAgICAgICAgICAgICBub25jZTogdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuZnJvbSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTm8gdHJhbnNhY3Rpb24gb3Igb3VyIG5vbmNlIGhhcyBub3QgYmVlbiBtaW5lZCB5ZXQ7IGJ1dCB3ZVxuICAgICAgICAgICAgLy8gY2FuIHN0YXJ0IHNjYW5uaW5nIGxhdGVyIHdoZW4gd2UgZG8gc3RhcnRcbiAgICAgICAgICAgIGlmIChub25jZSA8IHRoaXMubm9uY2UpIHtcbiAgICAgICAgICAgICAgICBzdGFydEJsb2NrID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2Ugd2VyZSBtaW5lZDsgbm8gcmVwbGFjZW1lbnRcbiAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1pbmVkID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvbigpO1xuICAgICAgICAgICAgaWYgKG1pbmVkICYmIG1pbmVkLmJsb2NrTnVtYmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSB3ZXJlIHJlcGxhY2VkOyBzdGFydCBzY2FubmluZyBmb3IgdGhhdCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgLy8gU3RhcnRpbmcgdG8gc2NhbjsgbG9vayBiYWNrIGEgZmV3IGV4dHJhIGJsb2NrcyBmb3Igc2FmZXR5XG4gICAgICAgICAgICBpZiAobmV4dFNjYW4gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbmV4dFNjYW4gPSBzdGFydEJsb2NrIC0gMztcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNjYW4gPCB0aGlzLiNzdGFydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRTY2FuID0gdGhpcy4jc3RhcnRCbG9jaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAobmV4dFNjYW4gPD0gYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIG5leHQgYmxvY2sgdG8gc2NhblxuICAgICAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9jayhuZXh0U2NhbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbjsgYnV0IHdlJ2xsIHRyeSBhZ2FpbiBzaG9ydGx5XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSB3ZXJlIG1pbmVkOyBubyByZXBsYWNlbWVudFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaGFzaCBvZiBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzaCA9PT0gdGhpcy5oYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VhcmNoIGZvciB0aGUgdHJhbnNhY3Rpb24gdGhhdCByZXBsYWNlZCB1c1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCBibG9jay5nZXRUcmFuc2FjdGlvbihpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmZyb20gPT09IHRoaXMuZnJvbSAmJiB0eC5ub25jZSA9PT0gdGhpcy5ub25jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByZWNlaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcFNjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHguaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuOyBidXQgd2UnbGwgdHJ5IGFnYWluIHNob3J0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB3aWxsIHJldHJ5IHRoaXMgb24gdGhlIG5leHQgYmxvY2sgKHRoaXMgY2FzZSBjb3VsZCBiZSBvcHRpbWl6ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGJsb2NrTnVtYmVyIC0gcmVjZWlwdC5ibG9ja051bWJlciArIDEpIDwgY29uZmlybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVhc29uIHdlIHdlcmUgcmVwbGFjZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWFzb24gPSBcInJlcGxhY2VkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZGF0YSA9PT0gdGhpcy5kYXRhICYmIHR4LnRvID09PSB0aGlzLnRvICYmIHR4LnZhbHVlID09PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gXCJyZXByaWNlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHguZGF0YSA9PT0gXCIweFwiICYmIHR4LmZyb20gPT09IHR4LnRvICYmIHR4LnZhbHVlID09PSBCTl8wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gXCJjYW5jZWxsZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJ0cmFuc2FjdGlvbiB3YXMgcmVwbGFjZWRcIiwgXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGVkOiAocmVhc29uID09PSBcInJlcGxhY2VkXCIgfHwgcmVhc29uID09PSBcImNhbmNlbGxlZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQ6IHR4LnJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oc3RhcnRCbG9jayksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogdHguaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0U2NhbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjaGVja1JlY2VpcHQgPSAocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCB8fCByZWNlaXB0LnN0YXR1cyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInRyYW5zYWN0aW9uIGV4ZWN1dGlvbiByZXZlcnRlZFwiLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwic2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCwgcmVhc29uOiBudWxsLCBpbnZvY2F0aW9uOiBudWxsLCByZXZlcnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgdG86IHJlY2VpcHQudG8sXG4gICAgICAgICAgICAgICAgICAgIGZyb206IHJlY2VpcHQuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogXCJcIiAvLyBAVE9ETzogaW4gdjcsIHNwbGl0IG91dCBzZW5kVHJhbnNhY3Rpb24gcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIH0sIHJlY2VpcHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodGhpcy5oYXNoKTtcbiAgICAgICAgaWYgKGNvbmZpcm1zID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tSZWNlaXB0KHJlY2VpcHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWNlaXB0KSB7XG4gICAgICAgICAgICBpZiAoKGF3YWl0IHJlY2VpcHQuY29uZmlybWF0aW9ucygpKSA+PSBjb25maXJtcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1JlY2VpcHQocmVjZWlwdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgYSByZXBsYWNlbWVudDsgdGhyb3dzIGlmIGEgcmVwbGFjZW1lbnQgd2FzIGZvdW5kXG4gICAgICAgICAgICBhd2FpdCBjaGVja1JlcGxhY2VtZW50KCk7XG4gICAgICAgICAgICAvLyBBbGxvdyBudWxsIG9ubHkgd2hlbiB0aGUgY29uZmlybXMgaXMgMFxuICAgICAgICAgICAgaWYgKGNvbmZpcm1zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2FpdGVyID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gTGlzdCBvZiB0aGluZ3MgdG8gY2FuY2VsIHdoZW4gd2UgaGF2ZSBhIHJlc3VsdCAob25lIHdheSBvciB0aGUgb3RoZXIpXG4gICAgICAgICAgICBjb25zdCBjYW5jZWxsZXJzID0gW107XG4gICAgICAgICAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7IGNhbmNlbGxlcnMuZm9yRWFjaCgoYykgPT4gYygpKTsgfTtcbiAgICAgICAgICAgIC8vIE9uIGNhbmNlbCwgc3RvcCBzY2FubmluZyBmb3IgcmVwbGFjZW1lbnRzXG4gICAgICAgICAgICBjYW5jZWxsZXJzLnB1c2goKCkgPT4geyBzdG9wU2Nhbm5pbmcgPSB0cnVlOyB9KTtcbiAgICAgICAgICAgIC8vIFNldCB1cCBhbnkgdGltZW91dCByZXF1ZXN0ZWRcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwid2FpdCBmb3IgdHJhbnNhY3Rpb24gdGltZW91dFwiLCBcIlRJTUVPVVRcIikpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IGNsZWFyVGltZW91dCh0aW1lcik7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHhMaXN0ZW5lciA9IGFzeW5jIChyZWNlaXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRG9uZTsgcmV0dXJuIGl0IVxuICAgICAgICAgICAgICAgIGlmICgoYXdhaXQgcmVjZWlwdC5jb25maXJtYXRpb25zKCkpID49IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjaGVja1JlY2VpcHQocmVjZWlwdCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYW5jZWxsZXJzLnB1c2goKCkgPT4geyB0aGlzLnByb3ZpZGVyLm9mZih0aGlzLmhhc2gsIHR4TGlzdGVuZXIpOyB9KTtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub24odGhpcy5oYXNoLCB0eExpc3RlbmVyKTtcbiAgICAgICAgICAgIC8vIFdlIHN1cHBvcnQgcmVwbGFjZW1lbnQgZGV0ZWN0aW9uOyBzdGFydCBjaGVja2luZ1xuICAgICAgICAgICAgaWYgKHN0YXJ0QmxvY2sgPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VMaXN0ZW5lciA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHJlcGxhY2VtZW50OyB0aGlzIHRocm93cyBvbmx5IGlmIG9uZSBpcyBmb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2hlY2tSZXBsYWNlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSByZXBsYWNlZCAod2l0aCBlbm91Z2ggY29uZmlybXMpOyByZS10aHJvdyB0aGUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzY2hldWRsZSBhIGNoZWNrIG9uIHRoZSBuZXh0IGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RvcFNjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCByZXBsYWNlTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYW5jZWxsZXJzLnB1c2goKCkgPT4geyB0aGlzLnByb3ZpZGVyLm9mZihcImJsb2NrXCIsIHJlcGxhY2VMaXN0ZW5lcik7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub25jZShcImJsb2NrXCIsIHJlcGxhY2VMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgd2FpdGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBpZiB0aGlzIHRyYW5zYWN0aW9uIGhhcyBiZWVuIGluY2x1ZGVkLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZWZmZWN0aXZlIG9ubHkgYXMgb2YgdGhlIHRpbWUgdGhlIFRyYW5zYWN0aW9uUmVzcG9uc2VcbiAgICAgKiAgd2FzIGluc3RhbnRpYXRlZC4gVG8gZ2V0IHVwLXRvLWRhdGUgaW5mb3JtYXRpb24sIHVzZVxuICAgICAqICBbW2dldFRyYW5zYWN0aW9uXV0uXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdpbGwgaGF2ZVxuICAgICAqICBub24tbnVsbCBwcm9wZXJ0eSB2YWx1ZXMgZm9yIHByb3BlcnRpZXMgdGhhdCBhcmUgbnVsbCBmb3JcbiAgICAgKiAgdW5taW5lZCB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgaXNNaW5lZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJsb2NrSGFzaCAhPSBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBsZWdhY3kgKGkuZS4gYGB0eXBlID09IDBgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdpbGwgaGF2ZVxuICAgICAqICB0aGUgYGBudWxsYGAtbmVzcyBmb3IgaGFyZGZvcmstc3BlY2lmaWMgcHJvcGVydGllcyBzZXQgY29ycmVjdGx5LlxuICAgICAqL1xuICAgIGlzTGVnYWN5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGEgQmVybGluIChpLmUuIGBgdHlwZSA9PSAxYGApXG4gICAgICogIHRyYW5zYWN0aW9uLiBTZWUgW1tsaW5rLWVpcC0yMDcwXV0uXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdpbGwgaGF2ZVxuICAgICAqICB0aGUgYGBudWxsYGAtbmVzcyBmb3IgaGFyZGZvcmstc3BlY2lmaWMgcHJvcGVydGllcyBzZXQgY29ycmVjdGx5LlxuICAgICAqL1xuICAgIGlzQmVybGluKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGEgTG9uZG9uIChpLmUuIGBgdHlwZSA9PSAyYGApXG4gICAgICogIHRyYW5zYWN0aW9uLiBTZWUgW1tsaW5rLWVpcC0xNTU5XV0uXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdpbGwgaGF2ZVxuICAgICAqICB0aGUgYGBudWxsYGAtbmVzcyBmb3IgaGFyZGZvcmstc3BlY2lmaWMgcHJvcGVydGllcyBzZXQgY29ycmVjdGx5LlxuICAgICAqL1xuICAgIGlzTG9uZG9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgZmlsdGVyIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGxpc3RlbiBmb3Igb3JwaGFuIGV2ZW50c1xuICAgICAqICB0aGF0IGV2aWN0IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgcmVtb3ZlZEV2ZW50KCkge1xuICAgICAgICBhc3NlcnQodGhpcy5pc01pbmVkKCksIFwidW5taW5lZCB0cmFuc2FjdGlvbiBjYW5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW1vdmVFdmVudCgpXCIgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgZmlsdGVyIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGxpc3RlbiBmb3Igb3JwaGFuIGV2ZW50c1xuICAgICAqICB0aGF0IHJlLW9yZGVyIHRoaXMgZXZlbnQgYWdhaW5zdCAlJW90aGVyJSUuXG4gICAgICovXG4gICAgcmVvcmRlcmVkRXZlbnQob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuaXNNaW5lZCgpLCBcInVubWluZWQgdHJhbnNhY3Rpb24gY2Fub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVtb3ZlRXZlbnQoKVwiIH0pO1xuICAgICAgICBhc3NlcnQoIW90aGVyIHx8IG90aGVyLmlzTWluZWQoKSwgXCJ1bm1pbmVkICdvdGhlcicgdHJhbnNhY3Rpb24gY2Fub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVtb3ZlRXZlbnQoKVwiIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIodGhpcywgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlIGluc3RhbmNlIHdoaWNoIGhhcyB0aGUgYWJpbGl0eSB0b1xuICAgICAqICBkZXRlY3QgKGFuZCB0aHJvdyBhbiBlcnJvcikgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIHJlcGxhY2VkLCB3aGljaFxuICAgICAqICB3aWxsIGJlZ2luIHNjYW5uaW5nIGF0ICUlc3RhcnRCbG9jayUlLlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgdXNlZCBieSBkZXZlbG9wZXJzIGFuZCBpcyBpbnRlbmRlZFxuICAgICAqICBwcmltYXJpbHkgZm9yIGludGVybmFsIHVzZS4gU2V0dGluZyBhbiBpbmNvcnJlY3QgJSVzdGFydEJsb2NrJSUgY2FuXG4gICAgICogIGhhdmUgZGV2YXN0YXRpbmcgcGVyZm9ybWFuY2UgY29uc2VxdWVuY2VzIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICovXG4gICAgcmVwbGFjZWFibGVUcmFuc2FjdGlvbihzdGFydEJsb2NrKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIoc3RhcnRCbG9jaykgJiYgc3RhcnRCbG9jayA+PSAwLCBcImludmFsaWQgc3RhcnRCbG9ja1wiLCBcInN0YXJ0QmxvY2tcIiwgc3RhcnRCbG9jayk7XG4gICAgICAgIGNvbnN0IHR4ID0gbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UodGhpcywgdGhpcy5wcm92aWRlcik7XG4gICAgICAgIHR4LiNzdGFydEJsb2NrID0gc3RhcnRCbG9jaztcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZU9ycGhhbmVkQmxvY2tGaWx0ZXIoYmxvY2spIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC1ibG9ja1wiLCBoYXNoOiBibG9jay5oYXNoLCBudW1iZXI6IGJsb2NrLm51bWJlciB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIodHgsIG90aGVyKSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcInJlb3JkZXItdHJhbnNhY3Rpb25cIiwgdHgsIG90aGVyIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIodHgpIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC10cmFuc2FjdGlvblwiLCB0eCB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVtb3ZlZExvZ0ZpbHRlcihsb2cpIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC1sb2dcIiwgbG9nOiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGxvZy50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICBibG9ja0hhc2g6IGxvZy5ibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9ja051bWJlcjogbG9nLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgYWRkcmVzczogbG9nLmFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgIHRvcGljczogT2JqZWN0LmZyZWV6ZShsb2cudG9waWNzLnNsaWNlKCkpLFxuICAgICAgICAgICAgaW5kZXg6IGxvZy5pbmRleFxuICAgICAgICB9IH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci5qcy5tYXAiLCIvLyBpbXBvcnQgZnJvbSBwcm92aWRlci50cyBpbnN0ZWFkIG9mIGluZGV4LnRzIHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwXG4vLyBmcm9tIEV0aGVyc2NhblByb3ZpZGVyXG5pbXBvcnQgeyBMb2csIFRyYW5zYWN0aW9uUmVjZWlwdCwgVHJhbnNhY3Rpb25SZXNwb25zZSB9IGZyb20gXCIuLi9wcm92aWRlcnMvcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIEV2ZW50UGF5bG9hZCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiAgQW4gKipFdmVudExvZyoqIGNvbnRhaW5zIGFkZGl0aW9uYWwgcHJvcGVydGllcyBwYXJzZWQgZnJvbSB0aGUgW1tMb2ddXS5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50TG9nIGV4dGVuZHMgTG9nIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIENvbnRyYWN0IEludGVyZmFjZS5cbiAgICAgKi9cbiAgICBpbnRlcmZhY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBldmVudC5cbiAgICAgKi9cbiAgICBmcmFnbWVudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHBhcnNlZCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBldmVudCBieSBgYGVtaXRgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZywgaWZhY2UsIGZyYWdtZW50KSB7XG4gICAgICAgIHN1cGVyKGxvZywgbG9nLnByb3ZpZGVyKTtcbiAgICAgICAgY29uc3QgYXJncyA9IGlmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhcmdzLCBmcmFnbWVudCwgaW50ZXJmYWNlOiBpZmFjZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnROYW1lKCkgeyByZXR1cm4gdGhpcy5mcmFnbWVudC5uYW1lOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzaWduYXR1cmUgb2YgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIGdldCBldmVudFNpZ25hdHVyZSgpIHsgcmV0dXJuIHRoaXMuZnJhZ21lbnQuZm9ybWF0KCk7IH1cbn1cbi8qKlxuICogIEFuICoqRXZlbnRMb2cqKiBjb250YWlucyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgcGFyc2VkIGZyb20gdGhlIFtbTG9nXV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBVbmRlY29kZWRFdmVudExvZyBleHRlbmRzIExvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBlcnJvciBlbmNvdW50ZWQgd2hlbiB0cnlpbmcgdG8gZGVjb2RlIHRoZSBsb2cuXG4gICAgICovXG4gICAgZXJyb3I7XG4gICAgLyoqXG4gICAgICogQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9nLCBlcnJvcikge1xuICAgICAgICBzdXBlcihsb2csIGxvZy5wcm92aWRlcik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBlcnJvciB9KTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQqKiBpbmNsdWRlcyB0aGUgcGFyc2VkIGxvZ3MgZnJvbSBhXG4gKiAgW1tUcmFuc2FjdGlvblJlY2VpcHRdXS5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0IGV4dGVuZHMgVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICAjaWZhY2U7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlmYWNlLCBwcm92aWRlciwgdHgpIHtcbiAgICAgICAgc3VwZXIodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jaWZhY2UgPSBpZmFjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXJzZWQgbG9ncyBmb3IgYW55IFtbTG9nXV0gd2hpY2ggaGFzIGEgbWF0Y2hpbmcgZXZlbnQgaW4gdGhlXG4gICAgICogIENvbnRyYWN0IEFCSS5cbiAgICAgKi9cbiAgICBnZXQgbG9ncygpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmxvZ3MubWFwKChsb2cpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbG9nLnRvcGljcy5sZW5ndGggPyB0aGlzLiNpZmFjZS5nZXRFdmVudChsb2cudG9waWNzWzBdKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50TG9nKGxvZywgdGhpcy4jaWZhY2UsIGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5kZWNvZGVkRXZlbnRMb2cobG9nLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkNvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSoqIHdpbGwgcmV0dXJuIGFcbiAqICBbW0NvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0XV0gd2hlbiB3YWl0ZWQgb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UgZXh0ZW5kcyBUcmFuc2FjdGlvblJlc3BvbnNlIHtcbiAgICAjaWZhY2U7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlmYWNlLCBwcm92aWRlciwgdHgpIHtcbiAgICAgICAgc3VwZXIodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jaWZhY2UgPSBpZmFjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhbmQgaGFzXG4gICAgICogICUlY29uZmlybXMlJSBibG9ja3MgaW5jbHVkaW5nIGl0IChkZWZhdWx0OiBgYDFgYCkgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJXRpbWVvdXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiByZXNvbHZlIHRvIGBgbnVsbGBgIG9ubHkgaWYgJSVjb25maXJtcyUlIGlzIGBgMGBgXG4gICAgICogIGFuZCB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkLCBvdGhlcndpc2UgdGhpcyB3aWxsXG4gICAgICogIHdhaXQgdW50aWwgZW5vdWdoIGNvbmZpcm1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdChjb25maXJtcykge1xuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgc3VwZXIud2FpdChjb25maXJtcyk7XG4gICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQodGhpcy4jaWZhY2UsIHRoaXMucHJvdmlkZXIsIHJlY2VpcHQpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipDb250cmFjdFVua25vd25FdmVudFBheWxvYWQqKiBpcyBpbmNsdWRlZCBhcyB0aGUgbGFzdCBwYXJhbWV0ZXIgdG9cbiAqICBDb250cmFjdCBFdmVudHMgd2hlbiB0aGUgZXZlbnQgZG9lcyBub3QgbWF0Y2ggYW55IGV2ZW50cyBpbiB0aGUgQUJJLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkIGV4dGVuZHMgRXZlbnRQYXlsb2FkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGxvZyB3aXRoIG5vIG1hdGNoaW5nIGV2ZW50cy5cbiAgICAgKi9cbiAgICBsb2c7XG4gICAgLyoqXG4gICAgICogIEBfZXZlbnQ6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIsIGxvZykge1xuICAgICAgICBzdXBlcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlcik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBsb2cgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYmxvY2sgdGhlIGV2ZW50IG9jY3VyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvZy5nZXRCbG9jaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2cuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9nLmdldFRyYW5zYWN0aW9uUmVjZWlwdCgpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipDb250cmFjdEV2ZW50UGF5bG9hZCoqIGlzIGluY2x1ZGVkIGFzIHRoZSBsYXN0IHBhcmFtZXRlciB0b1xuICogIENvbnRyYWN0IEV2ZW50cyB3aGVuIHRoZSBldmVudCBpcyBrbm93bi5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0RXZlbnRQYXlsb2FkIGV4dGVuZHMgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkIHtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIsIGZyYWdtZW50LCBfbG9nKSB7XG4gICAgICAgIHN1cGVyKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyLCBuZXcgRXZlbnRMb2coX2xvZywgY29udHJhY3QuaW50ZXJmYWNlLCBmcmFnbWVudCkpO1xuICAgICAgICBjb25zdCBhcmdzID0gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCB0aGlzLmxvZy5kYXRhLCB0aGlzLmxvZy50b3BpY3MpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYXJncywgZnJhZ21lbnQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZXZlbnQgbmFtZS5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGV2ZW50IHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRTaWduYXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50LmZvcm1hdCgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdyYXBwZXJzLmpzLm1hcCIsImltcG9ydCB7IEludGVyZmFjZSwgVHlwZWQgfSBmcm9tIFwiLi4vYWJpL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpc0FkZHJlc3NhYmxlLCByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG4vLyBpbXBvcnQgZnJvbSBwcm92aWRlci50cyBpbnN0ZWFkIG9mIGluZGV4LnRzIHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwXG4vLyBmcm9tIEV0aGVyc2NhblByb3ZpZGVyXG5pbXBvcnQgeyBjb3B5UmVxdWVzdCwgTG9nIH0gZnJvbSBcIi4uL3Byb3ZpZGVycy9wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBpc0NhbGxFeGNlcHRpb24sIGlzSGV4U3RyaW5nLCByZXNvbHZlUHJvcGVydGllcywgaXNFcnJvciwgbWFrZUVycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDb250cmFjdEV2ZW50UGF5bG9hZCwgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkLCBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UsIEV2ZW50TG9nLCBVbmRlY29kZWRFdmVudExvZyB9IGZyb20gXCIuL3dyYXBwZXJzLmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuZnVuY3Rpb24gY2FuQ2FsbCh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5jYWxsKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGNhbkVzdGltYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmVzdGltYXRlR2FzKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGNhblJlc29sdmUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUucmVzb2x2ZU5hbWUpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gY2FuU2VuZCh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5zZW5kVHJhbnNhY3Rpb24pID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBpZiAoY2FuUmVzb2x2ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5wcm92aWRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuY2xhc3MgUHJlcGFyZWRUb3BpY0ZpbHRlciB7XG4gICAgI2ZpbHRlcjtcbiAgICBmcmFnbWVudDtcbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGZyYWdtZW50IH0pO1xuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbWFueSBhcmd1bWVudHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZGVzY2VuZCBpbnRvIGFyZ3MgYW5kIHJlc29sdmUgYW55IGFkZHJlc3Nlc1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGNhblJlc29sdmUocnVubmVyKSA/IHJ1bm5lciA6IG51bGw7XG4gICAgICAgIHRoaXMuI2ZpbHRlciA9IChhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZEFyZ3MgPSBhd2FpdCBQcm9taXNlLmFsbChmcmFnbWVudC5pbnB1dHMubWFwKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbS53YWxrQXN5bmMoYXJnc1tpbmRleF0sICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh2YWx1ZS5tYXAoKHYpID0+IHJlc29sdmVBZGRyZXNzKHYsIHJlc29sdmVyKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzKHZhbHVlLCByZXNvbHZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGaWx0ZXJUb3BpY3MoZnJhZ21lbnQsIHJlc29sdmVkQXJncyk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGdldFRvcGljRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZmlsdGVyO1xuICAgIH1cbn1cbi8vIEEgPSBBcmd1bWVudHMgcGFzc2VkIGluIGFzIGEgdHVwbGVcbi8vIFIgPSBUaGUgcmVzdWx0IHR5cGUgb2YgdGhlIGNhbGwgKGkuZS4gaWYgb25seSBvbmUgcmV0dXJuIHR5cGUsXG4vLyAgICAgdGhlIHF1YWxpZmllZCB0eXBlLCBvdGhlcndpc2UgUmVzdWx0KVxuLy8gRCA9IFRoZSB0eXBlIHRoZSBkZWZhdWx0IGNhbGwgd2lsbCByZXR1cm4gKGkuZS4gUiBmb3Igdmlldy9wdXJlLFxuLy8gICAgIFRyYW5zYWN0aW9uUmVzcG9uc2Ugb3RoZXJ3aXNlKVxuLy9leHBvcnQgaW50ZXJmYWNlIENvbnRyYWN0TWV0aG9kPEEgZXh0ZW5kcyBBcnJheTxhbnk+ID0gQXJyYXk8YW55PiwgUiA9IGFueSwgRCBleHRlbmRzIFIgfCBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UgPSBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2U+IHtcbmZ1bmN0aW9uIGdldFJ1bm5lcih2YWx1ZSwgZmVhdHVyZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZVtmZWF0dXJlXSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5wcm92aWRlciAmJiB0eXBlb2YgKHZhbHVlLnByb3ZpZGVyW2ZlYXR1cmVdKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5wcm92aWRlcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRQcm92aWRlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUucHJvdmlkZXIgfHwgbnVsbDtcbn1cbi8qKlxuICogIEBfaWdub3JlOlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29weU92ZXJyaWRlcyhhcmcsIGFsbG93ZWQpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG92ZXJyaWRlcyBwYXNzZWQgaW4gYXJlIGEgdmFsaWQgb3ZlcnJpZGVzIG9iamVjdFxuICAgIGNvbnN0IF9vdmVycmlkZXMgPSBUeXBlZC5kZXJlZmVyZW5jZShhcmcsIFwib3ZlcnJpZGVzXCIpO1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoX292ZXJyaWRlcykgPT09IFwib2JqZWN0XCIsIFwiaW52YWxpZCBvdmVycmlkZXMgcGFyYW1ldGVyXCIsIFwib3ZlcnJpZGVzXCIsIGFyZyk7XG4gICAgLy8gQ3JlYXRlIGEgc2hhbGxvdyBjb3B5ICh3ZSdsbCBkZWVwLWlmeSBhbnl0aGluZyBuZWVkZWQgZHVyaW5nIG5vcm1hbGl6aW5nKVxuICAgIGNvbnN0IG92ZXJyaWRlcyA9IGNvcHlSZXF1ZXN0KF9vdmVycmlkZXMpO1xuICAgIGFzc2VydEFyZ3VtZW50KG92ZXJyaWRlcy50byA9PSBudWxsIHx8IChhbGxvd2VkIHx8IFtdKS5pbmRleE9mKFwidG9cIikgPj0gMCwgXCJjYW5ub3Qgb3ZlcnJpZGUgdG9cIiwgXCJvdmVycmlkZXMudG9cIiwgb3ZlcnJpZGVzLnRvKTtcbiAgICBhc3NlcnRBcmd1bWVudChvdmVycmlkZXMuZGF0YSA9PSBudWxsIHx8IChhbGxvd2VkIHx8IFtdKS5pbmRleE9mKFwiZGF0YVwiKSA+PSAwLCBcImNhbm5vdCBvdmVycmlkZSBkYXRhXCIsIFwib3ZlcnJpZGVzLmRhdGFcIiwgb3ZlcnJpZGVzLmRhdGEpO1xuICAgIC8vIFJlc29sdmUgYW55IGZyb21cbiAgICBpZiAob3ZlcnJpZGVzLmZyb20pIHtcbiAgICAgICAgb3ZlcnJpZGVzLmZyb20gPSBvdmVycmlkZXMuZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIG92ZXJyaWRlcztcbn1cbi8qKlxuICogIEBfaWdub3JlOlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUFyZ3MoX3J1bm5lciwgaW5wdXRzLCBhcmdzKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgZGVzY2VuZCBpbnRvIGFyZ3MgYW5kIHJlc29sdmUgYW55IGFkZHJlc3Nlc1xuICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihfcnVubmVyLCBcInJlc29sdmVOYW1lXCIpO1xuICAgIGNvbnN0IHJlc29sdmVyID0gY2FuUmVzb2x2ZShydW5uZXIpID8gcnVubmVyIDogbnVsbDtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoaW5wdXRzLm1hcCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiBwYXJhbS53YWxrQXN5bmMoYXJnc1tpbmRleF0sICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZSh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUFkZHJlc3ModmFsdWUsIHJlc29sdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gYnVpbGRXcmFwcGVkRmFsbGJhY2soY29udHJhY3QpIHtcbiAgICBjb25zdCBwb3B1bGF0ZVRyYW5zYWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICAvLyBJZiBhbiBvdmVycmlkZXMgd2FzIHBhc3NlZCBpbiwgY29weSBpdCBhbmQgbm9ybWFsaXplIHRoZSB2YWx1ZXNcbiAgICAgICAgY29uc3QgdHggPSAoYXdhaXQgY29weU92ZXJyaWRlcyhvdmVycmlkZXMsIFtcImRhdGFcIl0pKTtcbiAgICAgICAgdHgudG8gPSBhd2FpdCBjb250cmFjdC5nZXRBZGRyZXNzKCk7XG4gICAgICAgIGlmICh0eC5mcm9tKSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3ModHguZnJvbSwgZ2V0UmVzb2x2ZXIoY29udHJhY3QucnVubmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWZhY2UgPSBjb250cmFjdC5pbnRlcmZhY2U7XG4gICAgICAgIGNvbnN0IG5vVmFsdWUgPSAoZ2V0QmlnSW50KCh0eC52YWx1ZSB8fCBCTl8wKSwgXCJvdmVycmlkZXMudmFsdWVcIikgPT09IEJOXzApO1xuICAgICAgICBjb25zdCBub0RhdGEgPSAoKHR4LmRhdGEgfHwgXCIweFwiKSA9PT0gXCIweFwiKTtcbiAgICAgICAgaWYgKGlmYWNlLmZhbGxiYWNrICYmICFpZmFjZS5mYWxsYmFjay5wYXlhYmxlICYmIGlmYWNlLnJlY2VpdmUgJiYgIW5vRGF0YSAmJiAhbm9WYWx1ZSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiY2Fubm90IHNlbmQgZGF0YSB0byByZWNlaXZlIG9yIHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZmFsbGJhY2tcIiwgXCJvdmVycmlkZXNcIiwgb3ZlcnJpZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChpZmFjZS5mYWxsYmFjayB8fCBub0RhdGEsIFwiY2Fubm90IHNlbmQgZGF0YSB0byByZWNlaXZlLW9ubHkgY29udHJhY3RcIiwgXCJvdmVycmlkZXMuZGF0YVwiLCB0eC5kYXRhKTtcbiAgICAgICAgLy8gT25seSBhbGxvdyBwYXlhYmxlIGNvbnRyYWN0cyB0byBzZXQgbm9uLXplcm8gdmFsdWVcbiAgICAgICAgY29uc3QgcGF5YWJsZSA9IGlmYWNlLnJlY2VpdmUgfHwgKGlmYWNlLmZhbGxiYWNrICYmIGlmYWNlLmZhbGxiYWNrLnBheWFibGUpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwYXlhYmxlIHx8IG5vVmFsdWUsIFwiY2Fubm90IHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZmFsbGJhY2tcIiwgXCJvdmVycmlkZXMudmFsdWVcIiwgdHgudmFsdWUpO1xuICAgICAgICAvLyBPbmx5IGFsbG93IGZhbGxiYWNrIGNvbnRyYWN0cyB0byBzZXQgbm9uLWVtcHR5IGRhdGFcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaWZhY2UuZmFsbGJhY2sgfHwgbm9EYXRhLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZS1vbmx5IGNvbnRyYWN0XCIsIFwib3ZlcnJpZGVzLmRhdGFcIiwgdHguZGF0YSk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0NhbGwgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiY2FsbFwiKTtcbiAgICAgICAgYXNzZXJ0KGNhbkNhbGwocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBjYWxsaW5nXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImNhbGxcIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcnVubmVyLmNhbGwodHgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikgJiYgZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNvbnRyYWN0LmludGVyZmFjZS5tYWtlRXJyb3IoZXJyb3IuZGF0YSwgdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNlbmQgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGNvbnRyYWN0LnJ1bm5lcjtcbiAgICAgICAgYXNzZXJ0KGNhblNlbmQocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzZW5kaW5nIHRyYW5zYWN0aW9uc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBydW5uZXIuc2VuZFRyYW5zYWN0aW9uKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24ob3ZlcnJpZGVzKSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcbiAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxuICAgICAgICAvLyBtZWFuaW5nZnVsIGVycm9yXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKGNvbnRyYWN0LmludGVyZmFjZSwgcHJvdmlkZXIsIHR4KTtcbiAgICB9O1xuICAgIGNvbnN0IGVzdGltYXRlR2FzID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImVzdGltYXRlR2FzXCIpO1xuICAgICAgICBhc3NlcnQoY2FuRXN0aW1hdGUocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBnYXMgZXN0aW1hdGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJlc3RpbWF0ZUdhc1wiIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgcnVubmVyLmVzdGltYXRlR2FzKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24ob3ZlcnJpZGVzKSk7XG4gICAgfTtcbiAgICBjb25zdCBtZXRob2QgPSBhc3luYyAob3ZlcnJpZGVzKSA9PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzZW5kKG92ZXJyaWRlcyk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKG1ldGhvZCwge1xuICAgICAgICBfY29udHJhY3Q6IGNvbnRyYWN0LFxuICAgICAgICBlc3RpbWF0ZUdhcyxcbiAgICAgICAgcG9wdWxhdGVUcmFuc2FjdGlvbixcbiAgICAgICAgc2VuZCwgc3RhdGljQ2FsbFxuICAgIH0pO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG5mdW5jdGlvbiBidWlsZFdyYXBwZWRNZXRob2QoY29udHJhY3QsIGtleSkge1xuICAgIGNvbnN0IGdldEZyYWdtZW50ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RnVuY3Rpb24oa2V5LCBhcmdzKTtcbiAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgaW5mbzogeyBrZXksIGFyZ3MgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH07XG4gICAgY29uc3QgcG9wdWxhdGVUcmFuc2FjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XG4gICAgICAgIC8vIElmIGFuIG92ZXJyaWRlcyB3YXMgcGFzc2VkIGluLCBjb3B5IGl0IGFuZCBub3JtYWxpemUgdGhlIHZhbHVlc1xuICAgICAgICBsZXQgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoICsgMSA9PT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlcyA9IGF3YWl0IGNvcHlPdmVycmlkZXMoYXJncy5wb3AoKSk7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVzLmZyb20pIHtcbiAgICAgICAgICAgICAgICBvdmVycmlkZXMuZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKG92ZXJyaWRlcy5mcm9tLCBnZXRSZXNvbHZlcihjb250cmFjdC5ydW5uZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsIGVycm9yOiBmcmFnbWVudCBpbnB1dHMgZG9lc24ndCBtYXRjaCBhcmd1bWVudHM7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc29sdmVkQXJncyA9IGF3YWl0IHJlc29sdmVBcmdzKGNvbnRyYWN0LnJ1bm5lciwgZnJhZ21lbnQuaW5wdXRzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRlcywgYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgdG86IGNvbnRyYWN0LmdldEFkZHJlc3MoKSxcbiAgICAgICAgICAgIGRhdGE6IGNvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHJlc29sdmVkQXJncylcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgY29uc3Qgc3RhdGljQ2FsbCA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0YXRpY0NhbGxSZXN1bHQoLi4uYXJncyk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBjb25zdCBzZW5kID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gY29udHJhY3QucnVubmVyO1xuICAgICAgICBhc3NlcnQoY2FuU2VuZChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHNlbmRpbmcgdHJhbnNhY3Rpb25zXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHJ1bm5lci5zZW5kVHJhbnNhY3Rpb24oYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbiguLi5hcmdzKSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcbiAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxuICAgICAgICAvLyBtZWFuaW5nZnVsIGVycm9yXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKGNvbnRyYWN0LmludGVyZmFjZSwgcHJvdmlkZXIsIHR4KTtcbiAgICB9O1xuICAgIGNvbnN0IGVzdGltYXRlR2FzID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJlc3RpbWF0ZUdhc1wiKTtcbiAgICAgICAgYXNzZXJ0KGNhbkVzdGltYXRlKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgZ2FzIGVzdGltYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZXN0aW1hdGVHYXNcIiB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5lc3RpbWF0ZUdhcyhhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKC4uLmFyZ3MpKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0NhbGxSZXN1bHQgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImNhbGxcIik7XG4gICAgICAgIGFzc2VydChjYW5DYWxsKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZ1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJjYWxsXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbiguLi5hcmdzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJ1bm5lci5jYWxsKHR4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0NhbGxFeGNlcHRpb24oZXJyb3IpICYmIGVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjb250cmFjdC5pbnRlcmZhY2UubWFrZUVycm9yKGVycm9yLmRhdGEsIHR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XG4gICAgICAgIHJldHVybiBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHJlc3VsdCk7XG4gICAgfTtcbiAgICBjb25zdCBtZXRob2QgPSBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGdldEZyYWdtZW50KC4uLmFyZ3MpO1xuICAgICAgICBpZiAoZnJhZ21lbnQuY29uc3RhbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBzdGF0aWNDYWxsKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBzZW5kKC4uLmFyZ3MpO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydGllcyhtZXRob2QsIHtcbiAgICAgICAgbmFtZTogY29udHJhY3QuaW50ZXJmYWNlLmdldEZ1bmN0aW9uTmFtZShrZXkpLFxuICAgICAgICBfY29udHJhY3Q6IGNvbnRyYWN0LCBfa2V5OiBrZXksXG4gICAgICAgIGdldEZyYWdtZW50LFxuICAgICAgICBlc3RpbWF0ZUdhcyxcbiAgICAgICAgcG9wdWxhdGVUcmFuc2FjdGlvbixcbiAgICAgICAgc2VuZCwgc3RhdGljQ2FsbCwgc3RhdGljQ2FsbFJlc3VsdCxcbiAgICB9KTtcbiAgICAvLyBPbmx5IHdvcmtzIG9uIG5vbi1hbWJpZ3VvdXMga2V5cyAocmVmaW5lZCBmcmFnbWVudCBpcyBhbHdheXMgbm9uLWFtYmlndW91cylcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0aG9kLCBcImZyYWdtZW50XCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRGdW5jdGlvbihrZXkpO1xuICAgICAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IGtleSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG5mdW5jdGlvbiBidWlsZFdyYXBwZWRFdmVudChjb250cmFjdCwga2V5KSB7XG4gICAgY29uc3QgZ2V0RnJhZ21lbnQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChrZXksIGFyZ3MpO1xuICAgICAgICBhc3NlcnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnJhZ21lbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICBpbmZvOiB7IGtleSwgYXJncyB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfTtcbiAgICBjb25zdCBtZXRob2QgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFByZXBhcmVkVG9waWNGaWx0ZXIoY29udHJhY3QsIGdldEZyYWdtZW50KC4uLmFyZ3MpLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnRpZXMobWV0aG9kLCB7XG4gICAgICAgIG5hbWU6IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudE5hbWUoa2V5KSxcbiAgICAgICAgX2NvbnRyYWN0OiBjb250cmFjdCwgX2tleToga2V5LFxuICAgICAgICBnZXRGcmFnbWVudFxuICAgIH0pO1xuICAgIC8vIE9ubHkgd29ya3Mgb24gbm9uLWFtYmlndW91cyBrZXlzIChyZWZpbmVkIGZyYWdtZW50IGlzIGFsd2F5cyBub24tYW1iaWd1b3VzKVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRob2QsIFwiZnJhZ21lbnRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGtleSk7XG4gICAgICAgICAgICBhc3NlcnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnJhZ21lbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgICAgIGluZm86IHsga2V5IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbi8vIFRoZSBjb21iaW5hdGlvbiBvZiBUeXBlU2NyeXBlLCBQcml2YXRlIEZpZWxkcyBhbmQgUHJveGllcyBtYWtlc1xuLy8gdGhlIHdvcmxkIGdvIGJvb207IHNvIHdlIGhpZGUgdmFyaWFibGVzIHdpdGggc29tZSB0cmlja2VyeSBrZWVwaW5nXG4vLyBhIHN5bWJvbCBhdHRhY2hlZCB0byBlYWNoIEJhc2VDb250cmFjdCB3aGljaCBpdHMgc3ViLWNsYXNzIChldmVuXG4vLyB2aWEgYSBQcm94eSkgY2FuIHJlYWNoIGFuZCB1c2UgdG8gbG9vayB1cCBpdHMgaW50ZXJuYWwgdmFsdWVzLlxuY29uc3QgaW50ZXJuYWwgPSBTeW1ib2wuZm9yKFwiX2V0aGVyc0ludGVybmFsX2NvbnRyYWN0XCIpO1xuY29uc3QgaW50ZXJuYWxWYWx1ZXMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc2V0SW50ZXJuYWwoY29udHJhY3QsIHZhbHVlcykge1xuICAgIGludGVybmFsVmFsdWVzLnNldChjb250cmFjdFtpbnRlcm5hbF0sIHZhbHVlcyk7XG59XG5mdW5jdGlvbiBnZXRJbnRlcm5hbChjb250cmFjdCkge1xuICAgIHJldHVybiBpbnRlcm5hbFZhbHVlcy5nZXQoY29udHJhY3RbaW50ZXJuYWxdKTtcbn1cbmZ1bmN0aW9uIGlzRGVmZXJyZWQodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiICYmIChcImdldFRvcGljRmlsdGVyXCIgaW4gdmFsdWUpICYmXG4gICAgICAgICh0eXBlb2YgKHZhbHVlLmdldFRvcGljRmlsdGVyKSA9PT0gXCJmdW5jdGlvblwiKSAmJiB2YWx1ZS5mcmFnbWVudCk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCkge1xuICAgIGxldCB0b3BpY3M7XG4gICAgbGV0IGZyYWdtZW50ID0gbnVsbDtcbiAgICAvLyBDb252ZXJ0IG5hbWVkIGV2ZW50cyB0byB0b3BpY0hhc2ggYW5kIGdldCB0aGUgZnJhZ21lbnQgZm9yXG4gICAgLy8gZXZlbnRzIHdoaWNoIG5lZWQgZGVjb25zdHJ1Y3RpbmcuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgIGNvbnN0IHRvcGljSGFzaGlmeSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcobmFtZSwgMzIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChuYW1lKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcInVua25vd24gZnJhZ21lbnRcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQXJyYXkgb2YgVG9waWNzIGFuZCBOYW1lczsgZS5nLiBgWyBcIjB4MTIzNC4uLjg5YWJcIiwgXCJUcmFuc2ZlcihhZGRyZXNzKVwiIF1gXG4gICAgICAgIHRvcGljcyA9IGV2ZW50Lm1hcCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5tYXAodG9waWNIYXNoaWZ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b3BpY0hhc2hpZnkoZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudCA9PT0gXCIqXCIpIHtcbiAgICAgICAgdG9waWNzID0gW251bGxdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGV2ZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoZXZlbnQsIDMyKSkge1xuICAgICAgICAgICAgLy8gVG9waWMgSGFzaFxuICAgICAgICAgICAgdG9waWNzID0gW2V2ZW50XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5hbWUgb3IgU2lnbmF0dXJlOyBlLmcuIGBcIlRyYW5zZmVyXCIsIGBcIlRyYW5zZmVyKGFkZHJlc3MpXCJgXG4gICAgICAgICAgICBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChldmVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJ1bmtub3duIGZyYWdtZW50XCIsIFwiZXZlbnRcIiwgZXZlbnQpO1xuICAgICAgICAgICAgdG9waWNzID0gW2ZyYWdtZW50LnRvcGljSGFzaF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZWZlcnJlZChldmVudCkpIHtcbiAgICAgICAgLy8gRGVmZXJyZWQgVG9waWMgRmlsdGVyOyBlLmcuIGBjb250cmFjdC5maWx0ZXIuVHJhbnNmZXIoZnJvbSlgXG4gICAgICAgIHRvcGljcyA9IGF3YWl0IGV2ZW50LmdldFRvcGljRmlsdGVyKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKFwiZnJhZ21lbnRcIiBpbiBldmVudCkge1xuICAgICAgICAvLyBDb250cmFjdEV2ZW50OyBlLmcuIGBjb250cmFjdC5maWx0ZXIuVHJhbnNmZXJgXG4gICAgICAgIGZyYWdtZW50ID0gZXZlbnQuZnJhZ21lbnQ7XG4gICAgICAgIHRvcGljcyA9IFtmcmFnbWVudC50b3BpY0hhc2hdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5rbm93biBldmVudCBuYW1lXCIsIFwiZXZlbnRcIiwgZXZlbnQpO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgdG9waWNzIGFuZCBzb3J0IFRvcGljU2V0c1xuICAgIHRvcGljcyA9IHRvcGljcy5tYXAoKHQpID0+IHtcbiAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbShuZXcgU2V0KHQubWFwKCh0KSA9PiB0LnRvTG93ZXJDYXNlKCkpKS52YWx1ZXMoKSk7XG4gICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gICAgY29uc3QgdGFnID0gdG9waWNzLm1hcCgodCkgPT4ge1xuICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0LmpvaW4oXCJ8XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH0pLmpvaW4oXCImXCIpO1xuICAgIHJldHVybiB7IGZyYWdtZW50LCB0YWcsIHRvcGljcyB9O1xufVxuYXN5bmMgZnVuY3Rpb24gaGFzU3ViKGNvbnRyYWN0LCBldmVudCkge1xuICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwoY29udHJhY3QpO1xuICAgIHJldHVybiBzdWJzLmdldCgoYXdhaXQgZ2V0U3ViSW5mbyhjb250cmFjdCwgZXZlbnQpKS50YWcpIHx8IG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTdWIoY29udHJhY3QsIG9wZXJhdGlvbiwgZXZlbnQpIHtcbiAgICAvLyBNYWtlIHN1cmUgb3VyIHJ1bm5lciBjYW4gYWN0dWFsbHkgc3Vic2NyaWJlIHRvIGV2ZW50c1xuICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcbiAgICBhc3NlcnQocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc3Vic2NyaWJpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb24gfSk7XG4gICAgY29uc3QgeyBmcmFnbWVudCwgdGFnLCB0b3BpY3MgfSA9IGF3YWl0IGdldFN1YkluZm8oY29udHJhY3QsIGV2ZW50KTtcbiAgICBjb25zdCB7IGFkZHIsIHN1YnMgfSA9IGdldEludGVybmFsKGNvbnRyYWN0KTtcbiAgICBsZXQgc3ViID0gc3Vicy5nZXQodGFnKTtcbiAgICBpZiAoIXN1Yikge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gKGFkZHIgPyBhZGRyIDogY29udHJhY3QpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7IGFkZHJlc3MsIHRvcGljcyB9O1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChsb2cpID0+IHtcbiAgICAgICAgICAgIGxldCBmb3VuZEZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGZyYWdtZW50IGlzIG51bGwsIHdlIGRvIG5vdCBkZWNvbnN0cnVjdCB0aGUgYXJncyB0byBlbWl0XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9mb3VuZEZyYWdtZW50ID0gZm91bmRGcmFnbWVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gZnJhZ21lbnQgPyBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKSA6IFtdO1xuICAgICAgICAgICAgICAgIGVtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCAobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdEV2ZW50UGF5bG9hZChjb250cmFjdCwgbGlzdGVuZXIsIGV2ZW50LCBfZm91bmRGcmFnbWVudCwgbG9nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVtaXQoY29udHJhY3QsIGV2ZW50LCBbXSwgKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkKGNvbnRyYWN0LCBsaXN0ZW5lciwgZXZlbnQsIGxvZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBzdGFydGluZyA9IFtdO1xuICAgICAgICBjb25zdCBzdGFydCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGFydGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydGluZy5wdXNoKHByb3ZpZGVyLm9uKGZpbHRlciwgbGlzdGVuZXIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RvcCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGFydGluZy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydGVkID0gc3RhcnRpbmc7XG4gICAgICAgICAgICBzdGFydGluZyA9IFtdO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoc3RhcnRlZCk7XG4gICAgICAgICAgICBwcm92aWRlci5vZmYoZmlsdGVyLCBsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgICAgIHN1YiA9IHsgdGFnLCBsaXN0ZW5lcnM6IFtdLCBzdGFydCwgc3RvcCB9O1xuICAgICAgICBzdWJzLnNldCh0YWcsIHN1Yik7XG4gICAgfVxuICAgIHJldHVybiBzdWI7XG59XG4vLyBXZSB1c2UgdGhpcyB0byBlbnN1cmUgb25lIGVtaXQgcmVzb2x2ZXMgYmVmb3JlIGZpcmluZyB0aGUgbmV4dCB0b1xuLy8gZW5zdXJlIGNvcnJlY3Qgb3JkZXJpbmcgKG5vdGUgdGhpcyBjYW5ub3QgdGhyb3cgYW5kIGp1c3QgYWRkcyB0aGVcbi8vIG5vdGljZSB0byB0aGUgZXZlbnQgcXVldSB1c2luZyBzZXRUaW1lb3V0KS5cbmxldCBsYXN0RW1pdCA9IFByb21pc2UucmVzb2x2ZSgpO1xuYXN5bmMgZnVuY3Rpb24gX2VtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCBwYXlsb2FkRnVuYykge1xuICAgIGF3YWl0IGxhc3RFbWl0O1xuICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yihjb250cmFjdCwgZXZlbnQpO1xuICAgIGlmICghc3ViKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY291bnQgPSBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICBzdWIubGlzdGVuZXJzID0gc3ViLmxpc3RlbmVycy5maWx0ZXIoKHsgbGlzdGVuZXIsIG9uY2UgfSkgPT4ge1xuICAgICAgICBjb25zdCBwYXNzQXJncyA9IEFycmF5LmZyb20oYXJncyk7XG4gICAgICAgIGlmIChwYXlsb2FkRnVuYykge1xuICAgICAgICAgICAgcGFzc0FyZ3MucHVzaChwYXlsb2FkRnVuYyhvbmNlID8gbnVsbCA6IGxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwoY29udHJhY3QsIC4uLnBhc3NBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gIW9uY2U7XG4gICAgfSk7XG4gICAgaWYgKHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN1Yi5zdG9wKCk7XG4gICAgICAgIGdldEludGVybmFsKGNvbnRyYWN0KS5zdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICB9XG4gICAgcmV0dXJuIChjb3VudCA+IDApO1xufVxuYXN5bmMgZnVuY3Rpb24gZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIHBheWxvYWRGdW5jKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbGFzdEVtaXQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgY29uc3QgcmVzdWx0UHJvbWlzZSA9IF9lbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgcGF5bG9hZEZ1bmMpO1xuICAgIGxhc3RFbWl0ID0gcmVzdWx0UHJvbWlzZTtcbiAgICByZXR1cm4gYXdhaXQgcmVzdWx0UHJvbWlzZTtcbn1cbmNvbnN0IHBhc3NQcm9wZXJ0aWVzID0gW1widGhlblwiXTtcbmV4cG9ydCBjbGFzcyBCYXNlQ29udHJhY3Qge1xuICAgIC8qKlxuICAgICAqICBUaGUgdGFyZ2V0IHRvIGNvbm5lY3QgdG8uXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gYmUgYW4gYWRkcmVzcywgRU5TIG5hbWUgb3IgYW55IFtbQWRkcmVzc2FibGVdXSwgc3VjaCBhc1xuICAgICAqICBhbm90aGVyIGNvbnRyYWN0LiBUbyBnZXQgdGhlIHJlc292bGVkIGFkZHJlc3MsIHVzZSB0aGUgYGBnZXRBZGRyZXNzYGBcbiAgICAgKiAgbWV0aG9kLlxuICAgICAqL1xuICAgIHRhcmdldDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbnRyYWN0IEludGVyZmFjZS5cbiAgICAgKi9cbiAgICBpbnRlcmZhY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb25uZWN0ZWQgcnVubmVyLiBUaGlzIGlzIGdlbmVyYWxseSBhIFtbUHJvdmlkZXJdXSBvciBhXG4gICAgICogIFtbU2lnbmVyXV0sIHdoaWNoIGRpY3RhdGVzIHdoYXQgb3BlcmF0aW9ucyBhcmUgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCBhICoqQ29udHJhY3QqKiBjb25uZWN0ZWQgdG8gYSBbW1Byb3ZpZGVyXV0gbWF5XG4gICAgICogIG9ubHkgZXhlY3V0ZSByZWFkLW9ubHkgb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBydW5uZXI7XG4gICAgLyoqXG4gICAgICogIEFsbCB0aGUgRXZlbnRzIGF2YWlsYWJsZSBvbiB0aGlzIGNvbnRyYWN0LlxuICAgICAqL1xuICAgIGZpbHRlcnM7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIFtpbnRlcm5hbF07XG4gICAgLyoqXG4gICAgICogIFRoZSBmYWxsYmFjayBvciByZWNlaXZlIGZ1bmN0aW9uIGlmIGFueS5cbiAgICAgKi9cbiAgICBmYWxsYmFjaztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBjb250cmFjdCBjb25uZWN0ZWQgdG8gJSV0YXJnZXQlJSB3aXRoIHRoZSAlJWFiaSUlIGFuZFxuICAgICAqICBvcHRpb25hbGx5IGNvbm5lY3RlZCB0byBhICUlcnVubmVyJSUgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGJlaGFsZlxuICAgICAqICBvZi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGFiaSwgcnVubmVyLCBfZGVwbG95VHgpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh0YXJnZXQpID09PSBcInN0cmluZ1wiIHx8IGlzQWRkcmVzc2FibGUodGFyZ2V0KSwgXCJpbnZhbGlkIHZhbHVlIGZvciBDb250cmFjdCB0YXJnZXRcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKHJ1bm5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICBydW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlmYWNlID0gSW50ZXJmYWNlLmZyb20oYWJpKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHRhcmdldCwgcnVubmVyLCBpbnRlcmZhY2U6IGlmYWNlIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IHt9IH0pO1xuICAgICAgICBsZXQgYWRkclByb21pc2U7XG4gICAgICAgIGxldCBhZGRyID0gbnVsbDtcbiAgICAgICAgbGV0IGRlcGxveVR4ID0gbnVsbDtcbiAgICAgICAgaWYgKF9kZXBsb3lUeCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihydW5uZXIpO1xuICAgICAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxuICAgICAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxuICAgICAgICAgICAgZGVwbG95VHggPSBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKHRoaXMuaW50ZXJmYWNlLCBwcm92aWRlciwgX2RlcGxveVR4KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3VicyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgdGFyZ2V0IGFzIHRoZSBhZGRyZXNzXG4gICAgICAgIGlmICh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgYWRkciA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICBhZGRyUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBnZXRSdW5uZXIocnVubmVyLCBcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICAgICAgICAgIGlmICghY2FuUmVzb2x2ZShyZXNvbHZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbWFrZUVycm9yKFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgbmFtZSByZXNvbHV0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXNvbHZlTmFtZVwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRyUHJvbWlzZSA9IHJlc29sdmVyLnJlc29sdmVOYW1lKHRhcmdldCkudGhlbigoYWRkcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBtYWtlRXJyb3IoXCJhbiBFTlMgbmFtZSB1c2VkIGZvciBhIGNvbnRyYWN0IHRhcmdldCBtdXN0IGJlIGNvcnJlY3RseSBjb25maWd1cmVkXCIsIFwiVU5DT05GSUdVUkVEX05BTUVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLmFkZHIgPSBhZGRyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFkZHJQcm9taXNlID0gdGFyZ2V0LmdldEFkZHJlc3MoKS50aGVuKChhZGRyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5hZGRyID0gYWRkcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBvdXIgcHJpdmF0ZSB2YWx1ZXNcbiAgICAgICAgc2V0SW50ZXJuYWwodGhpcywgeyBhZGRyUHJvbWlzZSwgYWRkciwgZGVwbG95VHgsIHN1YnMgfSk7XG4gICAgICAgIC8vIEFkZCB0aGUgZXZlbnQgZmlsdGVyc1xuICAgICAgICBjb25zdCBmaWx0ZXJzID0gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUGFzcyBpbXBvcnRhbnQgY2hlY2tzIChsaWtlIGB0aGVuYCBmb3IgUHJvbWlzZSkgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN5bWJvbFwiIHx8IHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEV2ZW50KHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIklOVkFMSURfQVJHVU1FTlRcIikgfHwgZXJyb3IuYXJndW1lbnQgIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUGFzcyBpbXBvcnRhbnQgY2hlY2tzIChsaWtlIGB0aGVuYCBmb3IgUHJvbWlzZSkgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGlmIChwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApIHx8IHRoaXMuaW50ZXJmYWNlLmhhc0V2ZW50KFN0cmluZyhwcm9wKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZmlsdGVycyB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmYWxsYmFjazogKChpZmFjZS5yZWNlaXZlIHx8IGlmYWNlLmZhbGxiYWNrKSA/IChidWlsZFdyYXBwZWRGYWxsYmFjayh0aGlzKSkgOiBudWxsKVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmV0dXJuIGEgUHJveHkgdGhhdCB3aWxsIHJlc3BvbmQgdG8gZnVuY3Rpb25zXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN5bWJvbFwiIHx8IHByb3AgaW4gdGFyZ2V0IHx8IHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVuZGVmaW5lZCBwcm9wZXJ0aWVzIHNob3VsZCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5nZXRGdW5jdGlvbihwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFcnJvcihlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpIHx8IGVycm9yLmFyZ3VtZW50ICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN5bWJvbFwiIHx8IHByb3AgaW4gdGFyZ2V0IHx8IHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5pbnRlcmZhY2UuaGFzRnVuY3Rpb24ocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IENvbnRyYWN0IGluc3RhbmNlIHdpdGggdGhlIHNhbWUgdGFyZ2V0IGFuZCBBQkksIGJ1dFxuICAgICAqICBhIGRpZmZlcmVudCAlJXJ1bm5lciUlLlxuICAgICAqL1xuICAgIGNvbm5lY3QocnVubmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZUNvbnRyYWN0KHRoaXMudGFyZ2V0LCB0aGlzLmludGVyZmFjZSwgcnVubmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBDb250cmFjdCBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIEFCSSBhbmQgcnVubmVyLCBidXRcbiAgICAgKiAgYSBkaWZmZXJlbnQgJSV0YXJnZXQlJS5cbiAgICAgKi9cbiAgICBhdHRhY2godGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZUNvbnRyYWN0KHRhcmdldCwgdGhpcy5pbnRlcmZhY2UsIHRoaXMucnVubmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcmVzb2x2ZWQgYWRkcmVzcyBvZiB0aGlzIENvbnRyYWN0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7IHJldHVybiBhd2FpdCBnZXRJbnRlcm5hbCh0aGlzKS5hZGRyUHJvbWlzZTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGRlcGxveWVkIGJ5dGVjb2RlIG9yIG51bGwgaWYgbm8gYnl0ZWNvZGUgaXMgZm91bmQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVwbG95ZWRDb2RlKCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgYXNzZXJ0KHByb3ZpZGVyLCBcInJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IC5wcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJnZXREZXBsb3llZENvZGVcIiB9KTtcbiAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHByb3ZpZGVyLmdldENvZGUoYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCkpO1xuICAgICAgICBpZiAoY29kZSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmUgdG8gdGhpcyBDb250cmFjdCBvbmNlIHRoZSBieXRlY29kZSBoYXMgYmVlbiBkZXBsb3llZCwgb3JcbiAgICAgKiAgcmVzb2x2ZSBpbW1lZGlhdGVseSBpZiBhbHJlYWR5IGRlcGxveWVkLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXRGb3JEZXBsb3ltZW50KCkge1xuICAgICAgICAvLyBXZSBoYXZlIHRoZSBkZXBsb3llbWVudCB0cmFuc2FjdGlvbjsganVzdCB1c2UgdGhhdCAodGhyb3dzIGlmIGRlcGxveWVtZW50IGZhaWxzKVxuICAgICAgICBjb25zdCBkZXBsb3lUeCA9IHRoaXMuZGVwbG95bWVudFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIGlmIChkZXBsb3lUeCkge1xuICAgICAgICAgICAgYXdhaXQgZGVwbG95VHgud2FpdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNvZGVcbiAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHRoaXMuZ2V0RGVwbG95ZWRDb2RlKCk7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBjYW4gc3Vic2NyaWJlIHRvIGEgcHJvdmlkZXIgZXZlbnRcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgIGFzc2VydChwcm92aWRlciAhPSBudWxsLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IC5wcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJ3YWl0Rm9yRGVwbG95bWVudFwiIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hlY2tDb2RlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCB0aGlzLmdldERlcGxveWVkQ29kZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgY2hlY2tDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNoZWNrQ29kZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgdHJhbnNhY3Rpb24gdXNlZCB0byBkZXBsb3kgdGhpcyBjb250cmFjdC5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGlmIHRoaXMgaW5zdGFuY2Ugd2FzIHJldHVybmVkIGZyb20gYVxuICAgICAqICBbW0NvbnRyYWN0RmFjdG9yeV1dLlxuICAgICAqL1xuICAgIGRlcGxveW1lbnRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsKHRoaXMpLmRlcGxveVR4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdW5jdGlvbiBmb3IgYSBnaXZlbiBuYW1lLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgY29udHJhY3RcbiAgICAgKiAgbWV0aG9kIG5hbWUgY29uZmxpY3RzIHdpdGggYSBKYXZhU2NyaXB0IG5hbWUgc3VjaCBhcyBgYHByb3RvdHlwZWBgIG9yXG4gICAgICogIHdoZW4gdXNpbmcgYSBDb250cmFjdCBwcm9ncmFtYXRpY2FsbHkuXG4gICAgICovXG4gICAgZ2V0RnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGtleSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5mb3JtYXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdW5jID0gYnVpbGRXcmFwcGVkTWV0aG9kKHRoaXMsIGtleSk7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBldmVudCBmb3IgYSBnaXZlbiBuYW1lLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgY29udHJhY3RcbiAgICAgKiAgZXZlbnQgbmFtZSBjb25mbGljdHMgd2l0aCBhIEphdmFTY3JpcHQgbmFtZSBzdWNoIGFzIGBgcHJvdG90eXBlYGAgb3JcbiAgICAgKiAgd2hlbiB1c2luZyBhIENvbnRyYWN0IHByb2dyYW1hdGljYWxseS5cbiAgICAgKi9cbiAgICBnZXRFdmVudChrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoa2V5KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAga2V5ID0ga2V5LmZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZFdyYXBwZWRFdmVudCh0aGlzLCBrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgYXN5bmMgcXVlcnlUcmFuc2FjdGlvbihoYXNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgIH1cbiAgICAvKlxuICAgIC8vIEBUT0RPOiB0aGlzIGlzIGEgbm9uLWJhY2t3YXJkcyBjb21wYXRpYmxlIGNoYW5nZSwgYnV0IHdpbGwgYmUgYWRkZWRcbiAgICAvLyAgICAgICAgaW4gdjcgYW5kIGluIGEgcG90ZW50aWFsIFNtYXJ0Q29udHJhY3QgY2xhc3MgaW4gYW4gdXBjb21pbmdcbiAgICAvLyAgICAgICAgdjYgcmVsZWFzZVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoOiBzdHJpbmcpOiBQcm9taXNlPG51bGwgfCBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdD4ge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgYXNzZXJ0KHByb3ZpZGVyLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBoYXZlIGEgcHJvdmlkZXJcIixcbiAgICAgICAgICAgIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInF1ZXJ5VHJhbnNhY3Rpb25cIiB9KTtcblxuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgcHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLmludGVyZmFjZSwgcHJvdmlkZXIsIHJlY2VpcHQpO1xuICAgIH1cbiAgICAqL1xuICAgIC8qKlxuICAgICAqICBQcm92aWRlIGhpc3RvcmljIGFjY2VzcyB0byBldmVudCBkYXRhIGZvciAlJWV2ZW50JSUgaW4gdGhlIHJhbmdlXG4gICAgICogICUlZnJvbUJsb2NrJSUgKGRlZmF1bHQ6IGBgMGBgKSB0byAlJXRvQmxvY2slJSAoZGVmYXVsdDogYGBcImxhdGVzdFwiYGApXG4gICAgICogIGluY2x1c2l2ZS5cbiAgICAgKi9cbiAgICBhc3luYyBxdWVyeUZpbHRlcihldmVudCwgZnJvbUJsb2NrLCB0b0Jsb2NrKSB7XG4gICAgICAgIGlmIChmcm9tQmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgZnJvbUJsb2NrID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9CbG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0b0Jsb2NrID0gXCJsYXRlc3RcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFkZHIsIGFkZHJQcm9taXNlIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IChhZGRyID8gYWRkciA6IChhd2FpdCBhZGRyUHJvbWlzZSkpO1xuICAgICAgICBjb25zdCB7IGZyYWdtZW50LCB0b3BpY3MgfSA9IGF3YWl0IGdldFN1YkluZm8odGhpcywgZXZlbnQpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7IGFkZHJlc3MsIHRvcGljcywgZnJvbUJsb2NrLCB0b0Jsb2NrIH07XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICBhc3NlcnQocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IGhhdmUgYSBwcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJxdWVyeUZpbHRlclwiIH0pO1xuICAgICAgICByZXR1cm4gKGF3YWl0IHByb3ZpZGVyLmdldExvZ3MoZmlsdGVyKSkubWFwKChsb2cpID0+IHtcbiAgICAgICAgICAgIGxldCBmb3VuZEZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnbWVudCA9IHRoaXMuaW50ZXJmYWNlLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50TG9nKGxvZywgdGhpcy5pbnRlcmZhY2UsIGZvdW5kRnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmRlY29kZWRFdmVudExvZyhsb2csIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZyhsb2csIHByb3ZpZGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBZGQgYW4gZXZlbnQgJSVsaXN0ZW5lciUlIGZvciB0aGUgJSVldmVudCUlLlxuICAgICAqL1xuICAgIGFzeW5jIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBnZXRTdWIodGhpcywgXCJvblwiLCBldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiBmYWxzZSB9KTtcbiAgICAgICAgc3ViLnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWRkIGFuIGV2ZW50ICUlbGlzdGVuZXIlJSBmb3IgdGhlICUlZXZlbnQlJSwgYnV0IHJlbW92ZSB0aGUgbGlzdGVuZXJcbiAgICAgKiAgYWZ0ZXIgaXQgaXMgZmlyZWQgb25jZS5cbiAgICAgKi9cbiAgICBhc3luYyBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBnZXRTdWIodGhpcywgXCJvbmNlXCIsIGV2ZW50KTtcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IHRydWUgfSk7XG4gICAgICAgIHN1Yi5zdGFydCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVtaXQgYW4gJSVldmVudCUlIGNhbGxpbmcgYWxsIGxpc3RlbmVycyB3aXRoICUlYXJncyUlLlxuICAgICAqXG4gICAgICogIFJlc29sdmVzIHRvIGBgdHJ1ZWBgIGlmIGFueSBsaXN0ZW5lcnMgd2VyZSBjYWxsZWQuXG4gICAgICovXG4gICAgYXN5bmMgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gYXdhaXQgZW1pdCh0aGlzLCBldmVudCwgYXJncywgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBvZiAlJWV2ZW50JSUgb3IgdGhlIHRvdGFsIG51bWJlclxuICAgICAqICBvZiBsaXN0ZW5lcnMgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdGVuZXJDb3VudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiBzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICB0b3RhbCArPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBsaXN0ZW5lcnMgc3Vic2NyaWJlZCB0byAlJWV2ZW50JSUgb3IgYWxsIGxpc3RlbmVyc1xuICAgICAqICBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IGxpc3RlbmVycyB9IG9mIHN1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQobGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZW1vdmUgdGhlICUlbGlzdGVuZXIlJSBmcm9tIHRoZSBsaXN0ZW5lcnMgZm9yICUlZXZlbnQlJSBvciByZW1vdmVcbiAgICAgKiAgYWxsIGxpc3RlbmVycyBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdWIubGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN1Yi5zdG9wKCk7XG4gICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5zdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlbW92ZSBhbGwgdGhlIGxpc3RlbmVycyBmb3IgJSVldmVudCUlIG9yIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGlmXG4gICAgICogIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViLnN0b3AoKTtcbiAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLnN1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyB0YWcsIHN0b3AgfSBvZiBzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgIHN1YnMuZGVsZXRlKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBbGlhcyBmb3IgW29uXS5cbiAgICAgKi9cbiAgICBhc3luYyBhZGRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFsaWFzIGZvciBbb2ZmXS5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgQ2xhc3MgZm9yIHRoZSAlJWFiaSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZENsYXNzKGFiaSkge1xuICAgICAgICBjbGFzcyBDdXN0b21Db250cmFjdCBleHRlbmRzIEJhc2VDb250cmFjdCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBydW5uZXIgPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIoYWRkcmVzcywgYWJpLCBydW5uZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDdXN0b21Db250cmFjdDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgQmFzZUNvbnRyYWN0IHdpdGggYSBzcGVjaWZpZWQgSW50ZXJmYWNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHRhcmdldCwgYWJpLCBydW5uZXIpIHtcbiAgICAgICAgaWYgKHJ1bm5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICBydW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IHRoaXModGFyZ2V0LCBhYmksIHJ1bm5lcik7XG4gICAgICAgIHJldHVybiBjb250cmFjdDtcbiAgICB9XG59XG5mdW5jdGlvbiBfQ29udHJhY3RCYXNlKCkge1xuICAgIHJldHVybiBCYXNlQ29udHJhY3Q7XG59XG4vKipcbiAqICBBIFtbQmFzZUNvbnRyYWN0XV0gd2l0aCBubyB0eXBlIGd1YXJkcyBvbiBpdHMgbWV0aG9kcyBvciBldmVudHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdCBleHRlbmRzIF9Db250cmFjdEJhc2UoKSB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cmFjdC5qcy5tYXAiLCIvKipcbiAqICBFTlMgaXMgYSBzZXJ2aWNlIHdoaWNoIGFsbG93cyBlYXN5LXRvLXJlbWVtYmVyIG5hbWVzIHRvIG1hcCB0b1xuICogIG5ldHdvcmsgYWRkcmVzc2VzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvZW5zLXJlc29sdmVyOkVOUyBSZXNvbHZlciAgW2Fib3V0LWVucy1yc29sdmVyXVxuICovXG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFplcm9BZGRyZXNzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29udHJhY3QgfSBmcm9tIFwiLi4vY29udHJhY3QvaW5kZXguanNcIjtcbmltcG9ydCB7IGRuc0VuY29kZSwgbmFtZWhhc2ggfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIHRvQmVIZXgsIGRlZmluZVByb3BlcnRpZXMsIGVuY29kZUJhc2U1OCwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgaXNFcnJvciwgRmV0Y2hSZXF1ZXN0IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vLyBAVE9ETzogVGhpcyBzaG91bGQgdXNlIHRoZSBmZXRjaC1kYXRhOmlwZnMgZ2F0ZXdheVxuLy8gVHJpbSBvZmYgdGhlIGlwZnM6Ly8gcHJlZml4IGFuZCByZXR1cm4gdGhlIGRlZmF1bHQgZ2F0ZXdheSBVUkxcbmZ1bmN0aW9uIGdldElwZnNMaW5rKGxpbmspIHtcbiAgICBpZiAobGluay5tYXRjaCgvXmlwZnM6XFwvXFwvaXBmc1xcLy9pKSkge1xuICAgICAgICBsaW5rID0gbGluay5zdWJzdHJpbmcoMTIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaW5rLm1hdGNoKC9eaXBmczpcXC9cXC8vaSkpIHtcbiAgICAgICAgbGluayA9IGxpbmsuc3Vic3RyaW5nKDcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgSVBGUyBmb3JtYXRcIiwgXCJsaW5rXCIsIGxpbmspO1xuICAgIH1cbiAgICByZXR1cm4gYGh0dHBzOi9cXC9nYXRld2F5LmlwZnMuaW8vaXBmcy8ke2xpbmt9YDtcbn1cbjtcbjtcbi8qKlxuICogIEEgcHJvdmlkZXIgcGx1Z2luIHN1cGVyLWNsYXNzIGZvciBwcm9jZXNzaW5nIG11bHRpY29pbiBhZGRyZXNzIHR5cGVzLlxuICovXG5leHBvcnQgY2xhc3MgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZS5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqTXVsdGljb2luUHJvdmlkZXJQbHVpbmcqKiBmb3IgJSVuYW1lJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm9pdmRlcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgaWYgJSVjb2luVHlwZSUlIGlzIHN1cHBvcnRlZCBieSB0aGlzIHBsdWdpbi5cbiAgICAgKi9cbiAgICBzdXBwb3J0c0NvaW5UeXBlKGNvaW5UeXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc292bGVzIHRvIHRoZSBlbmNvZGVkICUlYWRkcmVzcyUlIGZvciAlJWNvaW5UeXBlJSUuXG4gICAgICovXG4gICAgYXN5bmMgZW5jb2RlQWRkcmVzcyhjb2luVHlwZSwgYWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBjb2luXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb3ZsZXMgdG8gdGhlIGRlY29kZWQgJSVkYXRhJSUgZm9yICUlY29pblR5cGUlJS5cbiAgICAgKi9cbiAgICBhc3luYyBkZWNvZGVBZGRyZXNzKGNvaW5UeXBlLCBkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGNvaW5cIik7XG4gICAgfVxufVxuY29uc3QgQmFzaWNNdWx0aWNvaW5QbHVnaW5JZCA9IFwib3JnLmV0aGVycy5wbHVnaW5zLnByb3ZpZGVyLkJhc2ljTXVsdGljb2luXCI7XG4vKipcbiAqICBBICoqQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbioqIHByb3ZpZGVzIHNlcnZpY2UgZm9yIGNvbW1vblxuICogIGNvaW4gdHlwZXMsIHdoaWNoIGRvIG5vdCByZXF1aXJlIGFkZGl0aW9uYWwgbGlicmFyaWVzIHRvIGVuY29kZSBvclxuICogIGRlY29kZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4gZXh0ZW5kcyBNdWx0aWNvaW5Qcm92aWRlclBsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipCYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luKiouXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKEJhc2ljTXVsdGljb2luUGx1Z2luSWQpO1xuICAgIH1cbn1cbmNvbnN0IG1hdGNoZXJJcGZzID0gbmV3IFJlZ0V4cChcIl4oaXBmcyk6L1xcLyguKikkXCIsIFwiaVwiKTtcbmNvbnN0IG1hdGNoZXJzID0gW1xuICAgIG5ldyBSZWdFeHAoXCJeKGh0dHBzKTovXFwvKC4qKSRcIiwgXCJpXCIpLFxuICAgIG5ldyBSZWdFeHAoXCJeKGRhdGEpOiguKikkXCIsIFwiaVwiKSxcbiAgICBtYXRjaGVySXBmcyxcbiAgICBuZXcgUmVnRXhwKFwiXmVpcDE1NTpbMC05XSsvKGVyY1swLTldKyk6KC4qKSRcIiwgXCJpXCIpLFxuXTtcbi8qKlxuICogIEEgY29ubmVjdGVkIG9iamVjdCB0byBhIHJlc29sdmVkIEVOUyBuYW1lIHJlc29sdmVyLCB3aGljaCBjYW4gYmVcbiAqICB1c2VkIHRvIHF1ZXJ5IGFkZGl0aW9uYWwgZGV0YWlscy5cbiAqL1xuZXhwb3J0IGNsYXNzIEVuc1Jlc29sdmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbm5lY3RlZCBwcm92aWRlci5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3Mgb2YgdGhlIHJlc29sdmVyLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIHRoaXMgcmVzb2x2ZXIgd2FzIHJlc29sdmVkIGFnYWluc3QuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvLyBGb3IgRUlQLTI1NDQgbmFtZXMsIHRoZSBhbmNlc3RvciB0aGF0IHByb3ZpZGVkIHRoZSByZXNvbHZlclxuICAgICNzdXBwb3J0czI1NDQ7XG4gICAgI3Jlc29sdmVyO1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBhZGRyZXNzLCBuYW1lKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwcm92aWRlciwgYWRkcmVzcywgbmFtZSB9KTtcbiAgICAgICAgdGhpcy4jc3VwcG9ydHMyNTQ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jcmVzb2x2ZXIgPSBuZXcgQ29udHJhY3QoYWRkcmVzcywgW1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBzdXBwb3J0c0ludGVyZmFjZShieXRlczQpIHZpZXcgcmV0dXJucyAoYm9vbClcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcmVzb2x2ZShieXRlcywgYnl0ZXMpIHZpZXcgcmV0dXJucyAoYnl0ZXMpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIGFkZHIoYnl0ZXMzMikgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiBhZGRyKGJ5dGVzMzIsIHVpbnQpIHZpZXcgcmV0dXJucyAoYnl0ZXMpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHRleHQoYnl0ZXMzMiwgc3RyaW5nKSB2aWV3IHJldHVybnMgKHN0cmluZylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gY29udGVudGhhc2goYnl0ZXMzMikgdmlldyByZXR1cm5zIChieXRlcylcIixcbiAgICAgICAgXSwgcHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgcmVzb2x2ZXIgc3VwcG9ydHMgd2lsZGNhcmQgcmVzb2x1dGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBzdXBwb3J0c1dpbGRjYXJkKCkge1xuICAgICAgICBpZiAodGhpcy4jc3VwcG9ydHMyNTQ0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI3N1cHBvcnRzMjU0NCA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3Jlc29sdmVyLnN1cHBvcnRzSW50ZXJmYWNlKFwiMHg5MDYxYjkyM1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdpbGRjYXJkIHJlc29sdmVycyBtdXN0IHVuZGVyc3RhbmQgc3VwcG9ydHNJbnRlcmZhY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHJldHVybiB0cnVlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIExldCBmdXR1cmUgYXR0ZW1wdHMgdHJ5IGFnYWluLi4uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3N1cHBvcnRzMjU0NCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3N1cHBvcnRzMjU0NDtcbiAgICB9XG4gICAgYXN5bmMgI2ZldGNoKGZ1bmNOYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgY29uc3QgaWZhY2UgPSB0aGlzLiNyZXNvbHZlci5pbnRlcmZhY2U7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJhbWV0ZXJzIGlzIGFsd2F5cyB0aGUgbm9kZWhhc2hcbiAgICAgICAgcGFyYW1zLnVuc2hpZnQobmFtZWhhc2godGhpcy5uYW1lKSk7XG4gICAgICAgIGxldCBmcmFnbWVudCA9IG51bGw7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLnN1cHBvcnRzV2lsZGNhcmQoKSkge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBpZmFjZS5nZXRGdW5jdGlvbihmdW5jTmFtZSk7XG4gICAgICAgICAgICBhc3NlcnQoZnJhZ21lbnQsIFwibWlzc2luZyBmcmFnbWVudFwiLCBcIlVOS05PV05fRVJST1JcIiwge1xuICAgICAgICAgICAgICAgIGluZm86IHsgZnVuY05hbWUgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJhbXMgPSBbXG4gICAgICAgICAgICAgICAgZG5zRW5jb2RlKHRoaXMubmFtZSksXG4gICAgICAgICAgICAgICAgaWZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCBwYXJhbXMpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgZnVuY05hbWUgPSBcInJlc29sdmUoYnl0ZXMsYnl0ZXMpXCI7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLnB1c2goe1xuICAgICAgICAgICAgZW5hYmxlQ2NpcFJlYWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNyZXNvbHZlcltmdW5jTmFtZV0oLi4ucGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZmFjZS5kZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgcmVzdWx0KVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIWlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBhZGRyZXNzIGZvciAlJWNvaW5UeXBlJSUgb3IgbnVsbCBpZiB0aGVcbiAgICAgKiAgcHJvdmlkZWQgJSVjb2luVHlwZSUlIGhhcyBub3QgYmVlbiBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFkZHJlc3MoY29pblR5cGUpIHtcbiAgICAgICAgaWYgKGNvaW5UeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvaW5UeXBlID0gNjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvaW5UeXBlID09PSA2MCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMilcIik7XG4gICAgICAgICAgICAgICAgLy8gTm8gYWRkcmVzc1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCByZXN1bHQgPT09IFplcm9BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSBkZWNvZGluZyBpdHMgRVZNIGNhbm9uaWNhbCBjaGFpbiBhcyBhbiBFVk0gY2hhaW4gYWRkcmVzcyBmaXJzdFxuICAgICAgICBpZiAoY29pblR5cGUgPj0gMCAmJiBjb2luVHlwZSA8IDB4ODAwMDAwMDApIHtcbiAgICAgICAgICAgIGxldCBldGhDb2luVHlwZSA9IGNvaW5UeXBlICsgMHg4MDAwMDAwMDtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMix1aW50KVwiLCBbZXRoQ29pblR5cGVdKTtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhkYXRhLCAyMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyhkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY29pblBsdWdpbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMucHJvdmlkZXIucGx1Z2lucykge1xuICAgICAgICAgICAgaWYgKCEocGx1Z2luIGluc3RhbmNlb2YgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGx1Z2luLnN1cHBvcnRzQ29pblR5cGUoY29pblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgY29pblBsdWdpbiA9IHBsdWdpbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29pblBsdWdpbiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBrZWNjYWsyNTYoXCJhZGRyKGJ5dGVzMzIsdWludDI1NlwiKVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIsdWludClcIiwgW2NvaW5UeXBlXSk7XG4gICAgICAgIC8vIE5vIGFkZHJlc3NcbiAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGFkZHJlc3NcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IGNvaW5QbHVnaW4uZGVjb2RlQWRkcmVzcyhjb2luVHlwZSwgZGF0YSk7XG4gICAgICAgIGlmIChhZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgYGludmFsaWQgY29pbiBkYXRhYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBgZ2V0QWRkcmVzcygke2NvaW5UeXBlfSlgLFxuICAgICAgICAgICAgaW5mbzogeyBjb2luVHlwZSwgZGF0YSB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIEVJUC02MzQgdGV4dCByZWNvcmQgZm9yICUla2V5JSUsIG9yIGBgbnVsbGBgXG4gICAgICogIGlmIHVuY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUZXh0KGtleSkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJ0ZXh0KGJ5dGVzMzIsc3RyaW5nKVwiLCBba2V5XSk7XG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJzb2x2ZXMgdG8gdGhlIGNvbnRlbnQtaGFzaCBvciBgYG51bGxgYCBpZiB1bmNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q29udGVudEhhc2goKSB7XG4gICAgICAgIC8vIGtlY2NhazI1NihcImNvbnRlbnRoYXNoKClcIilcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwiY29udGVudGhhc2goYnl0ZXMzMilcIik7XG4gICAgICAgIC8vIE5vIGNvbnRlbnRoYXNoXG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJUEZTIChDSUQ6IDEsIFR5cGU6IDcwPURBRy1QQiwgNzI9bGlicDJwLWtleSlcbiAgICAgICAgY29uc3QgaXBmcyA9IGRhdGEubWF0Y2goL14weChlMzAxMDE3MHxlNTAxMDE3MikoKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKikpJC8pO1xuICAgICAgICBpZiAoaXBmcykge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gKGlwZnNbMV0gPT09IFwiZTMwMTAxNzBcIikgPyBcImlwZnNcIiA6IFwiaXBuc1wiO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoaXBmc1s0XSwgMTYpO1xuICAgICAgICAgICAgaWYgKGlwZnNbNV0ubGVuZ3RoID09PSBsZW5ndGggKiAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3NjaGVtZX06L1xcLyR7ZW5jb2RlQmFzZTU4KFwiMHhcIiArIGlwZnNbMl0pfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3dhcm0gKENJRDogMSwgVHlwZTogc3dhcm0tbWFuaWZlc3Q7IGhhc2gvbGVuZ3RoIGhhcmQtY29kZWQgdG8ga2VjY2FrMjU2LzMyKVxuICAgICAgICBjb25zdCBzd2FybSA9IGRhdGEubWF0Y2goL14weGU0MDEwMWZhMDExYjIwKFswLTlhLWZdKikkLyk7XG4gICAgICAgIGlmIChzd2FybSAmJiBzd2FybVsxXS5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgICAgICByZXR1cm4gYGJ6ejovXFwvJHtzd2FybVsxXX1gO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgYGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgY29udGVudCBoYXNoIGRhdGFgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0Q29udGVudEhhc2goKVwiLFxuICAgICAgICAgICAgaW5mbzogeyBkYXRhIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYXZhdGFyIHVybCBvciBgYG51bGxgYCBpZiB0aGUgYXZhdGFyIGlzIGVpdGhlclxuICAgICAqICB1bmNvbmZpZ3VyZWQgb3IgaW5jb3JyZWN0bHkgY29uZmlndXJlZCAoZS5nLiByZWZlcmVuY2VzIGFuIE5GVFxuICAgICAqICBub3Qgb3duZWQgYnkgdGhlIGFkZHJlc3MpLlxuICAgICAqXG4gICAgICogIElmIGRpYWdub3NpbmcgaXNzdWVzIHdpdGggY29uZmlndXJhdGlvbnMsIHRoZSBbW19nZXRBdmF0YXJdXVxuICAgICAqICBtZXRob2QgbWF5IGJlIHVzZWZ1bC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBdmF0YXIoKSB7XG4gICAgICAgIGNvbnN0IGF2YXRhciA9IGF3YWl0IHRoaXMuX2dldEF2YXRhcigpO1xuICAgICAgICByZXR1cm4gYXZhdGFyLnVybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdoZW4gcmVzb2x2aW5nIGFuIGF2YXRhciwgdGhlcmUgYXJlIG1hbnkgc3RlcHMgaW52b2x2ZWQsIHN1Y2hcbiAgICAgKiAgZmV0Y2hpbmcgbWV0YWRhdGEgYW5kIHBvc3NpYmx5IHZhbGlkYXRpbmcgb3duZXJzaGlwIG9mIGFuXG4gICAgICogIE5GVC5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBleGFtaW5lIGVhY2ggc3RlcCBhbmQgdGhlIHZhbHVlIGl0XG4gICAgICogIHdhcyB3b3JraW5nIGZyb20uXG4gICAgICovXG4gICAgYXN5bmMgX2dldEF2YXRhcigpIHtcbiAgICAgICAgY29uc3QgbGlua2FnZSA9IFt7IHR5cGU6IFwibmFtZVwiLCB2YWx1ZTogdGhpcy5uYW1lIH1dO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gdGVzdCBkYXRhIGZvciByaWNtb28uZXRoXG4gICAgICAgICAgICAvL2NvbnN0IGF2YXRhciA9IFwiZWlwMTU1OjEvZXJjNzIxOjB4MjY1Mzg1YzdmNDEzMjIyOEEwZDU0RUIxQTllNzQ2MGI5MWMwY0M2OC8yOTIzM1wiO1xuICAgICAgICAgICAgY29uc3QgYXZhdGFyID0gYXdhaXQgdGhpcy5nZXRUZXh0KFwiYXZhdGFyXCIpO1xuICAgICAgICAgICAgaWYgKGF2YXRhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhYXZhdGFyXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJhdmF0YXJcIiwgdmFsdWU6IGF2YXRhciB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGF2YXRhci5tYXRjaChtYXRjaGVyc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtZSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzY2hlbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImh0dHBzXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBhdmF0YXIgfTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlwZnNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gZ2V0SXBmc0xpbmsoYXZhdGFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiaXBmc1wiLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgdmFsdWU6IHVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcmM3MjFcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzExNTVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBFUkMgdHlwZSwgdXNlIHRva2VuVVJJKHVpbnQyNTYpIG9yIHVybCh1aW50MjU2KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoc2NoZW1lID09PSBcImVyYzcyMVwiKSA/IFwidG9rZW5VUkkodWludDI1NilcIiA6IFwidXJpKHVpbnQyNTYpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBzY2hlbWUsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3duZXIgb2YgdGhpcyBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvd25lciA9IGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG93bmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFvd25lclwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBzID0gKG1hdGNoWzJdIHx8IFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBgISR7c2NoZW1lfWNhaXBgLCB2YWx1ZTogKG1hdGNoWzJdIHx8IFwiXCIpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5JZCA9IGNvbXBzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoY29tcHNbMF0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFUkMtNzIxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiB0b2tlblVSSSh1aW50KSB2aWV3IHJldHVybnMgKHN0cmluZylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIG93bmVyT2YodWludCkgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVSQy0xMTU1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiB1cmkodWludCkgdmlldyByZXR1cm5zIChzdHJpbmcpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBiYWxhbmNlT2YoYWRkcmVzcywgdWludDI1NikgdmlldyByZXR1cm5zICh1aW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBdLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhpcyBhY2NvdW50IG93bnMgdGhlIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1lID09PSBcImVyYzcyMVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5Pd25lciA9IGF3YWl0IGNvbnRyYWN0Lm93bmVyT2YodG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG93bmVyICE9PSB0b2tlbk93bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW93bmVyXCIsIHZhbHVlOiB0b2tlbk93bmVyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJvd25lclwiLCB2YWx1ZTogdG9rZW5Pd25lciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtZSA9PT0gXCJlcmMxMTU1XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgY29udHJhY3QuYmFsYW5jZU9mKG93bmVyLCB0b2tlbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJhbGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhYmFsYW5jZVwiLCB2YWx1ZTogXCIwXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImJhbGFuY2VcIiwgdmFsdWU6IGJhbGFuY2UudG9TdHJpbmcoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgdGhlIHRva2VuIGNvbnRyYWN0IGZvciB0aGUgbWV0YWRhdGEgVVJMXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWV0YWRhdGFVcmwgPSBhd2FpdCBjb250cmFjdFtzZWxlY3Rvcl0odG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwgPT0gbnVsbCB8fCBtZXRhZGF0YVVybCA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGEtdXJsXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmwtYmFzZVwiLCB2YWx1ZTogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFUkMtMTE1NSBhbGxvd3MgYSBnZW5lcmljIHtpZH0gaW4gdGhlIFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJlcmMxMTU1XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVVybCA9IG1ldGFkYXRhVXJsLnJlcGxhY2UoXCJ7aWR9XCIsIHRvQmVIZXgodG9rZW5JZCwgMzIpLnN1YnN0cmluZygyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmwtZXhwYW5kZWRcIiwgdmFsdWU6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElQRlMgbWV0YWRhdGEgbGlua3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVVybC5tYXRjaCgvXmlwZnM6L2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBnZXRJcGZzTGluayhtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybFwiLCB2YWx1ZTogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRva2VuIG1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKG5ldyBGZXRjaFJlcXVlc3QobWV0YWRhdGFVcmwpKS5zZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5hc3NlcnRPaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHJlc3BvbnNlLmJvZHlKc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGFcIiwgdmFsdWU6IHJlc3BvbnNlLmJvZHlUZXh0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSByZXNwb25zZS5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhXCIsIHZhbHVlOiBoZXhsaWZ5KGJ5dGVzKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGFcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhXCIsIHZhbHVlOiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQdWxsIHRoZSBpbWFnZSBVUkwgb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW1hZ2VVcmwgPSBtZXRhZGF0YS5pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGltYWdlVXJsKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWltYWdlVXJsXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlVXJsLm1hdGNoKC9eKGh0dHBzOlxcL1xcL3xkYXRhOikvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElQRlMgbGluayB0byBnYXRld2F5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXBmcyA9IGltYWdlVXJsLm1hdGNoKG1hdGNoZXJJcGZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXBmcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWltYWdlVXJsLWlwZnNcIiwgdmFsdWU6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJpbWFnZVVybC1pcGZzXCIsIHZhbHVlOiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVVybCA9IGdldElwZnNMaW5rKGltYWdlVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIHZhbHVlOiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogaW1hZ2VVcmwgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IG51bGwgfTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGdldEVuc0FkZHJlc3MocHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHByb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICAgICAgY29uc3QgZW5zUGx1Z2luID0gbmV0d29yay5nZXRQbHVnaW4oXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5FbnNcIik7XG4gICAgICAgIC8vIE5vIEVOUy4uLlxuICAgICAgICBhc3NlcnQoZW5zUGx1Z2luLCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFTlNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEVuc0FkZHJlc3NcIiwgaW5mbzogeyBuZXR3b3JrIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbnNQbHVnaW4uYWRkcmVzcztcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jICNnZXRSZXNvbHZlcihwcm92aWRlciwgbmFtZSkge1xuICAgICAgICBjb25zdCBlbnNBZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuZ2V0RW5zQWRkcmVzcyhwcm92aWRlcik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyBDb250cmFjdChlbnNBZGRyLCBbXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbiByZXNvbHZlcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCJcbiAgICAgICAgICAgIF0sIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSBhd2FpdCBjb250cmFjdC5yZXNvbHZlcihuYW1laGFzaChuYW1lKSwge1xuICAgICAgICAgICAgICAgIGVuYWJsZUNjaXBSZWFkOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhZGRyID09PSBaZXJvQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBFTlMgcmVnaXN0cnkgY2Fubm90IHRocm93IGVycm9ycyBvbiByZXNvbHZlcihieXRlczMyKSxcbiAgICAgICAgICAgIC8vIHNvIHByb2JhYmx5IGEgbGluayBlcnJvclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlIHRvIHRoZSBFTlMgcmVzb2x2ZXIgZm9yICUlbmFtZSUlIHVzaW5nICUlcHJvdmlkZXIlJSBvclxuICAgICAqICBgYG51bGxgYCBpZiB1bmNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21OYW1lKHByb3ZpZGVyLCBuYW1lKSB7XG4gICAgICAgIGxldCBjdXJyZW50TmFtZSA9IG5hbWU7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudE5hbWUgPT09IFwiXCIgfHwgY3VycmVudE5hbWUgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPcHRpbWl6YXRpb24gc2luY2UgdGhlIGV0aCBub2RlIGNhbm5vdCBjaGFuZ2UgYW5kIGRvZXNcbiAgICAgICAgICAgIC8vIG5vdCBoYXZlIGEgd2lsZGNhcmQgcmVzb2x2ZXJcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSBcImV0aFwiICYmIGN1cnJlbnROYW1lID09PSBcImV0aFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgY3VycmVudCBub2RlIGZvciBhIHJlc29sdmVyXG4gICAgICAgICAgICBjb25zdCBhZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuI2dldFJlc29sdmVyKHByb3ZpZGVyLCBjdXJyZW50TmFtZSk7XG4gICAgICAgICAgICAvLyBGb3VuZCBhIHJlc29sdmVyIVxuICAgICAgICAgICAgaWYgKGFkZHIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gbmV3IEVuc1Jlc29sdmVyKHByb3ZpZGVyLCBhZGRyLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBMZWdhY3kgcmVzb2x2ZXIgZm91bmQsIHVzaW5nIEVJUC0yNTQ0IHNvIGl0IGlzbid0IHNhZmUgdG8gdXNlXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROYW1lICE9PSBuYW1lICYmICEoYXdhaXQgcmVzb2x2ZXIuc3VwcG9ydHNXaWxkY2FyZCgpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgY3VycmVudE5hbWUgPSBjdXJyZW50TmFtZS5zcGxpdChcIi5cIikuc2xpY2UoMSkuam9pbihcIi5cIik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnMtcmVzb2x2ZXIuanMubWFwIiwiLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgZ2V0Q3JlYXRlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRCaWdJbnQsIGdldE51bWJlciwgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIHplcm9QYWRWYWx1ZSwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmV4cG9ydCBmdW5jdGlvbiBhbGxvd051bGwoZm9ybWF0LCBudWxsVmFsdWUpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0KHZhbHVlKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcnJheU9mKGZvcm1hdCkge1xuICAgIHJldHVybiAoKGFycmF5KSA9PiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhbiBhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXkubWFwKChpKSA9PiBmb3JtYXQoaSkpO1xuICAgIH0pO1xufVxuLy8gUmVxdWlyZXMgYW4gb2JqZWN0IHdoaWNoIG1hdGNoZXMgYSBmbGVldCBvZiBvdGhlciBmb3JtYXR0ZXJzXG4vLyBBbnkgRm9ybWF0RnVuYyBtYXkgcmV0dXJuIGB1bmRlZmluZWRgIHRvIGhhdmUgdGhlIHZhbHVlIG9taXR0ZWRcbi8vIGZyb20gdGhlIHJlc3VsdCBvYmplY3QuIENhbGxzIHByZXNlcnZlIGB0aGlzYC5cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3QoZm9ybWF0LCBhbHROYW1lcykge1xuICAgIHJldHVybiAoKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBmb3JtYXQpIHtcbiAgICAgICAgICAgIGxldCBzcmNLZXkgPSBrZXk7XG4gICAgICAgICAgICBpZiAoYWx0TmFtZXMgJiYga2V5IGluIGFsdE5hbWVzICYmICEoc3JjS2V5IGluIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWx0S2V5IG9mIGFsdE5hbWVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsdEtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjS2V5ID0gYWx0S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG52ID0gZm9ybWF0W2tleV0odmFsdWVbc3JjS2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKG52ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBudjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpID8gZXJyb3IubWVzc2FnZSA6IFwibm90LWFuLWVycm9yXCI7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgaW52YWxpZCB2YWx1ZSBmb3IgdmFsdWUuJHtrZXl9ICgke21lc3NhZ2V9KWAsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEJvb2xlYW4odmFsdWUpIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgY2FzZSBcInRydWVcIjpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlIGZhbHNlOlxuICAgICAgICBjYXNlIFwiZmFsc2VcIjpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIGJvb2xlYW47ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGEodmFsdWUpIHtcbiAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh2YWx1ZSwgdHJ1ZSksIFwiaW52YWxpZCBkYXRhXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRIYXNoKHZhbHVlKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodmFsdWUsIDMyKSwgXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFVpbnQyNTYodmFsdWUpIHtcbiAgICBpZiAoIWlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVpbnQyNTZcIik7XG4gICAgfVxuICAgIHJldHVybiB6ZXJvUGFkVmFsdWUodmFsdWUsIDMyKTtcbn1cbmNvbnN0IF9mb3JtYXRMb2cgPSBvYmplY3Qoe1xuICAgIGFkZHJlc3M6IGdldEFkZHJlc3MsXG4gICAgYmxvY2tIYXNoOiBmb3JtYXRIYXNoLFxuICAgIGJsb2NrTnVtYmVyOiBnZXROdW1iZXIsXG4gICAgZGF0YTogZm9ybWF0RGF0YSxcbiAgICBpbmRleDogZ2V0TnVtYmVyLFxuICAgIHJlbW92ZWQ6IGFsbG93TnVsbChmb3JtYXRCb29sZWFuLCBmYWxzZSksXG4gICAgdG9waWNzOiBhcnJheU9mKGZvcm1hdEhhc2gpLFxuICAgIHRyYW5zYWN0aW9uSGFzaDogZm9ybWF0SGFzaCxcbiAgICB0cmFuc2FjdGlvbkluZGV4OiBnZXROdW1iZXIsXG59LCB7XG4gICAgaW5kZXg6IFtcImxvZ0luZGV4XCJdXG59KTtcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRMb2codmFsdWUpIHtcbiAgICByZXR1cm4gX2Zvcm1hdExvZyh2YWx1ZSk7XG59XG5jb25zdCBfZm9ybWF0QmxvY2sgPSBvYmplY3Qoe1xuICAgIGhhc2g6IGFsbG93TnVsbChmb3JtYXRIYXNoKSxcbiAgICBwYXJlbnRIYXNoOiBmb3JtYXRIYXNoLFxuICAgIG51bWJlcjogZ2V0TnVtYmVyLFxuICAgIHRpbWVzdGFtcDogZ2V0TnVtYmVyLFxuICAgIG5vbmNlOiBhbGxvd051bGwoZm9ybWF0RGF0YSksXG4gICAgZGlmZmljdWx0eTogZ2V0QmlnSW50LFxuICAgIGdhc0xpbWl0OiBnZXRCaWdJbnQsXG4gICAgZ2FzVXNlZDogZ2V0QmlnSW50LFxuICAgIG1pbmVyOiBhbGxvd051bGwoZ2V0QWRkcmVzcyksXG4gICAgZXh0cmFEYXRhOiBmb3JtYXREYXRhLFxuICAgIGJhc2VGZWVQZXJHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQpXG59KTtcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRCbG9jayh2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IF9mb3JtYXRCbG9jayh2YWx1ZSk7XG4gICAgcmVzdWx0LnRyYW5zYWN0aW9ucyA9IHZhbHVlLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlKHR4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgX2Zvcm1hdFJlY2VpcHRMb2cgPSBvYmplY3Qoe1xuICAgIHRyYW5zYWN0aW9uSW5kZXg6IGdldE51bWJlcixcbiAgICBibG9ja051bWJlcjogZ2V0TnVtYmVyLFxuICAgIHRyYW5zYWN0aW9uSGFzaDogZm9ybWF0SGFzaCxcbiAgICBhZGRyZXNzOiBnZXRBZGRyZXNzLFxuICAgIHRvcGljczogYXJyYXlPZihmb3JtYXRIYXNoKSxcbiAgICBkYXRhOiBmb3JtYXREYXRhLFxuICAgIGluZGV4OiBnZXROdW1iZXIsXG4gICAgYmxvY2tIYXNoOiBmb3JtYXRIYXNoLFxufSwge1xuICAgIGluZGV4OiBbXCJsb2dJbmRleFwiXVxufSk7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UmVjZWlwdExvZyh2YWx1ZSkge1xuICAgIHJldHVybiBfZm9ybWF0UmVjZWlwdExvZyh2YWx1ZSk7XG59XG5jb25zdCBfZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0ID0gb2JqZWN0KHtcbiAgICB0bzogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgIGZyb206IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcbiAgICBjb250cmFjdEFkZHJlc3M6IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcbiAgICAvLyBzaG91bGQgYmUgYWxsb3dOdWxsKGhhc2gpLCBidXQgYnJva2VuLUVJUC02NTggc3VwcG9ydCBpcyBoYW5kbGVkIGluIHJlY2VpcHRcbiAgICBpbmRleDogZ2V0TnVtYmVyLFxuICAgIHJvb3Q6IGFsbG93TnVsbChoZXhsaWZ5KSxcbiAgICBnYXNVc2VkOiBnZXRCaWdJbnQsXG4gICAgbG9nc0Jsb29tOiBhbGxvd051bGwoZm9ybWF0RGF0YSksXG4gICAgYmxvY2tIYXNoOiBmb3JtYXRIYXNoLFxuICAgIGhhc2g6IGZvcm1hdEhhc2gsXG4gICAgbG9nczogYXJyYXlPZihmb3JtYXRSZWNlaXB0TG9nKSxcbiAgICBibG9ja051bWJlcjogZ2V0TnVtYmVyLFxuICAgIC8vY29uZmlybWF0aW9uczogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXG4gICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IGdldEJpZ0ludCxcbiAgICBlZmZlY3RpdmVHYXNQcmljZTogYWxsb3dOdWxsKGdldEJpZ0ludCksXG4gICAgc3RhdHVzOiBhbGxvd051bGwoZ2V0TnVtYmVyKSxcbiAgICB0eXBlOiBhbGxvd051bGwoZ2V0TnVtYmVyLCAwKVxufSwge1xuICAgIGVmZmVjdGl2ZUdhc1ByaWNlOiBbXCJnYXNQcmljZVwiXSxcbiAgICBoYXNoOiBbXCJ0cmFuc2FjdGlvbkhhc2hcIl0sXG4gICAgaW5kZXg6IFtcInRyYW5zYWN0aW9uSW5kZXhcIl0sXG59KTtcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUpIHtcbiAgICByZXR1cm4gX2Zvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSh2YWx1ZSkge1xuICAgIC8vIFNvbWUgY2xpZW50cyAoVGVzdFJQQykgZG8gc3RyYW5nZSB0aGluZ3MgbGlrZSByZXR1cm4gMHgwIGZvciB0aGVcbiAgICAvLyAwIGFkZHJlc3M7IGNvcnJlY3QgdGhpcyB0byBiZSBhIHJlYWwgYWRkcmVzc1xuICAgIGlmICh2YWx1ZS50byAmJiBnZXRCaWdJbnQodmFsdWUudG8pID09PSBCTl8wKSB7XG4gICAgICAgIHZhbHVlLnRvID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gb2JqZWN0KHtcbiAgICAgICAgaGFzaDogZm9ybWF0SGFzaCxcbiAgICAgICAgdHlwZTogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiMHhcIiB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0TnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWNjZXNzTGlzdDogYWxsb3dOdWxsKGFjY2Vzc0xpc3RpZnksIG51bGwpLFxuICAgICAgICBibG9ja0hhc2g6IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcbiAgICAgICAgYmxvY2tOdW1iZXI6IGFsbG93TnVsbChnZXROdW1iZXIsIG51bGwpLFxuICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBhbGxvd051bGwoZ2V0TnVtYmVyLCBudWxsKSxcbiAgICAgICAgLy9jb25maXJtYXRpb25zOiBhbGxvd051bGwoZ2V0TnVtYmVyLCBudWxsKSxcbiAgICAgICAgZnJvbTogZ2V0QWRkcmVzcyxcbiAgICAgICAgLy8gZWl0aGVyIChnYXNQcmljZSkgb3IgKG1heFByaW9yaXR5RmVlUGVyR2FzICsgbWF4RmVlUGVyR2FzKSBtdXN0IGJlIHNldFxuICAgICAgICBnYXNQcmljZTogYWxsb3dOdWxsKGdldEJpZ0ludCksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50KSxcbiAgICAgICAgbWF4RmVlUGVyR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50KSxcbiAgICAgICAgZ2FzTGltaXQ6IGdldEJpZ0ludCxcbiAgICAgICAgdG86IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcbiAgICAgICAgdmFsdWU6IGdldEJpZ0ludCxcbiAgICAgICAgbm9uY2U6IGdldE51bWJlcixcbiAgICAgICAgZGF0YTogZm9ybWF0RGF0YSxcbiAgICAgICAgY3JlYXRlczogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgICAgICBjaGFpbklkOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKVxuICAgIH0sIHtcbiAgICAgICAgZGF0YTogW1wiaW5wdXRcIl0sXG4gICAgICAgIGdhc0xpbWl0OiBbXCJnYXNcIl1cbiAgICB9KSh2YWx1ZSk7XG4gICAgLy8gSWYgdG8gYW5kIGNyZWF0ZXMgYXJlIGVtcHR5LCBwb3B1bGF0ZSB0aGUgY3JlYXRlcyBmcm9tIHRoZSB2YWx1ZVxuICAgIGlmIChyZXN1bHQudG8gPT0gbnVsbCAmJiByZXN1bHQuY3JlYXRlcyA9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC5jcmVhdGVzID0gZ2V0Q3JlYXRlQWRkcmVzcyhyZXN1bHQpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogQ2hlY2sgZmVlIGRhdGFcbiAgICAvLyBBZGQgYW4gYWNjZXNzIGxpc3QgdG8gc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVzXG4gICAgaWYgKCh2YWx1ZS50eXBlID09PSAxIHx8IHZhbHVlLnR5cGUgPT09IDIpICYmIHZhbHVlLmFjY2Vzc0xpc3QgPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuYWNjZXNzTGlzdCA9IFtdO1xuICAgIH1cbiAgICAvLyBDb21wdXRlIHRoZSBzaWduYXR1cmVcbiAgICBpZiAodmFsdWUuc2lnbmF0dXJlKSB7XG4gICAgICAgIHJlc3VsdC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh2YWx1ZS5zaWduYXR1cmUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgLy8gU29tZSBiYWNrZW5kcyBvbWl0IENoYWluSWQgb24gbGVnYWN5IHRyYW5zYWN0aW9ucywgYnV0IHdlIGNhbiBjb21wdXRlIGl0XG4gICAgaWYgKHJlc3VsdC5jaGFpbklkID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9IHJlc3VsdC5zaWduYXR1cmUubGVnYWN5Q2hhaW5JZDtcbiAgICAgICAgaWYgKGNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEBUT0RPOiBjaGVjayBjaGFpbklEXG4gICAgLypcbiAgICBpZiAodmFsdWUuY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgIGxldCBjaGFpbklkID0gdmFsdWUuY2hhaW5JZDtcblxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNoYWluSWQgPSB2YWx1ZS5uZXR3b3JrSWQ7XG5cbiAgICAgICAgLy8gZ2V0aC1ldGMgcmV0dXJucyBjaGFpbklkXG4gICAgICAgIGlmIChjaGFpbklkID09IG51bGwgJiYgcmVzdWx0LnYgPT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IHZhbHVlLmNoYWluSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihjaGFpbklkKSAhPT0gXCJudW1iZXJcIiAmJiByZXN1bHQudiAhPSBudWxsKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gKHJlc3VsdC52IC0gMzUpIC8gMjtcbiAgICAgICAgICAgIGlmIChjaGFpbklkIDwgMCkgeyBjaGFpbklkID0gMDsgfVxuICAgICAgICAgICAgY2hhaW5JZCA9IHBhcnNlSW50KGNoYWluSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihjaGFpbklkKSAhPT0gXCJudW1iZXJcIikgeyBjaGFpbklkID0gMDsgfVxuXG4gICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcbiAgICB9XG4gICAgKi9cbiAgICAvLyAweDAwMDAuLi4gc2hvdWxkIGFjdHVhbGx5IGJlIG51bGxcbiAgICBpZiAocmVzdWx0LmJsb2NrSGFzaCAmJiBnZXRCaWdJbnQocmVzdWx0LmJsb2NrSGFzaCkgPT09IEJOXzApIHtcbiAgICAgICAgcmVzdWx0LmJsb2NrSGFzaCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQuanMubWFwIiwiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuLi91dGlscy9wcm9wZXJ0aWVzLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3QgRW5zQWRkcmVzcyA9IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCI7XG4vKipcbiAqICBBICoqTmV0d29ya1BsdWdpbioqIHByb3ZpZGVzIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eSBvbiBhIFtbTmV0d29ya11dLlxuICovXG5leHBvcnQgY2xhc3MgTmV0d29ya1BsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXG4gICAgICpcbiAgICAgKiAgSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHJldmVyc2UtZG9tYWluLW5vdGF0aW9uLCB3aGljaCBwZXJtaXRzXG4gICAgICogIHVuaXF1ZSBuYW1lcyB3aXRoIGEga25vd24gYXV0aG9yaXR5IGFzIHdlbGwgYXMgaGllcmFyY2hhbCBlbnRyaWVzLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipOZXR3b3JrUGx1Z2luKiouXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgcGx1Z2luLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5ldHdvcmtQbHVnaW4odGhpcy5uYW1lKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqR2FzQ29zdFBsdWdpbioqIGFsbG93cyBhIG5ldHdvcmsgdG8gcHJvdmlkZSBhbHRlcm5hdGl2ZSB2YWx1ZXMgd2hlblxuICogIGNvbXB1dGluZyB0aGUgaW50cmluc2ljIGdhcyByZXF1aXJlZCBmb3IgYSB0cmFuc2FjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEdhc0Nvc3RQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciB0byB0cmVhdCB0aGVzZSB2YWx1ZXMgYXMgdmFsaWQgZnJvbS5cbiAgICAgKlxuICAgICAqICBUaGlzIGFsbG93cyBhIGhhcmRmb3JrIHRvIGhhdmUgdXBkYXRlZCB2YWx1ZXMgaW5jbHVkZWQgYXMgd2VsbCBhc1xuICAgICAqICBtdWx1dGlwbGUgaGFyZGZvcmtzIHRvIGJlIHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICBlZmZlY3RpdmVCbG9jaztcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9ucyBiYXNlIGZlZS5cbiAgICAgKi9cbiAgICB0eEJhc2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgZm9yIGNyZWF0aW5nIGEgbmV3IGFjY291bnQuXG4gICAgICovXG4gICAgdHhDcmVhdGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgcGVyIHplcm8tYnl0ZSBpbiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICB0eERhdGFaZXJvO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIHBlciBub24temVyby1ieXRlIGluIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHR4RGF0YU5vbnplcm87XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgcGVyIHN0b3JhZ2Uga2V5IGluIHRoZSBbW2xpbmstZWlwLTI5MzBdXSBhY2Nlc3MgbGlzdC5cbiAgICAgKi9cbiAgICB0eEFjY2Vzc0xpc3RTdG9yYWdlS2V5O1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIHBlciBhZGRyZXNzIGluIHRoZSBbW2xpbmstZWlwLTI5MzBdXSBhY2Nlc3MgbGlzdC5cbiAgICAgKi9cbiAgICB0eEFjY2Vzc0xpc3RBZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IEdhc0Nvc3RQbHVnaW4gZnJvbSAlJWVmZmVjdGl2ZUJsb2NrJSUgdW50aWwgdGhlXG4gICAgICogIGxhdGVzdCBibG9jayBvciBhbm90aGVyIEdhc0Nvc3RQbHVnaW4gc3VwZXJjZWRlcyB0aGF0IGJsb2NrIG51bWJlcixcbiAgICAgKiAgd2l0aCB0aGUgYXNzb2NpYXRlZCAlJWNvc3RzJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWZmZWN0aXZlQmxvY2ssIGNvc3RzKSB7XG4gICAgICAgIGlmIChlZmZlY3RpdmVCbG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICBlZmZlY3RpdmVCbG9jayA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoYG9yZy5ldGhlcnMubmV0d29yay5wbHVnaW5zLkdhc0Nvc3QjJHsoZWZmZWN0aXZlQmxvY2sgfHwgMCl9YCk7XG4gICAgICAgIGNvbnN0IHByb3BzID0geyBlZmZlY3RpdmVCbG9jayB9O1xuICAgICAgICBmdW5jdGlvbiBzZXQobmFtZSwgbnVsbGlzaCkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gKGNvc3RzIHx8IHt9KVtuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsaXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIsIGBpbnZhbHVkIHZhbHVlIGZvciAke25hbWV9YCwgXCJjb3N0c1wiLCBjb3N0cyk7XG4gICAgICAgICAgICBwcm9wc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHNldChcInR4QmFzZVwiLCAyMTAwMCk7XG4gICAgICAgIHNldChcInR4Q3JlYXRlXCIsIDMyMDAwKTtcbiAgICAgICAgc2V0KFwidHhEYXRhWmVyb1wiLCA0KTtcbiAgICAgICAgc2V0KFwidHhEYXRhTm9uemVyb1wiLCAxNik7XG4gICAgICAgIHNldChcInR4QWNjZXNzTGlzdFN0b3JhZ2VLZXlcIiwgMTkwMCk7XG4gICAgICAgIHNldChcInR4QWNjZXNzTGlzdEFkZHJlc3NcIiwgMjQwMCk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgcHJvcHMpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHYXNDb3N0UGx1Z2luKHRoaXMuZWZmZWN0aXZlQmxvY2ssIHRoaXMpO1xuICAgIH1cbn1cbi8qKlxuICogIEFuICoqRW5zUGx1Z2luKiogYWxsb3dzIGEgW1tOZXR3b3JrXV0gdG8gc3BlY2lmeSB0aGUgRU5TIFJlZ2lzdHJ5XG4gKiAgQ29udHJhY3QgYWRkcmVzcyBhbmQgdGhlIHRhcmdldCBuZXR3b3JrIHRvIHVzZSB3aGVuIHVzaW5nIHRoYXRcbiAqICBjb250cmFjdC5cbiAqXG4gKiAgVmFyaW91cyB0ZXN0bmV0cyBoYXZlIHRoZWlyIG93biBpbnN0YW5jZSBvZiB0aGUgY29udHJhY3QgdG8gdXNlLCBidXRcbiAqICBpbiBnZW5lcmFsLCB0aGUgbWFpbm5ldCBpbnN0YW5jZSBzdXBwb3J0cyBtdWx0aS1jaGFpbiBhZGRyZXNzZXMgYW5kXG4gKiAgc2hvdWxkIGJlIHVzZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFbnNQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIEVOUyBSZWdpc3RydHkgQ29udHJhY3QgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW4gSUQgdGhhdCB0aGUgRU5TIGNvbnRyYWN0IGxpdmVzIG9uLlxuICAgICAqL1xuICAgIHRhcmdldE5ldHdvcms7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipFbnNQbHVnaW4qKiBjb25uZWN0ZWQgdG8gJSVhZGRyZXNzJSUgb24gdGhlXG4gICAgICogICUldGFyZ2V0TmV0d29yayUlLiBUaGUgZGVmYXVsdCBFTlMgYWRkcmVzcyBhbmQgbWFpbm5ldCBpcyB1c2VkXG4gICAgICogIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHRhcmdldE5ldHdvcmspIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5FbnNcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgYWRkcmVzczogKGFkZHJlc3MgfHwgRW5zQWRkcmVzcyksXG4gICAgICAgICAgICB0YXJnZXROZXR3b3JrOiAoKHRhcmdldE5ldHdvcmsgPT0gbnVsbCkgPyAxIDogdGFyZ2V0TmV0d29yaylcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEVuc1BsdWdpbih0aGlzLmFkZHJlc3MsIHRoaXMudGFyZ2V0TmV0d29yayk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkZlZURhdGFOZXR3b3JrUGx1Z2luKiogYWxsb3dzIGEgbmV0d29yayB0byBwcm92aWRlIGFuZCBhbHRlcm5hdGVcbiAqICBtZWFucyB0byBzcGVjaWZ5IGl0cyBmZWUgZGF0YS5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGEgbmV0d29yayB3aGljaCBkb2VzIG5vdCBzdXBwb3J0IFtbbGluay1laXAtMTU1OV1dIG1heVxuICogIGNob29zZSB0byB1c2UgYSBHYXMgU3RhdGlvbiBzaXRlIHRvIGFwcHJveGltYXRlIHRoZSBnYXMgcHJpY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBGZWVEYXRhTmV0d29ya1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgICNmZWVEYXRhRnVuYztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBkYXRhIGZ1bmN0aW9uIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBnZXQgZmVlRGF0YUZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmZWVEYXRhRnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGZWVEYXRhTmV0d29ya1BsdWdpbioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZlZURhdGFGdW5jKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmVlRGF0YVwiKTtcbiAgICAgICAgdGhpcy4jZmVlRGF0YUZ1bmMgPSBmZWVEYXRhRnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBmZWUgZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRGZWVEYXRhKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNmZWVEYXRhRnVuYyhwcm92aWRlcik7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEZlZURhdGFOZXR3b3JrUGx1Z2luKHRoaXMuI2ZlZURhdGFGdW5jKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgICN1cmw7XG4gICAgI3Byb2Nlc3NGdW5jO1xuICAgIC8qKlxuICAgICAqICBUaGUgVVJMIHRvIGluaXRpYWxpemUgdGhlIEZldGNoUmVxdWVzdCB3aXRoIGluICUlcHJvY2Vzc0Z1bmMlJS5cbiAgICAgKi9cbiAgICBnZXQgdXJsKCkgeyByZXR1cm4gdGhpcy4jdXJsOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBjYWxsYmFjayB0byB1c2Ugd2hlbiBjb21wdXRpbmcgdGhlIEZlZURhdGEuXG4gICAgICovXG4gICAgZ2V0IHByb2Nlc3NGdW5jKCkgeyByZXR1cm4gdGhpcy4jcHJvY2Vzc0Z1bmM7IH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4qKiB3aGljaCB3aWxsXG4gICAgICogIGJlIHVzZWQgd2hlbiBjb21wdXRpbmcgdGhlIGZlZSBkYXRhIGZvciB0aGUgbmV0d29yay5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHByb2Nlc3NGdW5jKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmV0Y2hVcmxGZWVEYXRhUGx1Z2luXCIpO1xuICAgICAgICB0aGlzLiN1cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuI3Byb2Nlc3NGdW5jID0gcHJvY2Vzc0Z1bmM7XG4gICAgfVxuICAgIC8vIFdlIGFyZSBpbW11dGFibGUsIHNvIHdlIGNhbiBzZXJ2ZSBhcyBvdXIgb3duIGNsb25lXG4gICAgY2xvbmUoKSB7IHJldHVybiB0aGlzOyB9XG59XG4vKlxuZXhwb3J0IGNsYXNzIEN1c3RvbUJsb2NrTmV0d29ya1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIHJlYWRvbmx5ICNibG9ja0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxzdHJpbmc+KSA9PiBCbG9jazxzdHJpbmc+O1xuICAgIHJlYWRvbmx5ICNibG9ja1dpdGhUeHNGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8VHJhbnNhY3Rpb25SZXNwb25zZVBhcmFtcz4pID0+IEJsb2NrPFRyYW5zYWN0aW9uUmVzcG9uc2U+O1xuXG4gICAgY29uc3RydWN0b3IoYmxvY2tGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8c3RyaW5nPikgPT4gQmxvY2s8c3RyaW5nPiwgYmxvY2tXaXRoVHhzRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPFRyYW5zYWN0aW9uUmVzcG9uc2VQYXJhbXM+KSA9PiBCbG9jazxUcmFuc2FjdGlvblJlc3BvbnNlPikge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMubmV0d29yay1wbHVnaW5zLmN1c3RvbS1ibG9ja1wiKTtcbiAgICAgICAgdGhpcy4jYmxvY2tGdW5jID0gYmxvY2tGdW5jO1xuICAgICAgICB0aGlzLiNibG9ja1dpdGhUeHNGdW5jID0gYmxvY2tXaXRoVHhzRnVuYztcbiAgICB9XG5cbiAgICBhc3luYyBnZXRCbG9jayhwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxzdHJpbmc+KTogUHJvbWlzZTxCbG9jazxzdHJpbmc+PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNibG9ja0Z1bmMocHJvdmlkZXIsIGJsb2NrKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRCbG9ja2lvbnMocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8VHJhbnNhY3Rpb25SZXNwb25zZVBhcmFtcz4pOiBQcm9taXNlPEJsb2NrPFRyYW5zYWN0aW9uUmVzcG9uc2U+PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNibG9ja1dpdGhUeHNGdW5jKHByb3ZpZGVyLCBibG9jayk7XG4gICAgfVxuXG4gICAgY2xvbmUoKTogQ3VzdG9tQmxvY2tOZXR3b3JrUGx1Z2luIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21CbG9ja05ldHdvcmtQbHVnaW4odGhpcy4jYmxvY2tGdW5jLCB0aGlzLiNibG9ja1dpdGhUeHNGdW5jKTtcbiAgICB9XG59XG4qL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2lucy1uZXR3b3JrLmpzLm1hcCIsIi8qKlxuICogIEEgKipOZXR3b3JrKiogZW5jYXBzdWxhdGVzIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgcmVxdWlyZWQgdG9cbiAqICBpbnRlcmFjdCB3aXRoIGEgc3BlY2lmaWMgY2hhaW4uXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVyczpOZXR3b3JrcyAgW25ldHdvcmtzXVxuICovXG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRCaWdJbnQsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEVuc1BsdWdpbiwgRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbiwgR2FzQ29zdFBsdWdpbiB9IGZyb20gXCIuL3BsdWdpbnMtbmV0d29yay5qc1wiO1xuLyogKiAqICpcbi8vIE5ldHdvcmtzIHdoaWNoIG9wZXJhdGlvbiBhZ2FpbnN0IGFuIEwyIGNhbiB1c2UgdGhpcyBwbHVnaW4gdG9cbi8vIHNwZWNpZnkgaG93IHRvIGFjY2VzcyBMMSwgZm9yIHRoZSBwdXJwb3NlIG9mIHJlc29sdmluZyBFTlMsXG4vLyBmb3IgZXhhbXBsZS5cbmV4cG9ydCBjbGFzcyBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICByZWFkb25seSBwcm92aWRlciE6IFByb3ZpZGVyO1xuLy8gQFRPRE86IFJlbmFtZSB0byBDaGFpbkFjY2VzcyBhbmQgYWxsb3cgZm9yIGNvbm5lY3RpbmcgdG8gYW55IGNoYWluXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXI6IFByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLmxheWVyLW9uZS1jb25uZWN0aW9uXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzPExheWVyT25lQ29ubmVjdGlvblBsdWdpbj4odGhpcywgeyBwcm92aWRlciB9KTtcbiAgICB9XG5cbiAgICBjbG9uZSgpOiBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4ge1xuICAgICAgICByZXR1cm4gbmV3IExheWVyT25lQ29ubmVjdGlvblBsdWdpbih0aGlzLnByb3ZpZGVyKTtcbiAgICB9XG59XG4qL1xuY29uc3QgTmV0d29ya3MgPSBuZXcgTWFwKCk7XG4vKipcbiAqICBBICoqTmV0d29yayoqIHByb3ZpZGVzIGFjY2VzcyB0byBhIGNoYWluJ3MgcHJvcGVydGllcyBhbmQgYWxsb3dzXG4gKiAgZm9yIHBsdWctaW5zIHRvIGV4dGVuZCBmdW5jdGlvbmFsaXR5LlxuICovXG5leHBvcnQgY2xhc3MgTmV0d29yayB7XG4gICAgI25hbWU7XG4gICAgI2NoYWluSWQ7XG4gICAgI3BsdWdpbnM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipOZXR3b3JrKiogZm9yICUlbmFtZSUlIGFuZCAlJWNoYWluSWQlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBjaGFpbklkKSB7XG4gICAgICAgIHRoaXMuI25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLiNjaGFpbklkID0gZ2V0QmlnSW50KGNoYWluSWQpO1xuICAgICAgICB0aGlzLiNwbHVnaW5zID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIE5ldHdvcmsuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBuYW1lOiB0aGlzLm5hbWUsIGNoYWluSWQ6IFN0cmluZyh0aGlzLmNoYWluSWQpIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmV0d29yayBjb21tb24gbmFtZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIHRoZSBjYW5vbmljYWwgbmFtZSwgYXMgbmV0d29ya3MgbWlnaCBoYXZlIG11bHRpcGxlXG4gICAgICogIG5hbWVzLlxuICAgICAqL1xuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy4jbmFtZTsgfVxuICAgIHNldCBuYW1lKHZhbHVlKSB7IHRoaXMuI25hbWUgPSB2YWx1ZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmV0d29yayBjaGFpbiBJRC5cbiAgICAgKi9cbiAgICBnZXQgY2hhaW5JZCgpIHsgcmV0dXJuIHRoaXMuI2NoYWluSWQ7IH1cbiAgICBzZXQgY2hhaW5JZCh2YWx1ZSkgeyB0aGlzLiNjaGFpbklkID0gZ2V0QmlnSW50KHZhbHVlLCBcImNoYWluSWRcIik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBtYXRjaGVzIHRoaXMgbmV0d29yay4gQW55IGNoYWluIElEXG4gICAgICogIG11c3QgbWF0Y2gsIGFuZCBpZiBubyBjaGFpbiBJRCBpcyBwcmVzZW50LCB0aGUgbmFtZSBtdXN0IG1hdGNoLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGRvZXMgbm90IGN1cnJlbnRseSBjaGVjayBmb3IgYWRkaXRpb25hbCBwcm9wZXJ0aWVzLFxuICAgICAqICBzdWNoIGFzIEVOUyBhZGRyZXNzIG9yIHBsdWctaW4gY29tcGF0aWJpbGl0eS5cbiAgICAgKi9cbiAgICBtYXRjaGVzKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob3RoZXIpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFpbklkID09PSBnZXRCaWdJbnQob3RoZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMubmFtZSA9PT0gb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG90aGVyKSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgKG90aGVyKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhaW5JZCA9PT0gZ2V0QmlnSW50KG90aGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG90aGVyKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKG90aGVyLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFpbklkID09PSBnZXRCaWdJbnQob3RoZXIuY2hhaW5JZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdGhlci5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMubmFtZSA9PT0gb3RoZXIubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgbGlzdCBvZiBwbHVnaW5zIGN1cnJlbnRseSBhdHRhY2hlZCB0byB0aGlzIE5ldHdvcmsuXG4gICAgICovXG4gICAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI3BsdWdpbnMudmFsdWVzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQXR0YWNoIGEgbmV3ICUlcGx1Z2luJSUgdG8gdGhpcyBOZXR3b3JrLiBUaGUgbmV0d29yayBuYW1lXG4gICAgICogIG11c3QgYmUgdW5pcXVlLCBleGNsdWRpbmcgYW55IGZyYWdtZW50LlxuICAgICAqL1xuICAgIGF0dGFjaFBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMuI3BsdWdpbnMuZ2V0KHBsdWdpbi5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVwbGFjZSBleGlzdGluZyBwbHVnaW46ICR7cGx1Z2luLm5hbWV9IGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BsdWdpbnMuc2V0KHBsdWdpbi5uYW1lLCBwbHVnaW4uY2xvbmUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBwbHVnaW4sIGlmIGFueSwgbWF0Y2hpbmcgJSVuYW1lJSUgZXhhY3RseS4gUGx1Z2luc1xuICAgICAqICB3aXRoIGZyYWdtZW50cyB3aWxsIG5vdCBiZSByZXR1cm5lZCB1bmxlc3MgJSVuYW1lJSUgaW5jbHVkZXNcbiAgICAgKiAgYSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBnZXRQbHVnaW4obmFtZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3BsdWdpbnMuZ2V0KG5hbWUpKSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0cyBhIGxpc3Qgb2YgYWxsIHBsdWdpbnMgdGhhdCBtYXRjaCAlJW5hbWUlJSwgd2l0aCBvdHIgd2l0aG91dFxuICAgICAqICBhIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGdldFBsdWdpbnMoYmFzZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnBsdWdpbnMuZmlsdGVyKChwKSA9PiAocC5uYW1lLnNwbGl0KFwiI1wiKVswXSA9PT0gYmFzZW5hbWUpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgTmV0d29yay5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgTmV0d29yayh0aGlzLm5hbWUsIHRoaXMuY2hhaW5JZCk7XG4gICAgICAgIHRoaXMucGx1Z2lucy5mb3JFYWNoKChwbHVnaW4pID0+IHtcbiAgICAgICAgICAgIGNsb25lLmF0dGFjaFBsdWdpbihwbHVnaW4uY2xvbmUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBpbnRyaW5zaWMgZ2FzIHJlcXVpcmVkIGZvciBhIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIEEgR2FzQ29zdFBsdWdpbiBjYW4gYmUgYXR0YWNoZWQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRcbiAgICAgKiAgdmFsdWVzLlxuICAgICAqL1xuICAgIGNvbXB1dGVJbnRyaW5zaWNHYXModHgpIHtcbiAgICAgICAgY29uc3QgY29zdHMgPSB0aGlzLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkdhc0Nvc3RcIikgfHwgKG5ldyBHYXNDb3N0UGx1Z2luKCkpO1xuICAgICAgICBsZXQgZ2FzID0gY29zdHMudHhCYXNlO1xuICAgICAgICBpZiAodHgudG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4Q3JlYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5kYXRhKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IHR4LmRhdGEubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHguZGF0YS5zdWJzdHJpbmcoaSwgaSArIDIpID09PSBcIjAwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4RGF0YVplcm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnYXMgKz0gY29zdHMudHhEYXRhTm9uemVybztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0xpc3QgPSBhY2Nlc3NMaXN0aWZ5KHR4LmFjY2Vzc0xpc3QpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhZGRyIGluIGFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICBnYXMgKz0gY29zdHMudHhBY2Nlc3NMaXN0QWRkcmVzcyArIGNvc3RzLnR4QWNjZXNzTGlzdFN0b3JhZ2VLZXkgKiBhY2Nlc3NMaXN0W2FkZHJdLnN0b3JhZ2VLZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2FzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBOZXR3b3JrIGZvciB0aGUgJSVuZXR3b3JrJSUgbmFtZSBvciBjaGFpbklkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG5ldHdvcmspIHtcbiAgICAgICAgaW5qZWN0Q29tbW9uTmV0d29ya3MoKTtcbiAgICAgICAgLy8gRGVmYXVsdCBuZXR3b3JrXG4gICAgICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOZXR3b3JrLmZyb20oXCJtYWlubmV0XCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbm9uaWNhbCBuYW1lIG9yIGNoYWluIElEXG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBuZXR3b3JrID0gQmlnSW50KG5ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiAobmV0d29yaykgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmtGdW5jID0gTmV0d29ya3MuZ2V0KG5ldHdvcmspO1xuICAgICAgICAgICAgaWYgKG5ldHdvcmtGdW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcmtGdW5jKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmV0d29yayhcInVua25vd25cIiwgbmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bmtub3duIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsb25hYmxlIHdpdGggbmV0d29yay1saWtlIGFiaWxpdGllc1xuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrLmNsb25lKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBjbG9uZSA9IG5ldHdvcmsuY2xvbmUoKTtcbiAgICAgICAgICAgIC8vaWYgKHR5cGVvZihuZXR3b3JrLm5hbWUpICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZihuZXR3b3JrLmNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAvL31cbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZXR3b3JraXNoXG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKG5ldHdvcmsubmFtZSkgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIChuZXR3b3JrLmNoYWluSWQpID09PSBcIm51bWJlclwiLCBcImludmFsaWQgbmV0d29yayBvYmplY3QgbmFtZSBvciBjaGFpbklkXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbSA9IG5ldyBOZXR3b3JrKChuZXR3b3JrLm5hbWUpLCAobmV0d29yay5jaGFpbklkKSk7XG4gICAgICAgICAgICBpZiAobmV0d29yay5lbnNBZGRyZXNzIHx8IG5ldHdvcmsuZW5zTmV0d29yayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tLmF0dGFjaFBsdWdpbihuZXcgRW5zUGx1Z2luKG5ldHdvcmsuZW5zQWRkcmVzcywgbmV0d29yay5lbnNOZXR3b3JrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2lmICgoPGFueT5uZXR3b3JrKS5sYXllck9uZUNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIC8vICAgIGN1c3RvbS5hdHRhY2hQbHVnaW4obmV3IExheWVyT25lQ29ubmVjdGlvblBsdWdpbigoPGFueT5uZXR3b3JrKS5sYXllck9uZUNvbm5lY3Rpb24pKTtcbiAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVnaXN0ZXIgJSVuYW1lT3JDaGFpbklkJSUgd2l0aCBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnNcbiAgICAgKiAgYW4gaW5zdGFuY2Ugb2YgYSBOZXR3b3JrIHJlcHJlc2VudGluZyB0aGF0IGNoYWluLlxuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlcihuYW1lT3JDaGFpbklkLCBuZXR3b3JrRnVuYykge1xuICAgICAgICBpZiAodHlwZW9mIChuYW1lT3JDaGFpbklkKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbmFtZU9yQ2hhaW5JZCA9IEJpZ0ludChuYW1lT3JDaGFpbklkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGlzdGluZyA9IE5ldHdvcmtzLmdldChuYW1lT3JDaGFpbklkKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGNvbmZsaWN0aW5nIG5ldHdvcmsgZm9yICR7SlNPTi5zdHJpbmdpZnkoZXhpc3RpbmcubmFtZSl9YCwgXCJuYW1lT3JDaGFpbklkXCIsIG5hbWVPckNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICAgIE5ldHdvcmtzLnNldChuYW1lT3JDaGFpbklkLCBuZXR3b3JrRnVuYyk7XG4gICAgfVxufVxuLy8gV2UgZG9uJ3Qgd2FudCB0byBicmluZyBpbiBmb3JtYXRVbml0cyBiZWNhdXNlIGl0IGlzIGJhY2tlZCBieVxuLy8gRml4ZWROdW1iZXIgYW5kIHdlIHdhbnQgdG8ga2VlcCBOZXR3b3JrcyB0aW55LiBUaGUgdmFsdWVzXG4vLyBpbmNsdWRlZCBieSB0aGUgR2FzIFN0YXRpb25zIGFyZSBhbHNvIElFRUUgNzU0IHdpdGggbG90cyBvZlxuLy8gcm91bmRpbmcgaXNzdWVzIGFuZCBleGNlZWQgdGhlIHN0cmljdCBjaGVja3MgZm9ybWF0VW5pdHMgaGFzLlxuZnVuY3Rpb24gcGFyc2VVbml0cyhfdmFsdWUsIGRlY2ltYWxzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBTdHJpbmcoX3ZhbHVlKTtcbiAgICBpZiAoIXZhbHVlLm1hdGNoKC9eWzAtOS5dKyQvKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZ3dlaSB2YWx1ZTogJHtfdmFsdWV9YCk7XG4gICAgfVxuICAgIC8vIEJyZWFrIGludG8gWyB3aG9sZSwgZnJhY3Rpb24gXVxuICAgIGNvbnN0IGNvbXBzID0gdmFsdWUuc3BsaXQoXCIuXCIpO1xuICAgIGlmIChjb21wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29tcHMucHVzaChcIlwiKTtcbiAgICB9XG4gICAgLy8gTW9yZSB0aGFuIDEgZGVjaW1hbCBwb2ludCBvciB0b28gbWFueSBmcmFjdGlvbmFsIHBvc2l0aW9uc1xuICAgIGlmIChjb21wcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGd3ZWkgdmFsdWU6ICR7X3ZhbHVlfWApO1xuICAgIH1cbiAgICAvLyBQYWQgdGhlIGZyYWN0aW9uIHRvIDkgZGVjaW1hbHBsYWNlc1xuICAgIHdoaWxlIChjb21wc1sxXS5sZW5ndGggPCBkZWNpbWFscykge1xuICAgICAgICBjb21wc1sxXSArPSBcIjBcIjtcbiAgICB9XG4gICAgLy8gVG9vIG1hbnkgZGVjaW1hbHMgYW5kIHNvbWUgbm9uLXplcm8gZW5kaW5nLCB0YWtlIHRoZSBjZWlsaW5nXG4gICAgaWYgKGNvbXBzWzFdLmxlbmd0aCA+IDkpIHtcbiAgICAgICAgbGV0IGZyYWMgPSBCaWdJbnQoY29tcHNbMV0uc3Vic3RyaW5nKDAsIDkpKTtcbiAgICAgICAgaWYgKCFjb21wc1sxXS5zdWJzdHJpbmcoOSkubWF0Y2goL14wKyQvKSkge1xuICAgICAgICAgICAgZnJhYysrO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBzWzFdID0gZnJhYy50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50KGNvbXBzWzBdICsgY29tcHNbMV0pO1xufVxuLy8gVXNlZCBieSBQb2x5Z29uIHRvIHVzZSBhIGdhcyBzdGF0aW9uIGZvciBmZWUgZGF0YVxuZnVuY3Rpb24gZ2V0R2FzU3RhdGlvblBsdWdpbih1cmwpIHtcbiAgICByZXR1cm4gbmV3IEZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4odXJsLCBhc3luYyAoZmV0Y2hGZWVEYXRhLCBwcm92aWRlciwgcmVxdWVzdCkgPT4ge1xuICAgICAgICAvLyBQcmV2ZW50IENsb3VkZmxhcmUgZnJvbSBibG9ja2luZyBvdXIgcmVxdWVzdCBpbiBub2RlLmpzXG4gICAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKFwiVXNlci1BZ2VudFwiLCBcImV0aGVyc1wiKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgW19yZXNwb25zZSwgX2ZlZURhdGFdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpLCBmZXRjaEZlZURhdGEoKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXNwb25zZSA9IF9yZXNwb25zZTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSByZXNwb25zZS5ib2R5SnNvbi5zdGFuZGFyZDtcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgZ2FzUHJpY2U6IF9mZWVEYXRhLmdhc1ByaWNlLFxuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhczogcGFyc2VVbml0cyhwYXlsb2FkLm1heEZlZSwgOSksXG4gICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHBhcnNlVW5pdHMocGF5bG9hZC5tYXhQcmlvcml0eUZlZSwgOSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZlZURhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGBlcnJvciBlbmNvdW50ZXJlZCB3aXRoIHBvbHlnb24gZ2FzIHN0YXRpb24gKCR7SlNPTi5zdHJpbmdpZnkocmVxdWVzdC51cmwpfSlgLCBcIlNFUlZFUl9FUlJPUlwiLCB7IHJlcXVlc3QsIHJlc3BvbnNlLCBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gU2VlOiBodHRwczovL2NoYWlubGlzdC5vcmdcbmxldCBpbmplY3RlZCA9IGZhbHNlO1xuZnVuY3Rpb24gaW5qZWN0Q29tbW9uTmV0d29ya3MoKSB7XG4gICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5qZWN0ZWQgPSB0cnVlO1xuICAgIC8vLyBSZWdpc3RlciBwb3B1bGFyIEV0aGVyZXVtIG5ldHdvcmtzXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJFdGgobmFtZSwgY2hhaW5JZCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IG5ldyBOZXR3b3JrKG5hbWUsIGNoYWluSWQpO1xuICAgICAgICAgICAgLy8gV2UgdXNlIDAgdG8gZGlzYWJsZSBFTlNcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVuc05ldHdvcmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ldHdvcmsuYXR0YWNoUGx1Z2luKG5ldyBFbnNQbHVnaW4obnVsbCwgb3B0aW9ucy5lbnNOZXR3b3JrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXR3b3JrLmF0dGFjaFBsdWdpbihuZXcgR2FzQ29zdFBsdWdpbigpKTtcbiAgICAgICAgICAgIChvcHRpb25zLnBsdWdpbnMgfHwgW10pLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgICAgICAgICAgIG5ldHdvcmsuYXR0YWNoUGx1Z2luKHBsdWdpbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZWdpc3RlciB0aGUgbmV0d29yayBieSBuYW1lIGFuZCBjaGFpbiBJRFxuICAgICAgICBOZXR3b3JrLnJlZ2lzdGVyKG5hbWUsIGZ1bmMpO1xuICAgICAgICBOZXR3b3JrLnJlZ2lzdGVyKGNoYWluSWQsIGZ1bmMpO1xuICAgICAgICBpZiAob3B0aW9ucy5hbHROYW1lcykge1xuICAgICAgICAgICAgb3B0aW9ucy5hbHROYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgTmV0d29yay5yZWdpc3RlcihuYW1lLCBmdW5jKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZ2lzdGVyRXRoKFwibWFpbm5ldFwiLCAxLCB7IGVuc05ldHdvcms6IDEsIGFsdE5hbWVzOiBbXCJob21lc3RlYWRcIl0gfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJyb3BzdGVuXCIsIDMsIHsgZW5zTmV0d29yazogMyB9KTtcbiAgICByZWdpc3RlckV0aChcInJpbmtlYnlcIiwgNCwgeyBlbnNOZXR3b3JrOiA0IH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiZ29lcmxpXCIsIDUsIHsgZW5zTmV0d29yazogNSB9KTtcbiAgICByZWdpc3RlckV0aChcImtvdmFuXCIsIDQyLCB7IGVuc05ldHdvcms6IDQyIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwic2Vwb2xpYVwiLCAxMTE1NTExMSwgeyBlbnNOZXR3b3JrOiAxMTE1NTExMSB9KTtcbiAgICByZWdpc3RlckV0aChcImNsYXNzaWNcIiwgNjEsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImNsYXNzaWNLb3R0aVwiLCA2LCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJhcmJpdHJ1bVwiLCA0MjE2MSwge1xuICAgICAgICBlbnNOZXR3b3JrOiAxLFxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYXJiaXRydW0tZ29lcmxpXCIsIDQyMTYxMywge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZVwiLCA4NDUzLCB7IGVuc05ldHdvcms6IDEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJiYXNlLWdvZXJsaVwiLCA4NDUzMSwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZS1zZXBvbGlhXCIsIDg0NTMyLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJibmJcIiwgNTYsIHsgZW5zTmV0d29yazogMSB9KTtcbiAgICByZWdpc3RlckV0aChcImJuYnRcIiwgOTcsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImxpbmVhXCIsIDU5MTQ0LCB7IGVuc05ldHdvcms6IDEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYS1nb2VybGlcIiwgNTkxNDAsIHt9KTtcbiAgICByZWdpc3RlckV0aChcIm1hdGljXCIsIDEzNywge1xuICAgICAgICBlbnNOZXR3b3JrOiAxLFxuICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICBnZXRHYXNTdGF0aW9uUGx1Z2luKFwiaHR0cHM6L1xcL2dhc3N0YXRpb24ucG9seWdvbi50ZWNobm9sb2d5L3YyXCIpXG4gICAgICAgIF1cbiAgICB9KTtcbiAgICByZWdpc3RlckV0aChcIm1hdGljLW11bWJhaVwiLCA4MDAwMSwge1xuICAgICAgICBhbHROYW1lczogW1wibWF0aWNNdW1iYWlcIiwgXCJtYXRpY211bVwiXSxcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgZ2V0R2FzU3RhdGlvblBsdWdpbihcImh0dHBzOi9cXC9nYXNzdGF0aW9uLXRlc3RuZXQucG9seWdvbi50ZWNobm9sb2d5L3YyXCIpXG4gICAgICAgIF1cbiAgICB9KTtcbiAgICByZWdpc3RlckV0aChcIm9wdGltaXNtXCIsIDEwLCB7XG4gICAgICAgIGVuc05ldHdvcms6IDEsXG4gICAgICAgIHBsdWdpbnM6IFtdXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJvcHRpbWlzbS1nb2VybGlcIiwgNDIwLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJ4ZGFpXCIsIDEwMCwgeyBlbnNOZXR3b3JrOiAxIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29yay5qcy5tYXAiLCJpbXBvcnQgeyBhc3NlcnQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5mdW5jdGlvbiBjb3B5KG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBwb2xsaW5nIHN1YnNjcmliZXIgZm9yIGNvbW1vbiBldmVudHMuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2xsaW5nU3Vic2NyaWJlcihwcm92aWRlciwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgPT09IFwiYmxvY2tcIikge1xuICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdCbG9ja1N1YnNjcmliZXIocHJvdmlkZXIpO1xuICAgIH1cbiAgICBpZiAoaXNIZXhTdHJpbmcoZXZlbnQsIDMyKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIocHJvdmlkZXIsIGV2ZW50KTtcbiAgICB9XG4gICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIHBvbGxpbmcgZXZlbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICBvcGVyYXRpb246IFwiZ2V0UG9sbGluZ1N1YnNjcmliZXJcIiwgaW5mbzogeyBldmVudCB9XG4gICAgfSk7XG59XG4vLyBAVE9ETzogcmVmYWN0b3IgdGhpc1xuLyoqXG4gKiAgQSAqKlBvbGxpbmdCbG9ja1N1YnNjcmliZXIqKiBwb2xscyBhdCBhIHJlZ3VsYXIgaW50ZXJ2YWwgZm9yIGEgY2hhbmdlXG4gKiAgaW4gdGhlIGJsb2NrIG51bWJlci5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFBvbGxpbmdCbG9ja1N1YnNjcmliZXIge1xuICAgICNwcm92aWRlcjtcbiAgICAjcG9sbGVyO1xuICAgICNpbnRlcnZhbDtcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgYmxvY2sgd2UgaGF2ZSBzY2FubmVkIGZvciBldmVudHMuIFRoZSB2YWx1ZSAtMlxuICAgIC8vIGluZGljYXRlcyB3ZSBzdGlsbCBuZWVkIHRvIGZldGNoIGFuIGluaXRpYWwgYmxvY2sgbnVtYmVyXG4gICAgI2Jsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKiogYXR0YWNoZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuI2ludGVydmFsID0gNDAwMDtcbiAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwb2xsaW5nIGludGVydmFsLlxuICAgICAqL1xuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7IHJldHVybiB0aGlzLiNpbnRlcnZhbDsgfVxuICAgIHNldCBwb2xsaW5nSW50ZXJ2YWwodmFsdWUpIHsgdGhpcy4jaW50ZXJ2YWwgPSB2YWx1ZTsgfVxuICAgIGFzeW5jICNwb2xsKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICAgICAgLy8gQm9vdHN0cmFwIHBvbGwgdG8gc2V0dXAgb3VyIGluaXRpYWwgYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAVE9ETzogUHV0IGEgY2FwIG9uIHRoZSBtYXhpbXVtIG51bWJlciBvZiBldmVudHMgcGVyIGxvb3A/XG4gICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgIT09IHRoaXMuI2Jsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYiA9IHRoaXMuI2Jsb2NrTnVtYmVyICsgMTsgYiA8PSBibG9ja051bWJlcjsgYisrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYmVlbiBzdG9wcGVkXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNwb2xsZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Byb3ZpZGVyLmVtaXQoXCJibG9ja1wiLCBiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEBUT0RPOiBNaW5vciBidW1wLCBhZGQgYW4gXCJlcnJvclwiIGV2ZW50IHRvIGxldCBzdWJzY3JpYmVyc1xuICAgICAgICAgICAgLy8gICAgICAgIGtub3cgdGhpbmdzIHdlbnQgYXdyeS5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgYmVlbiBzdG9wcGVkXG4gICAgICAgIGlmICh0aGlzLiNwb2xsZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3Byb3ZpZGVyLl9zZXRUaW1lb3V0KHRoaXMuI3BvbGwuYmluZCh0aGlzKSwgdGhpcy4jaW50ZXJ2YWwpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3BvbGxlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3Byb3ZpZGVyLl9zZXRUaW1lb3V0KHRoaXMuI3BvbGwuYmluZCh0aGlzKSwgdGhpcy4jaW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLiNwb2xsKCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy4jcG9sbGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIuX2NsZWFyVGltZW91dCh0aGlzLiNwb2xsZXIpO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSBudWxsO1xuICAgIH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gKipPbkJsb2NrU3Vic2NyaWJlcioqIGNhbiBiZSBzdWItY2xhc3NlZCwgd2l0aCBhIFtbX3BvbGxdXVxuICogIGltcGxtZW50YXRpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgb24gZXZlcnkgbmV3IGJsb2NrLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICNwcm92aWRlcjtcbiAgICAjcG9sbDtcbiAgICAjcnVubmluZztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqT25CbG9ja1N1YnNjcmliZXIqKiBhdHRhY2hlZCB0byAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNwb2xsID0gKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wb2xsKGJsb2NrTnVtYmVyLCB0aGlzLiNwcm92aWRlcik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDYWxsZWQgb24gZXZlcnkgbmV3IGJsb2NrLlxuICAgICAqL1xuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWItY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLiNwb2xsKC0yKTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub24oXCJibG9ja1wiLCB0aGlzLiNwb2xsKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNwcm92aWRlci5vZmYoXCJibG9ja1wiLCB0aGlzLiNwb2xsKTtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7IHRoaXMuc3RvcCgpOyB9XG4gICAgcmVzdW1lKCkgeyB0aGlzLnN0YXJ0KCk7IH1cbn1cbmV4cG9ydCBjbGFzcyBQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyIGV4dGVuZHMgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICN0YWc7XG4gICAgI2xhc3RCbG9jaztcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgdGFnKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jdGFnID0gdGFnO1xuICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSAtMjtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9jayA9IC0yO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnBhdXNlKGRyb3BXaGlsZVBhdXNlZCk7XG4gICAgfVxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHByb3ZpZGVyLmdldEJsb2NrKHRoaXMuI3RhZyk7XG4gICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI2xhc3RCbG9jayA9PT0gLTIpIHtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9jayA9IGJsb2NrLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibG9jay5udW1iZXIgPiB0aGlzLiNsYXN0QmxvY2spIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQodGhpcy4jdGFnLCBibG9jay5udW1iZXIpO1xuICAgICAgICAgICAgdGhpcy4jbGFzdEJsb2NrID0gYmxvY2subnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2xsaW5nT3JwaGFuU3Vic2NyaWJlciBleHRlbmRzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjZmlsdGVyO1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBmaWx0ZXIpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNmaWx0ZXIgPSBjb3B5KGZpbHRlcik7XG4gICAgfVxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy4jZmlsdGVyKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcioqIHdpbGwgcG9sbCBmb3IgYSBnaXZlbiB0cmFuc2FjdGlvblxuICogIGhhc2ggZm9yIGl0cyByZWNlaXB0LlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlciBleHRlbmRzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjaGFzaDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvXG4gICAgICogICUlcHJvdmlkZXIlJSwgbGlzdGVuaW5nIGZvciAlJWhhc2glJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgaGFzaCkge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2hhc2ggPSBoYXNoO1xuICAgIH1cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodGhpcy4jaGFzaCk7XG4gICAgICAgIGlmICh0eCkge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdCh0aGlzLiNoYXNoLCB0eCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqICBBICoqUG9sbGluZ0V2ZW50U3Vic2NyaWJlcioqIHdpbGwgcG9sbCBmb3IgYSBnaXZlbiBmaWx0ZXIgZm9yIGl0cyBsb2dzLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNmaWx0ZXI7XG4gICAgI3BvbGxlcjtcbiAgICAjcnVubmluZztcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgYmxvY2sgd2UgaGF2ZSBzY2FubmVkIGZvciBldmVudHMuIFRoZSB2YWx1ZSAtMlxuICAgIC8vIGluZGljYXRlcyB3ZSBzdGlsbCBuZWVkIHRvIGZldGNoIGFuIGluaXRpYWwgYmxvY2sgbnVtYmVyXG4gICAgI2Jsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKiogYXR0YWNoZWQgdG9cbiAgICAgKiAgJSVwcm92aWRlciUlLCBsaXN0ZW5pbmcgZm9yICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNmaWx0ZXIgPSBjb3B5KGZpbHRlcik7XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3BvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgIH1cbiAgICBhc3luYyAjcG9sbChibG9ja051bWJlcikge1xuICAgICAgICAvLyBUaGUgaW5pdGlhbCBibG9jayBoYXNuJ3QgYmVlbiBkZXRlcm1pbmVkIHlldFxuICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVyID0gY29weSh0aGlzLiNmaWx0ZXIpO1xuICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gdGhpcy4jYmxvY2tOdW1iZXIgKyAxO1xuICAgICAgICBmaWx0ZXIudG9CbG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICBjb25zdCBsb2dzID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpO1xuICAgICAgICAvLyBObyBsb2dzIGNvdWxkIGp1c3QgbWVhbiB0aGUgbm9kZSBoYXMgbm90IGluZGV4ZWQgdGhlbSB5ZXQsXG4gICAgICAgIC8vIHNvIHdlIGtlZXAgYSBzbGlkaW5nIHdpbmRvdyBvZiA2MCBibG9ja3MgdG8ga2VlcCBzY2FubmluZ1xuICAgICAgICBpZiAobG9ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA8IGJsb2NrTnVtYmVyIC0gNjApIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGJsb2NrTnVtYmVyIC0gNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgbG9ncykge1xuICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuZW1pdCh0aGlzLiNmaWx0ZXIsIGxvZyk7XG4gICAgICAgICAgICAvLyBPbmx5IGFkdmFuY2UgdGhlIGJsb2NrIG51bWJlciB3aGVuIGxvZ3Mgd2VyZSBmb3VuZCB0b1xuICAgICAgICAgICAgLy8gYWNjb3VudCBmb3IgbmV0d29ya3MgKGxpa2UgQk5CIGFuZCBQb2x5Z29uKSB3aGljaCBtYXlcbiAgICAgICAgICAgIC8vIHNhY3JpZmljZSBldmVudCBjb25zaXN0ZW5jeSBmb3IgYmxvY2sgZXZlbnQgc3BlZWRcbiAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gbG9nLmJsb2NrTnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICB0aGlzLiNwcm92aWRlci5nZXRCbG9ja051bWJlcigpLnRoZW4oKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNwcm92aWRlci5vZmYoXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xuICAgIH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlci1wb2xsaW5nLmpzLm1hcCIsIi8qKlxuICogIFRoZSBhdmFpbGFibGUgcHJvdmlkZXJzIHNob3VsZCBzdWZmaWNlIGZvciBtb3N0IGRldmVsb3BlcnMgcHVycG9zZXMsXG4gKiAgYnV0IHRoZSBbW0Fic3RyYWN0UHJvdmlkZXJdXSBjbGFzcyBoYXMgbWFueSBmZWF0dXJlcyB3aGljaCBlbmFibGVcbiAqICBzdWItY2xhc3NpbmcgaXQgZm9yIHNwZWNpZmljIHB1cnBvc2VzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXI6IFN1YmNsYXNzaW5nIFByb3ZpZGVyICBbYWJzdHJhY3QtcHJvdmlkZXJdXG4gKi9cbi8vIEBUT0RPXG4vLyBFdmVudCBjb2FsZXNjZW5jZVxuLy8gICBXaGVuIHdlIHJlZ2lzdGVyIGFuIGV2ZW50IHdpdGggYW4gYXN5bmMgdmFsdWUgKGUuZy4gYWRkcmVzcyBpcyBhIFNpZ25lclxuLy8gICBvciBFTlMgbmFtZSksIHdlIG5lZWQgdG8gYWRkIGl0IGltbWVpZGF0ZWx5IGZvciB0aGUgRXZlbnQgQVBJLCBidXQgYWxzb1xuLy8gICBuZWVkIHRpbWUgdG8gcmVzb2x2ZSB0aGUgYWRkcmVzcy4gVXBvbiByZXNvbHZpbmcgdGhlIGFkZHJlc3MsIHdlIG5lZWQgdG9cbi8vICAgbWlncmF0ZSB0aGUgbGlzdGVuZXIgdG8gdGhlIHN0YXRpYyBldmVudC4gV2UgYWxzbyBuZWVkIHRvIG1haW50YWluIGEgbWFwXG4vLyAgIG9mIFNpZ25lci9FTlMgbmFtZSB0byBhZGRyZXNzIHNvIHdlIGNhbiBzeW5jIHJlc3BvbmQgdG8gbGlzdGVuZXJDb3VudC5cbmltcG9ydCB7IGdldEFkZHJlc3MsIHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFplcm9BZGRyZXNzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29udHJhY3QgfSBmcm9tIFwiLi4vY29udHJhY3QvaW5kZXguanNcIjtcbmltcG9ydCB7IG5hbWVoYXNoIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRhdGFMZW5ndGgsIGRhdGFTbGljZSwgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGdldE51bWJlciwgaXNDYWxsRXhjZXB0aW9uLCBpc0Vycm9yLCBtYWtlRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIEZldGNoUmVxdWVzdCwgdG9CZUFycmF5LCB0b1F1YW50aXR5LCBkZWZpbmVQcm9wZXJ0aWVzLCBFdmVudFBheWxvYWQsIHJlc29sdmVQcm9wZXJ0aWVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEVuc1Jlc29sdmVyIH0gZnJvbSBcIi4vZW5zLXJlc29sdmVyLmpzXCI7XG5pbXBvcnQgeyBmb3JtYXRCbG9jaywgZm9ybWF0TG9nLCBmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQsIGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UgfSBmcm9tIFwiLi9mb3JtYXQuanNcIjtcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XG5pbXBvcnQgeyBjb3B5UmVxdWVzdCwgQmxvY2ssIEZlZURhdGEsIExvZywgVHJhbnNhY3Rpb25SZWNlaXB0LCBUcmFuc2FjdGlvblJlc3BvbnNlIH0gZnJvbSBcIi4vcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IFBvbGxpbmdCbG9ja1N1YnNjcmliZXIsIFBvbGxpbmdCbG9ja1RhZ1N1YnNjcmliZXIsIFBvbGxpbmdFdmVudFN1YnNjcmliZXIsIFBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyLCBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyIH0gZnJvbSBcIi4vc3Vic2NyaWJlci1wb2xsaW5nLmpzXCI7XG4vLyBDb25zdGFudHNcbmNvbnN0IEJOXzIgPSBCaWdJbnQoMik7XG5jb25zdCBNQVhfQ0NJUF9SRURJUkVDVFMgPSAxMDtcbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS50aGVuKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGdldFRhZyhwcmVmaXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHByZWZpeCArIFwiOlwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUsIChrLCB2KSA9PiB7XG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGBiaWdpbnQ6JHt2LnRvU3RyaW5nKCl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHYudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0IG9iamVjdCBrZXlzXG4gICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModik7XG4gICAgICAgICAgICBrZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBrZXlzLnJlZHVjZSgoYWNjdW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY3VtW2tleV0gPSB2W2tleV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH0pO1xufVxuLyoqXG4gKiAgQW4gKipVbm1hbmFnZWRTdWJzY3JpYmVyKiogaXMgdXNlZnVsIGZvciBldmVudHMgd2hpY2ggZG8gbm90IHJlcXVpcmVcbiAqICBhbnkgYWRkaXRpb25hbCBtYW5hZ2VtZW50LCBzdWNoIGFzIGBgXCJkZWJ1Z1wiYGAgd2hpY2ggb25seSByZXF1aXJlc1xuICogIGVtaXQgaW4gc3luY2hyb25vdXMgZXZlbnQgbG9vcCB0cmlnZ2VyZWQgY2FsbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBVbm1hbmFnZWRTdWJzY3JpYmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgZm9mIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgVW5tYW5hZ2VkU3Vic2NyaWJlciB3aXRoICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHsgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUgfSk7IH1cbiAgICBzdGFydCgpIHsgfVxuICAgIHN0b3AoKSB7IH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHsgfVxuICAgIHJlc3VtZSgpIHsgfVxufVxuZnVuY3Rpb24gY29weSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5mdW5jdGlvbiBjb25jaXNpZnkoaXRlbXMpIHtcbiAgICBpdGVtcyA9IEFycmF5LmZyb20oKG5ldyBTZXQoaXRlbXMpKS52YWx1ZXMoKSk7XG4gICAgaXRlbXMuc29ydCgpO1xuICAgIHJldHVybiBpdGVtcztcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFN1YnNjcmlwdGlvbihfZXZlbnQsIHByb3ZpZGVyKSB7XG4gICAgaWYgKF9ldmVudCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZXZlbnRcIik7XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSB0b3BpYyBhcnJheSBpbmZvIGFuIEV2ZW50RmlsdGVyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoX2V2ZW50KSkge1xuICAgICAgICBfZXZlbnQgPSB7IHRvcGljczogX2V2ZW50IH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKF9ldmVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3dpdGNoIChfZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOlxuICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJuZXR3b3JrXCI6XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcInNhZmVcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IF9ldmVudCwgdGFnOiBfZXZlbnQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNIZXhTdHJpbmcoX2V2ZW50LCAzMikpIHtcbiAgICAgICAgY29uc3QgaGFzaCA9IF9ldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInRyYW5zYWN0aW9uXCIsIHRhZzogZ2V0VGFnKFwidHhcIiwgeyBoYXNoIH0pLCBoYXNoIH07XG4gICAgfVxuICAgIGlmIChfZXZlbnQub3JwaGFuKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gX2V2ZW50O1xuICAgICAgICAvLyBAVE9ETzogU2hvdWxkIGxvd2VyY2FzZSBhbmQgd2hhdG5vdCB0aGluZ3MgaGVyZSBpbnN0ZWFkIG9mIGNvcHkuLi5cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJvcnBoYW5cIiwgdGFnOiBnZXRUYWcoXCJvcnBoYW5cIiwgZXZlbnQpLCBmaWx0ZXI6IGNvcHkoZXZlbnQpIH07XG4gICAgfVxuICAgIGlmICgoX2V2ZW50LmFkZHJlc3MgfHwgX2V2ZW50LnRvcGljcykpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBfZXZlbnQ7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICAgIHRvcGljczogKChldmVudC50b3BpY3MgfHwgW10pLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25jaXNpZnkodC5tYXAoKHQpID0+IHQudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChldmVudC5hZGRyZXNzKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgICAgICBjb25zdCBhZGRBZGRyZXNzID0gKGFkZHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYWRkcikpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goYWRkcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhd2FpdCByZXNvbHZlQWRkcmVzcyhhZGRyLCBwcm92aWRlcikpO1xuICAgICAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICBldmVudC5hZGRyZXNzLmZvckVhY2goYWRkQWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRBZGRyZXNzKGV2ZW50LmFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbHRlci5hZGRyZXNzID0gY29uY2lzaWZ5KGFkZHJlc3Nlcy5tYXAoKGEpID0+IGEudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZpbHRlciwgdGFnOiBnZXRUYWcoXCJldmVudFwiLCBmaWx0ZXIpLCB0eXBlOiBcImV2ZW50XCIgfTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5rbm93biBQcm92aWRlckV2ZW50XCIsIFwiZXZlbnRcIiwgX2V2ZW50KTtcbn1cbmZ1bmN0aW9uIGdldFRpbWUoKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBjYWNoZVRpbWVvdXQ6IDI1MCxcbiAgICBwb2xsaW5nSW50ZXJ2YWw6IDQwMDBcbn07XG4vKipcbiAqICBBbiAqKkFic3RyYWN0UHJvdmlkZXIqKiBwcm92aWRlcyBhIGJhc2UgY2xhc3MgZm9yIG90aGVyIHN1Yi1jbGFzc2VzIHRvXG4gKiAgaW1wbGVtZW50IHRoZSBbW1Byb3ZpZGVyXV0gQVBJIGJ5IG5vcm1hbGl6aW5nIGlucHV0IGFyZ3VtZW50cyBhbmRcbiAqICBmb3JtYXR0aW5nIG91dHB1dCByZXN1bHRzIGFzIHdlbGwgYXMgdHJhY2tpbmcgZXZlbnRzIGZvciBjb25zaXN0ZW50XG4gKiAgYmVoYXZpb3VyIG9uIGFuIGV2ZW50dWFsbHktY29uc2lzdGVudCBuZXR3b3JrLlxuICovXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RQcm92aWRlciB7XG4gICAgI3N1YnM7XG4gICAgI3BsdWdpbnM7XG4gICAgLy8gbnVsbD11bnBhdXNlZCwgdHJ1ZT1wYXVzZWQrZHJvcFdoaWxlUGF1c2VkLCBmYWxzZT1wYXVzZWRcbiAgICAjcGF1c2VkU3RhdGU7XG4gICAgI2Rlc3Ryb3llZDtcbiAgICAjbmV0d29ya1Byb21pc2U7XG4gICAgI2FueU5ldHdvcms7XG4gICAgI3BlcmZvcm1DYWNoZTtcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgYmxvY2sgbnVtYmVyIGlmIHJ1bm5pbmcgYW4gZXZlbnQgb3IgLTEgaWYgbm8gXCJibG9ja1wiIGV2ZW50XG4gICAgI2xhc3RCbG9ja051bWJlcjtcbiAgICAjbmV4dFRpbWVyO1xuICAgICN0aW1lcnM7XG4gICAgI2Rpc2FibGVDY2lwUmVhZDtcbiAgICAjb3B0aW9ucztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqQWJzdHJhY3RQcm92aWRlcioqIGNvbm5lY3RlZCB0byAlJW5ldHdvcmslJSwgb3JcbiAgICAgKiAgdXNlIHRoZSB2YXJpb3VzIG5ldHdvcmsgZGV0ZWN0aW9uIGNhcGFiaWxpdGllcyB0byBkaXNjb3ZlciB0aGVcbiAgICAgKiAgW1tOZXR3b3JrXV0gaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIGlmIChfbmV0d29yayA9PT0gXCJhbnlcIikge1xuICAgICAgICAgICAgdGhpcy4jYW55TmV0d29yayA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX25ldHdvcmspIHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBOZXR3b3JrLmZyb20oX25ldHdvcmspO1xuICAgICAgICAgICAgdGhpcy4jYW55TmV0d29yayA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUobmV0d29yayk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTsgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNhbnlOZXR3b3JrID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbGFzdEJsb2NrTnVtYmVyID0gLTE7XG4gICAgICAgIHRoaXMuI3BlcmZvcm1DYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jc3VicyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jcGx1Z2lucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jcGF1c2VkU3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLiNkZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jbmV4dFRpbWVyID0gMTtcbiAgICAgICAgdGhpcy4jdGltZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNkaXNhYmxlQ2NpcFJlYWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI29wdGlvbnMucG9sbGluZ0ludGVydmFsOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0aGlzYGAsIHRvIGFsbG93IGFuICoqQWJzdHJhY3RQcm92aWRlcioqIHRvIGltcGxlbWVudFxuICAgICAqICB0aGUgW1tDb250cmFjdFJ1bm5lcl1dIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBnZXQgcHJvdmlkZXIoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYWxsIHRoZSByZWdpc3RlcmVkIHBsdWctaW5zLlxuICAgICAqL1xuICAgIGdldCBwbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNwbHVnaW5zLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEF0dGFjaCBhIG5ldyBwbHVnLWluLlxuICAgICAqL1xuICAgIGF0dGFjaFBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMuI3BsdWdpbnMuZ2V0KHBsdWdpbi5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVwbGFjZSBleGlzdGluZyBwbHVnaW46ICR7cGx1Z2luLm5hbWV9IGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BsdWdpbnMuc2V0KHBsdWdpbi5uYW1lLCBwbHVnaW4uY29ubmVjdCh0aGlzKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IGEgcGx1Z2luIGJ5IG5hbWUuXG4gICAgICovXG4gICAgZ2V0UGx1Z2luKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNwbHVnaW5zLmdldChuYW1lKSkgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByZXZlbnQgYW55IENDSVAtcmVhZCBvcGVyYXRpb24sIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciByZXF1ZXN0ZWRcbiAgICAgKiAgaW4gYSBbW2NhbGxdXSB1c2luZyBgYGVuYWJsZUNjaXBSZWFkYGAuXG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVDY2lwUmVhZCgpIHsgcmV0dXJuIHRoaXMuI2Rpc2FibGVDY2lwUmVhZDsgfVxuICAgIHNldCBkaXNhYmxlQ2NpcFJlYWQodmFsdWUpIHsgdGhpcy4jZGlzYWJsZUNjaXBSZWFkID0gISF2YWx1ZTsgfVxuICAgIC8vIFNoYXJlcyBtdWx0aXBsZSBpZGVudGljYWwgcmVxdWVzdHMgbWFkZSBkdXJpbmcgdGhlIHNhbWUgMjUwbXNcbiAgICBhc3luYyAjcGVyZm9ybShyZXEpIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuI29wdGlvbnMuY2FjaGVUaW1lb3V0O1xuICAgICAgICAvLyBDYWNoaW5nIGRpc2FibGVkXG4gICAgICAgIGlmICh0aW1lb3V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3BlcmZvcm0ocmVxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSB0YWdcbiAgICAgICAgY29uc3QgdGFnID0gZ2V0VGFnKHJlcS5tZXRob2QsIHJlcSk7XG4gICAgICAgIGxldCBwZXJmb3JtID0gdGhpcy4jcGVyZm9ybUNhY2hlLmdldCh0YWcpO1xuICAgICAgICBpZiAoIXBlcmZvcm0pIHtcbiAgICAgICAgICAgIHBlcmZvcm0gPSB0aGlzLl9wZXJmb3JtKHJlcSk7XG4gICAgICAgICAgICB0aGlzLiNwZXJmb3JtQ2FjaGUuc2V0KHRhZywgcGVyZm9ybSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jcGVyZm9ybUNhY2hlLmdldCh0YWcpID09PSBwZXJmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3BlcmZvcm1DYWNoZS5kZWxldGUodGFnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgcGVyZm9ybTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBkYXRhIGZvciBleGVjdXRpbmcgdGhlIENDSVAtcmVhZCBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIGFzeW5jIGNjaXBSZWFkRmV0Y2godHgsIGNhbGxkYXRhLCB1cmxzKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVDY2lwUmVhZCB8fCB1cmxzLmxlbmd0aCA9PT0gMCB8fCB0eC50byA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5kZXIgPSB0eC50by50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBkYXRhID0gY2FsbGRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHVybHNbaV07XG4gICAgICAgICAgICAvLyBVUkwgZXhwYW5zaW9uXG4gICAgICAgICAgICBjb25zdCBocmVmID0gdXJsLnJlcGxhY2UoXCJ7c2VuZGVyfVwiLCBzZW5kZXIpLnJlcGxhY2UoXCJ7ZGF0YX1cIiwgZGF0YSk7XG4gICAgICAgICAgICAvLyBJZiBubyB7ZGF0YX0gaXMgcHJlc2VudCwgdXNlIFBPU1Q7IG90aGVyd2lzZSBHRVRcbiAgICAgICAgICAgIC8vY29uc3QganNvbjogc3RyaW5nIHwgbnVsbCA9ICh1cmwuaW5kZXhPZihcIntkYXRhfVwiKSA+PSAwKSA/IG51bGw6IEpTT04uc3RyaW5naWZ5KHsgZGF0YSwgc2VuZGVyIH0pO1xuICAgICAgICAgICAgLy9jb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaEpzb24oeyB1cmw6IGhyZWYsIGVycm9yUGFzc1Rocm91Z2g6IHRydWUgfSwganNvbiwgKHZhbHVlLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgLy8gICAgdmFsdWUuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgICAgIC8vICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIC8vfSk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IEZldGNoUmVxdWVzdChocmVmKTtcbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZihcIntkYXRhfVwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmJvZHkgPSB7IGRhdGEsIHNlbmRlciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZENjaXBSZWFkRmV0Y2hSZXF1ZXN0XCIsIHJlcXVlc3QsIGluZGV4OiBpLCB1cmxzIH0pO1xuICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IFwidW5rbm93biBlcnJvclwiO1xuICAgICAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNwLmJvZHlKc29uO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRGZXRjaFJlc3VsdFwiLCByZXF1ZXN0LCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHJlc3VsdC5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRGZXRjaEVycm9yXCIsIHJlcXVlc3QsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAvLyA0eHggaW5kaWNhdGVzIHRoZSByZXN1bHQgaXMgbm90IHByZXNlbnQ7IHN0b3BcbiAgICAgICAgICAgIGFzc2VydChyZXNwLnN0YXR1c0NvZGUgPCA0MDAgfHwgcmVzcC5zdGF0dXNDb2RlID49IDUwMCwgYHJlc3BvbnNlIG5vdCBmb3VuZCBkdXJpbmcgQ0NJUCBmZXRjaDogJHtlcnJvck1lc3NhZ2V9YCwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7IHJlYXNvbjogXCI0MDRfTUlTU0lOR19SRVNPVVJDRVwiLCB0cmFuc2FjdGlvbjogdHgsIGluZm86IHsgdXJsLCBlcnJvck1lc3NhZ2UgfSB9KTtcbiAgICAgICAgICAgIC8vIDV4eCBpbmRpY2F0ZXMgc2VydmVyIGlzc3VlOyB0cnkgdGhlIG5leHQgdXJsXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzLnB1c2goZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgQ0NJUCBmZXRjaDogJHtlcnJvck1lc3NhZ2VzLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobSkpLmpvaW4oXCIsIFwiKX1gLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCI1MDBfU0VSVkVSX0VSUk9SXCIsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHgsIGluZm86IHsgdXJscywgZXJyb3JNZXNzYWdlcyB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgYmxvY2sgYmVmb3JlXG4gICAgICogIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhbiBhbHRlcm5hdGVcbiAgICAgKiAgc3ViLWNsYXNzIG9mIFtbQmxvY2tdXS5cbiAgICAgKi9cbiAgICBfd3JhcEJsb2NrKHZhbHVlLCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2soZm9ybWF0QmxvY2sodmFsdWUpLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIGxvZyBiZWZvcmVcbiAgICAgKiAgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuIGFsdGVybmF0ZVxuICAgICAqICBzdWItY2xhc3Mgb2YgW1tMb2ddXS5cbiAgICAgKi9cbiAgICBfd3JhcExvZyh2YWx1ZSwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IExvZyhmb3JtYXRMb2codmFsdWUpLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIHRyYW5zYWN0aW9uXG4gICAgICogIHJlY2VpcHQgYmVmb3JlIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhblxuICAgICAqICBhbHRlcm5hdGUgc3ViLWNsYXNzIG9mIFtbVHJhbnNhY3Rpb25SZWNlaXB0XV0uXG4gICAgICovXG4gICAgX3dyYXBUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUsIG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblJlY2VpcHQoZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlKSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSB0cmFuc2FjdGlvblxuICAgICAqICByZXNwb25zZSBiZWZvcmUgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuXG4gICAgICogIGFsdGVybmF0ZSBzdWItY2xhc3Mgb2YgW1tUcmFuc2FjdGlvblJlc3BvbnNlXV0uXG4gICAgICovXG4gICAgX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZShmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlKHR4KSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgTmV0d29yaywgZm9yY2luZyBhIG5ldHdvcmsgZGV0ZWN0aW9uIHVzaW5nIHdoYXRldmVyXG4gICAgICogIHRlY2huaXF1ZSB0aGUgc3ViLWNsYXNzIHJlcXVpcmVzLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMuXG4gICAgICovXG4gICAgX2RldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJzdWItY2xhc3NlcyBtdXN0IGltcGxlbWVudCB0aGlzXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJfZGV0ZWN0TmV0d29ya1wiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgc2hvdWxkIHVzZSB0aGlzIHRvIHBlcmZvcm0gYWxsIGJ1aWx0LWluIG9wZXJhdGlvbnMuIEFsbFxuICAgICAqICBtZXRob2RzIHNhbml0aXplcyBhbmQgbm9ybWFsaXplcyB0aGUgdmFsdWVzIHBhc3NlZCBpbnRvIHRoaXMuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcy5cbiAgICAgKi9cbiAgICBhc3luYyBfcGVyZm9ybShyZXEpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgdW5zdXBwb3J0ZWQgbWV0aG9kOiAke3JlcS5tZXRob2R9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiByZXEubWV0aG9kLFxuICAgICAgICAgICAgaW5mbzogcmVxXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBTdGF0ZVxuICAgIGFzeW5jIGdldEJsb2NrTnVtYmVyKCkge1xuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGdldE51bWJlcihhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldEJsb2NrTnVtYmVyXCIgfSksIFwiJXJlc3BvbnNlXCIpO1xuICAgICAgICBpZiAodGhpcy4jbGFzdEJsb2NrTnVtYmVyID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9ja051bWJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb2x2ZXMgdG8gdGhlIGFkZHJlc3MgZm9yICUlYWRkcmVzcyUlLCByZXNvbHZpbmcgRU5TXG4gICAgICogIG5hbWVzIGFuZCBbW0FkZHJlc3NhYmxlXV0gb2JqZWN0cyBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYW5cbiAgICAgKiAgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBfZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzcyhhZGRyZXNzLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb2x2ZXMgdG8gYSB2YWxpZCBibG9jayB0YWcgZm9yICUlYmxvY2tUYWclJSwgcmVzb2x2aW5nXG4gICAgICogIG5lZ2F0aXZlIHZhbHVlcyBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYSB2YWxpZCBibG9jayB0YWcuXG4gICAgICovXG4gICAgX2dldEJsb2NrVGFnKGJsb2NrVGFnKSB7XG4gICAgICAgIGlmIChibG9ja1RhZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJsYXRlc3RcIjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGJsb2NrVGFnKSB7XG4gICAgICAgICAgICBjYXNlIFwiZWFybGllc3RcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIweDBcIjtcbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJsYXRlc3RcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICBjYXNlIFwic2FmZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1RhZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYmxvY2tUYWcsIDMyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1RhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b1F1YW50aXR5KGJsb2NrVGFnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIGJsb2NrVGFnID0gZ2V0TnVtYmVyKGJsb2NrVGFnLCBcImJsb2NrVGFnXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKGJsb2NrVGFnID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9RdWFudGl0eShibG9ja1RhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jbGFzdEJsb2NrTnVtYmVyID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9RdWFudGl0eSh0aGlzLiNsYXN0QmxvY2tOdW1iZXIgKyBibG9ja1RhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCbG9ja051bWJlcigpLnRoZW4oKGIpID0+IHRvUXVhbnRpdHkoYiArIGJsb2NrVGFnKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBibG9ja1RhZ1wiLCBcImJsb2NrVGFnXCIsIGJsb2NrVGFnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb2x2ZXMgdG8gYSBmaWx0ZXIgZm9yICUlZmlsdGVyJSUsIHJlc29sdmluZyBhbnkgRU5TXG4gICAgICogIG5hbWVzIG9yIFtbQWRkcmVzc2FibGVdXSBvYmplY3QgYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGEgdmFsaWRcbiAgICAgKiAgZmlsdGVyLlxuICAgICAqL1xuICAgIF9nZXRGaWx0ZXIoZmlsdGVyKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIGNhbm9uaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdG9waWNzXG4gICAgICAgIGNvbnN0IHRvcGljcyA9IChmaWx0ZXIudG9waWNzIHx8IFtdKS5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNpc2lmeSh0Lm1hcCgodCkgPT4gdC50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYmxvY2tIYXNoID0gKFwiYmxvY2tIYXNoXCIgaW4gZmlsdGVyKSA/IGZpbHRlci5ibG9ja0hhc2ggOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHJlc29sdmUgPSAoX2FkZHJlc3MsIGZyb21CbG9jaywgdG9CbG9jaykgPT4ge1xuICAgICAgICAgICAgbGV0IGFkZHJlc3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hZGRyZXNzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2FkZHJlc3NbMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIF9hZGRyZXNzLnNvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrSGFzaCkge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQmxvY2sgIT0gbnVsbCB8fCB0b0Jsb2NrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmaWx0ZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsdGVyID0ge307XG4gICAgICAgICAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIGZpbHRlci5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3BpY3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IHRvcGljcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcm9tQmxvY2spIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gZnJvbUJsb2NrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvQmxvY2spIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudG9CbG9jayA9IHRvQmxvY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmxvY2tIYXNoKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmJsb2NrSGFzaCA9IGJsb2NrSGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEFkZHJlc3NlcyBjb3VsZCBiZSBhc3luYyAoRU5TIG5hbWVzIG9yIEFkZHJlc3NhYmxlcylcbiAgICAgICAgbGV0IGFkZHJlc3MgPSBbXTtcbiAgICAgICAgaWYgKGZpbHRlci5hZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFkZHIgb2YgZmlsdGVyLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5wdXNoKHRoaXMuX2dldEFkZHJlc3MoYWRkcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZHJlc3MucHVzaCh0aGlzLl9nZXRBZGRyZXNzKGZpbHRlci5hZGRyZXNzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZyb21CbG9jayA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKFwiZnJvbUJsb2NrXCIgaW4gZmlsdGVyKSB7XG4gICAgICAgICAgICBmcm9tQmxvY2sgPSB0aGlzLl9nZXRCbG9ja1RhZyhmaWx0ZXIuZnJvbUJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9CbG9jayA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKFwidG9CbG9ja1wiIGluIGZpbHRlcikge1xuICAgICAgICAgICAgdG9CbG9jayA9IHRoaXMuX2dldEJsb2NrVGFnKGZpbHRlci50b0Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkcmVzcy5maWx0ZXIoKGEpID0+ICh0eXBlb2YgKGEpICE9PSBcInN0cmluZ1wiKSkubGVuZ3RoIHx8XG4gICAgICAgICAgICAoZnJvbUJsb2NrICE9IG51bGwgJiYgdHlwZW9mIChmcm9tQmxvY2spICE9PSBcInN0cmluZ1wiKSB8fFxuICAgICAgICAgICAgKHRvQmxvY2sgIT0gbnVsbCAmJiB0eXBlb2YgKHRvQmxvY2spICE9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtQcm9taXNlLmFsbChhZGRyZXNzKSwgZnJvbUJsb2NrLCB0b0Jsb2NrXSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0WzBdLCByZXN1bHRbMV0sIHJlc3VsdFsyXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShhZGRyZXNzLCBmcm9tQmxvY2ssIHRvQmxvY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBvciByZXNvdmxlcyB0byBhIHRyYW5zYWN0aW9uIGZvciAlJXJlcXVlc3QlJSwgcmVzb2x2aW5nXG4gICAgICogIGFueSBFTlMgbmFtZXMgb3IgW1tBZGRyZXNzYWJsZV1dIGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhIHZhbGlkXG4gICAgICogIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIF9nZXRUcmFuc2FjdGlvblJlcXVlc3QoX3JlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGNvcHlSZXF1ZXN0KF9yZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgW1widG9cIiwgXCJmcm9tXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Rba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWRkciA9IHJlc29sdmVBZGRyZXNzKHJlcXVlc3Rba2V5XSwgdGhpcyk7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKGFkZHIpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyByZXF1ZXN0W2tleV0gPSBhd2FpdCBhZGRyOyB9KSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Rba2V5XSA9IGFkZHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVxdWVzdC5ibG9ja1RhZyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKHJlcXVlc3QuYmxvY2tUYWcpO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShibG9ja1RhZykpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyBmdW5jdGlvbiAoKSB7IHJlcXVlc3QuYmxvY2tUYWcgPSBhd2FpdCBibG9ja1RhZzsgfSkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmJsb2NrVGFnID0gYmxvY2tUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIChhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TmV0d29yaygpIHtcbiAgICAgICAgLy8gTm8gZXhwbGljaXQgbmV0d29yayB3YXMgc2V0IGFuZCB0aGlzIGlzIG91ciBmaXJzdCB0aW1lXG4gICAgICAgIGlmICh0aGlzLiNuZXR3b3JrUHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBEZXRlY3QgdGhlIGN1cnJlbnQgbmV0d29yayAoc2hhcmVkIHdpdGggYWxsIGNhbGxzKVxuICAgICAgICAgICAgY29uc3QgZGV0ZWN0TmV0d29yayA9IHRoaXMuX2RldGVjdE5ldHdvcmsoKS50aGVuKChuZXR3b3JrKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBuZXR3b3JrUHJvbWlzZSBvbiBmYWlsdXJlLCBzbyB3ZSB3aWxsIHRyeSBhZ2FpblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrUHJvbWlzZSA9PT0gZGV0ZWN0TmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IGRldGVjdE5ldHdvcms7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IGRldGVjdE5ldHdvcmspLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29ya1Byb21pc2UgPSB0aGlzLiNuZXR3b3JrUHJvbWlzZTtcbiAgICAgICAgY29uc3QgW2V4cGVjdGVkLCBhY3R1YWxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgbmV0d29ya1Byb21pc2UsXG4gICAgICAgICAgICB0aGlzLl9kZXRlY3ROZXR3b3JrKCkgLy8gVGhlIGFjdHVhbCBjb25uZWN0ZWQgbmV0d29ya1xuICAgICAgICBdKTtcbiAgICAgICAgaWYgKGV4cGVjdGVkLmNoYWluSWQgIT09IGFjdHVhbC5jaGFpbklkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYW55TmV0d29yaykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBcImFueVwiIG5ldHdvcmsgY2FuIGNoYW5nZSwgc28gbm90aWZ5IGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgYWN0dWFsLCBleHBlY3RlZCk7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBuZXR3b3JrIGlmIHNvbWV0aGluZyBlbHNlIGhhc24ndCBhbHJlYWR5IGNoYW5nZWQgaXRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT09IG5ldHdvcmtQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGFjdHVhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBkbyBub3QgYWxsb3cgY2hhbmdlcyB0byB0aGUgdW5kZXJseWluZyBuZXR3b3JrXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgbmV0d29yayBjaGFuZ2VkOiAke2V4cGVjdGVkLmNoYWluSWR9ID0+ICR7YWN0dWFsLmNoYWluSWR9IGAsIFwiTkVUV09SS19FUlJPUlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImNoYW5nZWRcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBlY3RlZC5jbG9uZSgpO1xuICAgIH1cbiAgICBhc3luYyBnZXRGZWVEYXRhKCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgIGNvbnN0IGdldEZlZURhdGFGdW5jID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBfYmxvY2ssIGdhc1ByaWNlLCBwcmlvcml0eUZlZSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIF9ibG9jazogdGhpcy4jZ2V0QmxvY2soXCJsYXRlc3RcIiwgZmFsc2UpLFxuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiAoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRHYXNQcmljZVwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSwgXCIlcmVzcG9uc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSkoKSksXG4gICAgICAgICAgICAgICAgcHJpb3JpdHlGZWU6ICgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFByaW9yaXR5RmVlXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QmlnSW50KHZhbHVlLCBcIiVyZXNwb25zZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSgpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgbWF4RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIHJlY29tbWVuZGVkIEVJUC0xNTU5IGhldXJpc3RpY3MgZm9yIGZlZSBkYXRhXG4gICAgICAgICAgICBjb25zdCBibG9jayA9IHRoaXMuX3dyYXBCbG9jayhfYmxvY2ssIG5ldHdvcmspO1xuICAgICAgICAgICAgaWYgKGJsb2NrICYmIGJsb2NrLmJhc2VGZWVQZXJHYXMpIHtcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IChwcmlvcml0eUZlZSAhPSBudWxsKSA/IHByaW9yaXR5RmVlIDogQmlnSW50KFwiMTAwMDAwMDAwMFwiKTtcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMgPSAoYmxvY2suYmFzZUZlZVBlckdhcyAqIEJOXzIpICsgbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZlZURhdGEoZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBDaGVjayBmb3IgYSBGZWVEYXRhTmV0V29ya1BsdWdpblxuICAgICAgICBjb25zdCBwbHVnaW4gPSBuZXR3b3JrLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkZldGNoVXJsRmVlRGF0YVBsdWdpblwiKTtcbiAgICAgICAgaWYgKHBsdWdpbikge1xuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IEZldGNoUmVxdWVzdChwbHVnaW4udXJsKTtcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwbHVnaW4ucHJvY2Vzc0Z1bmMoZ2V0RmVlRGF0YUZ1bmMsIHRoaXMsIHJlcSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZlZURhdGEoZmVlRGF0YS5nYXNQcmljZSwgZmVlRGF0YS5tYXhGZWVQZXJHYXMsIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBnZXRGZWVEYXRhRnVuYygpO1xuICAgIH1cbiAgICBhc3luYyBlc3RpbWF0ZUdhcyhfdHgpIHtcbiAgICAgICAgbGV0IHR4ID0gdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KF90eCk7XG4gICAgICAgIGlmIChpc1Byb21pc2UodHgpKSB7XG4gICAgICAgICAgICB0eCA9IGF3YWl0IHR4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRCaWdJbnQoYXdhaXQgdGhpcy4jcGVyZm9ybSh7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZXN0aW1hdGVHYXNcIiwgdHJhbnNhY3Rpb246IHR4XG4gICAgICAgIH0pLCBcIiVyZXNwb25zZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgI2NhbGwodHgsIGJsb2NrVGFnLCBhdHRlbXB0KSB7XG4gICAgICAgIGFzc2VydChhdHRlbXB0IDwgTUFYX0NDSVBfUkVESVJFQ1RTLCBcIkNDSVAgcmVhZCBleGNlZWRlZCBtYXhpbXVtIHJlZGlyZWN0aW9uc1wiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJUT09fTUFOWV9SRURJUkVDVFNcIixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCwgeyBibG9ja1RhZywgZW5hYmxlQ2NpcFJlYWQ6IHRydWUgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoaXMgY2FtZSBpbiBhcyBhIFBlcmZvcm1BY3Rpb25UcmFuc2FjdGlvbiwgc28gdG8vZnJvbSBhcmUgc2FmZTsgd2UgY2FuIGNhc3RcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBjb3B5UmVxdWVzdCh0eCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4bGlmeShhd2FpdCB0aGlzLl9wZXJmb3JtKHsgbWV0aG9kOiBcImNhbGxcIiwgdHJhbnNhY3Rpb24sIGJsb2NrVGFnIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIENDSVAgUmVhZCBPZmZjaGFpbkxvb2t1cFxuICAgICAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVDY2lwUmVhZCAmJiBpc0NhbGxFeGNlcHRpb24oZXJyb3IpICYmIGVycm9yLmRhdGEgJiYgYXR0ZW1wdCA+PSAwICYmIGJsb2NrVGFnID09PSBcImxhdGVzdFwiICYmIHRyYW5zYWN0aW9uLnRvICE9IG51bGwgJiYgZGF0YVNsaWNlKGVycm9yLmRhdGEsIDAsIDQpID09PSBcIjB4NTU2ZjE4MzBcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlcnJvci5kYXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4U2VuZGVyID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3ModHJhbnNhY3Rpb24udG8sIHRoaXMpO1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBDQ0lQIFJlYWQgQXJndW1lbnRzXG4gICAgICAgICAgICAgICAgbGV0IGNjaXBBcmdzO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNjaXBBcmdzID0gcGFyc2VPZmZjaGFpbkxvb2t1cChkYXRhU2xpY2UoZXJyb3IuZGF0YSwgNCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBlcnJvci5tZXNzYWdlLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJCQURfREFUQVwiLCB0cmFuc2FjdGlvbiwgaW5mbzogeyBkYXRhIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBzZW5kZXIgb2YgdGhlIE9mZmNoYWluTG9va3VwIG1hdGNoZXMgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNjaXBBcmdzLnNlbmRlci50b0xvd2VyQ2FzZSgpID09PSB0eFNlbmRlci50b0xvd2VyQ2FzZSgpLCBcIkNDSVAgUmVhZCBzZW5kZXIgbWlzbWF0Y2hcIiwgXCJDQUxMX0VYQ0VQVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJjYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGludm9jYXRpb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJldmVydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIk9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogY2NpcEFyZ3MuZXJyb3JBcmdzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjY2lwUmVzdWx0ID0gYXdhaXQgdGhpcy5jY2lwUmVhZEZldGNoKHRyYW5zYWN0aW9uLCBjY2lwQXJncy5jYWxsZGF0YSwgY2NpcEFyZ3MudXJscyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNjaXBSZXN1bHQgIT0gbnVsbCwgXCJDQ0lQIFJlYWQgZmFpbGVkIHRvIGZldGNoIGRhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJGRVRDSF9GQUlMRURcIiwgdHJhbnNhY3Rpb24sIGluZm86IHsgZGF0YTogZXJyb3IuZGF0YSwgZXJyb3JBcmdzOiBjY2lwQXJncy5lcnJvckFyZ3MgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICAgICAgICAgICAgICB0bzogdHhTZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNvbmNhdChbY2NpcEFyZ3Muc2VsZWN0b3IsIGVuY29kZUJ5dGVzKFtjY2lwUmVzdWx0LCBjY2lwQXJncy5leHRyYURhdGFdKV0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kQ2NpcFJlYWRDYWxsXCIsIHRyYW5zYWN0aW9uOiB0eCB9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjYWxsKHR4LCBibG9ja1RhZywgYXR0ZW1wdCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRDYWxsUmVzdWx0XCIsIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCksIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZENhbGxFcnJvclwiLCB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgdHgpLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI2NoZWNrTmV0d29yayhwcm9taXNlKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgdmFsdWU6IHByb21pc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbChfdHgpIHtcbiAgICAgICAgY29uc3QgeyB0eCwgYmxvY2tUYWcgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIHR4OiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QoX3R4KSxcbiAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhfdHguYmxvY2tUYWcpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2hlY2tOZXR3b3JrKHRoaXMuI2NhbGwodHgsIGJsb2NrVGFnLCBfdHguZW5hYmxlQ2NpcFJlYWQgPyAwIDogLTEpKTtcbiAgICB9XG4gICAgLy8gQWNjb3VudFxuICAgIGFzeW5jICNnZXRBY2NvdW50VmFsdWUocmVxdWVzdCwgX2FkZHJlc3MsIF9ibG9ja1RhZykge1xuICAgICAgICBsZXQgYWRkcmVzcyA9IHRoaXMuX2dldEFkZHJlc3MoX2FkZHJlc3MpO1xuICAgICAgICBsZXQgYmxvY2tUYWcgPSB0aGlzLl9nZXRCbG9ja1RhZyhfYmxvY2tUYWcpO1xuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzKSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgKGJsb2NrVGFnKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgW2FkZHJlc3MsIGJsb2NrVGFnXSA9IGF3YWl0IFByb21pc2UuYWxsKFthZGRyZXNzLCBibG9ja1RhZ10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjaGVja05ldHdvcmsodGhpcy4jcGVyZm9ybShPYmplY3QuYXNzaWduKHJlcXVlc3QsIHsgYWRkcmVzcywgYmxvY2tUYWcgfSkpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QmFsYW5jZShhZGRyZXNzLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gZ2V0QmlnSW50KGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRCYWxhbmNlXCIgfSwgYWRkcmVzcywgYmxvY2tUYWcpLCBcIiVyZXNwb25zZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25Db3VudChhZGRyZXNzLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gZ2V0TnVtYmVyKGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIgfSwgYWRkcmVzcywgYmxvY2tUYWcpLCBcIiVyZXNwb25zZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q29kZShhZGRyZXNzLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gaGV4bGlmeShhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0Q29kZVwiIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFN0b3JhZ2UoYWRkcmVzcywgX3Bvc2l0aW9uLCBibG9ja1RhZykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldEJpZ0ludChfcG9zaXRpb24sIFwicG9zaXRpb25cIik7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRTdG9yYWdlXCIsIHBvc2l0aW9uIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSk7XG4gICAgfVxuICAgIC8vIFdyaXRlXG4gICAgYXN5bmMgYnJvYWRjYXN0VHJhbnNhY3Rpb24oc2lnbmVkVHgpIHtcbiAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgaGFzaCwgbmV0d29yayB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKSxcbiAgICAgICAgICAgIGhhc2g6IHRoaXMuX3BlcmZvcm0oe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIHNpZ25lZFRyYW5zYWN0aW9uOiBzaWduZWRUeFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHggPSBUcmFuc2FjdGlvbi5mcm9tKHNpZ25lZFR4KTtcbiAgICAgICAgaWYgKHR4Lmhhc2ggIT09IGhhc2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPOiB0aGUgcmV0dXJuZWQgaGFzaCBkaWQgbm90IG1hdGNoXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb25SZXNwb25zZSh0eCwgbmV0d29yaykucmVwbGFjZWFibGVUcmFuc2FjdGlvbihibG9ja051bWJlcik7XG4gICAgfVxuICAgIGFzeW5jICNnZXRCbG9jayhibG9jaywgaW5jbHVkZVRyYW5zYWN0aW9ucykge1xuICAgICAgICAvLyBAVE9ETzogQWRkIEN1c3RvbUJsb2NrUGx1Z2luIGNoZWNrXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhibG9jaywgMzIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVyZm9ybSh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldEJsb2NrXCIsIGJsb2NrSGFzaDogYmxvY2ssIGluY2x1ZGVUcmFuc2FjdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9IGF3YWl0IGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZXJmb3JtKHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRCbG9ja1wiLCBibG9ja1RhZywgaW5jbHVkZVRyYW5zYWN0aW9uc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUXVlcmllc1xuICAgIGFzeW5jIGdldEJsb2NrKGJsb2NrLCBwcmVmZXRjaFR4cykge1xuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuI2dldEJsb2NrKGJsb2NrLCAhIXByZWZldGNoVHhzKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcEJsb2NrKHBhcmFtcywgbmV0d29yayk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKGhhc2gpIHtcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uXCIsIGhhc2ggfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlKHBhcmFtcywgbmV0d29yayk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKSB7XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgaGFzaCB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIGJhY2tlbmRzIGRpZCBub3QgYmFja2ZpbGwgdGhlIGVmZmVjdGl2ZUdhc1ByaWNlIGludG8gb2xkIHRyYW5zYWN0aW9uc1xuICAgICAgICAvLyBpbiB0aGUgcmVjZWlwdCwgc28gd2UgbG9vayBpdCB1cCBtYW51YWxseSBhbmQgaW5qZWN0IGl0LlxuICAgICAgICBpZiAocGFyYW1zLmdhc1ByaWNlID09IG51bGwgJiYgcGFyYW1zLmVmZmVjdGl2ZUdhc1ByaWNlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblwiLCBoYXNoIH0pO1xuICAgICAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXBvcnQgdGhpczsgY291bGQgbm90IGZpbmQgdHggb3IgZWZmZWN0aXZlR2FzUHJpY2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXMuZWZmZWN0aXZlR2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVjZWlwdChwYXJhbXMsIG5ldHdvcmspO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlc3VsdChoYXNoKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHJlc3VsdDogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblJlc3VsdFwiLCBoYXNoIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG4gICAgfVxuICAgIC8vIEJsb29tLWZpbHRlciBRdWVyaWVzXG4gICAgYXN5bmMgZ2V0TG9ncyhfZmlsdGVyKSB7XG4gICAgICAgIGxldCBmaWx0ZXIgPSB0aGlzLl9nZXRGaWx0ZXIoX2ZpbHRlcik7XG4gICAgICAgIGlmIChpc1Byb21pc2UoZmlsdGVyKSkge1xuICAgICAgICAgICAgZmlsdGVyID0gYXdhaXQgZmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRMb2dzXCIsIGZpbHRlciB9KVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5tYXAoKHApID0+IHRoaXMuX3dyYXBMb2cocCwgbmV0d29yaykpO1xuICAgIH1cbiAgICAvLyBFTlNcbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwicHJvdmlkZXIgY2Fubm90IGNvbm5lY3QgdG8gdGFyZ2V0IG5ldHdvcmtcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIl9nZXRQcm92aWRlcigpXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlc29sdmVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IEVuc1Jlc29sdmVyLmZyb21OYW1lKHRoaXMsIG5hbWUpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBdmF0YXIobmFtZSkge1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSk7XG4gICAgICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVyLmdldEF2YXRhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gYXdhaXQgdGhpcy5nZXRSZXNvbHZlcihuYW1lKTtcbiAgICAgICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZXIuZ2V0QWRkcmVzcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBsb29rdXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuYW1laGFzaChhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZW5zQWRkciA9IGF3YWl0IEVuc1Jlc29sdmVyLmdldEVuc0FkZHJlc3ModGhpcyk7XG4gICAgICAgICAgICBjb25zdCBlbnNDb250cmFjdCA9IG5ldyBDb250cmFjdChlbnNBZGRyLCBbXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbiByZXNvbHZlcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCJcbiAgICAgICAgICAgIF0sIHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBhd2FpdCBlbnNDb250cmFjdC5yZXNvbHZlcihub2RlKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlciA9PSBudWxsIHx8IHJlc29sdmVyID09PSBaZXJvQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXJDb250cmFjdCA9IG5ldyBDb250cmFjdChyZXNvbHZlciwgW1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gbmFtZShieXRlczMyKSB2aWV3IHJldHVybnMgKHN0cmluZylcIlxuICAgICAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gYXdhaXQgcmVzb2x2ZXJDb250cmFjdC5uYW1lKG5vZGUpO1xuICAgICAgICAgICAgLy8gRmFpbGVkIGZvcndhcmQgcmVzb2x1dGlvblxuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSBhd2FpdCB0aGlzLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGNoZWNrICE9PSBhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIE5vIGRhdGEgd2FzIHJldHVybmVkIGZyb20gdGhlIHJlc29sdmVyXG4gICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJCQURfREFUQVwiKSAmJiBlcnJvci52YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgcmVlcnRlZFxuICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyB3YWl0Rm9yVHJhbnNhY3Rpb24oaGFzaCwgX2NvbmZpcm1zLCB0aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1zID0gKF9jb25maXJtcyAhPSBudWxsKSA/IF9jb25maXJtcyA6IDE7XG4gICAgICAgIGlmIChjb25maXJtcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoYXN5bmMgKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyICsgMSA+PSBjb25maXJtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzLm9mZihcImJsb2NrXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRUVFXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiYmxvY2tcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2ZmKFwiYmxvY2tcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwidGltZW91dFwiLCBcIlRJTUVPVVRcIiwgeyByZWFzb246IFwidGltZW91dFwiIH0pKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVyKGF3YWl0IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB3YWl0Rm9yQmxvY2soYmxvY2tUYWcpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIiwgXCJOT1RfSU1QTEVNRU5URURcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIndhaXRGb3JCbG9ja1wiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2xlYXIgYSB0aW1lciBjcmVhdGVkIHVzaW5nIHRoZSBbW19zZXRUaW1lb3V0XV0gbWV0aG9kLlxuICAgICAqL1xuICAgIF9jbGVhclRpbWVvdXQodGltZXJJZCkge1xuICAgICAgICBjb25zdCB0aW1lciA9IHRoaXMuI3RpbWVycy5nZXQodGltZXJJZCk7XG4gICAgICAgIGlmICghdGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXIudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lci50aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jdGltZXJzLmRlbGV0ZSh0aW1lcklkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIHRpbWVyIHRoYXQgd2lsbCBleGVjdXRlICUlZnVuYyUlIGFmdGVyIGF0IGxlYXN0ICUldGltZW91dCUlXG4gICAgICogIChpbiBtcykuIElmICUldGltZW91dCUlIGlzIHVuc3BlY2lmaWVkLCB0aGVuICUlZnVuYyUlIHdpbGwgZXhlY3V0ZVxuICAgICAqICBpbiB0aGUgbmV4dCBldmVudCBsb29wLlxuICAgICAqXG4gICAgICogIFtQYXVzaW5nXShBYnN0cmFjdFByb3ZpZGVyLXBhdXNlZCkgdGhlIHByb3ZpZGVyIHdpbGwgcGF1c2UgYW55XG4gICAgICogIGFzc29jaWF0ZWQgdGltZXJzLlxuICAgICAqL1xuICAgIF9zZXRUaW1lb3V0KF9mdW5jLCB0aW1lb3V0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVySWQgPSB0aGlzLiNuZXh0VGltZXIrKztcbiAgICAgICAgY29uc3QgZnVuYyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5kZWxldGUodGltZXJJZCk7XG4gICAgICAgICAgICBfZnVuYygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5zZXQodGltZXJJZCwgeyB0aW1lcjogbnVsbCwgZnVuYywgdGltZTogdGltZW91dCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dChmdW5jLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5zZXQodGltZXJJZCwgeyB0aW1lciwgZnVuYywgdGltZTogZ2V0VGltZSgpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1lcklkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGVyZm9ybSAlJWZ1bmMlJSBvbiBlYWNoIHN1YnNjcmliZXIuXG4gICAgICovXG4gICAgX2ZvckVhY2hTdWJzY3JpYmVyKGZ1bmMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZnVuYyhzdWIuc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIGN1c3RvbWl6ZSBzdWJzY3JpcHRpb25cbiAgICAgKiAgaW1wbGVtZW50YXRpb25zLlxuICAgICAqL1xuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xuICAgICAgICBzd2l0Y2ggKHN1Yi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY2FzZSBcIm5ldHdvcmtcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVubWFuYWdlZFN1YnNjcmliZXIoc3ViLnR5cGUpO1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gbmV3IFBvbGxpbmdCbG9ja1N1YnNjcmliZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5wb2xsaW5nSW50ZXJ2YWwgPSB0aGlzLnBvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzYWZlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmluYWxpemVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyKHRoaXMsIHN1Yi50eXBlKTtcbiAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ0V2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcih0aGlzLCBzdWIuaGFzaCk7XG4gICAgICAgICAgICBjYXNlIFwib3JwaGFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nT3JwaGFuU3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV2ZW50OiAke3N1Yi50eXBlfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgYSBbW1N1YnNjcmliZXJdXSBmYWlscyBhbmQgbmVlZHMgdG8gcmVwbGFjZSBpdHNlbGYsIHRoaXNcbiAgICAgKiAgbWV0aG9kIG1heSBiZSB1c2VkLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCB0aGlzIGlzIHVzZWQgZm9yIHByb3ZpZGVycyB3aGVuIHVzaW5nIHRoZVxuICAgICAqICBgYGV0aF9nZXRGaWx0ZXJDaGFuZ2VzYGAgbWV0aG9kLCB3aGljaCBjYW4gcmV0dXJuIG51bGwgaWYgc3RhdGVcbiAgICAgKiAgZmlsdGVycyBhcmUgbm90IHN1cHBvcnRlZCBieSB0aGUgYmFja2VuZCwgYWxsb3dpbmcgdGhlIFN1YnNjcmliZXJcbiAgICAgKiAgdG8gc3dhcCBpbiBhIFtbUG9sbGluZ0V2ZW50U3Vic2NyaWJlcl1dLlxuICAgICAqL1xuICAgIF9yZWNvdmVyU3Vic2NyaWJlcihvbGRTdWIsIG5ld1N1Yikge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnN1YnNjcmliZXIgPT09IG9sZFN1Yikge1xuICAgICAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyID0gbmV3U3ViO1xuICAgICAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdWIuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3ViLnBhdXNlKHRoaXMuI3BhdXNlZFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI2hhc1N1YihldmVudCwgZW1pdEFyZ3MpIHtcbiAgICAgICAgbGV0IHN1YiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbihldmVudCwgdGhpcyk7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBsb2cgdGhhdCBpcyByZW1vdmluZyBhbiBleGlzdGluZyBsb2c7IHdlIGFjdHVhbGx5IHdhbnRcbiAgICAgICAgLy8gdG8gZW1pdCBhbiBvcnBoYW4gZXZlbnQgZm9yIHRoZSByZW1vdmVkIGxvZ1xuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwiZXZlbnRcIiAmJiBlbWl0QXJncyAmJiBlbWl0QXJncy5sZW5ndGggPiAwICYmIGVtaXRBcmdzWzBdLnJlbW92ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN1YiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbih7IG9ycGhhbjogXCJkcm9wLWxvZ1wiLCBsb2c6IGVtaXRBcmdzWzBdIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNzdWJzLmdldChzdWIudGFnKSB8fCBudWxsO1xuICAgIH1cbiAgICBhc3luYyAjZ2V0U3ViKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbihldmVudCwgdGhpcyk7XG4gICAgICAgIC8vIFByZXZlbnQgdGFtcGVyaW5nIHdpdGggb3VyIHRhZyBpbiBhbnkgc3ViY2xhc3MnIF9nZXRTdWJzY3JpYmVyXG4gICAgICAgIGNvbnN0IHRhZyA9IHN1YnNjcmlwdGlvbi50YWc7XG4gICAgICAgIGxldCBzdWIgPSB0aGlzLiNzdWJzLmdldCh0YWcpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHRoaXMuX2dldFN1YnNjcmliZXIoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NhYmxlTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBzdWIgPSB7IHN1YnNjcmliZXIsIHRhZywgYWRkcmVzc2FibGVNYXAsIG5hbWVNYXAsIHN0YXJ0ZWQ6IGZhbHNlLCBsaXN0ZW5lcnM6IFtdIH07XG4gICAgICAgICAgICB0aGlzLiNzdWJzLnNldCh0YWcsIHN1Yik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9XG4gICAgYXN5bmMgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2dldFN1YihldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiBmYWxzZSB9KTtcbiAgICAgICAgaWYgKCFzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIHN1Yi5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIucGF1c2UodGhpcy4jcGF1c2VkU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNnZXRTdWIoZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKCFzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIHN1Yi5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIucGF1c2UodGhpcy4jcGF1c2VkU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCwgYXJncyk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdCBzdWJzY3JpcHRpb24gb3IgaWYgYSByZWNlbnQgZW1pdCByZW1vdmVkXG4gICAgICAgIC8vIHRoZSBsYXN0IG9mIHRoZW0gKHdoaWNoIGFsc28gZGVsZXRlZCB0aGUgc3ViKSBkbyBub3RoaW5nXG4gICAgICAgIGlmICghc3ViIHx8IHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBjb25zdCBjb3VudCA9IHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICBzdWIubGlzdGVuZXJzID0gc3ViLmxpc3RlbmVycy5maWx0ZXIoKHsgbGlzdGVuZXIsIG9uY2UgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IG5ldyBFdmVudFBheWxvYWQodGhpcywgKG9uY2UgPyBudWxsIDogbGlzdGVuZXIpLCBldmVudCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgLi4uYXJncywgcGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuICFvbmNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNvdW50ID4gMCk7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgdG90YWwgKz0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChsaXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc3ViLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbGlzdGVuZXIgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRhZywgc3RhcnRlZCwgc3Vic2NyaWJlciB9ID0gYXdhaXQgdGhpcy4jZ2V0U3ViKGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbdGFnLCB7IHN0YXJ0ZWQsIHN1YnNjcmliZXIgfV0gb2YgdGhpcy4jc3Vicykge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBBbGlhcyBmb3IgXCJvblwiXG4gICAgYXN5bmMgYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8vIEFsaWFzIGZvciBcIm9mZlwiXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdGhpcyBwcm92aWRlciBoYXMgYmVlbiBkZXN0cm95ZWQgdXNpbmcgdGhlIFtbZGVzdHJveV1dIG1ldGhvZC5cbiAgICAgKlxuICAgICAqICBPbmNlIGRlc3Ryb3llZCwgYWxsIHJlc291cmNlcyBhcmUgcmVjbGFpbWVkLCBpbnRlcm5hbCBldmVudCBsb29wc1xuICAgICAqICBhbmQgdGltZXJzIGFyZSBjbGVhbmVkIHVwIGFuZCBubyBmdXJ0aGVyIHJlcXVlc3RzIG1heSBiZSBzZW50IHRvXG4gICAgICogIHRoZSBwcm92aWRlci5cbiAgICAgKi9cbiAgICBnZXQgZGVzdHJveWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGVzdHJveWVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IHVzZSB0aGlzIHRvIHNodXRkb3duIGFueSBzb2NrZXRzIG9yIHJlbGVhc2UgdGhlaXJcbiAgICAgKiAgcmVzb3VyY2VzIGFuZCByZWplY3QgYW55IHBlbmRpbmcgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0KiogY2FsbCBgYHN1cGVyLmRlc3Ryb3koKWBgLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIFN0b3AgYWxsIGxpc3RlbmVyc1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAvLyBTaHV0IGRvd24gYWxsIHRpZW1yc1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVySWQgb2YgdGhpcy4jdGltZXJzLmtleXMoKSkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXaGV0aGVyIHRoZSBwcm92aWRlciBpcyBjdXJyZW50bHkgcGF1c2VkLlxuICAgICAqXG4gICAgICogIEEgcGF1c2VkIHByb3ZpZGVyIHdpbGwgbm90IGVtaXQgYW55IGV2ZW50cywgYW5kIGdlbmVyYWxseSBzaG91bGRcbiAgICAgKiAgbm90IG1ha2UgYW55IHJlcXVlc3RzIHRvIHRoZSBuZXR3b3JrLCBidXQgdGhhdCBpcyB1cCB0byBzdWItY2xhc3Nlc1xuICAgICAqICB0byBtYW5hZ2UuXG4gICAgICpcbiAgICAgKiAgU2V0dGluZyBgYHBhdXNlZCA9IHRydWVgYCBpcyBpZGVudGljYWwgdG8gY2FsbGluZyBgYC5wYXVzZShmYWxzZSlgYCxcbiAgICAgKiAgd2hpY2ggd2lsbCBidWZmZXIgYW55IGV2ZW50cyB0aGF0IG9jY3VyIHdoaWxlIHBhdXNlZCB1bnRpbCB0aGVcbiAgICAgKiAgcHJvdmlkZXIgaXMgdW5wYXVzZWQuXG4gICAgICovXG4gICAgZ2V0IHBhdXNlZCgpIHsgcmV0dXJuICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKTsgfVxuICAgIHNldCBwYXVzZWQocGF1c2UpIHtcbiAgICAgICAgaWYgKCEhcGF1c2UgPT09IHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXVzZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhdXNlIHRoZSBwcm92aWRlci4gSWYgJSVkcm9wV2hpbGVQYXVzZWQlJSwgYW55IGV2ZW50cyB0aGF0IG9jY3VyXG4gICAgICogIHdoaWxlIHBhdXNlZCBhcmUgZHJvcHBlZCwgb3RoZXJ3aXNlIGFsbCBldmVudHMgd2lsbCBiZSBlbWl0dGVkIG9uY2VcbiAgICAgKiAgdGhlIHByb3ZpZGVyIGlzIHVucGF1c2VkLlxuICAgICAqL1xuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSA9PSAhIWRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJjYW5ub3QgY2hhbmdlIHBhdXNlIHR5cGU7IHJlc3VtZSBmaXJzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInBhdXNlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzKSA9PiBzLnBhdXNlKGRyb3BXaGlsZVBhdXNlZCkpO1xuICAgICAgICB0aGlzLiNwYXVzZWRTdGF0ZSA9ICEhZHJvcFdoaWxlUGF1c2VkO1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVyIG9mIHRoaXMuI3RpbWVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIHRpbWVyXG4gICAgICAgICAgICBpZiAodGltZXIudGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIudGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtYWluaW5nIHRpbWUgbmVlZGVkIGZvciB3aGVuIHdlIGJlY29tZSB1bnBhdXNlZFxuICAgICAgICAgICAgdGltZXIudGltZSA9IGdldFRpbWUoKSAtIHRpbWVyLnRpbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc3VtZSB0aGUgcHJvdmlkZXIuXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzKSA9PiBzLnJlc3VtZSgpKTtcbiAgICAgICAgdGhpcy4jcGF1c2VkU3RhdGUgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVyIG9mIHRoaXMuI3RpbWVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgLy8gUmVtYWluaW5nIHRpbWUgd2hlbiB3ZSB3ZXJlIHBhdXNlZFxuICAgICAgICAgICAgbGV0IHRpbWVvdXQgPSB0aW1lci50aW1lO1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGFydCB0aW1lIChpbiBjYXVzZSBwYXVzZWQsIHNvIHdlIGNvbiBjb21wdXRlIHJlbWFpbmluZiB0aW1lKVxuICAgICAgICAgICAgdGltZXIudGltZSA9IGdldFRpbWUoKTtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lclxuICAgICAgICAgICAgc2V0VGltZW91dCh0aW1lci5mdW5jLCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIF9wYXJzZVN0cmluZyhyZXN1bHQsIHN0YXJ0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBfcGFyc2VCeXRlcyhyZXN1bHQsIHN0YXJ0KTtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9VdGY4U3RyaW5nKGJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gX3BhcnNlQnl0ZXMocmVzdWx0LCBzdGFydCkge1xuICAgIGlmIChyZXN1bHQgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZ2V0TnVtYmVyKGRhdGFTbGljZShyZXN1bHQsIHN0YXJ0LCBzdGFydCArIDMyKSk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGdldE51bWJlcihkYXRhU2xpY2UocmVzdWx0LCBvZmZzZXQsIG9mZnNldCArIDMyKSk7XG4gICAgICAgIHJldHVybiBkYXRhU2xpY2UocmVzdWx0LCBvZmZzZXQgKyAzMiwgb2Zmc2V0ICsgMzIgKyBsZW5ndGgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbnVtUGFkKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdG9CZUFycmF5KHZhbHVlKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgIHBhZGRlZC5zZXQocmVzdWx0LCAzMiAtIHJlc3VsdC5sZW5ndGgpO1xuICAgIHJldHVybiBwYWRkZWQ7XG59XG5mdW5jdGlvbiBieXRlc1BhZCh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUubGVuZ3RoICUgMzIpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKHZhbHVlLmxlbmd0aCAvIDMyKSAqIDMyKTtcbiAgICByZXN1bHQuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZW1wdHkgPSBuZXcgVWludDhBcnJheShbXSk7XG4vLyBBQkkgRW5jb2RlcyBhIHNlcmllcyBvZiAoYnl0ZXMsIGJ5dGVzLCAuLi4pXG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhkYXRhcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBieXRlQ291bnQgPSAwO1xuICAgIC8vIEFkZCBwbGFjZS1ob2xkZXJzIGZvciBwb2ludGVycyBhcyB3ZSBhZGQgaXRlbXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGVtcHR5KTtcbiAgICAgICAgYnl0ZUNvdW50ICs9IDMyO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhkYXRhc1tpXSk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYnl0ZXMgb2Zmc2V0XG4gICAgICAgIHJlc3VsdFtpXSA9IG51bVBhZChieXRlQ291bnQpO1xuICAgICAgICAvLyBUaGUgbGVuZ3RoIGFuZCBwYWRkZWQgdmFsdWUgb2YgZGF0YVxuICAgICAgICByZXN1bHQucHVzaChudW1QYWQoZGF0YS5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0LnB1c2goYnl0ZXNQYWQoZGF0YSkpO1xuICAgICAgICBieXRlQ291bnQgKz0gMzIgKyBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyAzMikgKiAzMjtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdChyZXN1bHQpO1xufVxuY29uc3QgemVyb3MgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuZnVuY3Rpb24gcGFyc2VPZmZjaGFpbkxvb2t1cChkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBzZW5kZXI6IFwiXCIsIHVybHM6IFtdLCBjYWxsZGF0YTogXCJcIiwgc2VsZWN0b3I6IFwiXCIsIGV4dHJhRGF0YTogXCJcIiwgZXJyb3JBcmdzOiBbXVxuICAgIH07XG4gICAgYXNzZXJ0KGRhdGFMZW5ndGgoZGF0YSkgPj0gNSAqIDMyLCBcImluc3VmZmljaWVudCBPZmZjaGFpbkxvb2t1cCBkYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICByZWFzb246IFwiaW5zdWZmaWNpZW50IE9mZmNoYWluTG9va3VwIGRhdGFcIlxuICAgIH0pO1xuICAgIGNvbnN0IHNlbmRlciA9IGRhdGFTbGljZShkYXRhLCAwLCAzMik7XG4gICAgYXNzZXJ0KGRhdGFTbGljZShzZW5kZXIsIDAsIDEyKSA9PT0gZGF0YVNsaWNlKHplcm9zLCAwLCAxMiksIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBzZW5kZXJcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHNlbmRlclwiXG4gICAgfSk7XG4gICAgcmVzdWx0LnNlbmRlciA9IGRhdGFTbGljZShzZW5kZXIsIDEyKTtcbiAgICAvLyBSZWFkIHRoZSBVUkxzIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJscyA9IFtdO1xuICAgICAgICBjb25zdCB1cmxzT2Zmc2V0ID0gZ2V0TnVtYmVyKGRhdGFTbGljZShkYXRhLCAzMiwgNjQpKTtcbiAgICAgICAgY29uc3QgdXJsc0xlbmd0aCA9IGdldE51bWJlcihkYXRhU2xpY2UoZGF0YSwgdXJsc09mZnNldCwgdXJsc09mZnNldCArIDMyKSk7XG4gICAgICAgIGNvbnN0IHVybHNEYXRhID0gZGF0YVNsaWNlKGRhdGEsIHVybHNPZmZzZXQgKyAzMik7XG4gICAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgdXJsc0xlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBfcGFyc2VTdHJpbmcodXJsc0RhdGEsIHUgKiAzMik7XG4gICAgICAgICAgICBpZiAodXJsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybHMucHVzaCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC51cmxzID0gdXJscztcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHVybHNcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCB1cmxzXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgQ0NJUCBjYWxsZGF0YSB0byBmb3J3YXJkXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FsbGRhdGEgPSBfcGFyc2VCeXRlcyhkYXRhLCA2NCk7XG4gICAgICAgIGlmIChjYWxsZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuY2FsbGRhdGEgPSBjYWxsZGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxkYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGRhdGFcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBjYWxsYmFja1NlbGVjdG9yIChieXRlczQpXG4gICAgYXNzZXJ0KGRhdGFTbGljZShkYXRhLCAxMDAsIDEyOCkgPT09IGRhdGFTbGljZSh6ZXJvcywgMCwgMjgpLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGJhYWNrU2VsZWN0b3JcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxiYWFja1NlbGVjdG9yXCJcbiAgICB9KTtcbiAgICByZXN1bHQuc2VsZWN0b3IgPSBkYXRhU2xpY2UoZGF0YSwgOTYsIDEwMCk7XG4gICAgLy8gR2V0IHRoZSBleHRyYSBkYXRhIHRvIHNlbmQgYmFjayB0byB0aGUgY29udHJhY3QgYXMgY29udGV4dFxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGV4dHJhRGF0YSA9IF9wYXJzZUJ5dGVzKGRhdGEsIDEyOCk7XG4gICAgICAgIGlmIChleHRyYURhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWJvcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmV4dHJhRGF0YSA9IGV4dHJhRGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGV4dHJhRGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGV4dHJhRGF0YVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXN1bHQuZXJyb3JBcmdzID0gXCJzZW5kZXIsdXJscyxjYWxsZGF0YSxzZWxlY3RvcixleHRyYURhdGFcIi5zcGxpdCgvLC8pLm1hcCgoaykgPT4gcmVzdWx0W2tdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3QtcHJvdmlkZXIuanMubWFwIiwiLyoqXG4gKiAgR2VuZXJhbGx5IHRoZSBbW1dhbGxldF1dIGFuZCBbW0pzb25ScGNTaWduZXJdXSBhbmQgdGhlaXIgc3ViLWNsYXNzZXNcbiAqICBhcmUgc3VmZmljZW50IGZvciBtb3N0IGRldmVsb3BlcnMsIGJ1dCB0aGlzIGlzIHByb3ZpZGVkIHRvXG4gKiAgZmFzY2lsaXRhdGUgbW9yZSBjb21wbGV4IFNpZ25lcnMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1zaWduZXI6IFN1YmNsYXNzaW5nIFNpZ25lciBbYWJzdHJhY3Qtc2lnbmVyXVxuICovXG5pbXBvcnQgeyByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCByZXNvbHZlUHJvcGVydGllcywgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29weVJlcXVlc3QgfSBmcm9tIFwiLi9wcm92aWRlci5qc1wiO1xuZnVuY3Rpb24gY2hlY2tQcm92aWRlcihzaWduZXIsIG9wZXJhdGlvbikge1xuICAgIGlmIChzaWduZXIucHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIHNpZ25lci5wcm92aWRlcjtcbiAgICB9XG4gICAgYXNzZXJ0KGZhbHNlLCBcIm1pc3NpbmcgcHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb24gfSk7XG59XG5hc3luYyBmdW5jdGlvbiBwb3B1bGF0ZShzaWduZXIsIHR4KSB7XG4gICAgbGV0IHBvcCA9IGNvcHlSZXF1ZXN0KHR4KTtcbiAgICBpZiAocG9wLnRvICE9IG51bGwpIHtcbiAgICAgICAgcG9wLnRvID0gcmVzb2x2ZUFkZHJlc3MocG9wLnRvLCBzaWduZXIpO1xuICAgIH1cbiAgICBpZiAocG9wLmZyb20gIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBmcm9tID0gcG9wLmZyb207XG4gICAgICAgIHBvcC5mcm9tID0gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgc2lnbmVyLmdldEFkZHJlc3MoKSxcbiAgICAgICAgICAgIHJlc29sdmVBZGRyZXNzKGZyb20sIHNpZ25lcilcbiAgICAgICAgXSkudGhlbigoW2FkZHJlc3MsIGZyb21dKSA9PiB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGZyb20udG9Mb3dlckNhc2UoKSwgXCJ0cmFuc2FjdGlvbiBmcm9tIG1pc21hdGNoXCIsIFwidHguZnJvbVwiLCBmcm9tKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBvcC5mcm9tID0gc2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHBvcCk7XG59XG4vKipcbiAqICBBbiAqKkFic3RyYWN0U2lnbmVyKiogaW5jbHVkZXMgbW9zdCBvZiB0ZWggZnVuY3Rpb25hbGl0eSByZXF1aXJlZFxuICogIHRvIGdldCBhIFtbU2lnbmVyXV0gd29ya2luZyBhcyBleHBlY3RlZCwgYnV0IHJlcXVpcmVzIGEgZmV3XG4gKiAgU2lnbmVyLXNwZWNpZmljIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbi5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFNpZ25lciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciB0aGlzIHNpZ25lciBpcyBjb25uZWN0ZWQgdG8uXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgU2lnbmVyIGNvbm5lY3RlZCB0byAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHByb3ZpZGVyOiAocHJvdmlkZXIgfHwgbnVsbCkgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldE5vbmNlKGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBjaGVja1Byb3ZpZGVyKHRoaXMsIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiKS5nZXRUcmFuc2FjdGlvbkNvdW50KGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpLCBibG9ja1RhZyk7XG4gICAgfVxuICAgIGFzeW5jIHBvcHVsYXRlQ2FsbCh0eCkge1xuICAgICAgICBjb25zdCBwb3AgPSBhd2FpdCBwb3B1bGF0ZSh0aGlzLCB0eCk7XG4gICAgICAgIHJldHVybiBwb3A7XG4gICAgfVxuICAgIGFzeW5jIHBvcHVsYXRlVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBjaGVja1Byb3ZpZGVyKHRoaXMsIFwicG9wdWxhdGVUcmFuc2FjdGlvblwiKTtcbiAgICAgICAgY29uc3QgcG9wID0gYXdhaXQgcG9wdWxhdGUodGhpcywgdHgpO1xuICAgICAgICBpZiAocG9wLm5vbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcC5ub25jZSA9IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoXCJwZW5kaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3AuZ2FzTGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcG9wLmdhc0xpbWl0ID0gYXdhaXQgdGhpcy5lc3RpbWF0ZUdhcyhwb3ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBvcHVsYXRlIHRoZSBjaGFpbiBJRFxuICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgKHRoaXMucHJvdmlkZXIpLmdldE5ldHdvcmsoKTtcbiAgICAgICAgaWYgKHBvcC5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSBnZXRCaWdJbnQocG9wLmNoYWluSWQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoY2hhaW5JZCA9PT0gbmV0d29yay5jaGFpbklkLCBcInRyYW5zYWN0aW9uIGNoYWluSWQgbWlzbWF0Y2hcIiwgXCJ0eC5jaGFpbklkXCIsIHR4LmNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9wLmNoYWluSWQgPSBuZXR3b3JrLmNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90IGFsbG93IG1peGluZyBwcmUtZWlwLTE1NTkgYW5kIGVpcC0xNTU5IHByb3BlcnRpZXNcbiAgICAgICAgY29uc3QgaGFzRWlwMTU1OSA9IChwb3AubWF4RmVlUGVyR2FzICE9IG51bGwgfHwgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpO1xuICAgICAgICBpZiAocG9wLmdhc1ByaWNlICE9IG51bGwgJiYgKHBvcC50eXBlID09PSAyIHx8IGhhc0VpcDE1NTkpKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJlaXAtMTU1OSB0cmFuc2FjdGlvbiBkbyBub3Qgc3VwcG9ydCBnYXNQcmljZVwiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocG9wLnR5cGUgPT09IDAgfHwgcG9wLnR5cGUgPT09IDEpICYmIGhhc0VpcDE1NTkpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInByZS1laXAtMTU1OSB0cmFuc2FjdGlvbiBkbyBub3Qgc3VwcG9ydCBtYXhGZWVQZXJHYXMvbWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwb3AudHlwZSA9PT0gMiB8fCBwb3AudHlwZSA9PSBudWxsKSAmJiAocG9wLm1heEZlZVBlckdhcyAhPSBudWxsICYmIHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSkge1xuICAgICAgICAgICAgLy8gRnVsbHktZm9ybWVkIEVJUC0xNTU5IHRyYW5zYWN0aW9uIChza2lwIGdldEZlZURhdGEpXG4gICAgICAgICAgICBwb3AudHlwZSA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9wLnR5cGUgPT09IDAgfHwgcG9wLnR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIEV4cGxpY2l0IExlZ2FjeSBvciBFSVAtMjkzMCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBnZXQgZmVlIGRhdGEgdG8gZGV0ZXJtaW5lIHRoaW5nc1xuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHByb3ZpZGVyLmdldEZlZURhdGEoKTtcbiAgICAgICAgICAgIGFzc2VydChmZWVEYXRhLmdhc1ByaWNlICE9IG51bGwsIFwibmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IGdhc1ByaWNlXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0R2FzUHJpY2VcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGdhc1ByaWNlXG4gICAgICAgICAgICBpZiAocG9wLmdhc1ByaWNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwb3AuZ2FzUHJpY2UgPSBmZWVEYXRhLmdhc1ByaWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBnZXQgZmVlIGRhdGEgdG8gZGV0ZXJtaW5lIHRoaW5nc1xuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHByb3ZpZGVyLmdldEZlZURhdGEoKTtcbiAgICAgICAgICAgIGlmIChwb3AudHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBhdXRvLWRldGVjdCB0aGUgaW50ZW5kZWQgdHlwZSBvZiB0aGlzIHRyYW5zYWN0aW9uLi4uXG4gICAgICAgICAgICAgICAgaWYgKGZlZURhdGEubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBuZXR3b3JrIHN1cHBvcnRzIEVJUC0xNTU5IVxuICAgICAgICAgICAgICAgICAgICAvLyBVcGdyYWRlIHRyYW5zYWN0aW9uIGZyb20gbnVsbCB0byBlaXAtMTU1OVxuICAgICAgICAgICAgICAgICAgICBwb3AudHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3AuZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNpbmcgbGVnYWN5IGdhc1ByaWNlIHByb3BlcnR5IG9uIGFuIGVpcC0xNTU5IG5ldHdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB1c2UgZ2FzUHJpY2UgYXMgYm90aCBmZWUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2FzUHJpY2UgPSBwb3AuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcG9wLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heEZlZVBlckdhcyA9IGdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID0gZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9wLm1heEZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heEZlZVBlckdhcyA9IGZlZURhdGEubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmZWVEYXRhLmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV0d29yayBkb2Vzbid0IHN1cHBvcnQgRUlQLTE1NTkuLi5cbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uYnV0IHRoZXkgYXJlIHRyeWluZyB0byB1c2UgRUlQLTE1NTkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoIWhhc0VpcDE1NTksIFwibmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IEVJUC0xNTU5XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJwb3B1bGF0ZVRyYW5zYWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AuZ2FzUHJpY2UgPSBmZWVEYXRhLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgc2V0IHVudHlwZWQgdHJhbnNhY3Rpb24gdG8gbGVnYWN5XG4gICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBNYXliZSB0aGlzIHNob2xkIGFsbG93IHR5cGUgMT9cbiAgICAgICAgICAgICAgICAgICAgcG9wLnR5cGUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0RmVlRGF0YSBoYXMgZmFpbGVkIHVzLlxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwiZmFpbGVkIHRvIGdldCBjb25zaXN0ZW50IGZlZSBkYXRhXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzaWduZXIuZ2V0RmVlRGF0YVwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBvcC50eXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSB1c2luZyBFSVAtMTU1OVxuICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICBpZiAocG9wLm1heEZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcC5tYXhGZWVQZXJHYXMgPSBmZWVEYXRhLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vQFRPT0Q6IERvbid0IGF3YWl0IGFsbCBvdmVyIHRoZSBwbGFjZTsgc2F2ZSB0aGVtIHVwIGZvclxuICAgICAgICAvLyB0aGUgZW5kIGZvciBiZXR0ZXIgYmF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHBvcCk7XG4gICAgfVxuICAgIGFzeW5jIGVzdGltYXRlR2FzKHR4KSB7XG4gICAgICAgIHJldHVybiBjaGVja1Byb3ZpZGVyKHRoaXMsIFwiZXN0aW1hdGVHYXNcIikuZXN0aW1hdGVHYXMoYXdhaXQgdGhpcy5wb3B1bGF0ZUNhbGwodHgpKTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbCh0eCkge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm92aWRlcih0aGlzLCBcImNhbGxcIikuY2FsbChhd2FpdCB0aGlzLnBvcHVsYXRlQ2FsbCh0eCkpO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gY2hlY2tQcm92aWRlcih0aGlzLCBcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGNoZWNrUHJvdmlkZXIodGhpcywgXCJzZW5kVHJhbnNhY3Rpb25cIik7XG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIGRlbGV0ZSBwb3AuZnJvbTtcbiAgICAgICAgY29uc3QgdHhPYmogPSBUcmFuc2FjdGlvbi5mcm9tKHBvcCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5icm9hZGNhc3RUcmFuc2FjdGlvbihhd2FpdCB0aGlzLnNpZ25UcmFuc2FjdGlvbih0eE9iaikpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipWb2lkU2lnbmVyKiogaXMgYSBjbGFzcyBkZWlzZ25lZCB0byBhbGxvdyBhbiBhZGRyZXNzIHRvIGJlIHVzZWRcbiAqICBpbiBhbnkgQVBJIHdoaWNoIGFjY2VwdHMgYSBTaWduZXIsIGJ1dCBmb3Igd2hpY2ggdGhlcmUgYXJlIG5vXG4gKiAgY3JlZGVudGlhbHMgYXZhaWxhYmxlIHRvIHBlcmZvcm0gYW55IGFjdHVhbCBzaWduaW5nLlxuICpcbiAqICBUaGlzIGZvciBleGFtcGxlIGFsbG93IGltcGVyc29uYXRpbmcgYW4gYWNjb3VudCBmb3IgdGhlIHB1cnBvc2Ugb2ZcbiAqICBzdGF0aWMgY2FsbHMgb3IgZXN0aW1hdGluZyBnYXMsIGJ1dCBkb2VzIG5vdCBhbGxvdyBzZW5kaW5nIHRyYW5zYWN0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFZvaWRTaWduZXIgZXh0ZW5kcyBBYnN0cmFjdFNpZ25lciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBzaWduZXIgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqVm9pZFNpZ25lcioqIHdpdGggJSVhZGRyZXNzJSUgYXR0YWNoZWQgdG9cbiAgICAgKiAgJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFkZHJlc3MgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7IHJldHVybiB0aGlzLmFkZHJlc3M7IH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVm9pZFNpZ25lcih0aGlzLmFkZHJlc3MsIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgI3Rocm93VW5zdXBwb3J0ZWQoc3VmZml4LCBvcGVyYXRpb24pIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiAke3N1ZmZpeH1gLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbiB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJ0cmFuc2FjdGlvbnNcIiwgXCJzaWduVHJhbnNhY3Rpb25cIik7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy4jdGhyb3dVbnN1cHBvcnRlZChcIm1lc3NhZ2VzXCIsIFwic2lnbk1lc3NhZ2VcIik7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgdGhpcy4jdGhyb3dVbnN1cHBvcnRlZChcInR5cGVkLWRhdGFcIiwgXCJzaWduVHlwZWREYXRhXCIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFic3RyYWN0LXNpZ25lci5qcy5tYXAiLCJpbXBvcnQgeyBpc0Vycm9yIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIH0gZnJvbSBcIi4vc3Vic2NyaWJlci1wb2xsaW5nLmpzXCI7XG5mdW5jdGlvbiBjb3B5KG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufVxuLyoqXG4gKiAgU29tZSBiYWNrZW5kcyBzdXBwb3J0IHN1YnNjcmliaW5nIHRvIGV2ZW50cyB1c2luZyBhIEZpbHRlciBJRC5cbiAqXG4gKiAgV2hlbiBzdWJzY3JpYmluZyB3aXRoIHRoaXMgdGVjaG5pcXVlLCB0aGUgbm9kZSBpc3N1ZXMgYSB1bmlxdWVcbiAqICAvL0ZpbHRlciBJRC8vLiBBdCB0aGlzIHBvaW50IHRoZSBub2RlIGRlZGljYXRlcyByZXNvdXJjZXMgdG9cbiAqICB0aGUgZmlsdGVyLCBzbyB0aGF0IHBlcmlvZGljIGNhbGxzIHRvIGZvbGxvdyB1cCBvbiB0aGUgLy9GaWx0ZXIgSUQvL1xuICogIHdpbGwgcmVjZWl2ZSBhbnkgZXZlbnRzIHNpbmNlIHRoZSBsYXN0IGNhbGwuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWx0ZXJJZFN1YnNjcmliZXIge1xuICAgICNwcm92aWRlcjtcbiAgICAjZmlsdGVySWRQcm9taXNlO1xuICAgICNwb2xsZXI7XG4gICAgI3J1bm5pbmc7XG4gICAgI25ldHdvcms7XG4gICAgI2hhdWx0O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRmlsdGVySWRTdWJzY3JpYmVyKiogd2hpY2ggd2lsbCB1c2VkIFtbX3N1YnNjcmliZV1dXG4gICAgICogIGFuZCBbW19lbWl0UmVzdWx0c11dIHRvIHNldHVwIHRoZSBzdWJzY3JpcHRpb24gYW5kIHByb3ZpZGUgdGhlIGV2ZW50XG4gICAgICogIHRvIHRoZSAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy4jZmlsdGVySWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jcG9sbGVyID0gdGhpcy4jcG9sbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI25ldHdvcmsgPSBudWxsO1xuICAgICAgICB0aGlzLiNoYXVsdCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcyB0byBiZWdpbiB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAqL1xuICAgIF9zdWJzY3JpYmUocHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzIGhhbmRsZSB0aGUgZXZlbnRzLlxuICAgICAqL1xuICAgIF9lbWl0UmVzdWx0cyhwcm92aWRlciwgcmVzdWx0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcyBoYW5kbGUgcmVjb3Zlcnkgb24gZXJyb3JzLlxuICAgICAqL1xuICAgIF9yZWNvdmVyKHByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzXCIpO1xuICAgIH1cbiAgICBhc3luYyAjcG9sbChibG9ja051bWJlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gU3Vic2NyaWJlIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgaWYgKHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZmlsdGVySWRQcm9taXNlID0gdGhpcy5fc3Vic2NyaWJlKHRoaXMuI3Byb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgRmlsdGVyIElEXG4gICAgICAgICAgICBsZXQgZmlsdGVySWQgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJJZCA9IGF3YWl0IHRoaXMuI2ZpbHRlcklkUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghaXNFcnJvcihlcnJvciwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIikgfHwgZXJyb3Iub3BlcmF0aW9uICE9PSBcImV0aF9uZXdGaWx0ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgYmFja2VuZCBkb2VzIG5vdCBzdXBwb3J0IEZpbHRlciBJRDsgZG93bmdyYWRlIHRvXG4gICAgICAgICAgICAvLyBwb2xsaW5nXG4gICAgICAgICAgICBpZiAoZmlsdGVySWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuX3JlY292ZXJTdWJzY3JpYmVyKHRoaXMsIHRoaXMuX3JlY292ZXIodGhpcy4jcHJvdmlkZXIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLiNuZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IG5ldHdvcms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jbmV0d29yay5jaGFpbklkICE9PSBuZXR3b3JrLmNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaGFpZCBjaGFuZ2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI2hhdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuc2VuZChcImV0aF9nZXRGaWx0ZXJDaGFuZ2VzXCIsIFtmaWx0ZXJJZF0pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZW1pdFJlc3VsdHModGhpcy4jcHJvdmlkZXIsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkBUT0RPXCIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgI3RlYXJkb3duKCkge1xuICAgICAgICBjb25zdCBmaWx0ZXJJZFByb21pc2UgPSB0aGlzLiNmaWx0ZXJJZFByb21pc2U7XG4gICAgICAgIGlmIChmaWx0ZXJJZFByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICBmaWx0ZXJJZFByb21pc2UudGhlbigoZmlsdGVySWQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNwcm92aWRlci5zZW5kKFwiZXRoX3VuaW5zdGFsbEZpbHRlclwiLCBbZmlsdGVySWRdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLiNwb2xsKC0yKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNoYXVsdCA9IHRydWU7XG4gICAgICAgIHRoaXMuI3RlYXJkb3duKCk7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiN0ZWFyZG93bigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHJlc3VtZSgpIHsgdGhpcy5zdGFydCgpOyB9XG59XG4vKipcbiAqICBBICoqRmlsdGVySWRTdWJzY3JpYmVyKiogZm9yIHJlY2VpdmluZyBjb250cmFjdCBldmVudHMuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlciBleHRlbmRzIEZpbHRlcklkU3Vic2NyaWJlciB7XG4gICAgI2V2ZW50O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRmlsdGVySWRFdmVudFN1YnNjcmliZXIqKiBhdHRhY2hlZCB0byAlJXByb3ZpZGVyJSVcbiAgICAgKiAgbGlzdGVuaW5nIGZvciAlJWZpbHRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBmaWx0ZXIpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNldmVudCA9IGNvcHkoZmlsdGVyKTtcbiAgICB9XG4gICAgX3JlY292ZXIocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKHByb3ZpZGVyLCB0aGlzLiNldmVudCk7XG4gICAgfVxuICAgIGFzeW5jIF9zdWJzY3JpYmUocHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgZmlsdGVySWQgPSBhd2FpdCBwcm92aWRlci5zZW5kKFwiZXRoX25ld0ZpbHRlclwiLCBbdGhpcy4jZXZlbnRdKTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcklkO1xuICAgIH1cbiAgICBhc3luYyBfZW1pdFJlc3VsdHMocHJvdmlkZXIsIHJlc3VsdHMpIHtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdCh0aGlzLiNldmVudCwgcHJvdmlkZXIuX3dyYXBMb2cocmVzdWx0LCBwcm92aWRlci5fbmV0d29yaykpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkZpbHRlcklkU3Vic2NyaWJlcioqIGZvciByZWNlaXZpbmcgcGVuZGluZyB0cmFuc2FjdGlvbnMgZXZlbnRzLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciBleHRlbmRzIEZpbHRlcklkU3Vic2NyaWJlciB7XG4gICAgYXN5bmMgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuc2VuZChcImV0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXJcIiwgW10pO1xuICAgIH1cbiAgICBhc3luYyBfZW1pdFJlc3VsdHMocHJvdmlkZXIsIHJlc3VsdHMpIHtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdChcInBlbmRpbmdcIiwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZXItZmlsdGVyaWQuanMubWFwIiwiLyoqXG4gKiAgT25lIG9mIHRoZSBtb3N0IGNvbW1vbiB3YXlzIHRvIGludGVyYWN0IHdpdGggdGhlIGJsb2NrY2hhaW4gaXNcbiAqICBieSBhIG5vZGUgcnVubmluZyBhIEpTT04tUlBDIGludGVyZmFjZSB3aGljaCBjYW4gYmUgY29ubmVjdGVkIHRvLFxuICogIGJhc2VkIG9uIHRoZSB0cmFuc3BvcnQsIHVzaW5nOlxuICpcbiAqICAtIEhUVFAgb3IgSFRUUFMgLSBbW0pzb25ScGNQcm92aWRlcl1dXG4gKiAgLSBXZWJTb2NrZXQgLSBbW1dlYlNvY2tldFByb3ZpZGVyXV1cbiAqICAtIElQQyAtIFtbSXBjU29ja2V0UHJvdmlkZXJdXVxuICpcbiAqIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9qc29ucnBjOkpTT04tUlBDIFByb3ZpZGVyICBbYWJvdXQtanNvbnJwY1Byb3ZpZGVyXVxuICovXG4vLyBAVE9ETzpcbi8vIC0gQWRkIHRoZSBiYXRjaGluZyBBUElcbi8vIGh0dHBzOi8vcGxheWdyb3VuZC5vcGVuLXJwYy5vcmcvP3NjaGVtYVVybD1odHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZXRoZXJldW0vZXRoMS4wLWFwaXMvYXNzZW1ibGVkLXNwZWMvb3BlbnJwYy5qc29uJnVpU2NoZW1hJTVCYXBwQmFyJTVEJTVCdWk6c3BsaXRWaWV3JTVEPXRydWUmdWlTY2hlbWElNUJhcHBCYXIlNUQlNUJ1aTppbnB1dCU1RD1mYWxzZSZ1aVNjaGVtYSU1QmFwcEJhciU1RCU1QnVpOmV4YW1wbGVzRHJvcGRvd24lNUQ9ZmFsc2VcbmltcG9ydCB7IEFiaUNvZGVyIH0gZnJvbSBcIi4uL2FiaS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHlwZWREYXRhRW5jb2RlciB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGhleGxpZnksIGlzSGV4U3RyaW5nLCB0b1F1YW50aXR5LCB0b1V0ZjhCeXRlcywgbWFrZUVycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBGZXRjaFJlcXVlc3QsIHJlc29sdmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBBYnN0cmFjdFByb3ZpZGVyLCBVbm1hbmFnZWRTdWJzY3JpYmVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IEFic3RyYWN0U2lnbmVyIH0gZnJvbSBcIi4vYWJzdHJhY3Qtc2lnbmVyLmpzXCI7XG5pbXBvcnQgeyBOZXR3b3JrIH0gZnJvbSBcIi4vbmV0d29yay5qc1wiO1xuaW1wb3J0IHsgRmlsdGVySWRFdmVudFN1YnNjcmliZXIsIEZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLWZpbHRlcmlkLmpzXCI7XG5pbXBvcnQgeyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIH0gZnJvbSBcIi4vc3Vic2NyaWJlci1wb2xsaW5nLmpzXCI7XG5jb25zdCBQcmltaXRpdmUgPSBcImJpZ2ludCxib29sZWFuLGZ1bmN0aW9uLG51bWJlcixzdHJpbmcsc3ltYm9sXCIuc3BsaXQoLywvZyk7XG4vL2NvbnN0IE1ldGhvZHMgPSBcImdldEFkZHJlc3MsdGhlblwiLnNwbGl0KC8sL2cpO1xuZnVuY3Rpb24gZGVlcENvcHkodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBQcmltaXRpdmUuaW5kZXhPZih0eXBlb2YgKHZhbHVlKSkgPj0gMCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8vIEtlZXAgYW55IEFkZHJlc3NhYmxlXG4gICAgaWYgKHR5cGVvZiAodmFsdWUuZ2V0QWRkcmVzcykgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlLm1hcChkZWVwQ29weSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5yZWR1Y2UoKGFjY3VtLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGFjY3VtW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgc2hvdWxkIG5vdCBoYXBwZW46ICR7dmFsdWV9ICgke3R5cGVvZiAodmFsdWUpfSlgKTtcbn1cbmZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pOyB9KTtcbn1cbmZ1bmN0aW9uIGdldExvd2VyQ2FzZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gaXNQb2xsYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5wb2xsaW5nSW50ZXJ2YWwpID09PSBcIm51bWJlclwiKTtcbn1cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHBvbGxpbmc6IGZhbHNlLFxuICAgIHN0YXRpY05ldHdvcms6IG51bGwsXG4gICAgYmF0Y2hTdGFsbFRpbWU6IDEwLFxuICAgIGJhdGNoTWF4U2l6ZTogKDEgPDwgMjApLFxuICAgIGJhdGNoTWF4Q291bnQ6IDEwMCxcbiAgICBjYWNoZVRpbWVvdXQ6IDI1MCxcbiAgICBwb2xsaW5nSW50ZXJ2YWw6IDQwMDBcbn07XG4vLyBAVE9ETzogVW5jaGVja2VkIFNpZ25lcnNcbmV4cG9ydCBjbGFzcyBKc29uUnBjU2lnbmVyIGV4dGVuZHMgQWJzdHJhY3RTaWduZXIge1xuICAgIGFkZHJlc3M7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFkZHJlc3MpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICBhZGRyZXNzID0gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFkZHJlc3MgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNhbm5vdCByZWNvbm5lY3QgSnNvblJwY1NpZ25lclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwic2lnbmVyLmNvbm5lY3RcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkcmVzcztcbiAgICB9XG4gICAgLy8gSlNPTi1SUEMgd2lsbCBhdXRvbWF0aWFsbHkgZmlsbCBpbiBub25jZSwgZXRjLiBzbyB3ZSBqdXN0IGNoZWNrIGZyb21cbiAgICBhc3luYyBwb3B1bGF0ZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvcHVsYXRlQ2FsbCh0eCk7XG4gICAgfVxuICAgIC8vIFJldHVybnMganVzdCB0aGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gYWZ0ZXIgc2VudCwgd2hpY2ggaXMgd2hhdFxuICAgIC8vIHRoZSBiYXJlIEpTT04tUlBDIEFQSSBkb2VzO1xuICAgIGFzeW5jIHNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbihfdHgpIHtcbiAgICAgICAgY29uc3QgdHggPSBkZWVwQ29weShfdHgpO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGZyb20gbWF0Y2hlcyB0aGUgc2VuZGVyXG4gICAgICAgIGlmICh0eC5mcm9tKSB7XG4gICAgICAgICAgICBjb25zdCBfZnJvbSA9IHR4LmZyb207XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKF9mcm9tLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmcm9tICE9IG51bGwgJiYgZnJvbS50b0xvd2VyQ2FzZSgpID09PSB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgXCJmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCBfdHgpO1xuICAgICAgICAgICAgICAgIHR4LmZyb20gPSBmcm9tO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gdGhpcy5hZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBKU09OLVJQQyBmb3IgZXRoX3NlbmRUcmFuc2FjdGlvbiB1c2VzIDkwMDAwIGdhczsgaWYgdGhlIHVzZXJcbiAgICAgICAgLy8gd2lzaGVzIHRvIHVzZSB0aGlzLCBpdCBpcyBlYXN5IHRvIHNwZWNpZnkgZXhwbGljaXRseSwgb3RoZXJ3aXNlXG4gICAgICAgIC8vIHdlIGxvb2sgaXQgdXAgZm9yIHRoZW0uXG4gICAgICAgIGlmICh0eC5nYXNMaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHguZ2FzTGltaXQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKHsgLi4udHgsIGZyb206IHRoaXMuYWRkcmVzcyB9KTtcbiAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBhZGRyZXNzIG1heSBiZSBhbiBFTlMgbmFtZSBvciBBZGRyZXNzYWJsZVxuICAgICAgICBpZiAodHgudG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgX3RvID0gdHgudG87XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHgudG8gPSBhd2FpdCByZXNvbHZlQWRkcmVzcyhfdG8sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2FpdCB1bnRpbCBhbGwgb2Ygb3VyIHByb3BlcnRpZXMgYXJlIGZpbGxlZCBpblxuICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGV4VHggPSB0aGlzLnByb3ZpZGVyLmdldFJwY1RyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zZW5kVHJhbnNhY3Rpb25cIiwgW2hleFR4XSk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICAvLyBUaGlzIGNhbm5vdCBiZSBtaW5lZCBhbnkgZWFybGllciB0aGFuIGFueSByZWNlbnQgYmxvY2tcbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgICAgIC8vIFNlbmQgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCB0aGlzLnNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIEpTT04tUlBDIG9ubHkgcHJvdmlkZXMgYW5kIG9wYXF1ZSB0cmFuc2FjdGlvbiBoYXNoXG4gICAgICAgIC8vIGZvciBhIHJlc3BvbnNlLCBhbmQgd2UgbmVlZCB0aGUgYWN0dWFsIHRyYW5zYWN0aW9uLCBzbyB3ZSBwb2xsXG4gICAgICAgIC8vIGZvciBpdDsgaXQgc2hvdWxkIHNob3cgdXAgdmVyeSBxdWlja2x5XG4gICAgICAgIHJldHVybiBhd2FpdCAobmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dHMgPSBbMTAwMCwgMTAwXTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrVHggPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGhhc2gpO1xuICAgICAgICAgICAgICAgIGlmICh0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHgucmVwbGFjZWFibGVUcmFuc2FjdGlvbihibG9ja051bWJlcikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdhaXQgYW5vdGhlciA0IHNlY29uZHNcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLl9zZXRUaW1lb3V0KCgpID0+IHsgY2hlY2tUeCgpOyB9LCB0aW1lb3V0cy5wb3AoKSB8fCA0MDAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGVja1R4KCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKF90eCkge1xuICAgICAgICBjb25zdCB0eCA9IGRlZXBDb3B5KF90eCk7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZnJvbSBtYXRjaGVzIHRoZSBzZW5kZXJcbiAgICAgICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBhd2FpdCByZXNvbHZlQWRkcmVzcyh0eC5mcm9tLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZyb20gIT0gbnVsbCAmJiBmcm9tLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIF90eCk7XG4gICAgICAgICAgICB0eC5mcm9tID0gZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSB0aGlzLmFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGV4VHggPSB0aGlzLnByb3ZpZGVyLmdldFJwY1RyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduVHJhbnNhY3Rpb25cIiwgW2hleFR4XSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25NZXNzYWdlKF9tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoKHR5cGVvZiAoX21lc3NhZ2UpID09PSBcInN0cmluZ1wiKSA/IHRvVXRmOEJ5dGVzKF9tZXNzYWdlKSA6IF9tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZChcInBlcnNvbmFsX3NpZ25cIiwgW1xuICAgICAgICAgICAgaGV4bGlmeShtZXNzYWdlKSwgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKClcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGVlcENvcHkoX3ZhbHVlKTtcbiAgICAgICAgLy8gUG9wdWxhdGUgYW55IEVOUyBuYW1lcyAoaW4tcGxhY2UpXG4gICAgICAgIGNvbnN0IHBvcHVsYXRlZCA9IGF3YWl0IFR5cGVkRGF0YUVuY29kZXIucmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCBhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCByZXNvbHZlQWRkcmVzcyh2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhZGRyZXNzICE9IG51bGwsIFwiVHlwZWREYXRhIGRvZXMgbm90IHN1cHBvcnQgbnVsbCBhZGRyZXNzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UeXBlZERhdGFfdjRcIiwgW1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShUeXBlZERhdGFFbmNvZGVyLmdldFBheWxvYWQocG9wdWxhdGVkLmRvbWFpbiwgdHlwZXMsIHBvcHVsYXRlZC52YWx1ZSkpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyB1bmxvY2socGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZChcInBlcnNvbmFsX3VubG9ja0FjY291bnRcIiwgW1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIHBhc3N3b3JkLCBudWxsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0pTT04tUlBDI2V0aF9zaWduXG4gICAgYXN5bmMgX2xlZ2FjeVNpZ25NZXNzYWdlKF9tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoKHR5cGVvZiAoX21lc3NhZ2UpID09PSBcInN0cmluZ1wiKSA/IHRvVXRmOEJ5dGVzKF9tZXNzYWdlKSA6IF9tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduXCIsIFtcbiAgICAgICAgICAgIHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBoZXhsaWZ5KG1lc3NhZ2UpXG4gICAgICAgIF0pO1xuICAgIH1cbn1cbi8qKlxuICogIFRoZSBKc29uUnBjQXBpUHJvdmlkZXIgaXMgYW4gYWJzdHJhY3QgY2xhc3MgYW5kICoqTVVTVCoqIGJlXG4gKiAgc3ViLWNsYXNzZWQuXG4gKlxuICogIEl0IHByb3ZpZGVzIHRoZSBiYXNlIGZvciBhbGwgSlNPTi1SUEMtYmFzZWQgUHJvdmlkZXIgaW50ZXJhY3Rpb24uXG4gKlxuICogIFN1Yi1jbGFzc2luZyBOb3RlczpcbiAqICAtIGEgc3ViLWNsYXNzIE1VU1Qgb3ZlcnJpZGUgX3NlbmRcbiAqICAtIGEgc3ViLWNsYXNzIE1VU1QgY2FsbCB0aGUgYF9zdGFydCgpYCBtZXRob2Qgb25jZSBjb25uZWN0ZWRcbiAqL1xuZXhwb3J0IGNsYXNzIEpzb25ScGNBcGlQcm92aWRlciBleHRlbmRzIEFic3RyYWN0UHJvdmlkZXIge1xuICAgICNvcHRpb25zO1xuICAgIC8vIFRoZSBuZXh0IElEIHRvIHVzZSBmb3IgdGhlIEpTT04tUlBDIElEIGZpZWxkXG4gICAgI25leHRJZDtcbiAgICAvLyBQYXlsb2FkcyBhcmUgcXVldWVkIGFuZCB0cmlnZ2VyZWQgaW4gYmF0Y2hlcyB1c2luZyB0aGUgZHJhaW5UaW1lclxuICAgICNwYXlsb2FkcztcbiAgICAjZHJhaW5UaW1lcjtcbiAgICAjbm90UmVhZHk7XG4gICAgI25ldHdvcms7XG4gICAgI3BlbmRpbmdEZXRlY3ROZXR3b3JrO1xuICAgICNzY2hlZHVsZURyYWluKCkge1xuICAgICAgICBpZiAodGhpcy4jZHJhaW5UaW1lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGFyZW4ndCB1c2luZyBiYXRjaGluZywgbm8gaGFyZCBpbiBzZW5kaW5nIGl0IGltbWVpZGF0ZWx5XG4gICAgICAgIGNvbnN0IHN0YWxsVGltZSA9ICh0aGlzLl9nZXRPcHRpb24oXCJiYXRjaE1heENvdW50XCIpID09PSAxKSA/IDAgOiB0aGlzLl9nZXRPcHRpb24oXCJiYXRjaFN0YWxsVGltZVwiKTtcbiAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkcyA9IHRoaXMuI3BheWxvYWRzO1xuICAgICAgICAgICAgdGhpcy4jcGF5bG9hZHMgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChwYXlsb2Fkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgcGF5bG9hZCBiYXRjaGVzIHRoYXQgc2F0aXNmeSBvdXIgYmF0Y2ggY29uc3RyYWludHNcbiAgICAgICAgICAgICAgICBjb25zdCBiYXRjaCA9IFsocGF5bG9hZHMuc2hpZnQoKSldO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwYXlsb2Fkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhdGNoLmxlbmd0aCA9PT0gdGhpcy4jb3B0aW9ucy5iYXRjaE1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiYXRjaC5wdXNoKChwYXlsb2Fkcy5zaGlmdCgpKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gSlNPTi5zdHJpbmdpZnkoYmF0Y2gubWFwKChwKSA9PiBwLnBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IHRoaXMuI29wdGlvbnMuYmF0Y2hNYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2Fkcy51bnNoaWZ0KChiYXRjaC5wb3AoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgcmVzdWx0IHRvIGVhY2ggcGF5bG9hZFxuICAgICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSAoKGJhdGNoLmxlbmd0aCA9PT0gMSkgPyBiYXRjaFswXS5wYXlsb2FkIDogYmF0Y2gubWFwKChwKSA9PiBwLnBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZFJwY1BheWxvYWRcIiwgcGF5bG9hZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3NlbmQocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUnBjUmVzdWx0XCIsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgcmVzdWx0cyBpbiBiYXRjaCBvcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlc29sdmUsIHJlamVjdCwgcGF5bG9hZCB9IG9mIGJhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJwcm92aWRlciBkZXN0cm95ZWQ7IGNhbmNlbGxlZCByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBwYXlsb2FkLm1ldGhvZCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBtYXRjaGluZyByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gcmVzdWx0LmZpbHRlcigocikgPT4gKHIuaWQgPT09IHBheWxvYWQuaWQpKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyByZXN1bHQ7IHRoZSBub2RlIGZhaWxlZCB1cyBpbiB1bmV4cGVjdGVkIHdheXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbWFrZUVycm9yKFwibWlzc2luZyByZXNwb25zZSBmb3IgcmVxdWVzdFwiLCBcIkJBRF9EQVRBXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQsIGluZm86IHsgcGF5bG9hZCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVzcG9uc2UgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJlcnJvclwiIGluIHJlc3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRoaXMuZ2V0UnBjRXJyb3IocGF5bG9hZCwgcmVzcCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIGdvb2Q7IHNlbmQgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY0Vycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlamVjdCB9IG9mIGJhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IGF1Z21lbnQgdGhlIGVycm9yIHdpdGggdGhlIHBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3RhbGxUaW1lKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy4jbmV4dElkID0gMTtcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgdGhpcy4jcGF5bG9hZHMgPSBbXTtcbiAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuI25ldHdvcmsgPSBudWxsO1xuICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoX3Jlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlID0gX3Jlc29sdmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuI25vdFJlYWR5ID0geyBwcm9taXNlLCByZXNvbHZlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdGljTmV0d29yayA9IHRoaXMuX2dldE9wdGlvbihcInN0YXRpY05ldHdvcmtcIik7XG4gICAgICAgIGlmICh0eXBlb2YgKHN0YXRpY05ldHdvcmspID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIXN0YXRpY05ldHdvcmsgfHwgbmV0d29yayAhPT0gXCJhbnlcIiwgXCJzdGF0aWNOZXR3b3JrIGNhbm5vdCBiZSB1c2VkIG9uIHNwZWNpYWwgbmV0d29yayAnYW55J1wiLCBcIm9wdGlvbnNcIiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc3RhdGljTmV0d29yayAmJiBuZXR3b3JrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrID0gTmV0d29yay5mcm9tKG5ldHdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRpY05ldHdvcmspIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBhbnkgc3RhdGljIG5ldHdvcmsgaXMgY29tcGF0YmlsZSB3aXRoIHRoZSBwcm92aWRlZCBuZXR3cm9rXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChuZXR3b3JrID09IG51bGwgfHwgc3RhdGljTmV0d29yay5tYXRjaGVzKG5ldHdvcmspLCBcInN0YXRpY05ldHdvcmsgTVVTVCBtYXRjaCBuZXR3b3JrIG9iamVjdFwiLCBcIm9wdGlvbnNcIiwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrID0gc3RhdGljTmV0d29yaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBvcHRpb24gJSVrZXklJS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyBjYW4gdXNlIHRoaXMgdG8gaW5xdWlyZSBhYm91dCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICovXG4gICAgX2dldE9wdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI29wdGlvbnNba2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldHMgdGhlIFtbTmV0d29ya11dIHRoaXMgcHJvdmlkZXIgaGFzIGNvbW1pdHRlZCB0by4gT24gZWFjaCBjYWxsLCB0aGUgbmV0d29ya1xuICAgICAqICBpcyBkZXRlY3RlZCwgYW5kIGlmIGl0IGhhcyBjaGFuZ2VkLCB0aGUgY2FsbCB3aWxsIHJlamVjdC5cbiAgICAgKi9cbiAgICBnZXQgX25ldHdvcmsoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLiNuZXR3b3JrLCBcIm5ldHdvcmsgaXMgbm90IGF2YWlsYWJsZSB5ZXRcIiwgXCJORVRXT1JLX0VSUk9SXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy4jbmV0d29yaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBub24tbm9ybWFsaXplZCB2YWx1ZSBieSBwZXJmb3JtaW5nICUlcmVxJSUuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gbW9kaWZ5IGJlaGF2aW9yIG9mIGFjdGlvbnMsXG4gICAgICogIGFuZCBzaG91bGQgZ2VuZXJhbGx5IGNhbGwgYGBzdXBlci5fcGVyZm9ybWBgIGFzIGEgZmFsbGJhY2suXG4gICAgICovXG4gICAgYXN5bmMgX3BlcmZvcm0ocmVxKSB7XG4gICAgICAgIC8vIExlZ2FjeSBuZXR3b3JrcyBkbyBub3QgbGlrZSB0aGUgdHlwZSBmaWVsZCBiZWluZyBwYXNzZWQgYWxvbmcgKHdoaWNoXG4gICAgICAgIC8vIGlzIGZhaXIpLCBzbyB3ZSBkZWxldGUgdHlwZSBpZiBpdCBpcyAwIGFuZCBhIG5vbi1FSVAtMTU1OSBuZXR3b3JrXG4gICAgICAgIGlmIChyZXEubWV0aG9kID09PSBcImNhbGxcIiB8fCByZXEubWV0aG9kID09PSBcImVzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgICAgIGxldCB0eCA9IHJlcS50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIGlmICh0eCAmJiB0eC50eXBlICE9IG51bGwgJiYgZ2V0QmlnSW50KHR4LnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIEVJUC0xNTU5IHByb3BlcnRpZXMsIGl0IG1pZ2h0IGJlIG5vbi1FSVAtYTU1OVxuICAgICAgICAgICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgPT0gbnVsbCAmJiB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCB0aGlzLmdldEZlZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlZURhdGEubWF4RmVlUGVyR2FzID09IG51bGwgJiYgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGRvZXNuJ3Qga25vdyBhYm91dCBFSVAtMTU1OSAoYW5kIGhlbmNlIHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEgPSBPYmplY3QuYXNzaWduKHt9LCByZXEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgdHgsIHsgdHlwZTogdW5kZWZpbmVkIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5nZXRScGNSZXF1ZXN0KHJlcSk7XG4gICAgICAgIGlmIChyZXF1ZXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmQocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QuYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9wZXJmb3JtKHJlcSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpczsgaXQgZGV0ZWN0cyB0aGUgKmFjdHVhbCogbmV0d29yayB0aGF0XG4gICAgICogIHdlIGFyZSAqKmN1cnJlbnRseSoqIGNvbm5lY3RlZCB0by5cbiAgICAgKlxuICAgICAqICBLZWVwIGluIG1pbmQgdGhhdCBbW3NlbmRdXSBtYXkgb25seSBiZSB1c2VkIG9uY2UgW1tyZWFkeV1dLCBvdGhlcndpc2UgdGhlXG4gICAgICogIF9zZW5kIHByaW1pdGl2ZSBtdXN0IGJlIHVzZWQgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBfZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IHRoaXMuX2dldE9wdGlvbihcInN0YXRpY05ldHdvcmtcIik7XG4gICAgICAgIGlmIChuZXR3b3JrKSB7XG4gICAgICAgICAgICBpZiAobmV0d29yayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNuZXR3b3JrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaykge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGFyZSByZWFkeSwgdXNlIGBgc2VuZGBgLCB3aGljaCBlbmFibGVkIHJlcXVlc3RzIHRvIGJlIGJhdGNoZWRcbiAgICAgICAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBOZXR3b3JrLmZyb20oZ2V0QmlnSW50KGF3YWl0IHRoaXMuc2VuZChcImV0aF9jaGFpbklkXCIsIFtdKSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaztcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhcmUgbm90IHJlYWR5IHlldDsgdXNlIHRoZSBwcmltaXRpdmUgX3NlbmRcbiAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBpZDogdGhpcy4jbmV4dElkKyssIG1ldGhvZDogXCJldGhfY2hhaW5JZFwiLCBwYXJhbXM6IFtdLCBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZFJwY1BheWxvYWRcIiwgcGF5bG9hZCB9KTtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChhd2FpdCB0aGlzLl9zZW5kKHBheWxvYWQpKVswXTtcbiAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY0Vycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY1Jlc3VsdFwiLCByZXN1bHQgfSk7XG4gICAgICAgICAgICBpZiAoXCJyZXN1bHRcIiBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmV0d29yay5mcm9tKGdldEJpZ0ludChyZXN1bHQucmVzdWx0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmdldFJwY0Vycm9yKHBheWxvYWQsIHJlc3VsdCk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqTVVTVCoqIGNhbGwgdGhpcy4gVW50aWwgW1tfc3RhcnRdXSBoYXMgYmVlbiBjYWxsZWQsIG5vIGNhbGxzXG4gICAgICogIHdpbGwgYmUgcGFzc2VkIHRvIFtbX3NlbmRdXSBmcm9tIFtbc2VuZF1dLiBJZiBpdCBpcyBvdmVycmlkZGVuLCB0aGVuXG4gICAgICogIGBgc3VwZXIuX3N0YXJ0KClgYCAqKk1VU1QqKiBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiAgQ2FsbGluZyBpdCBtdWx0aXBsZSB0aW1lcyBpcyBzYWZlIGFuZCBoYXMgbm8gZWZmZWN0LlxuICAgICAqL1xuICAgIF9zdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI25vdFJlYWR5ID09IG51bGwgfHwgdGhpcy4jbm90UmVhZHkucmVzb2x2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbm90UmVhZHkucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLiNub3RSZWFkeSA9IG51bGw7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBCb290c3RyYXAgdGhlIG5ldHdvcmtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLiNuZXR3b3JrID09IG51bGwgJiYgIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IGF3YWl0IHRoaXMuX2RldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJKc29uUnBjUHJvdmlkZXIgZmFpbGVkIHRvIGRldGVjdCBuZXR3b3JrIGFuZCBjYW5ub3Qgc3RhcnQgdXA7IHJldHJ5IGluIDFzIChwZXJoYXBzIHRoZSBVUkwgaXMgd3Jvbmcgb3IgdGhlIG5vZGUgaXMgbm90IHN0YXJ0ZWQpXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBtYWtlRXJyb3IoXCJmYWlsZWQgdG8gYm9vdHN0cmFwIG5ldHdvcmsgZGV0ZWN0aW9uXCIsIFwiTkVUV09SS19FUlJPUlwiLCB7IGV2ZW50OiBcImluaXRpYWwtbmV0d29yay1kaXNjb3ZlcnlcIiwgaW5mbzogeyBlcnJvciB9IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RhbGwoMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgZGlzcGF0Y2hpbmcgcmVxdWVzdHNcbiAgICAgICAgICAgIHRoaXMuI3NjaGVkdWxlRHJhaW4oKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhlIFtbX3N0YXJ0XV0gaGFzIGJlZW4gY2FsbGVkLiBUaGlzIGNhbiBiZSB1c2VkIGluXG4gICAgICogIHN1Yi1jbGFzc2VzIHRvIGRlZmVyIHNlbmRpbmcgZGF0YSB1bnRpbCB0aGUgY29ubmVjdGlvbiBoYXMgYmVlblxuICAgICAqICBlc3RhYmxpc2hlZC5cbiAgICAgKi9cbiAgICBhc3luYyBfd2FpdFVudGlsUmVhZHkoKSB7XG4gICAgICAgIGlmICh0aGlzLiNub3RSZWFkeSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI25vdFJlYWR5LnByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBTdWJzY3JpYmVyIHRoYXQgd2lsbCBtYW5hZ2UgdGhlICUlc3ViJSUuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gbW9kaWZ5IHRoZSBiZWhhdmlvciBvZlxuICAgICAqICBzdWJzY3JpcHRpb24gbWFuYWdlbWVudC5cbiAgICAgKi9cbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcbiAgICAgICAgLy8gUGVuZGluZyBGaWx0ZXJzIGFyZW4ndCBhdmFpbGJsZSB2aWEgcG9sbGluZ1xuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcImV2ZW50XCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRPcHRpb24oXCJwb2xsaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPcnBoYW5lZCBMb2dzIGFyZSBoYW5kbGVkIGF1dG9tYXRpY2FsbHksIGJ5IHRoZSBmaWx0ZXIsIHNpbmNlXG4gICAgICAgIC8vIGxvZ3Mgd2l0aCByZW1vdmVkIGFyZSBlbWl0dGVkIGJ5IGl0XG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJvcnBoYW5cIiAmJiBzdWIuZmlsdGVyLm9ycGhhbiA9PT0gXCJkcm9wLWxvZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVubWFuYWdlZFN1YnNjcmliZXIoXCJvcnBoYW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9nZXRTdWJzY3JpYmVyKHN1Yik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgb25seSBpZiB0aGUgW1tfc3RhcnRdXSBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICovXG4gICAgZ2V0IHJlYWR5KCkgeyByZXR1cm4gdGhpcy4jbm90UmVhZHkgPT0gbnVsbDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zICUldHglJSBhcyBhIG5vcm1hbGl6ZWQgSlNPTi1SUEMgdHJhbnNhY3Rpb24gcmVxdWVzdCxcbiAgICAgKiAgd2hpY2ggaGFzIGFsbCB2YWx1ZXMgaGV4bGlmaWVkIGFuZCBhbnkgbnVtZXJpYyB2YWx1ZXMgY29udmVydGVkXG4gICAgICogIHRvIFF1YW50aXR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBnZXRScGNUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgLy8gSlNPTi1SUEMgbm93IHJlcXVpcmVzIG51bWVyaWMgdmFsdWVzIHRvIGJlIFwicXVhbnRpdHlcIiB2YWx1ZXNcbiAgICAgICAgW1wiY2hhaW5JZFwiLCBcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJ0eXBlXCIsIFwibWF4RmVlUGVyR2FzXCIsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJub25jZVwiLCBcInZhbHVlXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR4W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkc3RLZXkgPSBrZXk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImdhc0xpbWl0XCIpIHtcbiAgICAgICAgICAgICAgICBkc3RLZXkgPSBcImdhc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2RzdEtleV0gPSB0b1F1YW50aXR5KGdldEJpZ0ludCh0eFtrZXldLCBgdHguJHtrZXl9YCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGFkZHJlc3NlcyBhbmQgZGF0YSBhcmUgbG93ZXJjYXNlXG4gICAgICAgIFtcImZyb21cIiwgXCJ0b1wiLCBcImRhdGFcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBoZXhsaWZ5KHR4W2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBhY2Nlc3MgbGlzdCBvYmplY3RcbiAgICAgICAgaWYgKHR4LmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdFtcImFjY2Vzc0xpc3RcIl0gPSBhY2Nlc3NMaXN0aWZ5KHR4LmFjY2Vzc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSByZXF1ZXN0IG1ldGhvZCBhbmQgYXJndW1lbnRzIHJlcXVpcmVkIHRvIHBlcmZvcm1cbiAgICAgKiAgJSVyZXElJS5cbiAgICAgKi9cbiAgICBnZXRScGNSZXF1ZXN0KHJlcSkge1xuICAgICAgICBzd2l0Y2ggKHJlcS5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjaGFpbklkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9jaGFpbklkXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2Jsb2NrTnVtYmVyXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2dhc1ByaWNlXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0UHJpb3JpdHlGZWVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX21heFByaW9yaXR5RmVlUGVyR2FzXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmFsYW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0VHJhbnNhY3Rpb25Db3VudFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0Q29kZVwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0U3RvcmFnZUF0XCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCIweFwiICsgcmVxLnBvc2l0aW9uLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuYmxvY2tUYWdcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiYnJvYWRjYXN0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLnNpZ25lZFRyYW5zYWN0aW9uXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcbiAgICAgICAgICAgICAgICBpZiAoXCJibG9ja1RhZ1wiIGluIHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmJsb2NrVGFnLCAhIXJlcS5pbmNsdWRlVHJhbnNhY3Rpb25zXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImJsb2NrSGFzaFwiIGluIHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRCbG9ja0J5SGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5ibG9ja0hhc2gsICEhcmVxLmluY2x1ZGVUcmFuc2FjdGlvbnNdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmhhc2hdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmhhc2hdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLmdldFJwY1RyYW5zYWN0aW9uKHJlcS50cmFuc2FjdGlvbiksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2VzdGltYXRlR2FzXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLmdldFJwY1RyYW5zYWN0aW9uKHJlcS50cmFuc2FjdGlvbildXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5maWx0ZXIgJiYgcmVxLmZpbHRlci5hZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVxLmZpbHRlci5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmZpbHRlci5hZGRyZXNzID0gcmVxLmZpbHRlci5hZGRyZXNzLm1hcChnZXRMb3dlckNhc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmZpbHRlci5hZGRyZXNzID0gZ2V0TG93ZXJDYXNlKHJlcS5maWx0ZXIuYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9nZXRMb2dzXCIsIGFyZ3M6IFtyZXEuZmlsdGVyXSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhbiBldGhlcnMtc3R5bGUgRXJyb3IgZm9yIHRoZSBnaXZlbiBKU09OLVJQQyBlcnJvclxuICAgICAqICAlJXBheWxvYWQlJSwgY29hbGVzY2luZyB0aGUgdmFyaW91cyBzdHJpbmdzIGFuZCBlcnJvciBzaGFwZXNcbiAgICAgKiAgdGhhdCBkaWZmZXJlbnQgbm9kZXMgcmV0dXJuLCBjb2VyY2luZyB0aGVtIGludG8gYSBtYWNoaW5lLXJlYWRhYmxlXG4gICAgICogIHN0YW5kYXJkaXplZCBlcnJvci5cbiAgICAgKi9cbiAgICBnZXRScGNFcnJvcihwYXlsb2FkLCBfZXJyb3IpIHtcbiAgICAgICAgY29uc3QgeyBtZXRob2QgfSA9IHBheWxvYWQ7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IF9lcnJvcjtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJldGhfZXN0aW1hdGVHYXNcIiAmJiBlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgaWYgKCFtc2cubWF0Y2goL3JldmVydC9pKSAmJiBtc2cubWF0Y2goL2luc3VmZmljaWVudCBmdW5kcy9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHNcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogKHBheWxvYWQucGFyYW1zWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgaW5mbzogeyBwYXlsb2FkLCBlcnJvciB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJldGhfY2FsbFwiIHx8IG1ldGhvZCA9PT0gXCJldGhfZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3BlbHVua0RhdGEoZXJyb3IpO1xuICAgICAgICAgICAgY29uc3QgZSA9IEFiaUNvZGVyLmdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKChtZXRob2QgPT09IFwiZXRoX2NhbGxcIikgPyBcImNhbGxcIiA6IFwiZXN0aW1hdGVHYXNcIiwgKHBheWxvYWQucGFyYW1zWzBdKSwgKHJlc3VsdCA/IHJlc3VsdC5kYXRhIDogbnVsbCkpO1xuICAgICAgICAgICAgZS5pbmZvID0geyBlcnJvciwgcGF5bG9hZCB9O1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBlc3RpbWF0ZUdhcyBhbmQgY2FsbCBjYW4gcmV0dXJuIGFyYml0cmFyeSBjb250cmFjdC1kZWZpbmVkIHRleHQsIHNvIG5vdyB3ZVxuICAgICAgICAvLyB3ZSBjYW4gcHJvY2VzcyB0ZXh0IHNhZmVseS5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KHNwZWx1bmtNZXNzYWdlKGVycm9yKSk7XG4gICAgICAgIGlmICh0eXBlb2YgKGVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIGVycm9yLm1lc3NhZ2UubWF0Y2goL3VzZXIgZGVuaWVkfGV0aGVycy11c2VyLWRlbmllZC9pKSkge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uTWFwID0ge1xuICAgICAgICAgICAgICAgIGV0aF9zaWduOiBcInNpZ25NZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgcGVyc29uYWxfc2lnbjogXCJzaWduTWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgIGV0aF9zaWduVHlwZWREYXRhX3Y0OiBcInNpZ25UeXBlZERhdGFcIixcbiAgICAgICAgICAgICAgICBldGhfc2lnblRyYW5zYWN0aW9uOiBcInNpZ25UcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIGV0aF9zZW5kVHJhbnNhY3Rpb246IFwic2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZXRoX3JlcXVlc3RBY2NvdW50czogXCJyZXF1ZXN0QWNjZXNzXCIsXG4gICAgICAgICAgICAgICAgd2FsbGV0X3JlcXVlc3RBY2NvdW50czogXCJyZXF1ZXN0QWNjZXNzXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihgdXNlciByZWplY3RlZCBhY3Rpb25gLCBcIkFDVElPTl9SRUpFQ1RFRFwiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAoYWN0aW9uTWFwW21ldGhvZF0gfHwgXCJ1bmtub3duXCIpLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogXCJyZWplY3RlZFwiLFxuICAgICAgICAgICAgICAgIGluZm86IHsgcGF5bG9hZCwgZXJyb3IgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIgfHwgbWV0aG9kID09PSBcImV0aF9zZW5kVHJhbnNhY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSAocGF5bG9hZC5wYXJhbXNbMF0pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL2luc3VmZmljaWVudCBmdW5kc3xiYXNlIGZlZSBleGNlZWRzIGdhcyBsaW1pdC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGludHJpbnNpYyB0cmFuc2FjdGlvbiBjb3N0XCIsIFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL25vbmNlL2kpICYmIG1lc3NhZ2UubWF0Y2goL3RvbyBsb3cvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsIFwiTk9OQ0VfRVhQSVJFRFwiLCB7IHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBcInJlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkXCJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9yZXBsYWNlbWVudCB0cmFuc2FjdGlvbi9pKSAmJiBtZXNzYWdlLm1hdGNoKC91bmRlcnByaWNlZC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJyZXBsYWNlbWVudCBmZWUgdG9vIGxvd1wiLCBcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCIsIHsgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9vbmx5IHJlcGxheS1wcm90ZWN0ZWQvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwibGVnYWN5IHByZS1laXAtMTU1IHRyYW5zYWN0aW9ucyBub3Qgc3VwcG9ydGVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBtZXRob2QsIGluZm86IHsgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfSB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHVuc3VwcG9ydGVkID0gISFtZXNzYWdlLm1hdGNoKC90aGUgbWV0aG9kIC4qIGRvZXMgbm90IGV4aXN0L2kpO1xuICAgICAgICBpZiAoIXVuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IuZGV0YWlscyAmJiBlcnJvci5kZXRhaWxzLnN0YXJ0c1dpdGgoXCJVbmF1dGhvcml6ZWQgbWV0aG9kOlwiKSkge1xuICAgICAgICAgICAgICAgIHVuc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodW5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJ1bnN1cHBvcnRlZCBvcGVyYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogcGF5bG9hZC5tZXRob2QsIGluZm86IHsgZXJyb3IsIHBheWxvYWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcImNvdWxkIG5vdCBjb2FsZXNjZSBlcnJvclwiLCBcIlVOS05PV05fRVJST1JcIiwgeyBlcnJvciwgcGF5bG9hZCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlcXVlc3RzIHRoZSAlJW1ldGhvZCUlIHdpdGggJSVwYXJhbXMlJSB2aWEgdGhlIEpTT04tUlBDIHByb3RvY29sXG4gICAgICogIG92ZXIgdGhlIHVuZGVybHlpbmcgY2hhbm5lbC4gVGhpcyBjYW4gYmUgdXNlZCB0byBjYWxsIG1ldGhvZHNcbiAgICAgKiAgb24gdGhlIGJhY2tlbmQgdGhhdCBkbyBub3QgaGF2ZSBhIGhpZ2gtbGV2ZWwgQVBJIHdpdGhpbiB0aGUgUHJvdmlkZXJcbiAgICAgKiAgQVBJLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIHF1ZXVlcyByZXF1ZXN0cyBhY2NvcmRpbmcgdG8gdGhlIGJhdGNoIGNvbnN0cmFpbnRzXG4gICAgICogIGluIHRoZSBvcHRpb25zLCBhc3NpZ25zIHRoZSByZXF1ZXN0IGEgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogICoqRG8gTk9UIG92ZXJyaWRlKiogdGhpcyBtZXRob2QgaW4gc3ViLWNsYXNzZXM7IGluc3RlYWRcbiAgICAgKiAgb3ZlcnJpZGUgW1tfc2VuZF1dIG9yIGZvcmNlIHRoZSBvcHRpb25zIHZhbHVlcyBpbiB0aGVcbiAgICAgKiAgY2FsbCB0byB0aGUgY29uc3RydWN0b3IgdG8gbW9kaWZ5IHRoaXMgbWV0aG9kJ3MgYmVoYXZpb3IuXG4gICAgICovXG4gICAgc2VuZChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICAvLyBAVE9ETzogY2FjaGUgY2hhaW5JZD8/IHB1cmdlIG9uIHN3aXRjaF9uZXR3b3Jrc1xuICAgICAgICAvLyBXZSBoYXZlIGJlZW4gZGVzdHJveWVkOyBubyBvcGVyYXRpb25zIGFyZSBzdXBwb3J0ZWQgYW55bW9yZVxuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChtYWtlRXJyb3IoXCJwcm92aWRlciBkZXN0cm95ZWQ7IGNhbmNlbGxlZCByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBtZXRob2QgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy4jbmV4dElkKys7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNwYXlsb2Fkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByZXNvbHZlLCByZWplY3QsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogeyBtZXRob2QsIHBhcmFtcywgaWQsIGpzb25ycGM6IFwiMi4wXCIgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBub3QgYSBwZW5kaW5nIGRyYWluVGltZXIsIHNldCBvbmVcbiAgICAgICAgdGhpcy4jc2NoZWR1bGVEcmFpbigpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBbW1NpZ25lcl1dIGFjY291bnQgZm9yICAlJWFkZHJlc3MlJSBtYW5hZ2VkIGJ5XG4gICAgICogIHRoZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUlYWRkcmVzcyUlIGlzIGEgbnVtYmVyLCBpdCBpcyB1c2VkIGFzIGFuIGluZGV4IGluIHRoZVxuICAgICAqICB0aGUgYWNjb3VudHMgZnJvbSBbW2xpc3RBY2NvdW50c11dLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIG9ubHkgYmUgdXNlZCBvbiBjbGllbnRzIHdoaWNoIG1hbmFnZSBhY2NvdW50cyAoc3VjaCBhc1xuICAgICAqICBHZXRoIHdpdGggaW1wb3J0ZWQgYWNjb3VudCBvciBNZXRhTWFzaykuXG4gICAgICpcbiAgICAgKiAgVGhyb3dzIGlmIHRoZSBhY2NvdW50IGRvZXNuJ3QgZXhpc3QuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U2lnbmVyKGFkZHJlc3MpIHtcbiAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWNjb3VudHNQcm9taXNlID0gdGhpcy5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKTtcbiAgICAgICAgLy8gQWNjb3VudCBpbmRleFxuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSAoYXdhaXQgYWNjb3VudHNQcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzID49IGFjY291bnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHN1Y2ggYWNjb3VudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgSnNvblJwY1NpZ25lcih0aGlzLCBhY2NvdW50c1thZGRyZXNzXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhY2NvdW50cyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBhY2NvdW50czogYWNjb3VudHNQcm9taXNlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBY2NvdW50IGFkZHJlc3NcbiAgICAgICAgYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGZvciAoY29uc3QgYWNjb3VudCBvZiBhY2NvdW50cykge1xuICAgICAgICAgICAgaWYgKGdldEFkZHJlc3MoYWNjb3VudCkgPT09IGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEpzb25ScGNTaWduZXIodGhpcywgYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhY2NvdW50XCIpO1xuICAgIH1cbiAgICBhc3luYyBsaXN0QWNjb3VudHMoKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKTtcbiAgICAgICAgcmV0dXJuIGFjY291bnRzLm1hcCgoYSkgPT4gbmV3IEpzb25ScGNTaWduZXIodGhpcywgYSkpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvLyBTdG9wIHByb2Nlc3NpbmcgcmVxdWVzdHNcbiAgICAgICAgaWYgKHRoaXMuI2RyYWluVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNkcmFpblRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbmNlbCBhbGwgcGVuZGluZyByZXF1ZXN0c1xuICAgICAgICBmb3IgKGNvbnN0IHsgcGF5bG9hZCwgcmVqZWN0IH0gb2YgdGhpcy4jcGF5bG9hZHMpIHtcbiAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJwcm92aWRlciBkZXN0cm95ZWQ7IGNhbmNlbGxlZCByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBwYXlsb2FkLm1ldGhvZCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcGF5bG9hZHMgPSBbXTtcbiAgICAgICAgLy8gUGFyZW50IGNsZWFuLXVwXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vLyBAVE9ETzogcmVtb3ZlIHRoaXMgaW4gdjcsIGl0IGlzIG5vdCBleHBvcnRlZCBiZWNhdXNlIHRoaXMgZnVuY3Rpb25hbGl0eVxuLy8gaXMgZXhwb3NlZCBpbiB0aGUgSnNvblJwY0FwaVByb3ZpZGVyIGJ5IHNldHRpbmcgcG9sbGluZyB0byB0cnVlLiBJdCBzaG91bGRcbi8vIGJlIHNhZmUgdG8gcmVtb3ZlIHJlZ2FyZGxlc3MsIGJlY2F1c2UgaXQgaXNuJ3QgcmVhY2hhYmxlLCBidXQganVzdCBpbiBjYXNlLlxuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKi9cbmV4cG9ydCBjbGFzcyBKc29uUnBjQXBpUG9sbGluZ1Byb3ZpZGVyIGV4dGVuZHMgSnNvblJwY0FwaVByb3ZpZGVyIHtcbiAgICAjcG9sbGluZ0ludGVydmFsO1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuI3BvbGxpbmdJbnRlcnZhbCA9IDQwMDA7XG4gICAgfVxuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gc3VwZXIuX2dldFN1YnNjcmliZXIoc3ViKTtcbiAgICAgICAgaWYgKGlzUG9sbGFibGUoc3Vic2NyaWJlcikpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIucG9sbGluZ0ludGVydmFsID0gdGhpcy4jcG9sbGluZ0ludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHBvbGxpbmcgaW50ZXJ2YWwgKGRlZmF1bHQ6IDQwMDAgbXMpXG4gICAgICovXG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI3BvbGxpbmdJbnRlcnZhbDsgfVxuICAgIHNldCBwb2xsaW5nSW50ZXJ2YWwodmFsdWUpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50ZXJ2YWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcG9sbGluZ0ludGVydmFsID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzdWIpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1BvbGxhYmxlKHN1YikpIHtcbiAgICAgICAgICAgICAgICBzdWIucG9sbGluZ0ludGVydmFsID0gdGhpcy4jcG9sbGluZ0ludGVydmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqICBUaGUgSnNvblJwY1Byb3ZpZGVyIGlzIG9uZSBvZiB0aGUgbW9zdCBjb21tb24gUHJvdmlkZXJzLFxuICogIHdoaWNoIHBlcmZvcm1zIGFsbCBvcGVyYXRpb25zIG92ZXIgSFRUUCAob3IgSFRUUFMpIHJlcXVlc3RzLlxuICpcbiAqICBFdmVudHMgYXJlIHByb2Nlc3NlZCBieSBwb2xsaW5nIHRoZSBiYWNrZW5kIGZvciB0aGUgY3VycmVudCBibG9ja1xuICogIG51bWJlcjsgd2hlbiBpdCBhZHZhbmNlcywgYWxsIGJsb2NrLWJhc2UgZXZlbnRzIGFyZSB0aGVuIGNoZWNrZWRcbiAqICBmb3IgdXBkYXRlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEpzb25ScGNQcm92aWRlciBleHRlbmRzIEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIge1xuICAgICNjb25uZWN0O1xuICAgIGNvbnN0cnVjdG9yKHVybCwgbmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICBpZiAodXJsID09IG51bGwpIHtcbiAgICAgICAgICAgIHVybCA9IFwiaHR0cDovXFwvbG9jYWxob3N0Ojg1NDVcIjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCA9IG5ldyBGZXRjaFJlcXVlc3QodXJsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QgPSB1cmwuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0Q29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Nvbm5lY3QuY2xvbmUoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICAvLyBBbGwgcmVxdWVzdHMgYXJlIG92ZXIgSFRUUCwgc28gd2UgY2FuIGp1c3Qgc3RhcnQgaGFuZGxpbmcgcmVxdWVzdHNcbiAgICAgICAgLy8gV2UgZG8gdGhpcyBoZXJlIHJhdGhlciB0aGFuIHRoZSBjb25zdHJ1Y3RvciBzbyB0aGF0IHdlIGRvbid0IHNlbmQgYW55XG4gICAgICAgIC8vIHJlcXVlc3RzIHRvIHRoZSBuZXR3b3JrIChpLmUuIGV0aF9jaGFpbklkKSB1bnRpbCB3ZSBhYnNvbHV0ZWx5IGhhdmUgdG8uXG4gICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5zZW5kKG1ldGhvZCwgcGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgX3NlbmQocGF5bG9hZCkge1xuICAgICAgICAvLyBDb25maWd1cmUgYSBQT1NUIGNvbm5lY3Rpb24gZm9yIHRoZSByZXF1ZXN0ZWQgbWV0aG9kXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgIHJlcXVlc3QuYm9keSA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgICAgICByZXF1ZXN0LnNldEhlYWRlcihcImNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgIHJlc3BvbnNlLmFzc2VydE9rKCk7XG4gICAgICAgIGxldCByZXNwID0gcmVzcG9uc2UuYm9keUpzb247XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXNwKSkge1xuICAgICAgICAgICAgcmVzcCA9IFtyZXNwXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcDtcbiAgICB9XG59XG5mdW5jdGlvbiBzcGVsdW5rRGF0YSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBUaGVzZSAqYXJlKiB0aGUgZHJvaWRzIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLm1lc3NhZ2UubWF0Y2goL3JldmVydC9pKSAmJiBpc0hleFN0cmluZyh2YWx1ZS5kYXRhKSkge1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiB2YWx1ZS5tZXNzYWdlLCBkYXRhOiB2YWx1ZS5kYXRhIH07XG4gICAgfVxuICAgIC8vIFNwZWx1bmsgZnVydGhlci4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3BlbHVua0RhdGEodmFsdWVba2V5XSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gTWlnaHQgYmUgYSBKU09OIHN0cmluZyB3ZSBjYW4gZnVydGhlciBkZXNjZW5kLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlbHVua0RhdGEoSlNPTi5wYXJzZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gX3NwZWx1bmtNZXNzYWdlKHZhbHVlLCByZXN1bHQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFRoZXNlICphcmUqIHRoZSBkcm9pZHMgd2UncmUgbG9va2luZyBmb3IuXG4gICAgaWYgKHR5cGVvZiAodmFsdWUubWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUubWVzc2FnZSk7XG4gICAgfVxuICAgIC8vIFNwZWx1bmsgZnVydGhlci4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgX3NwZWx1bmtNZXNzYWdlKHZhbHVlW2tleV0sIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTWlnaHQgYmUgYSBKU09OIHN0cmluZyB3ZSBjYW4gZnVydGhlciBkZXNjZW5kLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gX3NwZWx1bmtNZXNzYWdlKEpTT04ucGFyc2UodmFsdWUpLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxufVxuZnVuY3Rpb24gc3BlbHVua01lc3NhZ2UodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBfc3BlbHVua01lc3NhZ2UodmFsdWUsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWpzb25ycGMuanMubWFwIiwiaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1qc29ucnBjLmpzXCI7XG47XG4vKipcbiAqICBBICoqQnJvd3NlclByb3ZpZGVyKiogaXMgaW50ZW5kZWQgdG8gd3JhcCBhbiBpbmplY3RlZCBwcm92aWRlciB3aGljaFxuICogIGFkaGVyZXMgdG8gdGhlIFtbbGluay1laXAtMTE5M11dIHN0YW5kYXJkLCB3aGljaCBtb3N0IChpZiBub3QgYWxsKVxuICogIGN1cnJlbnRseSBkby5cbiAqL1xuZXhwb3J0IGNsYXNzIEJyb3dzZXJQcm92aWRlciBleHRlbmRzIEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIge1xuICAgICNyZXF1ZXN0O1xuICAgIC8qKlxuICAgICAqICBDb25ubmVjdCB0byB0aGUgJSVldGhlcmV1bSUlIHByb3ZpZGVyLCBvcHRpb25hbGx5IGZvcmNpbmcgdGhlXG4gICAgICogICUlbmV0d29yayUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGV0aGVyZXVtLCBuZXR3b3JrKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIHsgYmF0Y2hNYXhDb3VudDogMSB9KTtcbiAgICAgICAgdGhpcy4jcmVxdWVzdCA9IGFzeW5jIChtZXRob2QsIHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHsgbWV0aG9kLCBwYXJhbXMgfTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRFaXAxMTkzUmVxdWVzdFwiLCBwYXlsb2FkIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldGhlcmV1bS5yZXF1ZXN0KHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFaXAxMTkzUmVzdWx0XCIsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSBlLmNvZGU7XG4gICAgICAgICAgICAgICAgZXJyb3IuZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgICAgICAgICBlcnJvci5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlRWlwMTE5M0Vycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5zZW5kKG1ldGhvZCwgcGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgX3NlbmQocGF5bG9hZCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCghQXJyYXkuaXNBcnJheShwYXlsb2FkKSwgXCJFSVAtMTE5MyBkb2VzIG5vdCBzdXBwb3J0IGJhdGNoIHJlcXVlc3RcIiwgXCJwYXlsb2FkXCIsIHBheWxvYWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jcmVxdWVzdChwYXlsb2FkLm1ldGhvZCwgcGF5bG9hZC5wYXJhbXMgfHwgW10pO1xuICAgICAgICAgICAgcmV0dXJuIFt7IGlkOiBwYXlsb2FkLmlkLCByZXN1bHQgfV07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICBpZDogcGF5bG9hZC5pZCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHsgY29kZTogZS5jb2RlLCBkYXRhOiBlLmRhdGEsIG1lc3NhZ2U6IGUubWVzc2FnZSB9XG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UnBjRXJyb3IocGF5bG9hZCwgZXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG4gICAgICAgIC8vIEVJUC0xMTkzIGdpdmVzIHVzIHNvbWUgbWFjaGluZS1yZWFkYWJsZSBlcnJvciBjb2Rlcywgc28gcmV3cml0ZVxuICAgICAgICAvLyB0aGVtIGludG8gXG4gICAgICAgIHN3aXRjaCAoZXJyb3IuZXJyb3IuY29kZSB8fCAtMSkge1xuICAgICAgICAgICAgY2FzZSA0MDAxOlxuICAgICAgICAgICAgICAgIGVycm9yLmVycm9yLm1lc3NhZ2UgPSBgZXRoZXJzLXVzZXItZGVuaWVkOiAke2Vycm9yLmVycm9yLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDIwMDpcbiAgICAgICAgICAgICAgICBlcnJvci5lcnJvci5tZXNzYWdlID0gYGV0aGVycy11bnN1cHBvcnRlZDogJHtlcnJvci5lcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldFJwY0Vycm9yKHBheWxvYWQsIGVycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIGBgdHJ1ZWBgIGlmIHRoZSBwcm92aWRlciBtYW5hZ2VzIHRoZSAlJWFkZHJlc3MlJS5cbiAgICAgKi9cbiAgICBhc3luYyBoYXNTaWduZXIoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSk7XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFjY291bnRzLmxlbmd0aCA+IGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBhY2NvdW50cy5maWx0ZXIoKGEpID0+IChhLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MpKS5sZW5ndGggIT09IDA7XG4gICAgfVxuICAgIGFzeW5jIGdldFNpZ25lcihhZGRyZXNzKSB7XG4gICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuaGFzU2lnbmVyKGFkZHJlc3MpKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvL2NvbnN0IHJlc3AgPSBcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNyZXF1ZXN0KFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiLCBbXSk7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJFU1BcIiwgcmVzcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZXJyb3IucGF5bG9hZDtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmdldFJwY0Vycm9yKHBheWxvYWQsIHsgaWQ6IHBheWxvYWQuaWQsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5nZXRTaWduZXIoYWRkcmVzcyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItYnJvd3Nlci5qcy5tYXAiLCJpbXBvcnQgeyBKc29uUnBjU2lnbmVyIH0gZnJvbSBcImV0aGVyc1wiO1xuaW1wb3J0IHsgQnJvd3NlclByb3ZpZGVyIH0gZnJvbSBcImV0aGVyc1wiO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4vL0B0cy1pZ25vcmVcbmV4cG9ydCBjb25zdCBwcm92aWRlciA9IG5ldyBCcm93c2VyUHJvdmlkZXIod2luZG93LmV0aGVyZXVtKTtcblxuLy8gZXhwb3J0IGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xuXG5sZXQgc2lnbmVyOiBKc29uUnBjU2lnbmVyO1xubGV0IHNpZ25lclByb21pc2U6IFByb21pc2U8SnNvblJwY1NpZ25lcj47XG5cbi8vIFByb21wdCB1c2VyIHRvIGVuYWJsZSB0aGVpciB3YWxsZXQsIGlmIG5vdCBhbHJlYWR5IGVuYWJsZWQ6XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2lnbmVyKCkge1xuICBpZiAoc2lnbmVyKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNpZ25lcik7XG4gIGlmIChzaWduZXJQcm9taXNlKSB7XG4gICAgcmV0dXJuIHNpZ25lclByb21pc2U7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWFzeW5jLXByb21pc2UtZXhlY3V0b3JcbiAgc2lnbmVyUHJvbWlzZSA9IG5ldyBQcm9taXNlKGFzeW5jIChyZXMpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgLy9AdHMtaWdub3JlXG4gICAgYXdhaXQgd2luZG93LmV0aGVyZXVtLmVuYWJsZSgpO1xuICAgIHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xuICAgIHJlcyhzaWduZXIpO1xuICB9KTtcblxuICByZXR1cm4gc2lnbmVyUHJvbWlzZTtcbn1cbiIsImV4cG9ydCBpbnRlcmZhY2UgQWN0aXZhdGlvbkZ1bmN0aW9uIHtcbiAgaWQ6IG51bWJlcjtcbiAgY29udGV4dDogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICBtdWx0aXBsaWVyOiBCaWdJbnQ7XG4gIHdlaWdodEluV2F0dDogQmlnSW50O1xufVxuXG5pbnRlcmZhY2UgUHJvcHMge1xuICBhY3RpdmF0aW5nOiBzdHJpbmc7XG4gIGJhbGFuY2U6IHN0cmluZztcbiAgc2VsZWN0ZWRGdW5jdGlvbklkOiBudW1iZXI7XG4gIGFjdGl2YXRpb25GdW5jdGlvbnM6IEFjdGl2YXRpb25GdW5jdGlvbltdO1xufVxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIFBhbmVsKHtcbiAgYWN0aXZhdGluZyxcbiAgYWN0aXZhdGlvbkZ1bmN0aW9ucyxcbiAgc2VsZWN0ZWRGdW5jdGlvbklkLFxuICBiYWxhbmNlLFxufTogUHJvcHMpIHtcbiAgY29uc29sZS5sb2coYWN0aXZhdGlvbkZ1bmN0aW9ucywgc2VsZWN0ZWRGdW5jdGlvbklkKTtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e2FjdGl2YXRpbmcgPT09IFwidW5hY3RpdmF0ZWRcIiA/IFwib3BhY2l0eS0xMDBcIiA6IFwib3BhY2l0eS0wXCJ9XG4gICAgICA+XG4gICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1jZW50ZXJcIj5cbiAgICAgICAgICB7YWN0aXZhdGlvbkZ1bmN0aW9uc1tzZWxlY3RlZEZ1bmN0aW9uSWRdLmNvbnRleHR9XG4gICAgICAgICAgPGJyIC8+XG4gICAgICAgICAgPGJyIC8+XG4gICAgICAgICAge2FjdGl2YXRpb25GdW5jdGlvbnNbc2VsZWN0ZWRGdW5jdGlvbklkXS5kZXNjcmlwdGlvbn1cbiAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICBSZXdhcmQ6e1wiIFwifVxuICAgICAgICAgIHtTdHJpbmcoXG4gICAgICAgICAgICAoYWN0aXZhdGlvbkZ1bmN0aW9uc1tzZWxlY3RlZEZ1bmN0aW9uSWRdLm11bHRpcGxpZXIgYXMgYmlnaW50KSAqXG4gICAgICAgICAgICAgIChhY3RpdmF0aW9uRnVuY3Rpb25zW3NlbGVjdGVkRnVuY3Rpb25JZF0ud2VpZ2h0SW5XYXR0IGFzIGJpZ2ludCksXG4gICAgICAgICAgKX17XCIgXCJ9XG4gICAgICAgICAgVmVyaWZpY2F0aW9uIFdBVFRcbiAgICAgICAgPC9wPlxuICAgICAgPC9kaXY+XG4gICAgICB7YWN0aXZhdGluZyA9PT0gXCJhY3RpdmF0aW5nXCIgJiYgKFxuICAgICAgICA8aW1nXG4gICAgICAgICAgc3JjPVwiLi9hc3NldHMvbG9hZGluZy5wbmdcIlxuICAgICAgICAgIGFsdD1cIkxvYWRpbmcuLi5cIlxuICAgICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIHRvcC0xNiB3LTIwIGgtMjBcIlxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICAgIHthY3RpdmF0aW5nID09PSBcImFjdGl2YXRlZFwiICYmIDxkaXY+YWN0aXZhdGVkICR7YmFsYW5jZX0gV0FUVFM8L2Rpdj59XG4gICAgPC8+XG4gICk7XG59XG4iLCJleHBvcnQgY29uc3QgY29udHJhY3RBQkk6IGFueVtdID0gW1xuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiX3BvQ1wiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIixcbiAgfSxcbiAge1xuICAgIGFub255bW91czogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcImFjdGl2YXRpb25GdW5jdGlvbklkXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwiQWN0aXZhdGlvbkZ1bmN0aW9uQXBwcm92ZWRcIixcbiAgICB0eXBlOiBcImV2ZW50XCIsXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJhY3RpdmF0aW9uRnVuY3Rpb25JZFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcImRldmVsb3BlclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIG5hbWU6IFwiY29udGV4dFwiLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwiQWN0aXZhdGlvbkZ1bmN0aW9uUmVnaXN0ZXJlZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgfSxcbiAge1xuICAgIGFub255bW91czogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcImFkZHJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJEZWJ1Z0FkZHJlc3NcIixcbiAgICB0eXBlOiBcImV2ZW50XCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJhY3RpdmF0aW9uRnVuY3Rpb25JZFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBuYW1lOiBcImFjdGl2YXRlXCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJhY3RpdmF0aW9uRnVuY3Rpb25zXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcImlzc3VlclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgIG5hbWU6IFwiYXBwcm92ZWRcIixcbiAgICAgICAgdHlwZTogXCJib29sXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiZW51bSBOZXdjb2luRW5jb2Rlci5XYXR0VHlwZVwiLFxuICAgICAgICBuYW1lOiBcIndhdHRUeXBlXCIsXG4gICAgICAgIHR5cGU6IFwidWludDhcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwibXVsdGlwbGllclwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJieXRlczMyXCIsXG4gICAgICAgIG5hbWU6IFwiY29udGV4dElkXCIsXG4gICAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBuYW1lOiBcImNvbnRleHRcIixcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgbmFtZTogXCJkZXNjcmlwdGlvblwiLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJhZGRyc3NcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIndlaWdodEluV2F0dFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgIG5hbWU6IFwiaXNBc3luY1wiLFxuICAgICAgICB0eXBlOiBcImJvb2xcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcImFjdGl2YXRpb25GdW5jdGlvbklkXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwiYXBwcm92ZUFjdGl2YXRpb25GdW5jdGlvblwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiYWN0aXZhdGlvbkZ1bmN0aW9uSWRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJjYW5NaW50XCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImJvb2xcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJnZXRBcHByb3ZlZEFjdGl2YXRpb25GdW5jdGlvbnNcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgbmFtZTogXCJpc3N1ZXJcIixcbiAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgICAgIG5hbWU6IFwiYXBwcm92ZWRcIixcbiAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImVudW0gTmV3Y29pbkVuY29kZXIuV2F0dFR5cGVcIixcbiAgICAgICAgICAgIG5hbWU6IFwid2F0dFR5cGVcIixcbiAgICAgICAgICAgIHR5cGU6IFwidWludDhcIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICBuYW1lOiBcIm11bHRpcGxpZXJcIixcbiAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICAgICAgICAgIG5hbWU6IFwiY29udGV4dElkXCIsXG4gICAgICAgICAgICB0eXBlOiBcImJ5dGVzMzJcIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIG5hbWU6IFwiY29udGV4dFwiLFxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIG5hbWU6IFwiZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgbmFtZTogXCJhZGRyc3NcIixcbiAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgIG5hbWU6IFwid2VpZ2h0SW5XYXR0XCIsXG4gICAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgICAgICBuYW1lOiBcImlzQXN5bmNcIixcbiAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGludGVybmFsVHlwZTogXCJzdHJ1Y3QgTmV3Y29pbkVuY29kZXIuQWN0aXZhdGlvbkZ1bmN0aW9uW11cIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ0dXBsZVtdXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgbmFtZTogXCJjb25kaXRpb25NZXRcIixcbiAgICAgICAgdHlwZTogXCJib29sXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcImFjdGl2YXRpb25GdW5jdGlvbklkXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwib3JhY2xlUmVzcG9uc2VcIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJvd25lclwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwicG9DXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiY29udHJhY3QgRW5lcmd5TWludGVyTW9ja1wiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiZW51bSBOZXdjb2luRW5jb2Rlci5XYXR0VHlwZVwiLFxuICAgICAgICBuYW1lOiBcIl93YXR0VHlwZVwiLFxuICAgICAgICB0eXBlOiBcInVpbnQ4XCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIl9tdWx0aXBsaWVyXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICAgICAgbmFtZTogXCJfY29udGV4dElkXCIsXG4gICAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBuYW1lOiBcIl9jb250ZXh0XCIsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIG5hbWU6IFwiX2Rlc2NyaXB0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIl9hZGRyc3NcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIl93ZWlnaHRJbldhdHRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLFxuICAgICAgICBuYW1lOiBcIl9pc0FzeW5jXCIsXG4gICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwicmVnaXN0ZXJBY3RpdmF0aW9uRnVuY3Rpb25cIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuXTtcbiIsImltcG9ydCB7IGV0aGVycywgQmFzZUNvbnRyYWN0LCBUcmFuc2FjdGlvblJlc3BvbnNlIH0gZnJvbSBcImV0aGVyc1wiO1xuaW1wb3J0IHsgcHJvdmlkZXIgfSBmcm9tIFwiLi4vZXRoZXJzUHJvdmlkZXJcIjtcbmltcG9ydCB7IGNvbnRyYWN0QUJJIH0gZnJvbSBcIi4vYWJpXCI7XG5pbXBvcnQgeyBBY3RpdmF0aW9uRnVuY3Rpb24gfSBmcm9tIFwiLi4vLi4vY29tcG9uZW50cy9QYW5lbFwiO1xuXG5jb25zdCBjb250cmFjdEFkZHJlc3MgPSBcIjB4ODQzODdlM2FkMDYyRDY4M0JGYzdlRDJFZWFmMkMzMEIyN0JkM2QwNVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEVuY29kZXJDb250cmFjdCBleHRlbmRzIEJhc2VDb250cmFjdCB7XG4gIGFjdGl2YXRlKGlkOiBudW1iZXIpOiBQcm9taXNlPFRyYW5zYWN0aW9uUmVzcG9uc2U+O1xuICBnZXRBcHByb3ZlZEFjdGl2YXRpb25GdW5jdGlvbnMoKTogUHJvbWlzZTxBY3RpdmF0aW9uRnVuY3Rpb25bXT47XG59XG5cbmV4cG9ydCBjb25zdCBlbmNvZGVyQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KFxuICBjb250cmFjdEFkZHJlc3MsXG4gIGNvbnRyYWN0QUJJLFxuICBwcm92aWRlcixcbik7XG5cbmV4cG9ydCBjb25zdCBlbmNvZGVyQ29udHJhY3RGYWN0b3J5ID0gKGFkZHJlc3M6IHN0cmluZykgPT4gbmV3IGV0aGVycy5Db250cmFjdChcbiAgYWRkcmVzcyB8fCBjb250cmFjdEFkZHJlc3MsXG4gIGNvbnRyYWN0QUJJLFxuICBwcm92aWRlcixcbik7XG5cbi8vIGVuY29kZXJDb250cmFjdC5jb25uZWN0KHNpZ25lcik7XG4iLCJleHBvcnQgY29uc3QgY29udHJhY3RBQkk6IGFueVtdID0gW1xuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIixcbiAgfSxcbiAge1xuICAgIGFub255bW91czogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJieXRlczMyXCIsXG4gICAgICAgIG5hbWU6IFwiaWRcIixcbiAgICAgICAgdHlwZTogXCJieXRlczMyXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJDaGFpbmxpbmtDYW5jZWxsZWRcIixcbiAgICB0eXBlOiBcImV2ZW50XCIsXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgICBuYW1lOiBcImlkXCIsXG4gICAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwiQ2hhaW5saW5rRnVsZmlsbGVkXCIsXG4gICAgdHlwZTogXCJldmVudFwiLFxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICAgICAgbmFtZTogXCJpZFwiLFxuICAgICAgICB0eXBlOiBcImJ5dGVzMzJcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBuYW1lOiBcIkNoYWlubGlua1JlcXVlc3RlZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgfSxcbiAge1xuICAgIGFub255bW91czogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiZnJvbVwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwidG9cIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJPd25lcnNoaXBUcmFuc2ZlclJlcXVlc3RlZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgfSxcbiAge1xuICAgIGFub255bW91czogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiZnJvbVwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwidG9cIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJPd25lcnNoaXBUcmFuc2ZlcnJlZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgfSxcbiAge1xuICAgIGFub255bW91czogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwicmVxdWVzdGVyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwiUmVxdWVzdEZ1bGZpbGxlZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJhY2NlcHRPd25lcnNoaXBcIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIl9hY3RpdmF0aW9uRnVuY3Rpb25JZFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBuYW1lOiBcImFjdGl2YXRlXCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICAgICAgbmFtZTogXCJyZXF1ZXN0SWRcIixcbiAgICAgICAgdHlwZTogXCJieXRlczMyXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLFxuICAgICAgICBuYW1lOiBcImRhdGFcIixcbiAgICAgICAgdHlwZTogXCJib29sXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJmdWxmaWxsXCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwiZ2V0RmVlSW5IdW5kcmVkdGhzT2ZMaW5rXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJnZXRKb2JJZFwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcImdldE9yYWNsZUFkZHJlc3NcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcIm93bmVyXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBuYW1lOiBcInBhc3Nwb3J0SG9sZGVyc1wiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJib29sXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwicmVxdWVzdFwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJieXRlczMyXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwicmVxdWVzdGVyc1wiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwicmVzcG9uc2VcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX2ZlZUluSHVuZHJlZHRoc09mTGlua1wiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBuYW1lOiBcInNldEZlZUluSHVuZHJlZHRoc09mTGlua1wiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX2ZlZUluSnVlbHNcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJzZXRGZWVJbkp1ZWxzXCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBuYW1lOiBcIl9qb2JJZFwiLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwic2V0Sm9iSWRcIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIl9vcmFjbGVBZGRyZXNzXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwic2V0T3JhY2xlQWRkcmVzc1wiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwidG9cIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogXCJ0cmFuc2Zlck93bmVyc2hpcFwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcIndpdGhkcmF3TGlua1wiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuXTtcbiIsImltcG9ydCB7IGV0aGVycyB9IGZyb20gXCJldGhlcnNcIjtcbmltcG9ydCB7IHByb3ZpZGVyIH0gZnJvbSBcIi4uL2V0aGVyc1Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBjb250cmFjdEFCSSB9IGZyb20gXCIuL2FiaVwiO1xuaW1wb3J0IHsgQmFzZUNvbnRyYWN0IH0gZnJvbSBcImV0aGVyc1wiO1xuXG5jb25zdCBjb250cmFjdEFkZHJlc3MgPSBcIjB4ZjE5MkVlNWE5ZkI5QUUzQThkZWU3OTY2OUNGZDJCQThDODQ0MWQ5Y1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEd1aWxkR2l0Y29pblBhc3Nwb3J0Q29udHJhY3QgZXh0ZW5kcyBCYXNlQ29udHJhY3Qge1xuICByZXF1ZXN0KCk6IFByb21pc2U8dm9pZD47XG59XG5cbmV4cG9ydCBjb25zdCBndWlsZEFGQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KFxuICBjb250cmFjdEFkZHJlc3MsXG4gIGNvbnRyYWN0QUJJLFxuICBwcm92aWRlcixcbik7XG5cblxuZXhwb3J0IGNvbnN0IGd1aWxkQUZDb250cmFjdEZhY3RvcnkgPSAoYWRkcmVzczogc3RyaW5nKSA9PiBuZXcgZXRoZXJzLkNvbnRyYWN0KFxuICBhZGRyZXNzIHx8IGNvbnRyYWN0QWRkcmVzcyxcbiAgY29udHJhY3RBQkksXG4gIHByb3ZpZGVyLFxuKTtcblxuLy8gZ2V0U2lnbmVyKCkudGhlbigoc2lnbmVyKSA9PiBndWlsZEFGQ29udHJhY3QuY29ubmVjdChzaWduZXIpKTtcblxuXG4iLCJleHBvcnQgY29uc3QgY29udHJhY3RBQkk6IGFueVtdID0gW1xuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiYWNjb3VudFwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50OFwiLFxuICAgICAgICBuYW1lOiBcImlkXCIsXG4gICAgICAgIHR5cGU6IFwidWludDhcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBuYW1lOiBcImJhbGFuY2VPZkVuZXJneVwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJhY2NvdW50XCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwiYmFsYW5jZU9mV2F0dHNcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiYWNjb3VudFwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50OFwiLFxuICAgICAgICBuYW1lOiBcImlkXCIsXG4gICAgICAgIHR5cGU6IFwidWludDhcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiYW1vdW50XCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwibWludFwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQ4XCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwidWludDhcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBuYW1lOiBcIm5ldXJhbFRva2VuQmFsYW5jZXNcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6IFwid2F0dEJhbGFuY2VzXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgfSxcbl07XG4iLCJpbXBvcnQgeyBldGhlcnMsIEJhc2VDb250cmFjdCwgQmlnTnVtYmVyaXNoIH0gZnJvbSBcImV0aGVyc1wiO1xuaW1wb3J0IHsgcHJvdmlkZXIgfSBmcm9tIFwiLi4vZXRoZXJzUHJvdmlkZXJcIjtcbmltcG9ydCB7IGNvbnRyYWN0QUJJIH0gZnJvbSBcIi4vYWJpXCI7XG5cbmNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IFwiMHhmMjcyRmU2MmVFZENCQ2Y3MjIxRDg0NTFhNjhhODVjM0FGNGZBY0ZlXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2F0dHNDb250cmFjdCBleHRlbmRzIEJhc2VDb250cmFjdCB7XG4gIHJlcXVlc3QoKTogUHJvbWlzZTx2b2lkPjtcbiAgYmFsYW5jZU9mV2F0dHMoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxCaWdOdW1iZXJpc2g+O1xufVxuXG5leHBvcnQgY29uc3Qgd2F0dHNDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoXG4gIGNvbnRyYWN0QWRkcmVzcyxcbiAgY29udHJhY3RBQkksXG4gIHByb3ZpZGVyLFxuKTtcblxuXG5leHBvcnQgY29uc3Qgd2F0dHNDb250cmFjdEZhY3RvcnkgPSAoYWRkcmVzczogc3RyaW5nKSA9PiBuZXcgZXRoZXJzLkNvbnRyYWN0KFxuICBhZGRyZXNzIHx8IGNvbnRyYWN0QWRkcmVzcyxcbiAgY29udHJhY3RBQkksXG4gIHByb3ZpZGVyLFxuKTtcblxuLy8gZ2V0U2lnbmVyKCkudGhlbigoc2lnbmVyKSA9PiB3YXR0c0NvbnRyYWN0LmNvbm5lY3Qoc2lnbmVyKSk7XG5cbiIsIi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2F3bWxlZXIvdXNlLWFzeW5jLW1lbW8vYmxvYi9tYXN0ZXIvc3JjL2luZGV4LnRzXG5cbmltcG9ydCB7RGVwZW5kZW5jeUxpc3QsIHVzZUVmZmVjdCwgdXNlU3RhdGV9IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlQXN5bmNNZW1vPFQ+KGZhY3Rvcnk6ICgpID0+IFByb21pc2U8VD4gfCB1bmRlZmluZWQgfCBudWxsLCBkZXBzOiBEZXBlbmRlbmN5TGlzdCk6IFQgfCB1bmRlZmluZWRcbmV4cG9ydCBmdW5jdGlvbiB1c2VBc3luY01lbW88VD4oZmFjdG9yeTogKCkgPT4gUHJvbWlzZTxUPiB8IHVuZGVmaW5lZCB8IG51bGwsIGRlcHM6IERlcGVuZGVuY3lMaXN0LCBpbml0aWFsOiBUKTogVFxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFzeW5jTWVtbzxUPihmYWN0b3J5OiAoKSA9PiBQcm9taXNlPFQ+IHwgdW5kZWZpbmVkIHwgbnVsbCwgZGVwczogRGVwZW5kZW5jeUxpc3QsIGluaXRpYWw/OiBUKSB7XG4gIGNvbnN0IFt2YWwsIHNldFZhbF0gPSB1c2VTdGF0ZTxUIHwgdW5kZWZpbmVkPihpbml0aWFsKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBjYW5jZWwgPSBmYWxzZVxuICAgIGNvbnN0IHByb21pc2UgPSBmYWN0b3J5KClcbiAgICBpZiAocHJvbWlzZSA9PT0gdW5kZWZpbmVkIHx8IHByb21pc2UgPT09IG51bGwpIHJldHVyblxuICAgIHByb21pc2UudGhlbigodmFsKSA9PiB7XG4gICAgICBpZiAoIWNhbmNlbCkge1xuICAgICAgICBzZXRWYWwodmFsKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbCA9IHRydWVcbiAgICB9XG4gIH0sIGRlcHMpXG4gIHJldHVybiB2YWxcbn0iLCJpbXBvcnQgeyBDb250cmFjdFR5cGUgfSBmcm9tIFwiLi4vY29udHJhY3RzXCI7XG5pbXBvcnQge1xuICBFbmNvZGVyQ29udHJhY3QsXG4gIGVuY29kZXJDb250cmFjdCxcbn0gZnJvbSBcIi4uL2NvbnRyYWN0cy9FbmNvZGVyQ29udHJhY3QvY29udHJhY3RcIjtcbmltcG9ydCB7IGdldFNpZ25lciB9IGZyb20gXCIuLi9jb250cmFjdHMvZXRoZXJzUHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIEd1aWxkR2l0Y29pblBhc3Nwb3J0Q29udHJhY3QsXG4gIGd1aWxkQUZDb250cmFjdCxcbn0gZnJvbSBcIi4uL2NvbnRyYWN0cy9ndWlsZEFGQ29udHJhY3QvY29udHJhY3RcIjtcbmltcG9ydCB7XG4gIFdhdHRzQ29udHJhY3QsXG4gIHdhdHRzQ29udHJhY3QsXG59IGZyb20gXCIuLi9jb250cmFjdHMvd2F0dHNDb250cmFjdC9jb250cmFjdFwiO1xuaW1wb3J0IHsgdXNlQXN5bmNNZW1vIH0gZnJvbSBcIi4uL3V0aWxzL3VzZUFzeW5jTWVtb1wiO1xuXG50eXBlIEJ1dHRvblByb3BzID0gUmVhY3QuRGV0YWlsZWRIVE1MUHJvcHM8XG4gIFJlYWN0LkJ1dHRvbkhUTUxBdHRyaWJ1dGVzPEhUTUxCdXR0b25FbGVtZW50PixcbiAgSFRNTEJ1dHRvbkVsZW1lbnRcbj47XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gIGFjdGl2YXRpbmc6IHN0cmluZztcbiAgc2V0QWN0aXZhdGluZzogKGFjdGl2YXRpbmc6IHN0cmluZykgPT4gdm9pZDtcbiAgLy8gYmFsYW5jZTogc3RyaW5nO1xuICBzZXRCYWxhbmNlOiAoYmFsYW5jZTogc3RyaW5nKSA9PiB2b2lkO1xuICBzZWxlY3RlZEZ1bmN0aW9uSWQ/OiBudW1iZXI7XG4gIHJlbmRlcj86IChwcm9wczogQnV0dG9uUHJvcHMpID0+IEpTWC5FbGVtZW50O1xuICBjb250cmFjdFR5cGU/OiBDb250cmFjdFR5cGU7XG4gIGNvbnRyYWN0QWRkcmVzcz86IHN0cmluZztcbn1cblxudHlwZSBBY3RpdmF0ZVBhcmFtcyA9IHtcbiAgc2VsZWN0ZWRGdW5jdGlvbklkOiBudW1iZXI7XG4gIGNvbnRyYWN0VHlwZTogQ29udHJhY3RUeXBlO1xuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgcGFyYW1zOiBhbnlbXTtcbn07XG5cbmV4cG9ydCBjb25zdCB1c2VCdXR0b24gPSAoe1xuICBzZXRBY3RpdmF0aW5nLFxuICBzZXRCYWxhbmNlLFxuICBzZWxlY3RlZEZ1bmN0aW9uSWQ6IF9zZWxlY3RlZEZ1bmN0aW9uSWQsXG4gIGNvbnRyYWN0VHlwZTogX2NvbnRyYWN0VHlwZSxcbiAgY29udHJhY3RBZGRyZXNzOiBfY29udHJhY3RBZGRyZXNzLFxufTogUHJvcHMpID0+IHtcbiAgY29uc3QgYWN0aXZhdGUgPSBhc3luYyAoYXJncz86IEFjdGl2YXRlUGFyYW1zKSA9PiB7XG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgZ2V0U2lnbmVyKCk7XG4gICAgbGV0IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICAgIHNlbGVjdGVkRnVuY3Rpb25JZCxcbiAgICAgIGNvbnRyYWN0VHlwZSxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIC8vIHBhcmFtc1xuICAgIH0gPSBhcmdzIHx8IHt9O1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGNvbnRyYWN0VHlwZSA9IGNvbnRyYWN0VHlwZSB8fCBfY29udHJhY3RUeXBlIHx8IFwiZ3VpbGRBRkNvbnRyYWN0XCI7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGNvbnRyYWN0QWRkcmVzcyA9IGNvbnRyYWN0QWRkcmVzcyB8fCBfY29udHJhY3RBZGRyZXNzIHx8IFwiXCI7XG4gICAgY29uc3Qgc2ZpZCA9XG4gICAgICB0eXBlb2Ygc2VsZWN0ZWRGdW5jdGlvbklkICE9IFwidW5kZWZpbmVkXCJcbiAgICAgICAgPyBzZWxlY3RlZEZ1bmN0aW9uSWRcbiAgICAgICAgOiBfc2VsZWN0ZWRGdW5jdGlvbklkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGd1aWxkQ29udHJhY3RXaXRoU2lnbmVyID0gZ3VpbGRBRkNvbnRyYWN0LmNvbm5lY3QoXG4gICAgICAgIHNpZ25lciFcbiAgICAgICkgYXMgR3VpbGRHaXRjb2luUGFzc3BvcnRDb250cmFjdDtcblxuICAgICAgYXdhaXQgZ3VpbGRDb250cmFjdFdpdGhTaWduZXIucmVxdWVzdCgpO1xuXG4gICAgICAvLyBXYWl0aW5nIGZvciAzIHNlY29uZHMgYWZ0ZXIgdGhlIHJlcXVlc3QgYmVmb3JlIGNhbGxpbmcgYWN0aXZhdGVcbiAgICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZXJDb250cmFjdFdpdGhTaWduZXIgPSBlbmNvZGVyQ29udHJhY3QuY29ubmVjdChcbiAgICAgICAgICAgIHNpZ25lciFcbiAgICAgICAgICApIGFzIEVuY29kZXJDb250cmFjdDtcblxuICAgICAgICAgIC8vIEFjdGl2YXRpbmcgd2l0aCBwYXJhbWV0ZXIgMFxuICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgZW5jb2RlckNvbnRyYWN0V2l0aFNpZ25lci5hY3RpdmF0ZShzZmlkISk7XG5cbiAgICAgICAgICAvLyBXYWl0aW5nIGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgbWluZWRcbiAgICAgICAgICBhd2FpdCB0eC53YWl0KCk7XG5cbiAgICAgICAgICAvLyBDaGVjayB0aGUgYmFsYW5jZU9mV2F0dHNcbiAgICAgICAgICBjaGVja0JhbGFuY2UoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZHVyaW5nIGFjdGl2YXRpb246IFwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSwgNjAwMDApOyAvLyA2MDAwMG1zID0gNjBzXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coXCJFcnJvciBkdXJpbmcgcmVxdWVzdDogXCIsIGUpO1xuICAgIH1cbiAgICBzZXRBY3RpdmF0aW5nKFwiYWN0aXZhdGluZ1wiKTtcblxuICAgIC8vIGNvbnRyYWN0VHlwZSA9IGNvbnRyYWN0VHlwZSB8fCBfY29udHJhY3RUeXBlIHx8IFwiZ3VpbGRBRkNvbnRyYWN0XCI7XG4gICAgLy8gY29udHJhY3RBZGRyZXNzID0gY29udHJhY3RBZGRyZXNzIHx8IF9jb250cmFjdEFkZHJlc3MgfHwgXCJcIjtcbiAgICAvLyBjb25zdCBzZmlkID0gc2VsZWN0ZWRGdW5jdGlvbklkIHx8IF9zZWxlY3RlZEZ1bmN0aW9uSWQ7XG4gICAgLy8gaWYoc2ZpZCA9PSB1bmRlZmluZWQpXG4gICAgLy8gICByZXR1cm4gY29uc29sZS53YXJuKFwiTm8gZnVuY3Rpb24gaWQgcHJvdmlkZWRcIik7XG5cbiAgICAvLyBjb25zdCB7IGZhY3RvcnksIGFjdGl2YXRpb25NZXRob2QgfSA9IGNvbnRyYWN0VHlwZXNbY29udHJhY3RUeXBlXTtcbiAgICAvLyBjb25zdCBjb250cmFjdCA9IGZhY3RvcnkoY29udHJhY3RBZGRyZXNzKVxuXG4gICAgLy8gdHJ5IHtcbiAgICAvLyAgIGNvbnN0IGNvbnRyYWN0V2l0aFNpZ25lciA9IGNvbnRyYWN0LmNvbm5lY3QoXG4gICAgLy8gICAgIHNpZ25lciEsXG4gICAgLy8gICApIGFzIENvbXBhdGlibGVDb250cmFjdDtcblxuICAgIC8vICAgLy8gY29uc3QgY29udHJhY3RXaXRoU2lnbmVyID0gY29udHJhY3RXaXRoU2lnbmVyLmNvbm5lY3QoXG4gICAgLy8gICAvLyAgIHNpZ25lciEsXG4gICAgLy8gICAvLyApIGFzIENvbXBhdGlibGVDb250cmFjdDtcblxuICAgIC8vICAgLy9AdHMtaWdub3JlXG4gICAgLy8gICBhd2FpdCBjb250cmFjdFdpdGhTaWduZXIucmVxdWVzdCgpO1xuXG4gICAgLy8gICAvLyBXYWl0aW5nIGZvciAzIHNlY29uZHMgYWZ0ZXIgdGhlIHJlcXVlc3QgYmVmb3JlIGNhbGxpbmcgYWN0aXZhdGVcbiAgICAvLyAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgIC8vICAgICB0cnkge1xuXG4gICAgLy8gICAgICAgLy8gQWN0aXZhdGluZyB3aXRoIHBhcmFtZXRlciAwXG4gICAgLy8gICAgICAgY29uc3QgdHggPVxuICAgIC8vICAgICAgICAgYXdhaXQgY29udHJhY3RXaXRoU2lnbmVyW2FjdGl2YXRpb25NZXRob2RdKHNlbGVjdGVkRnVuY3Rpb25JZCk7XG5cbiAgICAvLyAgICAgICAvLyBXYWl0aW5nIGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgbWluZWRcbiAgICAvLyAgICAgICBhd2FpdCB0eC53YWl0KCk7XG5cbiAgICAvLyAgICAgICAvLyBDaGVjayB0aGUgYmFsYW5jZU9mV2F0dHNcbiAgICAvLyAgICAgICBjaGVja0JhbGFuY2UoKTtcbiAgICAvLyAgICAgfSBjYXRjaCAoZSkge1xuICAgIC8vICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZHVyaW5nIGFjdGl2YXRpb246IFwiLCBlKTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgfSwgNjAwMDApOyAvLyA2MDAwMG1zID0gNjBzXG4gICAgLy8gfSBjYXRjaCAoZSkge1xuICAgIC8vICAgY29uc29sZS5sb2coXCJFcnJvciBkdXJpbmcgcmVxdWVzdDogXCIsIGUpO1xuICAgIC8vIH1cbiAgICAvLyBzZXRBY3RpdmF0aW5nKFwiYWN0aXZhdGluZ1wiKTtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiB0byBjaGVjayB0aGUgYmFsYW5jZSBvZiBXYXR0c1xuICBjb25zdCBjaGVja0JhbGFuY2UgPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgY29uc3Qgc2lnbmVyID0gdXNlQXN5bmNNZW1vKGdldFNpZ25lciwgW10pO1xuXG4gICAgY29uc3Qgd2F0dHNDb250cmFjdFdpdGhTaWduZXIgPSB3YXR0c0NvbnRyYWN0LmNvbm5lY3QoXG4gICAgICBzaWduZXIhXG4gICAgKSBhcyBXYXR0c0NvbnRyYWN0O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgc2lnbmVyIS5nZXRBZGRyZXNzKCk7XG4gICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgd2F0dHNDb250cmFjdFdpdGhTaWduZXIuYmFsYW5jZU9mV2F0dHMoYWRkcmVzcyk7XG4gICAgICBjb25zb2xlLmxvZyhcIkJhbGFuY2Ugb2YgV2F0dHM6IFwiLCBiYWxhbmNlLnRvU3RyaW5nKCkpO1xuICAgICAgc2V0QmFsYW5jZShiYWxhbmNlLnRvU3RyaW5nKCkpO1xuICAgICAgc2V0QWN0aXZhdGluZyhcImFjdGl2YXRlZFwiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGZldGNoaW5nIGJhbGFuY2U6IFwiLCBlKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBhY3RpdmF0ZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEJ1dHRvbih7XG4gIGFjdGl2YXRpbmcsXG4gIHNldEFjdGl2YXRpbmcsXG4gIHNldEJhbGFuY2UsXG4gIHNlbGVjdGVkRnVuY3Rpb25JZCxcbiAgcmVuZGVyLFxufTogUHJvcHMpIHtcbiAgY29uc3Qgc2lnbmVyID0gdXNlQXN5bmNNZW1vKGdldFNpZ25lciwgW10pO1xuXG4gIGNvbnN0IHsgYWN0aXZhdGUgfSA9IHVzZUJ1dHRvbih7XG4gICAgYWN0aXZhdGluZyxcbiAgICBzZXRBY3RpdmF0aW5nLFxuICAgIHNldEJhbGFuY2UsXG4gICAgc2VsZWN0ZWRGdW5jdGlvbklkLFxuICB9KTtcblxuICBjb25zdCBCdXR0b25Db21wID0gcmVuZGVyIHx8ICgocHJvcHM6IEJ1dHRvblByb3BzKSA9PiA8YnV0dG9uIHsuLi5wcm9wc30gLz4pO1xuXG4gIGlmICghc2lnbmVyKSByZXR1cm4gPD5XYWl0Li4uPC8+O1xuXG4gIHJldHVybiAoXG4gICAgPEJ1dHRvbkNvbXBcbiAgICAgIG9uQ2xpY2s9eygpID0+IGFjdGl2YXRlKCl9XG4gICAgICBjbGFzc05hbWU9e2BweS0yIHB4LTQgdGV4dC13aGl0ZSByb3VuZGVkLWZ1bGwgdy00MCAke1xuICAgICAgICBhY3RpdmF0aW5nID09PSBcImFjdGl2YXRpbmdcIiA/IFwiYmctZ3JheS00MDBcIiA6IFwiYmctYmxhY2tcIlxuICAgICAgfWB9XG4gICAgICBkaXNhYmxlZD17YWN0aXZhdGluZyA9PT0gXCJhY3RpdmF0aW5nXCJ9XG4gICAgPlxuICAgICAge2FjdGl2YXRpbmcgPT09IFwiYWN0aXZhdGluZ1wiID8gXCJBY3RpdmF0aW5nXCIgOiBcIkFjdGl2YXRlXCJ9XG4gICAgPC9CdXR0b25Db21wPlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgQWN0aXZhdGlvbkZ1bmN0aW9uIH0gZnJvbSBcIi4vUGFuZWxcIjtcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgYWN0aXZhdGlvbkZ1bmN0aW9uczogQWN0aXZhdGlvbkZ1bmN0aW9uW107XG4gIHNlbGVjdGVkRnVuY3Rpb25JZDogbnVtYmVyO1xuICBzZXRTZWxlY3RlZEZ1bmN0aW9uSWQ6IChpZDogbnVtYmVyKSA9PiB2b2lkO1xufVxuXG5mdW5jdGlvbiBEcm9wZG93bih7XG4gIGFjdGl2YXRpb25GdW5jdGlvbnMsXG4gIHNldFNlbGVjdGVkRnVuY3Rpb25JZCxcbiAgc2VsZWN0ZWRGdW5jdGlvbklkLFxufTogUHJvcHMpIHtcbiAgLy8gSGFuZGxlIGRyb3Bkb3duIGNoYW5nZVxuICBjb25zdCBoYW5kbGVDaGFuZ2UgPSAoZXZlbnQ6IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxTZWxlY3RFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHZhbHVlQXNOdW1iZXIgPSBOdW1iZXIoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICBzZXRTZWxlY3RlZEZ1bmN0aW9uSWQodmFsdWVBc051bWJlcik7XG4gIH07XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhzZWxlY3RlZEZ1bmN0aW9uSWQpO1xuICB9LCBbc2VsZWN0ZWRGdW5jdGlvbklkXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8c2VsZWN0XG4gICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfVxuICAgICAgdmFsdWU9e3NlbGVjdGVkRnVuY3Rpb25JZH1cbiAgICAgIGNsYXNzTmFtZT17YHB5LTIgcHgtNCB0ZXh0LXhzIHRleHQtYmxhY2sgcm91bmRlZC1mdWxsIHctNDAgYm9yZGVyIGJvcmRlci1ibGFjayAkeyFzZWxlY3RlZEZ1bmN0aW9uSWQgPyBcImJnLXdoaXRlXCIgOiBcImJnLWdyYXktMjAwXCJcbiAgICAgICAgfWB9XG4gICAgPlxuICAgICAgPG9wdGlvbiB2YWx1ZT1cIlwiIGRpc2FibGVkPlxuICAgICAgICBTZWxlY3QgYW4gYWN0aXZhdGlvbiBmdW5jdGlvblxuICAgICAgPC9vcHRpb24+XG4gICAgICB7YWN0aXZhdGlvbkZ1bmN0aW9ucy5tYXAoKGZ1bmMsIGluZGV4KSA9PiAoXG4gICAgICAgIDxvcHRpb24ga2V5PXtmdW5jLmlkfSB2YWx1ZT17aW5kZXh9PlxuICAgICAgICAgIHtmdW5jLmNvbnRleHR9IHtmdW5jLmlkfVxuICAgICAgICA8L29wdGlvbj5cbiAgICAgICkpfVxuICAgIDwvc2VsZWN0PlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBEcm9wZG93bjtcbiIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBnZXRTaWduZXIgfSBmcm9tIFwiLi9jb250cmFjdHMvZXRoZXJzUHJvdmlkZXJcIjtcbmltcG9ydCB7IEFjdGl2YXRpb25GdW5jdGlvbiwgUGFuZWwgfSBmcm9tIFwiLi9jb21wb25lbnRzL1BhbmVsXCI7XG5pbXBvcnQgQnV0dG9uLCB7IHVzZUJ1dHRvbiB9IGZyb20gXCIuL2NvbXBvbmVudHMvQnV0dG9uLnRzeFwiO1xuaW1wb3J0IERyb3Bkb3duIGZyb20gXCIuL2NvbXBvbmVudHMvRHJvcGRvd25cIjtcbmltcG9ydCB7XG4gIEVuY29kZXJDb250cmFjdCxcbiAgZW5jb2RlckNvbnRyYWN0LFxufSBmcm9tIFwiLi9jb250cmFjdHMvRW5jb2RlckNvbnRyYWN0L2NvbnRyYWN0XCI7XG5pbXBvcnQgeyB1c2VBc3luY01lbW8gfSBmcm9tIFwiLi91dGlscy91c2VBc3luY01lbW9cIjtcblxuZXhwb3J0IHsgdXNlQnV0dG9uIH07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1yZWZyZXNoL29ubHktZXhwb3J0LWNvbXBvbmVudHNcbmV4cG9ydCBjb25zdCB1c2VBY3RpdmF0aW9uRnVuY3Rpb25zID0gKFxuICBjb250cmFjdEFkZHJlc3M/OiBzdHJpbmcsXG4gIGF1dG9jb25uZWN0PzogYm9vbGVhblxuKSA9PiB7XG4gIGNvbnN0IFthY3RpdmF0aW5nLCBzZXRBY3RpdmF0aW5nXSA9IHVzZVN0YXRlKFwidW5hY3RpdmF0ZWRcIik7XG4gIGNvbnN0IFtiYWxhbmNlLCBzZXRCYWxhbmNlXSA9IHVzZVN0YXRlKFwiMFwiKTtcbiAgY29uc3QgW3NlbGVjdGVkRnVuY3Rpb25JZCwgc2V0U2VsZWN0ZWRGdW5jdGlvbklkXSA9IHVzZVN0YXRlKDApO1xuXG4gIC8vIGNvbnN0IFthY3RpdmF0aW9uRnVuY3Rpb25zLCBzZXRBY3RpdmF0aW9uRnVuY3Rpb25zXSA9IHVzZVN0YXRlPFxuICAvLyAgIEFjdGl2YXRpb25GdW5jdGlvbltdXG4gIC8vID4oW10pO1xuICBjb25zdCBbZG9Db25uZWN0LCBzZXREb0Nvbm5lY3RdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNDb25uZWN0aW5nLCBzZXRJc0Nvbm5lY3RpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNDb25uZWN0ZWQsIHNldElzQ29ubmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICBjb25zdCBjb25uZWN0ID0gKCkgPT4gc2V0RG9Db25uZWN0KHRydWUpO1xuXG4gIGNvbnN0IHNpZ25lciA9IHVzZUFzeW5jTWVtbyhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCEoZG9Db25uZWN0IHx8IGF1dG9jb25uZWN0KSkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgc2V0SXNDb25uZWN0aW5nKHRydWUpO1xuICAgIGNvbnN0IHNpID0gYXdhaXQgZ2V0U2lnbmVyKCk7XG4gICAgd2luZG93LmFsZXJ0KHNpKTtcbiAgICBzZXRJc0Nvbm5lY3RpbmcoZmFsc2UpO1xuICAgIHNldElzQ29ubmVjdGVkKCEhc2kpO1xuXG4gICAgcmV0dXJuIHNpO1xuICB9LCBbZG9Db25uZWN0LCBhdXRvY29ubmVjdF0pO1xuXG4gIGNvbnN0IF9hY3RpdmF0aW9uRnVuY3Rpb25zID0gdXNlQXN5bmNNZW1vKFxuICAgIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IGdldFNpZ25lcigpO1xuICAgICAgaWYgKCFzaWduZXIpIHJldHVybjtcblxuICAgICAgY29uc3QgZW5jb2RlckNvbnRyYWN0V2l0aFNpZ25lciA9IGVuY29kZXJDb250cmFjdC5jb25uZWN0KFxuICAgICAgICBzaWduZXJcbiAgICAgICkgYXMgRW5jb2RlckNvbnRyYWN0O1xuICAgICAgY29uc3QgcHJveHlPYmplY3QgPVxuICAgICAgICBhd2FpdCBlbmNvZGVyQ29udHJhY3RXaXRoU2lnbmVyLmdldEFwcHJvdmVkQWN0aXZhdGlvbkZ1bmN0aW9ucygpO1xuICAgICAgY29uc29sZS5sb2cocHJveHlPYmplY3QpO1xuICAgICAgcmV0dXJuIHByb3h5T2JqZWN0IGFzIEFjdGl2YXRpb25GdW5jdGlvbltdO1xuICAgICAgLy8gc2V0QWN0aXZhdGlvbkZ1bmN0aW9ucyhwcm94eU9iamVjdCBhcyBBY3RpdmF0aW9uRnVuY3Rpb25bXSk7XG4gICAgfSxcbiAgICBbc2lnbmVyLCBjb250cmFjdEFkZHJlc3NdLFxuICAgIFtdIGFzIEFjdGl2YXRpb25GdW5jdGlvbltdXG4gICk7XG5cbiAgY29uc3QgYWN0aXZhdGlvbkZ1bmN0aW9ucyA9IF9hY3RpdmF0aW9uRnVuY3Rpb25zIHx8IFtdO1xuXG4gIGNvbnN0IGRyb3BEb3duID0gKFxuICAgIDxEcm9wZG93blxuICAgICAgc2VsZWN0ZWRGdW5jdGlvbklkPXtzZWxlY3RlZEZ1bmN0aW9uSWR9XG4gICAgICBzZXRTZWxlY3RlZEZ1bmN0aW9uSWQ9e3NldFNlbGVjdGVkRnVuY3Rpb25JZH1cbiAgICAgIGFjdGl2YXRpb25GdW5jdGlvbnM9e2FjdGl2YXRpb25GdW5jdGlvbnN9XG4gICAgLz5cbiAgKTtcblxuICBjb25zdCBwYW5lbCA9IChcbiAgICA8UGFuZWxcbiAgICAgIGFjdGl2YXRpbmc9e2FjdGl2YXRpbmd9XG4gICAgICBhY3RpdmF0aW9uRnVuY3Rpb25zPXthY3RpdmF0aW9uRnVuY3Rpb25zfVxuICAgICAgc2VsZWN0ZWRGdW5jdGlvbklkPXtzZWxlY3RlZEZ1bmN0aW9uSWR9XG4gICAgICBiYWxhbmNlPXtiYWxhbmNlfVxuICAgIC8+XG4gICk7XG5cbiAgY29uc3QgYnV0dG9uUGFyYW1zID0ge1xuICAgIGFjdGl2YXRpbmcsXG4gICAgc2V0QWN0aXZhdGluZyxcbiAgICBiYWxhbmNlLFxuICAgIHNldEJhbGFuY2UsXG4gICAgc2VsZWN0ZWRGdW5jdGlvbklkLFxuICB9O1xuXG4gIGNvbnN0IGJ1dHRvbiA9IChcbiAgICA8QnV0dG9uXG4gICAgICB7Li4uYnV0dG9uUGFyYW1zfVxuICAgICAgLy8gYWN0aXZhdGluZz17YWN0aXZhdGluZ31cbiAgICAgIC8vIHNldEFjdGl2YXRpbmc9e3NldEFjdGl2YXRpbmd9XG4gICAgICAvLyBiYWxhbmNlPXtiYWxhbmNlfVxuICAgICAgLy8gc2V0QmFsYW5jZT17c2V0QmFsYW5jZX1cbiAgICAgIC8vIHNlbGVjdGVkRnVuY3Rpb25JZD17c2VsZWN0ZWRGdW5jdGlvbklkfVxuICAgIC8+XG4gICk7XG5cbiAgY29uc3QgeyBhY3RpdmF0ZSB9ID0gdXNlQnV0dG9uKGJ1dHRvblBhcmFtcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBhY3RpdmF0ZSxcbiAgICBhY3RpdmF0aW9uRnVuY3Rpb25zLFxuICAgIHNldEFjdGl2YXRpbmcsXG4gICAgYWN0aXZhdGluZyxcbiAgICBzZWxlY3RlZEZ1bmN0aW9uSWQsXG4gICAgc2V0U2VsZWN0ZWRGdW5jdGlvbklkLFxuICAgIGJhbGFuY2UsXG4gICAgc2V0QmFsYW5jZSxcblxuICAgIGJ1dHRvbixcbiAgICBwYW5lbCxcbiAgICBkcm9wRG93bixcblxuICAgIGNvbm5lY3QsXG4gICAgaXNDb25uZWN0aW5nLFxuICAgIGlzQ29ubmVjdGVkLFxuICAgIHNpZ25lcixcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFwcCgpIHtcbiAgY29uc3Qge1xuICAgIGFjdGl2YXRpb25GdW5jdGlvbnMsXG4gICAgYWN0aXZhdGluZyxcbiAgICBjb25uZWN0LFxuICAgIGJ1dHRvbixcbiAgICBwYW5lbCxcbiAgICBkcm9wRG93bixcbiAgICBpc0Nvbm5lY3RlZCxcbiAgfSA9IHVzZUFjdGl2YXRpb25GdW5jdGlvbnMoXCIweDg0Mzg3ZTNhZDA2MkQ2ODNCRmM3ZUQyRWVhZjJDMzBCMjdCZDNkMDVcIik7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cIm1pbi1oLXNjcmVlbiBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSBmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gcGwtMiBwci0yIHB0LTggcGItOCBib3JkZXIgYm9yZGVyLWJsYWNrIHctNjQgaC05NlwiPlxuICAgICAgICB7IWlzQ29ubmVjdGVkICYmIDxidXR0b24gb25DbGljaz17KCkgPT4gY29ubmVjdCgpfT5jb25uZWN0PC9idXR0b24+fVxuICAgICAgICA8YnIgLz5cbiAgICAgICAgPGJyIC8+XG4gICAgICAgIHthY3RpdmF0aW9uRnVuY3Rpb25zLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgIDw+XG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICB7YWN0aXZhdGluZyAhPSBcImFjdGl2YXRpbmdcIiAmJiBkcm9wRG93bn1cbiAgICAgICAgICAgICAge3BhbmVsfVxuICAgICAgICAgICAgICB7YnV0dG9ufVxuICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB7Lyoge2FjdGl2YXRpbmcgIT0gXCJhY3RpdmF0aW5nXCIgJiYgKFxuICAgICAgICAgICAgICA8RHJvcGRvd25cbiAgICAgICAgICAgICAgICBzZWxlY3RlZEZ1bmN0aW9uSWQ9e3NlbGVjdGVkRnVuY3Rpb25JZH1cbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZEZ1bmN0aW9uSWQ9e3NldFNlbGVjdGVkRnVuY3Rpb25JZH1cbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uRnVuY3Rpb25zPXthY3RpdmF0aW9uRnVuY3Rpb25zfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDxQYW5lbFxuICAgICAgICAgICAgICBhY3RpdmF0aW5nPXthY3RpdmF0aW5nfVxuICAgICAgICAgICAgICBhY3RpdmF0aW9uRnVuY3Rpb25zPXthY3RpdmF0aW9uRnVuY3Rpb25zfVxuICAgICAgICAgICAgICBzZWxlY3RlZEZ1bmN0aW9uSWQ9e3NlbGVjdGVkRnVuY3Rpb25JZH1cbiAgICAgICAgICAgICAgYmFsYW5jZT17YmFsYW5jZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgIGFjdGl2YXRpbmc9e2FjdGl2YXRpbmd9XG4gICAgICAgICAgICAgIHNldEFjdGl2YXRpbmc9e3NldEFjdGl2YXRpbmd9XG4gICAgICAgICAgICAgIGJhbGFuY2U9e2JhbGFuY2V9XG4gICAgICAgICAgICAgIHNldEJhbGFuY2U9e3NldEJhbGFuY2V9XG4gICAgICAgICAgICAgIHNlbGVjdGVkRnVuY3Rpb25JZD17c2VsZWN0ZWRGdW5jdGlvbklkfVxuICAgICAgICAgICAgLz4gKi99XG4gICAgICAgICAgPC8+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IEFjdGl2YXRpb25CeUNvbnRyYWN0QWRkcmVzcyA9IEFwcDtcbiJdLCJuYW1lcyI6WyJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJoYXNPd25Qcm9wZXJ0eSIsInByb3BJc0VudW1lcmFibGUiLCJ0b09iamVjdCIsInZhbCIsInNob3VsZFVzZU5hdGl2ZSIsInRlc3QxIiwidGVzdDIiLCJpIiwib3JkZXIyIiwibiIsInRlc3QzIiwibGV0dGVyIiwib2JqZWN0QXNzaWduIiwidGFyZ2V0Iiwic291cmNlIiwiZnJvbSIsInRvIiwic3ltYm9scyIsInMiLCJrZXkiLCJyZXF1aXJlJCQwIiwiZiIsInJlcXVpcmUkJDEiLCJnIiwicmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb25fbWluIiwiaCIsIm0iLCJwIiwicSIsImMiLCJhIiwiayIsImIiLCJkIiwiZSIsImwiLCJSZWFjdCIsIl9hc3NpZ24iLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsImV4cG9ydHMiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX0JMT0NLX1RZUEUiLCJSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSIsIlJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUiLCJSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSIsIlJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSIsInN5bWJvbEZvciIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiUmVhY3RTaGFyZWRJbnRlcm5hbHMiLCJlcnJvciIsImZvcm1hdCIsIl9sZW4yIiwiYXJncyIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJhcmdzV2l0aEZvcm1hdCIsIml0ZW0iLCJlbmFibGVTY29wZUFQSSIsImlzVmFsaWRFbGVtZW50VHlwZSIsInR5cGUiLCJnZXRXcmFwcGVkTmFtZSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZnVuY3Rpb25OYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJnZXRDb21wb25lbnROYW1lIiwiY29udGV4dCIsInByb3ZpZGVyIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJpbml0IiwiZGlzYWJsZWREZXB0aCIsInByZXZMb2ciLCJwcmV2SW5mbyIsInByZXZXYXJuIiwicHJldkVycm9yIiwicHJldkdyb3VwIiwicHJldkdyb3VwQ29sbGFwc2VkIiwicHJldkdyb3VwRW5kIiwiZGlzYWJsZWRMb2ciLCJkaXNhYmxlTG9ncyIsInByb3BzIiwicmVlbmFibGVMb2dzIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciIsInByZWZpeCIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwibmFtZSIsIm93bmVyRm4iLCJ4IiwibWF0Y2giLCJyZWVudHJ5IiwiY29tcG9uZW50RnJhbWVDYWNoZSIsIlBvc3NpYmx5V2Vha01hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiY29udHJvbCIsInByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UiLCJwcmV2aW91c0Rpc3BhdGNoZXIiLCJGYWtlIiwic2FtcGxlIiwic2FtcGxlTGluZXMiLCJjb250cm9sTGluZXMiLCJfZnJhbWUiLCJzeW50aGV0aWNGcmFtZSIsImRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSIsInNob3VsZENvbnN0cnVjdCIsIkNvbXBvbmVudCIsInByb3RvdHlwZSIsImRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFViIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50IiwiZWxlbWVudCIsIm93bmVyIiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJsb2NhdGlvbiIsImNvbXBvbmVudE5hbWUiLCJoYXMiLCJ0eXBlU3BlY05hbWUiLCJlcnJvciQxIiwiZXJyIiwiZXgiLCJSZWFjdEN1cnJlbnRPd25lciIsIlJFU0VSVkVEX1BST1BTIiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biIsImRpZFdhcm5BYm91dFN0cmluZ1JlZnMiLCJoYXNWYWxpZFJlZiIsImNvbmZpZyIsImdldHRlciIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwiZGlzcGxheU5hbWUiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdLZXkiLCJkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ1JlZiIsIlJlYWN0RWxlbWVudCIsInJlZiIsImpzeERFViIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSZWFjdEN1cnJlbnRPd25lciQxIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMSIsInByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duIiwiaXNWYWxpZEVsZW1lbnQiLCJvYmplY3QiLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsImdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJwYXJlbnRUeXBlIiwiaW5mbyIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJjaGlsZCIsIml0ZXJhdG9yRm4iLCJpdGVyYXRvciIsInN0ZXAiLCJ2YWxpZGF0ZVByb3BUeXBlcyIsInByb3BUeXBlcyIsIl9uYW1lIiwidmFsaWRhdGVGcmFnbWVudFByb3BzIiwiZnJhZ21lbnQiLCJrZXlzIiwianN4V2l0aFZhbGlkYXRpb24iLCJpc1N0YXRpY0NoaWxkcmVuIiwidmFsaWRUeXBlIiwic291cmNlSW5mbyIsInR5cGVTdHJpbmciLCJjaGlsZHJlbiIsImpzeFdpdGhWYWxpZGF0aW9uU3RhdGljIiwianN4V2l0aFZhbGlkYXRpb25EeW5hbWljIiwianN4IiwianN4cyIsImpzeFJ1bnRpbWVNb2R1bGUiLCJ2ZXJzaW9uIiwiY2hlY2tUeXBlIiwidmFsdWUiLCJ0eXBlcyIsInQiLCJyZXNvbHZlUHJvcGVydGllcyIsImFjY3VtIiwidiIsImluZGV4IiwiZGVmaW5lUHJvcGVydGllcyIsInN0cmluZ2lmeSIsIkhFWCIsInJlc3VsdCIsImlzRXJyb3IiLCJjb2RlIiwiaXNDYWxsRXhjZXB0aW9uIiwibWFrZUVycm9yIiwibWVzc2FnZSIsInNob3J0TWVzc2FnZSIsImRldGFpbHMiLCJhc3NlcnQiLCJjaGVjayIsImFzc2VydEFyZ3VtZW50IiwiYXNzZXJ0QXJndW1lbnRDb3VudCIsImNvdW50IiwiZXhwZWN0ZWRDb3VudCIsIl9ub3JtYWxpemVGb3JtcyIsImZvcm0iLCJleHBlY3RlZCIsImFzc2VydE5vcm1hbGl6ZSIsImFzc2VydFByaXZhdGUiLCJnaXZlbkd1YXJkIiwiZ3VhcmQiLCJjbGFzc05hbWUiLCJtZXRob2QiLCJvcGVyYXRpb24iLCJfZ2V0Qnl0ZXMiLCJjb3B5Iiwib2Zmc2V0IiwiZ2V0Qnl0ZXMiLCJnZXRCeXRlc0NvcHkiLCJpc0hleFN0cmluZyIsImxlbmd0aCIsImlzQnl0ZXNMaWtlIiwiSGV4Q2hhcmFjdGVycyIsImhleGxpZnkiLCJkYXRhIiwiYnl0ZXMiLCJjb25jYXQiLCJkYXRhcyIsImRhdGFMZW5ndGgiLCJkYXRhU2xpY2UiLCJzdGFydCIsImVuZCIsInplcm9QYWQiLCJsZWZ0IiwiemVyb1BhZFZhbHVlIiwiemVyb1BhZEJ5dGVzIiwiQk5fMCIsIkJOXzEiLCJtYXhWYWx1ZSIsImZyb21Ud29zIiwiX3ZhbHVlIiwiX3dpZHRoIiwiZ2V0VWludCIsIndpZHRoIiwiZ2V0TnVtYmVyIiwibWFzayIsInRvVHdvcyIsImdldEJpZ0ludCIsImxpbWl0IiwiX2JpdHMiLCJiaXRzIiwiTmliYmxlcyIsInRvQmlnSW50IiwidG9OdW1iZXIiLCJ0b0JlSGV4IiwidG9CZUFycmF5IiwiaGV4IiwidG9RdWFudGl0eSIsIkFscGhhYmV0IiwiQk5fNTgiLCJlbmNvZGVCYXNlNTgiLCJkZWNvZGVCYXNlNjQiLCJ0ZXh0RGF0YSIsImVuY29kZUJhc2U2NCIsIl9kYXRhIiwiRXZlbnRQYXlsb2FkIiwiZW1pdHRlciIsImxpc3RlbmVyIiwiZmlsdGVyIiwiX19wdWJsaWNGaWVsZCIsIl9fcHJpdmF0ZUFkZCIsIl9saXN0ZW5lciIsIl9fcHJpdmF0ZVNldCIsIl9fcHJpdmF0ZUdldCIsImVycm9yRnVuYyIsInJlYXNvbiIsIm91dHB1dCIsImJhZENvZGVwb2ludCIsImlnbm9yZUZ1bmMiLCJyZXBsYWNlRnVuYyIsIlV0ZjhFcnJvckZ1bmNzIiwiZ2V0VXRmOENvZGVQb2ludHMiLCJfYnl0ZXMiLCJvbkVycm9yIiwiZXh0cmFMZW5ndGgiLCJvdmVybG9uZ01hc2siLCJyZXMiLCJqIiwibmV4dENoYXIiLCJ0b1V0ZjhCeXRlcyIsInN0ciIsImMyIiwicGFpciIsIl90b1V0ZjhTdHJpbmciLCJjb2RlUG9pbnRzIiwiY29kZVBvaW50IiwidG9VdGY4U3RyaW5nIiwiY3JlYXRlR2V0VXJsIiwib3B0aW9ucyIsImdldFVybCIsInJlcSIsIl9zaWduYWwiLCJwcm90b2NvbCIsInNpZ25hbCIsImNvbnRyb2xsZXIiLCJyZXNwIiwiaGVhZGVycyIsInJlc3BCb2R5IiwiYm9keSIsIk1BWF9BVFRFTVBUUyIsIlNMT1RfSU5URVJWQUwiLCJkZWZhdWx0R2V0VXJsRnVuYyIsInJlRGF0YSIsInJlSXBmcyIsImxvY2tlZCIsImRhdGFHYXRld2F5RnVuYyIsInVybCIsIkZldGNoUmVzcG9uc2UiLCJ1bnBlcmNlbnQiLCJGZXRjaFJlcXVlc3QiLCJnZXRJcGZzR2F0ZXdheUZ1bmMiLCJiYXNlVXJsIiwiZ2F0ZXdheUlwZnMiLCJHYXRld2F5cyIsImZldGNoU2lnbmFscyIsIkZldGNoQ2FuY2VsU2lnbmFsIiwicmVxdWVzdCIsIl9saXN0ZW5lcnMiLCJfY2FuY2VsbGVkIiwiY2hlY2tTaWduYWwiLCJfRmV0Y2hSZXF1ZXN0IiwiX3NlbmQiLCJfYWxsb3dJbnNlY3VyZSIsIl9nemlwIiwiX2hlYWRlcnMiLCJfbWV0aG9kIiwiX3RpbWVvdXQiLCJfdXJsIiwiX2JvZHkiLCJfYm9keVR5cGUiLCJfY3JlZHMiLCJfcHJlZmxpZ2h0IiwiX3Byb2Nlc3MiLCJfcmV0cnkiLCJfdGhyb3R0bGUiLCJfZ2V0VXJsRnVuYyIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJ0aW1lb3V0IiwicHJlZmxpZ2h0IiwicHJvY2VzcyIsInJldHJ5IiwicGFyYW1zIiwiX19wcml2YXRlTWV0aG9kIiwic2VuZF9mbiIsImdldFRpbWUiLCJjdXJyZW50IiwiY2xvbmUiLCJzY2hlbWUiLCJmdW5jIiwiYXR0ZW1wdCIsImV4cGlyZXMiLCJkZWxheSIsIl9yZXF1ZXN0IiwiX3Jlc3BvbnNlIiwid2FpdCIsInJlc3BvbnNlIiwiX2EiLCJyZXRyeUFmdGVyIiwiX2IiLCJfYyIsIl9GZXRjaFJlc3BvbnNlIiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJfc3RhdHVzQ29kZSIsIl9zdGF0dXNNZXNzYWdlIiwiX2Vycm9yIiwic3RhbGwiLCJhbGwiLCJyZXNvbHZlIiwiaGV4bGlmeUJ5dGUiLCJ1bmFycmF5aWZ5SW50ZWdlciIsIl9kZWNvZGVDaGlsZHJlbiIsImNoaWxkT2Zmc2V0IiwiZGVjb2RlZCIsIl9kZWNvZGUiLCJjaGVja09mZnNldCIsImxlbmd0aExlbmd0aCIsImRlY29kZVJscCIsImFycmF5aWZ5SW50ZWdlciIsIl9lbmNvZGUiLCJuaWJibGVzIiwiZW5jb2RlUmxwIiwiV29yZFNpemUiLCJQYWRkaW5nIiwicGFzc1Byb3BlcnRpZXMiLCJfZ3VhcmQiLCJ0aHJvd0Vycm9yIiwid3JhcHBlZCIsIl9SZXN1bHQiLCJpdGVtcyIsIm5hbWVzIiwid3JhcCIsIl9uYW1lcyIsIm5hbWVDb3VudHMiLCJwcm9wIiwicmVjZWl2ZXIiLCJjYWxsYmFjayIsInRoaXNBcmciLCJSZXN1bHQiLCJnZXRWYWx1ZSIsIkNvZGVyIiwibG9jYWxOYW1lIiwiZHluYW1pYyIsIldyaXRlciIsIl93cml0ZURhdGEiLCJfZGF0YUxlbmd0aCIsIndyaXRlciIsIndyaXRlRGF0YV9mbiIsInBhZGRpbmdPZmZzZXQiLCJfUmVhZGVyIiwiYWxsb3dMb29zZSIsIl9wZWVrQnl0ZXMiLCJfb2Zmc2V0IiwibG9vc2UiLCJwZWVrQnl0ZXNfZm4iLCJhbGlnbmVkTGVuZ3RoIiwiUmVhZGVyIiwibnVtYmVyIiwibGVuZ3RocyIsImhhc2giLCJleGlzdHMiLCJpbnN0YW5jZSIsImNoZWNrRmluaXNoZWQiLCJvdXQiLCJtaW4iLCJjcnlwdG8iLCJ1OGEiLCJ1MzIiLCJhcnIiLCJjcmVhdGVWaWV3Iiwicm90ciIsIndvcmQiLCJzaGlmdCIsImlzTEUiLCJ1dGY4VG9CeXRlcyIsInRvQnl0ZXMiLCJjb25jYXRCeXRlcyIsImFycmF5cyIsInIiLCJzdW0iLCJwYWQiLCJIYXNoIiwid3JhcENvbnN0cnVjdG9yIiwiaGFzaENvbnMiLCJoYXNoQyIsIm1zZyIsInRtcCIsInJhbmRvbUJ5dGVzIiwiYnl0ZXNMZW5ndGgiLCJITUFDIiwiX2tleSIsImFzc2VydEhhc2giLCJibG9ja0xlbiIsImJ1ZiIsImFzc2VydEV4aXN0cyIsImFzc2VydEJ5dGVzIiwib0hhc2giLCJpSGFzaCIsImZpbmlzaGVkIiwiZGVzdHJveWVkIiwib3V0cHV0TGVuIiwiaG1hYyIsInNldEJpZ1VpbnQ2NCIsInZpZXciLCJieXRlT2Zmc2V0IiwiXzMybiIsIl91MzJfbWF4Iiwid2giLCJ3bCIsIlNIQTIiLCJwYWRPZmZzZXQiLCJidWZmZXIiLCJsZW4iLCJwb3MiLCJ0YWtlIiwiZGF0YVZpZXciLCJvdmlldyIsIm91dExlbiIsInN0YXRlIiwiQ2hpIiwiTWFqIiwiU0hBMjU2X0siLCJJViIsIlNIQTI1Nl9XIiwiU0hBMjU2IiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiRyIsIkgiLCJXMTUiLCJXMiIsInMwIiwiczEiLCJzaWdtYTEiLCJUMSIsIlQyIiwic2hhMjU2IiwiVTMyX01BU0s2NCIsImZyb21CaWciLCJsZSIsInNwbGl0IiwibHN0IiwiQWgiLCJBbCIsInJvdGxTSCIsInJvdGxTTCIsInJvdGxCSCIsInJvdGxCTCIsIlNIQTNfUEkiLCJTSEEzX1JPVEwiLCJfU0hBM19JT1RBIiwiXzBuIiwiXzFuIiwiXzJuIiwiXzduIiwiXzI1Nm4iLCJfMHg3MW4iLCJyb3VuZCIsIlIiLCJ5IiwiU0hBM19JT1RBX0giLCJTSEEzX0lPVEFfTCIsInJvdGxIIiwicm90bEwiLCJrZWNjYWtQIiwicm91bmRzIiwiaWR4MSIsImlkeDAiLCJCMCIsIkIxIiwiVGgiLCJUbCIsImN1ckgiLCJjdXJMIiwiUEkiLCJLZWNjYWsiLCJzdWZmaXgiLCJlbmFibGVYT0YiLCJidWZmZXJPdXQiLCJnZW4iLCJrZWNjYWtfMjU2IiwiX2tlY2NhazI1NiIsIl9fa2VjY2FrMjU2Iiwia2VjY2FrMjU2IiwiaGV4ZXMiLCJfIiwiYnl0ZXNUb0hleCIsIm51bWJlclRvSGV4VW5wYWRkZWQiLCJudW0iLCJoZXhUb051bWJlciIsImhleFRvQnl0ZXMiLCJhcnJheSIsImhleEJ5dGUiLCJieXRlIiwiYnl0ZXNUb051bWJlckJFIiwiYnl0ZXNUb051bWJlckxFIiwibnVtYmVyVG9CeXRlc0JFIiwibnVtYmVyVG9CeXRlc0xFIiwibnVtYmVyVG9WYXJCeXRlc0JFIiwiZW5zdXJlQnl0ZXMiLCJ0aXRsZSIsImV4cGVjdGVkTGVuZ3RoIiwiZXF1YWxCeXRlcyIsImIxIiwiYjIiLCJiaXRMZW4iLCJiaXRHZXQiLCJiaXRTZXQiLCJiaXRNYXNrIiwidThuIiwidThmciIsImNyZWF0ZUhtYWNEcmJnIiwiaGFzaExlbiIsInFCeXRlTGVuIiwiaG1hY0ZuIiwicmVzZXQiLCJyZXNlZWQiLCJzZWVkIiwic2wiLCJwcmVkIiwidmFsaWRhdG9yRm5zIiwidmFsaWRhdGVPYmplY3QiLCJ2YWxpZGF0b3JzIiwib3B0VmFsaWRhdG9ycyIsImNoZWNrRmllbGQiLCJmaWVsZE5hbWUiLCJpc09wdGlvbmFsIiwiY2hlY2tWYWwiLCJfM24iLCJfNG4iLCJfNW4iLCJfOG4iLCJtb2QiLCJwb3ciLCJwb3dlciIsIm1vZHVsbyIsInBvdzIiLCJpbnZlcnQiLCJ1IiwidG9uZWxsaVNoYW5rcyIsIlAiLCJsZWdlbmRyZUMiLCJRIiwiUyIsIloiLCJwMWRpdjQiLCJGcCIsInJvb3QiLCJRMWRpdjIiLCJ0MiIsImdlIiwiRnBTcXJ0IiwiYzEiLCJuMiIsIm52IiwiRklFTERfRklFTERTIiwidmFsaWRhdGVGaWVsZCIsImZpZWxkIiwiaW5pdGlhbCIsIm9wdHMiLCJtYXAiLCJGcFBvdyIsIkZwSW52ZXJ0QmF0Y2giLCJudW1zIiwibGFzdE11bHRpcGxpZWQiLCJhY2MiLCJpbnZlcnRlZCIsIm5MZW5ndGgiLCJuQml0TGVuZ3RoIiwiX25CaXRMZW5ndGgiLCJuQnl0ZUxlbmd0aCIsIkZpZWxkIiwiT1JERVIiLCJyZWRlZiIsIkJJVFMiLCJCWVRFUyIsInNxcnRQIiwibGhzIiwicmhzIiwiZ2V0RmllbGRCeXRlc0xlbmd0aCIsImZpZWxkT3JkZXIiLCJiaXRMZW5ndGgiLCJnZXRNaW5IYXNoTGVuZ3RoIiwibWFwSGFzaFRvRmllbGQiLCJmaWVsZExlbiIsIm1pbkxlbiIsInJlZHVjZWQiLCJ3TkFGIiwiY29uc3RUaW1lTmVnYXRlIiwiY29uZGl0aW9uIiwibmVnIiwiVyIsIndpbmRvd3MiLCJ3aW5kb3dTaXplIiwiZWxtIiwicG9pbnRzIiwiYmFzZSIsIndpbmRvdyIsInByZWNvbXB1dGVzIiwibWF4TnVtYmVyIiwic2hpZnRCeSIsIndiaXRzIiwib2Zmc2V0MSIsIm9mZnNldDIiLCJjb25kMSIsImNvbmQyIiwicHJlY29tcHV0ZXNNYXAiLCJ0cmFuc2Zvcm0iLCJjb21wIiwidmFsaWRhdGVCYXNpYyIsImN1cnZlIiwidmFsaWRhdGVQb2ludE9wdHMiLCJ1dC52YWxpZGF0ZU9iamVjdCIsImVuZG8iLCJiMm4iLCJoMmIiLCJ1dCIsIkRFUiIsInNCeXRlcyIsInJCeXRlc0xlZnQiLCJzaWciLCJzbGljZSIsInNobCIsInJobCIsInJsIiwid2VpZXJzdHJhc3NQb2ludHMiLCJDVVJWRSIsInBvaW50IiwiX2lzQ29tcHJlc3NlZCIsInV0LmNvbmNhdEJ5dGVzIiwiZnJvbUJ5dGVzIiwidGFpbCIsIndlaWVyc3RyYXNzRXF1YXRpb24iLCJ4MiIsIngzIiwiaXNXaXRoaW5DdXJ2ZU9yZGVyIiwiYXNzZXJ0R0UiLCJub3JtUHJpdmF0ZUtleVRvU2NhbGFyIiwid3JhcFByaXZhdGVLZXkiLCJ1dC5ieXRlc1RvSGV4IiwidXQuYnl0ZXNUb051bWJlckJFIiwibW9kLm1vZCIsInBvaW50UHJlY29tcHV0ZXMiLCJhc3NlcnRQcmpQb2ludCIsIm90aGVyIiwiUG9pbnQiLCJweCIsInB5IiwicHoiLCJpczAiLCJ0b0ludiIsInByaXZhdGVLZXkiLCJyaWdodCIsIlgxIiwiWTEiLCJaMSIsIlgyIiwiWTIiLCJaMiIsIlUxIiwiVTIiLCJiMyIsIlgzIiwiWTMiLCJaMyIsInQwIiwidDEiLCJ0MyIsInQ0IiwidDUiLCJ3bmFmIiwiSSIsImsxbmVnIiwiazEiLCJrMm5lZyIsImsyIiwiazFwIiwiazJwIiwic2NhbGFyIiwiZmFrZSIsImYxcCIsImYycCIsIm11bCIsIml6IiwieiIsImF4IiwiYXkiLCJ6eiIsImNvZmFjdG9yIiwiaXNUb3JzaW9uRnJlZSIsImNsZWFyQ29mYWN0b3IiLCJpc0NvbXByZXNzZWQiLCJ2YWxpZGF0ZU9wdHMiLCJ3ZWllcnN0cmFzcyIsImN1cnZlRGVmIiwiQ1VSVkVfT1JERVIiLCJjb21wcmVzc2VkTGVuIiwidW5jb21wcmVzc2VkTGVuIiwiaXNWYWxpZEZpZWxkRWxlbWVudCIsIm1vZE4iLCJpbnZOIiwibW9kLmludmVydCIsImNhdCIsImhlYWQiLCJ5MiIsImlzWU9kZCIsIm51bVRvTkJ5dGVTdHIiLCJ1dC5udW1iZXJUb0J5dGVzQkUiLCJpc0JpZ2dlclRoYW5IYWxmT3JkZXIiLCJIQUxGIiwibm9ybWFsaXplUyIsInNsY051bSIsIlNpZ25hdHVyZSIsInJlY292ZXJ5IiwibXNnSGFzaCIsInJlYyIsImJpdHMyaW50X21vZE4iLCJyYWRqIiwiaXIiLCJ1MSIsInUyIiwidXQuaGV4VG9CeXRlcyIsInV0aWxzIiwibW9kLmdldE1pbkhhc2hMZW5ndGgiLCJtb2QubWFwSGFzaFRvRmllbGQiLCJnZXRQdWJsaWNLZXkiLCJpc1Byb2JQdWIiLCJnZXRTaGFyZWRTZWNyZXQiLCJwcml2YXRlQSIsInB1YmxpY0IiLCJiaXRzMmludCIsImRlbHRhIiwiT1JERVJfTUFTSyIsInV0LmJpdE1hc2siLCJpbnQyb2N0ZXRzIiwicHJlcFNpZyIsImRlZmF1bHRTaWdPcHRzIiwibG93UyIsInByZWhhc2giLCJlbnQiLCJoMWludCIsInNlZWRBcmdzIiwiazJzaWciLCJrQnl0ZXMiLCJpayIsIm5vcm1TIiwiZGVmYXVsdFZlck9wdHMiLCJzaWduIiwicHJpdktleSIsInV0LmNyZWF0ZUhtYWNEcmJnIiwidmVyaWZ5Iiwic2lnbmF0dXJlIiwicHVibGljS2V5Iiwic2ciLCJfc2lnIiwiZGVyRXJyb3IiLCJpcyIsImdldEhhc2giLCJtc2dzIiwiY3JlYXRlQ3VydmUiLCJkZWZIYXNoIiwiY3JlYXRlIiwic2VjcDI1NmsxUCIsInNlY3AyNTZrMU4iLCJkaXZOZWFyZXN0Iiwic3FydE1vZCIsIl82biIsIl8xMW4iLCJfMjJuIiwiXzIzbiIsIl80NG4iLCJfODhuIiwiYjYiLCJiOSIsImIxMSIsImIyMiIsImI0NCIsImI4OCIsImIxNzYiLCJiMjIwIiwiYjIyMyIsInNlY3AyNTZrMSIsImExIiwiYTIiLCJQT1dfMl8xMjgiLCJaZXJvQWRkcmVzcyIsIlplcm9IYXNoIiwiQk5fMiIsIkJOXzI3IiwiQk5fMjgiLCJCTl8zNSIsInRvVWludDI1NiIsIl9TaWduYXR1cmUiLCJfciIsIl9zIiwiX3YiLCJfbmV0d29ya1YiLCJ5UGFyaXR5QW5kUyIsIm5ldHdvcmtWIiwiYnYiLCJjaGFpbklkIiwiYXNzZXJ0RXJyb3IiLCJ5UGFyaXR5IiwiX1NpZ25pbmdLZXkiLCJfcHJpdmF0ZUtleSIsImRpZ2VzdCIsInB1YktleSIsImNvbXByZXNzZWQiLCJwdWIiLCJzZWNwU2lnIiwicDAiLCJwMSIsInB1YjAiLCJwdWIxIiwiU2lnbmluZ0tleSIsIkJOXzM2IiwiZ2V0Q2hlY2tzdW1BZGRyZXNzIiwiYWRkcmVzcyIsImNoYXJzIiwiZXhwYW5kZWQiLCJoYXNoZWQiLCJpYmFuTG9va3VwIiwic2FmZURpZ2l0cyIsImliYW5DaGVja3N1bSIsImJsb2NrIiwiY2hlY2tzdW0iLCJCYXNlMzYiLCJmcm9tQmFzZTM2IiwiZ2V0QWRkcmVzcyIsImdldENyZWF0ZUFkZHJlc3MiLCJ0eCIsIm5vbmNlSGV4IiwiaXNBZGRyZXNzYWJsZSIsImNoZWNrQWRkcmVzcyIsInByb21pc2UiLCJyZXNvbHZlQWRkcmVzcyIsInJlc29sdmVyIiwiX2dhdXJkIiwic2lnbmVkIiwiVHlwZWQiLCJzaXplIiwiX3R5cGVkU3ltYm9sIiwiX1R5cGVkIiwiZ2F1cmQiLCJfb3B0aW9ucyIsIkFkZHJlc3NDb2RlciIsInJlYWRlciIsIkFub255bW91c0NvZGVyIiwiY29kZXIiLCJwYWNrIiwiY29kZXJzIiwiYXJyYXlWYWx1ZXMiLCJ1bmlxdWUiLCJzdGF0aWNXcml0ZXIiLCJkeW5hbWljV3JpdGVyIiwidXBkYXRlRnVuY3MiLCJkeW5hbWljT2Zmc2V0IiwidXBkYXRlRnVuYyIsImJhc2VPZmZzZXQiLCJ1bnBhY2siLCJiYXNlUmVhZGVyIiwib2Zmc2V0UmVhZGVyIiwiQXJyYXlDb2RlciIsImRlZmF1bHRDaGlsZCIsIkJvb2xlYW5Db2RlciIsIkR5bmFtaWNCeXRlc0NvZGVyIiwiQnl0ZXNDb2RlciIsIkZpeGVkQnl0ZXNDb2RlciIsIkVtcHR5IiwiTnVsbENvZGVyIiwiQk5fTUFYX1VJTlQyNTYiLCJOdW1iZXJDb2RlciIsIm1heFVpbnRWYWx1ZSIsImJvdW5kcyIsIlN0cmluZ0NvZGVyIiwiVHVwbGVDb2RlciIsInVuaXF1ZU5hbWVzIiwiaWQiLCJDT01QUkVTU0VEJDEiLCJGRU5DRUQiLCJOU01fTUFYIiwiZGVjb2RlX2FyaXRobWV0aWMiLCJ1MTYiLCJzeW1ib2xfY291bnQiLCJ0b3RhbCIsInNraXAiLCJwb3NfcGF5bG9hZCIsInJlYWRfd2lkdGgiLCJyZWFkX2J1ZmZlciIsInJlYWRfYml0IiwiTiIsIkZVTEwiLCJRUlRSIiwiTUFTSyIsInJlZ2lzdGVyIiwibG93IiwicmFuZ2UiLCJtaWQiLCJyZWFkX3BheWxvYWQiLCJyZWFkX2NvbXByZXNzZWRfcGF5bG9hZCIsInVuc2FmZV9hdG9iIiwibG9va3VwIiwicmV0IiwiY2FycnkiLCJyZWFkX2RlbHRhcyIsIm5leHQiLCJyZWFkX3NvcnRlZCIsInByZXYiLCJyZWFkX3NvcnRlZF9hcnJheXMiLCJyZWFkX2FycmF5X3doaWxlIiwicmVhZF9tYXBwZWQiLCJ3IiwicmVhZF9saW5lYXJfdGFibGUiLCJyZWFkX3JlcGxhY2VtZW50X3RhYmxlIiwicmVhZF90cmFuc3Bvc2VkIiwiZHgiLCJkeSIsInZOIiwieXMiLCJqX2R5IiwicmVhZF90cmllIiwic29ydGVkIiwiZXhwYW5kIiwiZGVjb2RlIiwiY3BzIiwic2F2ZWQiLCJiciIsImNwIiwiaGV4X2NwIiwicXVvdGVfY3AiLCJleHBsb2RlX2NwIiwic3RyX2Zyb21fY3BzIiwiY29tcGFyZV9hcnJheXMiLCJDT01QUkVTU0VEIiwiUzAiLCJMMCIsIlYwIiwiVDAiLCJMX0NPVU5UIiwiVl9DT1VOVCIsIlRfQ09VTlQiLCJOX0NPVU5UIiwiU19DT1VOVCIsIlMxIiwiTDEiLCJWMSIsInVucGFja19jYyIsInBhY2tlZCIsInVucGFja19jcCIsIlNISUZURURfUkFOSyIsIkVYQ0xVU0lPTlMiLCJERUNPTVAiLCJSRUNPTVAiLCJpbml0JDEiLCJidWNrZXQiLCJpc19oYW5ndWwiLCJjb21wb3NlX3BhaXIiLCJyZWNvbXAiLCJkZWNvbXBvc2VkIiwiY2hlY2tfb3JkZXIiLCJhZGQiLCJjYyIsInNfaW5kZXgiLCJsX2luZGV4Iiwidl9pbmRleCIsInRfaW5kZXgiLCJtYXBwZWQiLCJwcmV2X2NjIiwiY29tcG9zZWRfZnJvbV9kZWNvbXBvc2VkIiwicHJldl9jcCIsImNvbXBvc2VkIiwibmZkIiwibmZjIiwiSFlQSEVOIiwiU1RPUF9DSCIsIkZFMEYiLCJVTklRVUVfUEgiLCJBcnJheV9mcm9tIiwiZ3JvdXBfaGFzX2NwIiwiRW1vamkiLCJNQVBQRUQiLCJJR05PUkVEIiwiQ00iLCJOU00iLCJFU0NBUEUiLCJHUk9VUFMiLCJXSE9MRV9WQUxJRCIsIldIT0xFX01BUCIsIlZBTElEIiwiRU1PSklfTElTVCIsIkVNT0pJX1JPT1QiLCJyZWFkX3NvcnRlZF9hcnJheSIsInJlYWRfc29ydGVkX3NldCIsImNodW5rcyIsInVucmVzdHJpY3RlZCIsInJlYWRfY2h1bmtlZCIsIk0iLCJ3aG9sZXMiLCJWIiwicmVjcyIsImdzIiwidW5pb24iLCJjb21wbGVtZW50IiwibXVsdGkiLCJhZGRfdG9fdW5pb24iLCJxdW90ZWRfY3AiLCJzaG91bGRfZXNjYXBlIiwiYmlkaV9xcSIsInNhZmVfc3RyX2Zyb21fY3BzIiwiY2hlY2tfbGFiZWxfZXh0ZW5zaW9uIiwiY2hlY2tfbGVhZGluZ191bmRlcnNjb3JlIiwiY2hlY2tfZmVuY2VkIiwiZXJyb3JfcGxhY2VtZW50IiwibGFzdCIsInF1b3RlciIsImlzX2NvbWJpbmluZ19tYXJrIiwiZW5zX25vcm1hbGl6ZSIsImZsYXR0ZW4iLCJmaWx0ZXJfZmUwZiIsIm5mIiwiZWYiLCJsYWJlbCIsImlucHV0IiwidG9rZW5zIiwidG9rZW5zX2Zyb21fc3RyIiwidG9rZW5fY291bnQiLCJub3JtIiwiZGV0ZXJtaW5lX2dyb3VwIiwiY2hlY2tfZ3JvdXAiLCJjaGVja193aG9sZSIsImdyb3VwIiwibWFrZXIiLCJzaGFyZWQiLCJ3aG9sZSIsInNldCIsImdyb3VwcyIsImVycm9yX2dyb3VwX21lbWJlciIsImVycm9yX2Rpc2FsbG93ZWQiLCJxdW90ZWQiLCJnZyIsIndoZXJlIiwiZW1vamkiLCJjb25zdW1lX2Vtb2ppX3JldmVyc2VkIiwiZWF0ZW4iLCJaZXJvcyIsImNoZWNrQ29tcG9uZW50IiwiZW5zTmFtZVNwbGl0IiwiZW5zTm9ybWFsaXplIiwiY29tcHMiLCJuYW1laGFzaCIsImRuc0VuY29kZSIsImFjY2Vzc1NldGlmeSIsImFkZHIiLCJzdG9yYWdlS2V5cyIsInN0b3JhZ2VLZXkiLCJhY2Nlc3NMaXN0aWZ5IiwiY29tcHV0ZUFkZHJlc3MiLCJwdWJrZXkiLCJyZWNvdmVyQWRkcmVzcyIsIkJOX01BWF9VSU5UIiwiaGFuZGxlQWRkcmVzcyIsImhhbmRsZUFjY2Vzc0xpc3QiLCJwYXJhbSIsImhhbmRsZU51bWJlciIsImhhbmRsZVVpbnQiLCJmb3JtYXROdW1iZXIiLCJmb3JtYXRBY2Nlc3NMaXN0IiwiX3BhcnNlTGVnYWN5IiwiZmllbGRzIiwiX3NlcmlhbGl6ZUxlZ2FjeSIsImxlZ2FjeSIsIl9wYXJzZUVpcFNpZ25hdHVyZSIsIl9wYXJzZUVpcDE1NTkiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsIm1heEZlZVBlckdhcyIsIl9zZXJpYWxpemVFaXAxNTU5IiwiX3BhcnNlRWlwMjkzMCIsIl9zZXJpYWxpemVFaXAyOTMwIiwiX1RyYW5zYWN0aW9uIiwiX3R5cGUiLCJfdG8iLCJfbm9uY2UiLCJfZ2FzTGltaXQiLCJfZ2FzUHJpY2UiLCJfbWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJfbWF4RmVlUGVyR2FzIiwiX2NoYWluSWQiLCJfYWNjZXNzTGlzdCIsImhhc0dhc1ByaWNlIiwiaGFzRmVlIiwiaGFzQWNjZXNzTGlzdCIsIlRyYW5zYWN0aW9uIiwicGFkZGluZyIsIkJOX18xIiwiaGV4UGFkUmlnaHQiLCJoZXhUcnVlIiwiaGV4RmFsc2UiLCJkb21haW5GaWVsZFR5cGVzIiwiZG9tYWluRmllbGROYW1lcyIsImNoZWNrU3RyaW5nIiwiZG9tYWluQ2hlY2tzIiwiZ2V0QmFzZUVuY29kZXIiLCJib3VuZHNVcHBlciIsImJvdW5kc0xvd2VyIiwiZW5jb2RlVHlwZSIsIl9UeXBlZERhdGFFbmNvZGVyIiwiX2dldEVuY29kZXIiLCJfdHlwZXMiLCJfZnVsbFR5cGVzIiwiX2VuY29kZXJDYWNoZSIsImxpbmtzIiwicGFyZW50cyIsInN1YnR5cGVzIiwiYmFzZVR5cGUiLCJwcmltYXJ5VHlwZXMiLCJjaGVja0NpcmN1bGFyIiwiZm91bmQiLCJzdWJ0eXBlIiwic3QiLCJlbmNvZGVyIiwiZ2V0RW5jb2Rlcl9mbiIsImRvbWFpbiIsImRvbWFpbkZpZWxkcyIsInJlc29sdmVOYW1lIiwiZW5zQ2FjaGUiLCJkb21haW5WYWx1ZXMiLCJkb21haW5UeXBlcyIsInR5cGVzV2l0aERvbWFpbiIsInN1YkVuY29kZXIiLCJlbmNvZGVkVHlwZSIsIlR5cGVkRGF0YUVuY29kZXIiLCJzZXRpZnkiLCJfa3dWaXNpYkRlcGxveSIsIkt3VmlzaWJEZXBsb3kiLCJfa3dWaXNpYiIsIkt3VmlzaWIiLCJfa3dUeXBlcyIsIkt3VHlwZXMiLCJfa3dNb2RpZmllcnMiLCJLd01vZGlmaWVycyIsIl9rd090aGVyIiwiX2tleXdvcmRzIiwiS2V5d29yZHMiLCJTaW1wbGVUb2tlbnMiLCJyZWdleFdoaXRlc3BhY2VQcmVmaXgiLCJyZWdleE51bWJlclByZWZpeCIsInJlZ2V4SWRQcmVmaXgiLCJyZWdleElkIiwicmVnZXhUeXBlIiwiX1Rva2VuU3RyaW5nIiwiX3N1YlRva2VuU3RyaW5nIiwiX3Rva2VucyIsImFsbG93ZWQiLCJ0b3AiLCJzdWJUb2tlblN0cmluZ19mbiIsImxpbmsiLCJfX3ByaXZhdGVXcmFwcGVyIiwidG9rZW4iLCJUb2tlblN0cmluZyIsImxleCIsInRleHQiLCJicmFja2V0cyIsImNvbW1hcyIsImN1ciIsImFsbG93U2luZ2xlIiwiaW5jbHVkZWQiLCJjb25zdW1lTmFtZSIsImtleXdvcmQiLCJjb25zdW1lS2V5d29yZHMiLCJrZXl3b3JkcyIsImNvbnN1bWVNdXRhYmlsaXR5IiwibW9kaWZpZXJzIiwiY29uc3VtZVBhcmFtcyIsImFsbG93SW5kZXhlZCIsIlBhcmFtVHlwZSIsImNvbnN1bWVHYXMiLCJjb25zdW1lRW9pIiwicmVnZXhBcnJheVR5cGUiLCJ2ZXJpZnlCYXNpY1R5cGUiLCJpbnRlcm5hbCIsIlBhcmFtVHlwZUludGVybmFsIiwiRXJyb3JGcmFnbWVudEludGVybmFsIiwiRXZlbnRGcmFnbWVudEludGVybmFsIiwiQ29uc3RydWN0b3JGcmFnbWVudEludGVybmFsIiwiRmFsbGJhY2tGcmFnbWVudEludGVybmFsIiwiRnVuY3Rpb25GcmFnbWVudEludGVybmFsIiwiU3RydWN0RnJhZ21lbnRJbnRlcm5hbCIsIl9QYXJhbVR5cGUiLCJpbmRleGVkIiwiY29tcG9uZW50cyIsImFycmF5TGVuZ3RoIiwiYXJyYXlDaGlsZHJlbiIsIl93YWxrQXN5bmMiLCJfdGhpcyIsInByb21pc2VzIiwid2Fsa0FzeW5jX2ZuIiwib2JqIiwiYnJhY2tldCIsImFycmF5TWF0Y2giLCJzZXRWYWx1ZSIsImNoaWxkVHlwZSIsIkZyYWdtZW50IiwiaW5wdXRzIiwiQ29uc3RydWN0b3JGcmFnbWVudCIsIkVycm9yRnJhZ21lbnQiLCJFdmVudEZyYWdtZW50IiwiRmFsbGJhY2tGcmFnbWVudCIsIkZ1bmN0aW9uRnJhZ21lbnQiLCJTdHJ1Y3RGcmFnbWVudCIsIk5hbWVkRnJhZ21lbnQiLCJqb2luUGFyYW1zIiwiYW5vbnltb3VzIiwicGF5YWJsZSIsImdhcyIsInN0YXRlTXV0YWJpbGl0eSIsImVycm9yT2JqIiwidG9wSXNWYWxpZCIsIm11dGFiaWxpdHkiLCJvdXRwdXRzIiwibyIsIlBhbmljUmVhc29ucyIsInBhcmFtVHlwZUJ5dGVzIiwicGFyYW1UeXBlTnVtYmVyIiwiZGVmYXVsdENvZGVyIiwiZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24iLCJhY3Rpb24iLCJhYmlDb2RlciIsImludm9jYXRpb24iLCJyZXZlcnQiLCJ0cmFuc2FjdGlvbiIsIl9BYmlDb2RlciIsIl9nZXRDb2RlciIsImdldENvZGVyX2ZuIiwiQWJpQ29kZXIiLCJMb2dEZXNjcmlwdGlvbiIsInRvcGljIiwiVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiIsInNlbGVjdG9yIiwiRXJyb3JEZXNjcmlwdGlvbiIsIkluZGV4ZWQiLCJCdWlsdGluRXJyb3JzIiwiX0ludGVyZmFjZSIsImZyYWdtZW50cyIsIl9nZXRGdW5jdGlvbiIsIl9nZXRFdmVudCIsIl9lcnJvcnMiLCJfZXZlbnRzIiwiX2Z1bmN0aW9ucyIsIl9hYmlDb2RlciIsImFiaSIsImZyYWdzIiwiZmFsbGJhY2siLCJyZWNlaXZlIiwibWluaW1hbCIsImdldEZ1bmN0aW9uX2ZuIiwiZ2V0RXZlbnRfZm4iLCJtYXRjaGluZyIsIm1hdGNoU3RyIiwiY3VzdG9tUHJlZml4IiwicGFyc2VkIiwidG9waWNzIiwiZW5jb2RlVG9waWMiLCJkYXRhVHlwZXMiLCJkYXRhVmFsdWVzIiwiZXZlbnRUb3BpYyIsIm5vbkluZGV4ZWQiLCJyZXN1bHRJbmRleGVkIiwicmVzdWx0Tm9uSW5kZXhlZCIsIm5vbkluZGV4ZWRJbmRleCIsImluZGV4ZWRJbmRleCIsImxvZyIsImhleERhdGEiLCJmb3JjZVVuaXF1ZSIsImxhc3RWYWx1ZSIsInZhbHVlTGVuZ3RoIiwiYWxsb3dPcHRpb25zIiwibGFzdEFyZyIsIkludGVyZmFjZSIsInRvSnNvbiIsIkZlZURhdGEiLCJnYXNQcmljZSIsImNvcHlSZXF1ZXN0IiwiYmlnSW50S2V5cyIsIm51bWJlcktleXMiLCJCbG9jayIsIl90cmFuc2FjdGlvbnMiLCJUcmFuc2FjdGlvblJlc3BvbnNlIiwidHhzIiwiYmFzZUZlZVBlckdhcyIsImRpZmZpY3VsdHkiLCJleHRyYURhdGEiLCJnYXNMaW1pdCIsImdhc1VzZWQiLCJtaW5lciIsIm5vbmNlIiwicGFyZW50SGFzaCIsInRpbWVzdGFtcCIsInRyYW5zYWN0aW9ucyIsImluZGV4T3JIYXNoIiwiY3JlYXRlT3JwaGFuZWRCbG9ja0ZpbHRlciIsIkxvZyIsImJsb2NrSGFzaCIsImJsb2NrTnVtYmVyIiwicmVtb3ZlZCIsInRyYW5zYWN0aW9uSGFzaCIsInRyYW5zYWN0aW9uSW5kZXgiLCJyZWNlaXB0IiwiY3JlYXRlUmVtb3ZlZExvZ0ZpbHRlciIsIlRyYW5zYWN0aW9uUmVjZWlwdCIsIl9sb2dzIiwiY29udHJhY3RBZGRyZXNzIiwibG9nc0Jsb29tIiwibG9ncyIsInN0YXR1cyIsImNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlciIsImNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyIiwiX1RyYW5zYWN0aW9uUmVzcG9uc2UiLCJfc3RhcnRCbG9jayIsImFjY2Vzc0xpc3QiLCJfY29uZmlybXMiLCJjb25maXJtcyIsInN0YXJ0QmxvY2siLCJuZXh0U2NhbiIsInN0b3BTY2FubmluZyIsImNoZWNrUmVwbGFjZW1lbnQiLCJtaW5lZCIsImNoZWNrUmVjZWlwdCIsInJlamVjdCIsImNhbmNlbGxlcnMiLCJjYW5jZWwiLCJ0aW1lciIsInR4TGlzdGVuZXIiLCJyZXBsYWNlTGlzdGVuZXIiLCJFdmVudExvZyIsImlmYWNlIiwiVW5kZWNvZGVkRXZlbnRMb2ciLCJDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCIsIl9pZmFjZSIsIkNvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSIsIkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCIsImNvbnRyYWN0IiwiQ29udHJhY3RFdmVudFBheWxvYWQiLCJfbG9nIiwiY2FuQ2FsbCIsImNhbkVzdGltYXRlIiwiY2FuUmVzb2x2ZSIsImNhblNlbmQiLCJnZXRSZXNvbHZlciIsIlByZXBhcmVkVG9waWNGaWx0ZXIiLCJfZmlsdGVyIiwicnVubmVyIiwiZ2V0UnVubmVyIiwicmVzb2x2ZWRBcmdzIiwiZmVhdHVyZSIsImdldFByb3ZpZGVyIiwiY29weU92ZXJyaWRlcyIsImFyZyIsIl9vdmVycmlkZXMiLCJvdmVycmlkZXMiLCJyZXNvbHZlQXJncyIsIl9ydW5uZXIiLCJidWlsZFdyYXBwZWRGYWxsYmFjayIsInBvcHVsYXRlVHJhbnNhY3Rpb24iLCJub1ZhbHVlIiwibm9EYXRhIiwic3RhdGljQ2FsbCIsInNlbmQiLCJlc3RpbWF0ZUdhcyIsImJ1aWxkV3JhcHBlZE1ldGhvZCIsImdldEZyYWdtZW50Iiwic3RhdGljQ2FsbFJlc3VsdCIsImJ1aWxkV3JhcHBlZEV2ZW50IiwiaW50ZXJuYWxWYWx1ZXMiLCJzZXRJbnRlcm5hbCIsImdldEludGVybmFsIiwiaXNEZWZlcnJlZCIsImdldFN1YkluZm8iLCJldmVudCIsInRvcGljSGFzaGlmeSIsInRhZyIsImhhc1N1YiIsInN1YnMiLCJnZXRTdWIiLCJzdWIiLCJmb3VuZEZyYWdtZW50IiwiX2ZvdW5kRnJhZ21lbnQiLCJlbWl0Iiwic3RhcnRpbmciLCJzdGFydGVkIiwibGFzdEVtaXQiLCJfZW1pdCIsInBheWxvYWRGdW5jIiwib25jZSIsInBhc3NBcmdzIiwicmVzdWx0UHJvbWlzZSIsIl9CYXNlQ29udHJhY3QiLCJfZGVwbG95VHgiLCJhZGRyUHJvbWlzZSIsImRlcGxveVR4IiwiZmlsdGVycyIsImNoZWNrQ29kZSIsImZyb21CbG9jayIsInRvQmxvY2siLCJsaXN0ZW5lcnMiLCJzdG9wIiwiQ3VzdG9tQ29udHJhY3QiLCJCYXNlQ29udHJhY3QiLCJfQ29udHJhY3RCYXNlIiwiQ29udHJhY3QiLCJnZXRJcGZzTGluayIsIk11bHRpY29pblByb3ZpZGVyUGx1Z2luIiwicHJvaXZkZXIiLCJjb2luVHlwZSIsIm1hdGNoZXJJcGZzIiwibWF0Y2hlcnMiLCJfRW5zUmVzb2x2ZXIiLCJfZmV0Y2giLCJfc3VwcG9ydHMyNTQ0IiwiX3Jlc29sdmVyIiwiZmV0Y2hfZm4iLCJldGhDb2luVHlwZSIsImNvaW5QbHVnaW4iLCJwbHVnaW4iLCJpcGZzIiwic3dhcm0iLCJsaW5rYWdlIiwiYXZhdGFyIiwidG9rZW5JZCIsInRva2VuT3duZXIiLCJiYWxhbmNlIiwibWV0YWRhdGFVcmwiLCJtZXRhZGF0YSIsImltYWdlVXJsIiwibmV0d29yayIsImVuc1BsdWdpbiIsImN1cnJlbnROYW1lIiwiX2dldFJlc29sdmVyIiwiZ2V0UmVzb2x2ZXJfZm4iLCJmdW5jTmFtZSIsImVuc0FkZHIiLCJFbnNSZXNvbHZlciIsImFsbG93TnVsbCIsIm51bGxWYWx1ZSIsImFycmF5T2YiLCJhbHROYW1lcyIsInNyY0tleSIsImFsdEtleSIsImZvcm1hdEJvb2xlYW4iLCJmb3JtYXREYXRhIiwiZm9ybWF0SGFzaCIsIl9mb3JtYXRMb2ciLCJmb3JtYXRMb2ciLCJfZm9ybWF0QmxvY2siLCJmb3JtYXRCbG9jayIsImZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UiLCJfZm9ybWF0UmVjZWlwdExvZyIsImZvcm1hdFJlY2VpcHRMb2ciLCJfZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0IiwiZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0IiwiRW5zQWRkcmVzcyIsIk5ldHdvcmtQbHVnaW4iLCJHYXNDb3N0UGx1Z2luIiwiZWZmZWN0aXZlQmxvY2siLCJjb3N0cyIsIm51bGxpc2giLCJFbnNQbHVnaW4iLCJ0YXJnZXROZXR3b3JrIiwiRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbiIsInByb2Nlc3NGdW5jIiwiX3Byb2Nlc3NGdW5jIiwiTmV0d29ya3MiLCJfTmV0d29yayIsIl9wbHVnaW5zIiwiYmFzZW5hbWUiLCJpbmplY3RDb21tb25OZXR3b3JrcyIsIm5ldHdvcmtGdW5jIiwiY3VzdG9tIiwibmFtZU9yQ2hhaW5JZCIsImV4aXN0aW5nIiwiTmV0d29yayIsInBhcnNlVW5pdHMiLCJkZWNpbWFscyIsImZyYWMiLCJnZXRHYXNTdGF0aW9uUGx1Z2luIiwiZmV0Y2hGZWVEYXRhIiwiX2ZlZURhdGEiLCJpbmplY3RlZCIsInJlZ2lzdGVyRXRoIiwiUG9sbGluZ0Jsb2NrU3Vic2NyaWJlciIsIl9wb2xsIiwiX3Byb3ZpZGVyIiwiX3BvbGxlciIsIl9pbnRlcnZhbCIsIl9ibG9ja051bWJlciIsInBvbGxfZm4iLCJkcm9wV2hpbGVQYXVzZWQiLCJPbkJsb2NrU3Vic2NyaWJlciIsIl9ydW5uaW5nIiwiUG9sbGluZ0Jsb2NrVGFnU3Vic2NyaWJlciIsIl90YWciLCJfbGFzdEJsb2NrIiwiUG9sbGluZ09ycGhhblN1YnNjcmliZXIiLCJQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyIiwiX2hhc2giLCJQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIiwiTUFYX0NDSVBfUkVESVJFQ1RTIiwiaXNQcm9taXNlIiwiZ2V0VGFnIiwiVW5tYW5hZ2VkU3Vic2NyaWJlciIsImNvbmNpc2lmeSIsImdldFN1YnNjcmlwdGlvbiIsIl9ldmVudCIsImFkZHJlc3NlcyIsImFkZEFkZHJlc3MiLCJkZWZhdWx0T3B0aW9ucyIsIkFic3RyYWN0UHJvdmlkZXIiLCJfbmV0d29yayIsIl9wZXJmb3JtIiwiX2NhbGwiLCJfY2hlY2tOZXR3b3JrIiwiX2dldEFjY291bnRWYWx1ZSIsIl9nZXRCbG9jayIsIl9oYXNTdWIiLCJfZ2V0U3ViIiwiX3N1YnMiLCJfcGF1c2VkU3RhdGUiLCJfZGVzdHJveWVkIiwiX25ldHdvcmtQcm9taXNlIiwiX2FueU5ldHdvcmsiLCJfcGVyZm9ybUNhY2hlIiwiX2xhc3RCbG9ja051bWJlciIsIl9uZXh0VGltZXIiLCJfdGltZXJzIiwiX2Rpc2FibGVDY2lwUmVhZCIsImNhbGxkYXRhIiwidXJscyIsInNlbmRlciIsImVycm9yTWVzc2FnZXMiLCJocmVmIiwiZXJyb3JNZXNzYWdlIiwicGVyZm9ybV9mbiIsImJsb2NrVGFnIiwiX2FkZHJlc3MiLCJkZXRlY3ROZXR3b3JrIiwibmV0d29ya1Byb21pc2UiLCJhY3R1YWwiLCJnZXRGZWVEYXRhRnVuYyIsIl9ibG9jayIsInByaW9yaXR5RmVlIiwiZ2V0QmxvY2tfZm4iLCJmZWVEYXRhIiwiX3R4IiwiY2hlY2tOZXR3b3JrX2ZuIiwiY2FsbF9mbiIsImdldEFjY291bnRWYWx1ZV9mbiIsIl9wb3NpdGlvbiIsInBvc2l0aW9uIiwic2lnbmVkVHgiLCJwcmVmZXRjaFR4cyIsInRpbWVySWQiLCJfZnVuYyIsInN1YnNjcmliZXIiLCJvbGRTdWIiLCJuZXdTdWIiLCJnZXRTdWJfZm4iLCJoYXNTdWJfZm4iLCJwYXVzZSIsInBlcmZvcm0iLCJ0eFNlbmRlciIsImNjaXBBcmdzIiwicGFyc2VPZmZjaGFpbkxvb2t1cCIsImNjaXBSZXN1bHQiLCJlbmNvZGVCeXRlcyIsIl9ibG9ja1RhZyIsImluY2x1ZGVUcmFuc2FjdGlvbnMiLCJlbWl0QXJncyIsInN1YnNjcmlwdGlvbiIsIl9wYXJzZVN0cmluZyIsIl9wYXJzZUJ5dGVzIiwibnVtUGFkIiwicGFkZGVkIiwiYnl0ZXNQYWQiLCJlbXB0eSIsImJ5dGVDb3VudCIsInplcm9zIiwidXJsc09mZnNldCIsInVybHNMZW5ndGgiLCJ1cmxzRGF0YSIsImNoZWNrUHJvdmlkZXIiLCJzaWduZXIiLCJwb3B1bGF0ZSIsInBvcCIsIkFic3RyYWN0U2lnbmVyIiwiaGFzRWlwMTU1OSIsInR4T2JqIiwiRmlsdGVySWRTdWJzY3JpYmVyIiwiX3RlYXJkb3duIiwiX2ZpbHRlcklkUHJvbWlzZSIsIl9oYXVsdCIsInRlYXJkb3duX2ZuIiwiZmlsdGVySWQiLCJmaWx0ZXJJZFByb21pc2UiLCJGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlciIsInJlc3VsdHMiLCJGaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyIiwiUHJpbWl0aXZlIiwiZGVlcENvcHkiLCJkdXJhdGlvbiIsImdldExvd2VyQ2FzZSIsImlzUG9sbGFibGUiLCJKc29uUnBjU2lnbmVyIiwiX2Zyb20iLCJoZXhUeCIsInRpbWVvdXRzIiwiY2hlY2tUeCIsIl9tZXNzYWdlIiwicG9wdWxhdGVkIiwiSnNvblJwY0FwaVByb3ZpZGVyIiwiX3NjaGVkdWxlRHJhaW4iLCJfbmV4dElkIiwiX3BheWxvYWRzIiwiX2RyYWluVGltZXIiLCJfbm90UmVhZHkiLCJfcGVuZGluZ0RldGVjdE5ldHdvcmsiLCJfcmVzb2x2ZSIsInN0YXRpY05ldHdvcmsiLCJzY2hlZHVsZURyYWluX2ZuIiwiZHN0S2V5Iiwic3BlbHVua0RhdGEiLCJzcGVsdW5rTWVzc2FnZSIsInVuc3VwcG9ydGVkIiwiYWNjb3VudHNQcm9taXNlIiwiYWNjb3VudHMiLCJhY2NvdW50Iiwic3RhbGxUaW1lIiwicGF5bG9hZHMiLCJiYXRjaCIsIkpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIiLCJfcG9sbGluZ0ludGVydmFsIiwiX3NwZWx1bmtNZXNzYWdlIiwiQnJvd3NlclByb3ZpZGVyIiwiZXRoZXJldW0iLCJzaWduZXJQcm9taXNlIiwiZ2V0U2lnbmVyIiwiUGFuZWwiLCJhY3RpdmF0aW5nIiwiYWN0aXZhdGlvbkZ1bmN0aW9ucyIsInNlbGVjdGVkRnVuY3Rpb25JZCIsImNvbnRyYWN0QUJJIiwiZW5jb2RlckNvbnRyYWN0IiwiZXRoZXJzLkNvbnRyYWN0IiwiZ3VpbGRBRkNvbnRyYWN0Iiwid2F0dHNDb250cmFjdCIsInVzZUFzeW5jTWVtbyIsImZhY3RvcnkiLCJkZXBzIiwic2V0VmFsIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VCdXR0b24iLCJzZXRBY3RpdmF0aW5nIiwic2V0QmFsYW5jZSIsIl9zZWxlY3RlZEZ1bmN0aW9uSWQiLCJfY29udHJhY3RUeXBlIiwiX2NvbnRyYWN0QWRkcmVzcyIsImFjdGl2YXRlIiwiY29udHJhY3RUeXBlIiwic2ZpZCIsImNoZWNrQmFsYW5jZSIsIndhdHRzQ29udHJhY3RXaXRoU2lnbmVyIiwiQnV0dG9uIiwicmVuZGVyIiwiQnV0dG9uQ29tcCIsIkRyb3Bkb3duIiwic2V0U2VsZWN0ZWRGdW5jdGlvbklkIiwiaGFuZGxlQ2hhbmdlIiwidmFsdWVBc051bWJlciIsInVzZUFjdGl2YXRpb25GdW5jdGlvbnMiLCJhdXRvY29ubmVjdCIsImRvQ29ubmVjdCIsInNldERvQ29ubmVjdCIsImlzQ29ubmVjdGluZyIsInNldElzQ29ubmVjdGluZyIsImlzQ29ubmVjdGVkIiwic2V0SXNDb25uZWN0ZWQiLCJjb25uZWN0Iiwic2kiLCJwcm94eU9iamVjdCIsImRyb3BEb3duIiwicGFuZWwiLCJidXR0b25QYXJhbXMiLCJidXR0b24iLCJBcHAiLCJBY3RpdmF0aW9uQnlDb250cmFjdEFkZHJlc3MiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFRQSxNQUFJQSxJQUF3QixPQUFPLHVCQUMvQkMsSUFBaUIsT0FBTyxVQUFVLGdCQUNsQ0MsSUFBbUIsT0FBTyxVQUFVO0FBRXhDLFdBQVNDLEVBQVNDLEdBQUs7QUFDdEIsUUFBSUEsS0FBUTtBQUNYLFlBQU0sSUFBSSxVQUFVLHVEQUF1RDtBQUc1RSxXQUFPLE9BQU9BLENBQUc7QUFBQSxFQUNqQjtBQUVELFdBQVNDLElBQWtCO0FBQzFCLFFBQUk7QUFDSCxVQUFJLENBQUMsT0FBTztBQUNYLGVBQU87QUFNUixVQUFJQyxJQUFRLElBQUksT0FBTyxLQUFLO0FBRTVCLFVBREFBLEVBQU0sQ0FBQyxJQUFJLE1BQ1AsT0FBTyxvQkFBb0JBLENBQUssRUFBRSxDQUFDLE1BQU07QUFDNUMsZUFBTztBQUtSLGVBRElDLElBQVEsQ0FBQSxHQUNIQyxJQUFJLEdBQUdBLElBQUksSUFBSUE7QUFDdkIsUUFBQUQsRUFBTSxNQUFNLE9BQU8sYUFBYUMsQ0FBQyxDQUFDLElBQUlBO0FBRXZDLFVBQUlDLElBQVMsT0FBTyxvQkFBb0JGLENBQUssRUFBRSxJQUFJLFNBQVVHLEdBQUc7QUFDL0QsZUFBT0gsRUFBTUcsQ0FBQztBQUFBLE1BQ2pCLENBQUc7QUFDRCxVQUFJRCxFQUFPLEtBQUssRUFBRSxNQUFNO0FBQ3ZCLGVBQU87QUFJUixVQUFJRSxJQUFRLENBQUE7QUFJWixhQUhBLHVCQUF1QixNQUFNLEVBQUUsRUFBRSxRQUFRLFNB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O0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sS0FBS0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sS0FBS0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSW5DLE9BQU8sTUFBTUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sTUFBTUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sTUFBTUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sTUFBTUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sTUFBTUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sTUFBTUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sTUFBTUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sTUFBTUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sTUFBTUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sTUFBTUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sTUFBTUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxHQUFHO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXZDLE9BQU8sSUFBSUEsR0FBRztBQUFFLFdBQU8zTSxFQUFFMk0sR0FBRyxJQUFJO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxDQUFDO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxDQUFDO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxDQUFDO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxDQUFDO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxDQUFDO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxDQUFDO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxDQUFDO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxDQUFDO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sT0FBT0EsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxDQUFDO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0wsR0FBRyxFQUFFO0FBQUEsRUFBSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUUEsR0FBRztBQUFFLFdBQU9wTCxFQUFFb0ws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QUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsV0FBVztBQUFBLElBQ1gsUUFBUTtBQUFBLE1BQ047QUFBQSxRQUNFLFNBQVM7QUFBQSxRQUNULGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxXQUFXO0FBQUEsSUFDWCxRQUFRO0FBQUEsTUFDTjtBQUFBLFFBQ0UsU0FBUztBQUFBLFFBQ1QsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxNQUNBO0FBQUEsUUFDRSxTQUFTO0FBQUEsUUFDVCxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFLFNBQVM7QUFBQSxRQUNULGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxXQUFXO0FBQUEsSUFDWCxRQUFRO0FBQUEsTUFDTjtBQUFBLFFBQ0UsU0FBUztBQUFBLFFBQ1QsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFDTixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLFNBQVMsQ0FBQztBQUFBLElBQ1YsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxRQUFRO0FBQUEsTUFDTjtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsTUFDUDtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxNQUNBO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxNQUNBO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxNQUNBO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLFNBQVMsQ0FBQztBQUFBLElBQ1YsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxRQUFRO0FBQUEsTUFDTjtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsTUFDUDtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVEsQ0FBQztBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ04sU0FBUztBQUFBLE1BQ1A7QUFBQSxRQUNFLFlBQVk7QUFBQSxVQUNWO0FBQUEsWUFDRSxjQUFjO0FBQUEsWUFDZCxNQUFNO0FBQUEsWUFDTixNQUFNO0FBQUEsVUFDUjtBQUFBLFVBQ0E7QUFBQSxZQUNFLGNBQWM7QUFBQSxZQUNkLE1BQU07QUFBQSxZQUNOLE1BQU07QUFBQSxVQUNSO0FBQUEsVUFDQTtBQUFBLFlBQ0UsY0FBYztBQUFBLFlBQ2QsTUFBTTtBQUFBLFlBQ04sTUFBTTtBQUFBLFVBQ1I7QUFBQSxVQUNBO0FBQUEsWUFDRSxjQUFjO0FBQUEsWUFDZCxNQUFNO0FBQUEsWUFDTixNQUFNO0FBQUEsVUFDUjtBQUFBLFVBQ0E7QUFBQSxZQUNFLGNBQWM7QUFBQSxZQUNkLE1BQU07QUFBQSxZQUNOLE1BQU07QUFBQSxVQUNSO0FBQUEsVUFDQTtBQUFBLFlBQ0UsY0FBYztBQUFBLFlBQ2QsTUFBTTtBQUFBLFlBQ04sTUFBTTtBQUFBLFVBQ1I7QUFBQSxVQUNBO0FBQUEsWUFDRSxjQUFjO0FBQUEsWUFDZCxNQUFNO0FBQUEsWUFDTixNQUFNO0FBQUEsVUFDUjtBQUFBLFVBQ0E7QUFBQSxZQUNFLGNBQWM7QUFBQSxZQUNkLE1BQU07QUFBQSxZQUNOLE1BQU07QUFBQSxVQUNSO0FBQUEsVUFDQTtBQUFBLFlBQ0UsY0FBYztBQUFBLFlBQ2QsTUFBTTtBQUFBLFlBQ04sTUFBTTtBQUFBLFVBQ1I7QUFBQSxVQUNBO0FBQUEsWUFDRSxjQUFjO0FBQUEsWUFDZCxNQUFNO0FBQUEsWUFDTixNQUFNO0FBQUEsVUFDUjtBQUFBLFFBQ0Y7QUFBQSxRQUNBLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxRQUFRO0FBQUEsTUFDTjtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxNQUNBO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLFNBQVMsQ0FBQztBQUFBLElBQ1YsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxRQUFRLENBQUM7QUFBQSxJQUNULE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxNQUNQO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUSxDQUFDO0FBQUEsSUFDVCxNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsTUFDUDtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxNQUNBO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxNQUNBO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sU0FBUztBQUFBLE1BQ1A7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFDRixHQzFVTWxWLEtBQWtCLDhDQU9YbVYsS0FBa0IsSUFBSUM7QUFBQUEsRUFDakNwVjtBQUFBQSxFQUNBa1Y7QUFBQUEsRUFDQWxvRDtBQUNGLEdDaEJha29ELEtBQXFCO0FBQUEsRUFDaEM7QUFBQSxJQUNFLFFBQVEsQ0FBQztBQUFBLElBQ1QsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxXQUFXO0FBQUEsSUFDWCxRQUFRO0FBQUEsTUFDTjtBQUFBLFFBQ0UsU0FBUztBQUFBLFFBQ1QsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFDTixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFdBQVc7QUFBQSxJQUNYLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxTQUFTO0FBQUEsUUFDVCxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsV0FBVztBQUFBLElBQ1gsUUFBUTtBQUFBLE1BQ047QUFBQSxRQUNFLFNBQVM7QUFBQSxRQUNULGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxXQUFXO0FBQUEsSUFDWCxRQUFRO0FBQUEsTUFDTjtBQUFBLFFBQ0UsU0FBUztBQUFBLFFBQ1QsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxNQUNBO0FBQUEsUUFDRSxTQUFTO0FBQUEsUUFDVCxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsV0FBVztBQUFBLElBQ1gsUUFBUTtBQUFBLE1BQ047QUFBQSxRQUNFLFNBQVM7QUFBQSxRQUNULGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLFFBQ0UsU0FBUztBQUFBLFFBQ1QsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFDTixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFdBQVc7QUFBQSxJQUNYLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxTQUFTO0FBQUEsUUFDVCxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUSxDQUFDO0FBQUEsSUFDVCxNQUFNO0FBQUEsSUFDTixTQUFTLENBQUM7QUFBQSxJQUNWLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUTtBQUFBLE1BQ047QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sU0FBUyxDQUFDO0FBQUEsSUFDVixpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sU0FBUyxDQUFDO0FBQUEsSUFDVixpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVEsQ0FBQztBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ04sU0FBUztBQUFBLE1BQ1A7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxRQUFRLENBQUM7QUFBQSxJQUNULE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxNQUNQO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUSxDQUFDO0FBQUEsSUFDVCxNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsTUFDUDtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVEsQ0FBQztBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ04sU0FBUztBQUFBLE1BQ1A7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxRQUFRO0FBQUEsTUFDTjtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsTUFDUDtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVEsQ0FBQztBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ04sU0FBUyxDQUFDO0FBQUEsSUFDVixpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxNQUNQO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUSxDQUFDO0FBQUEsSUFDVCxNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsTUFDUDtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLFNBQVMsQ0FBQztBQUFBLElBQ1YsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxRQUFRO0FBQUEsTUFDTjtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFDTixTQUFTLENBQUM7QUFBQSxJQUNWLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUTtBQUFBLE1BQ047QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sU0FBUyxDQUFDO0FBQUEsSUFDVixpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxJQUNBLE1BQU07QUFBQSxJQUNOLFNBQVMsQ0FBQztBQUFBLElBQ1YsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxRQUFRO0FBQUEsTUFDTjtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFDTixTQUFTLENBQUM7QUFBQSxJQUNWLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUSxDQUFDO0FBQUEsSUFDVCxNQUFNO0FBQUEsSUFDTixTQUFTLENBQUM7QUFBQSxJQUNWLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQ0YsR0N2VE1sVixLQUFrQiw4Q0FNWHFWLEtBQWtCLElBQUlEO0FBQUFBLEVBQ2pDcFY7QUFBQUEsRUFDQWtWO0FBQUFBLEVBQ0Fsb0Q7QUFDRixHQ2Zha29ELEtBQXFCO0FBQUEsRUFDaEM7QUFBQSxJQUNFLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sU0FBUztBQUFBLE1BQ1A7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLElBQ0EsaUJBQWlCO0FBQUEsSUFDakIsTUFBTTtBQUFBLEVBQ1I7QUFBQSxFQUNBO0FBQUEsSUFDRSxRQUFRO0FBQUEsTUFDTjtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsTUFDUDtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxpQkFBaUI7QUFBQSxJQUNqQixNQUFNO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxJQUNFLFFBQVE7QUFBQSxNQUNOO0FBQUEsUUFDRSxjQUFjO0FBQUEsUUFDZCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFDTixTQUFTLENBQUM7QUFBQSxJQUNWLGlCQUFpQjtBQUFBLElBQ2pCLE1BQU07QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLElBQ0UsUUFBUTtBQUFBLE1BQ047QUFBQSxRQUNFLGNBQWM7QUFBQSxRQUNkLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsTUFDUDtBQUFBLFFBQ0UsY0FBYztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsSUFDQSxpQkFBaUI7QUFB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LGNBQUFKO0FBQUEsSUFDQSxhQUFBRTtBQUFBLElBQ0EsUUFBQTlGO0FBQUEsRUFBQTtBQUVKO0FBRUEsU0FBd0J1RyxLQUFNO0FBQ3RCLFFBQUE7QUFBQSxJQUNKLHFCQUFBOUM7QUFBQSxJQUNBLFlBQUFEO0FBQUEsSUFDQSxTQUFBd0M7QUFBQSxJQUNBLFFBQUFNO0FBQUEsSUFDQSxPQUFBRjtBQUFBLElBQ0EsVUFBQUQ7QUFBQSxJQUNBLGFBQUFMO0FBQUEsRUFBQSxJQUNFTixHQUF1Qiw0Q0FBNEM7QUFFdkUsK0JBQ0csT0FBSSxFQUFBLFdBQVUsaURBQ2IsVUFBQ3hpRCxnQkFBQUEsRUFBQSxLQUFBLE9BQUEsRUFBSSxXQUFVLHlHQUNaLFVBQUE7QUFBQSxJQUFBLENBQUM4aUQsS0FBZ0IvaUQsZ0JBQUFBLE1BQUEsVUFBQSxFQUFPLFNBQVMsTUFBTWlqRCxLQUFXLFVBQU8sV0FBQTtBQUFBLDBCQUN6RCxNQUFHLEVBQUE7QUFBQSwwQkFDSCxNQUFHLEVBQUE7QUFBQSxJQUNIdkMsRUFBb0IsU0FBUyxLQUM1QjFnRCxnQkFBQUEsTUFBQTZrQyxFQUFBQSxVQUFBLEVBQ0UsVUFDRzVrQyxnQkFBQUEsRUFBQSxLQUFBNGtDLFlBQUEsRUFBQSxVQUFBO0FBQUEsTUFBQTRiLEtBQWMsZ0JBQWdCMkM7QUFBQSxNQUM5QkM7QUFBQSxNQUNBRTtBQUFBLElBQUEsRUFBQSxDQUNILEVBcUJGLENBQUE7QUFBQSxFQUFBLEVBRUosQ0FBQSxFQUNGLENBQUE7QUFFSjtBQUVPLE1BQU1FLEtBQThCRDsiLCJ4X2dvb2dsZV9pZ25vcmVMaXN0IjpbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3M119
